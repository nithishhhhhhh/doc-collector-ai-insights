SOURCE URL: https://opentelemetry.io/docs/instrumentation/js/instrumentation
SCRAPED: 2025-06-19 18:09:58
================================================================================

Instrumentation
Instrumentation for OpenTelemetry JavaScript
Instrumentation
is the act of adding
observability code to an app yourself.
If you’re instrumenting an app, you need to use the OpenTelemetry SDK for your
language. You’ll then use the SDK to initialize OpenTelemetry and the API to
instrument your code. This will emit telemetry from your app, and any library
you installed that also comes with instrumentation.
If you’re instrumenting a library, only install the OpenTelemetry API package
for your language. Your library will not emit telemetry on its own. It will only
emit telemetry when it is part of an app that uses the OpenTelemetry SDK. For
more on instrumenting libraries, see
Libraries
For more information about the OpenTelemetry API and SDK, see the
specification
Note
On this page you will learn how you can add traces, metrics and logs to your
code
manually
. But, you are not limited to only use one kind of
instrumentation: use
automatic instrumentation
to get
started and then enrich your code with manual instrumentation as needed.
Also, for libraries your code depends on, you don’t have to write
instrumentation code yourself, since they might come with OpenTelemetry built-in
natively
or you can make use of
instrumentation libraries
Example app preparation
This page uses a modified version of the example app from
Getting Started
to help you learn
about manual instrumentation.
You don’t have to use the example app: if you want to instrument your own app or
library, follow the instructions here to adapt the process to your own code.
Dependencies
Create an empty NPM
--- CODE BLOCK 1 ---
package.json
--- END CODE BLOCK ---
file in a new directory:
--- CODE BLOCK 2 ---
npm init -y
--- END CODE BLOCK ---
Next, install Express dependencies.
TypeScript
JavaScript
--- CODE BLOCK 4 ---
npm install typescript \
ts-node \
@types/node \
express \
@types/express
--- END CODE BLOCK ---
--- CODE BLOCK 6 ---
npm install express
--- END CODE BLOCK ---
Create and launch an HTTP Server
To highlight the difference between instrumenting a
library
and a standalone
, split out the dice rolling into a
library file
, which then will be
imported as a dependency by the
app file
Create the
library file
named
--- CODE BLOCK 10 ---
/*dice.ts*/
function rollOnce(min: number, max: number) {
return Math.floor(Math.random() * (max - min + 1) + min);
export function rollTheDice(rolls: number, min: number, max: number) {
const result: number[] = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
return result;
--- END CODE BLOCK ---
--- CODE BLOCK 11 ---
/*dice.ts*/
function rollOnce(min: number, max: number) {
return Math.floor(Math.random() * (max - min + 1) + min);
export function rollTheDice(rolls: number, min: number, max: number) {
const result: number[] = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
return result;
--- END CODE BLOCK ---
if you are not using
TypeScript) and add the following code to it:
TypeScript
JavaScript
--- CODE BLOCK 12 ---
/*dice.js*/
function rollOnce(min, max) {
return Math.floor(Math.random() * (max - min + 1) + min);
function rollTheDice(rolls, min, max) {
const result = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
return result;
module.exports = { rollTheDice };
--- END CODE BLOCK ---
--- CODE BLOCK 16 ---
/*app.ts*/
import express, { Express } from 'express';
import { rollTheDice } from './dice';
const PORT: number = parseInt(process.env.PORT || '8080');
const app: Express = express();
app.get('/rolldice', (req, res) => {
const rolls = req.query.rolls ? parseInt(req.query.rolls.toString()) : NaN;
if (isNaN(rolls)) {
.status(400)
.send("Request parameter 'rolls' is missing or not a number.");
return;
res.send(JSON.stringify(rollTheDice(rolls, 1, 6)));
app.listen(PORT, () => {
console.log(`Listening for requests on http://localhost:${PORT}`);
--- END CODE BLOCK ---
Create the
app file
named
--- CODE BLOCK 18 ---
/*app.js*/
const express = require('express');
const { rollTheDice } = require('./dice.js');
const PORT = parseInt(process.env.PORT || '8080');
const app = express();
app.get('/rolldice', (req, res) => {
const rolls = req.query.rolls ? parseInt(req.query.rolls.toString()) : NaN;
if (isNaN(rolls)) {
.status(400)
.send("Request parameter 'rolls' is missing or not a number.");
return;
res.send(JSON.stringify(rollTheDice(rolls, 1, 6)));
app.listen(PORT, () => {
console.log(`Listening for requests on http://localhost:${PORT}`);
--- END CODE BLOCK ---
--- CODE BLOCK 19 ---
/*app.js*/
const express = require('express');
const { rollTheDice } = require('./dice.js');
const PORT = parseInt(process.env.PORT || '8080');
const app = express();
app.get('/rolldice', (req, res) => {
const rolls = req.query.rolls ? parseInt(req.query.rolls.toString()) : NaN;
if (isNaN(rolls)) {
.status(400)
.send("Request parameter 'rolls' is missing or not a number.");
return;
res.send(JSON.stringify(rollTheDice(rolls, 1, 6)));
app.listen(PORT, () => {
console.log(`Listening for requests on http://localhost:${PORT}`);
--- END CODE BLOCK ---
if not using TypeScript) and
add the following code to it:
TypeScript
JavaScript
--- CODE BLOCK 20 ---
$ npx ts-node app.ts
Listening for requests on http://localhost:8080
--- END CODE BLOCK ---
--- CODE BLOCK 22 ---
$ node app.js
Listening for requests on http://localhost:8080
--- END CODE BLOCK ---
To ensure that it is working, run the application with the following command and
open
http://localhost:8080/rolldice?rolls=12
in your web browser.
TypeScript
JavaScript
--- CODE BLOCK 24 ---
npm install @opentelemetry/api @opentelemetry/resources @opentelemetry/semantic-conventions
--- END CODE BLOCK ---
--- CODE BLOCK 26 ---
npm install @opentelemetry/sdk-node
--- END CODE BLOCK ---
Manual instrumentation setup
Dependencies
Install OpenTelemetry API packages:
--- CODE BLOCK 28 ---
/*instrumentation.ts*/
import { NodeSDK } from '@opentelemetry/sdk-node';
import { ConsoleSpanExporter } from '@opentelemetry/sdk-trace-node';
import {
PeriodicExportingMetricReader,
ConsoleMetricExporter,
} from '@opentelemetry/sdk-metrics';
import { resourceFromAttributes } from '@opentelemetry/resources';
import {
ATTR_SERVICE_NAME,
ATTR_SERVICE_VERSION,
} from '@opentelemetry/semantic-conventions';
const sdk = new NodeSDK({
resource: resourceFromAttributes({
[ATTR_SERVICE_NAME]: 'yourServiceName',
[ATTR_SERVICE_VERSION]: '1.0',
traceExporter: new ConsoleSpanExporter(),
metricReader: new PeriodicExportingMetricReader({
exporter: new ConsoleMetricExporter(),
sdk.start();
--- END CODE BLOCK ---
Initialize the SDK
Note
If you’re instrumenting a library,
skip this
step
If you instrument a Node.js application install the
OpenTelemetry SDK for Node.js
--- CODE BLOCK 30 ---
/*instrumentation.js*/
const { NodeSDK } = require('@opentelemetry/sdk-node');
const { ConsoleSpanExporter } = require('@opentelemetry/sdk-trace-node');
const {
PeriodicExportingMetricReader,
ConsoleMetricExporter,
} = require('@opentelemetry/sdk-metrics');
const { resourceFromAttributes } = require('@opentelemetry/resources');
const {
ATTR_SERVICE_NAME,
ATTR_SERVICE_VERSION,
} = require('@opentelemetry/semantic-conventions');
const sdk = new NodeSDK({
resource: resourceFromAttributes({
[ATTR_SERVICE_NAME]: 'dice-server',
[ATTR_SERVICE_VERSION]: '0.1.0',
traceExporter: new ConsoleSpanExporter(),
metricReader: new PeriodicExportingMetricReader({
exporter: new ConsoleMetricExporter(),
sdk.start();
--- END CODE BLOCK ---
Before any other module in your application is loaded, you must initialize the
SDK. If you fail to initialize the SDK or initialize it too late, no-op
implementations will be provided to any library that acquires a tracer or meter
from the API.
TypeScript
JavaScript
--- CODE BLOCK 32 ---
service.name
--- END CODE BLOCK ---
--- CODE BLOCK 34 ---
npx ts-node --require ./instrumentation.ts app.ts
--- END CODE BLOCK ---
For debugging and local development purposes, the following example exports
telemetry to the console. After you have finished setting up manual
instrumentation, you need to configure an appropriate exporter to
export the app’s telemetry data
to one or more
telemetry backends.
The example also sets up the mandatory SDK default attribute
--- CODE BLOCK 36 ---
node --require ./instrumentation.js app.js
--- END CODE BLOCK ---
which holds the logical name of the service, and the optional (but highly
encouraged!) attribute
--- CODE BLOCK 37 ---
node --require ./instrumentation.js app.js
--- END CODE BLOCK ---
, which holds the version of the service
API or implementation.
Alternative methods exist for setting up resource attributes. For more
information, see
Resources
To verify your code, run the app by requiring the library:
TypeScript
JavaScript
--- CODE BLOCK 38 ---
TracerProvider
--- END CODE BLOCK ---
--- CODE BLOCK 41 ---
instrumentation.ts
--- END CODE BLOCK ---
This basic setup has no effect on your app yet. You need to add code for
traces
metrics
, and/or
logs
You can register instrumentation libraries with the OpenTelemetry SDK for
Node.js in order to generate telemetry data for your dependencies. For more
information, see
Libraries
Traces
Initialize Tracing
Note
If you’re instrumenting a library,
skip this
step
To enable
tracing
in your app, you’ll need to
have an initialized
--- CODE BLOCK 43 ---
TracerProvider
--- END CODE BLOCK ---
that will let
you create a
--- CODE BLOCK 44 ---
npm install @opentelemetry/sdk-trace-web
--- END CODE BLOCK ---
If a
--- CODE BLOCK 45 ---
npm install @opentelemetry/sdk-trace-web
--- END CODE BLOCK ---
is not created, the OpenTelemetry APIs for tracing will
use a no-op implementation and fail to generate data. As explained next, modify
--- CODE BLOCK 46 ---
instrumentation.ts
--- END CODE BLOCK ---
--- CODE BLOCK 47 ---
instrumentation.js
--- END CODE BLOCK ---
) file to include all the SDK
initialization code in Node and the browser.
Node.js
If you followed the instructions to
initialize the SDK
above, you have a
--- CODE BLOCK 48 ---
import {
defaultResource,
resourceFromAttributes,
} from '@opentelemetry/resources';
import {
ATTR_SERVICE_NAME,
ATTR_SERVICE_VERSION,
} from '@opentelemetry/semantic-conventions';
import { WebTracerProvider } from '@opentelemetry/sdk-trace-web';
import {
BatchSpanProcessor,
ConsoleSpanExporter,
} from '@opentelemetry/sdk-trace-base';
const resource = defaultResource().merge(
resourceFromAttributes({
[ATTR_SERVICE_NAME]: 'service-name-here',
[ATTR_SERVICE_VERSION]: '0.1.0',
const exporter = new ConsoleSpanExporter();
const processor = new BatchSpanProcessor(exporter);
const provider = new WebTracerProvider({
resource: resource,
spanProcessors: [processor],
provider.register();
--- END CODE BLOCK ---
setup for you already. You can continue with
acquiring a tracer
Browser
Warning
Client instrumentation for the browser is
experimental
and mostly
unspecified
. If you are interested in helping out, get in touch with the
Client Instrumentation SIG
First, ensure you’ve got the right packages:
--- CODE BLOCK 49 ---
import {
defaultResource,
resourceFromAttributes,
} from '@opentelemetry/resources';
import {
ATTR_SERVICE_NAME,
ATTR_SERVICE_VERSION,
} from '@opentelemetry/semantic-conventions';
import { WebTracerProvider } from '@opentelemetry/sdk-trace-web';
import {
BatchSpanProcessor,
ConsoleSpanExporter,
} from '@opentelemetry/sdk-trace-base';
const resource = defaultResource().merge(
resourceFromAttributes({
[ATTR_SERVICE_NAME]: 'service-name-here',
[ATTR_SERVICE_VERSION]: '0.1.0',
const exporter = new ConsoleSpanExporter();
const processor = new BatchSpanProcessor(exporter);
const provider = new WebTracerProvider({
resource: resource,
spanProcessors: [processor],
provider.register();
--- END CODE BLOCK ---
Next, update
--- CODE BLOCK 51 ---
const opentelemetry = require('@opentelemetry/api');
const {
defaultResource,
resourceFromAttributes,
} = require('@opentelemetry/resources');
const {
ATTR_SERVICE_NAME,
ATTR_SERVICE_VERSION,
} = require('@opentelemetry/semantic-conventions');
const { WebTracerProvider } = require('@opentelemetry/sdk-trace-web');
const {
ConsoleSpanExporter,
BatchSpanProcessor,
} = require('@opentelemetry/sdk-trace-base');
const resource = defaultResource().merge(
resourceFromAttributes({
[ATTR_SERVICE_NAME]: 'service-name-here',
[ATTR_SERVICE_VERSION]: '0.1.0',
const exporter = new ConsoleSpanExporter();
const processor = new BatchSpanProcessor(exporter);
const provider = new WebTracerProvider({
resource: resource,
spanProcessors: [processor],
provider.register();
--- END CODE BLOCK ---
--- CODE BLOCK 52 ---
BatchSpanProcessor
--- END CODE BLOCK ---
) to contain all the
SDK initialization code in it:
TypeScript
JavaScript
--- CODE BLOCK 53 ---
BatchSpanProcessor
--- END CODE BLOCK ---
--- CODE BLOCK 55 ---
BatchSpanProcessor
--- END CODE BLOCK ---
You’ll need to bundle this file with your web application to be able to use
tracing throughout the rest of your web application.
This will have no effect on your app yet: you need to
create spans
to have telemetry emitted by your app.
Picking the right span processor
By default, the Node SDK uses the
--- CODE BLOCK 58 ---
import opentelemetry from '@opentelemetry/api';
//...
const tracer = opentelemetry.trace.getTracer(
'instrumentation-scope-name',
'instrumentation-scope-version',
// You can now use a 'tracer' to do tracing!
--- END CODE BLOCK ---
, and this span processor
is also chosen in the Web SDK example. The
--- CODE BLOCK 59 ---
import opentelemetry from '@opentelemetry/api';
//...
const tracer = opentelemetry.trace.getTracer(
'instrumentation-scope-name',
'instrumentation-scope-version',
// You can now use a 'tracer' to do tracing!
--- END CODE BLOCK ---
processes spans
in batches before they are exported. This is usually the right processor to use
for an application.
In contrast, the
--- CODE BLOCK 60 ---
const opentelemetry = require('@opentelemetry/api');
//...
const tracer = opentelemetry.trace.getTracer(
'instrumentation-scope-name',
'instrumentation-scope-version',
// You can now use a 'tracer' to do tracing!
--- END CODE BLOCK ---
processes spans as they are created. This
means that if you create 5 spans, each will be processed and exported before the
next span is created in code. This can be helpful in scenarios where you do not
want to risk losing a batch, or if you’re experimenting with OpenTelemetry in
development. However, it also comes with potentially significant overhead,
especially if spans are being exported over a network - each time a call to
create a span is made, it would be processed and sent over a network before your
app’s execution could continue.
In most cases, stick with
--- CODE BLOCK 61 ---
const opentelemetry = require('@opentelemetry/api');
//...
const tracer = opentelemetry.trace.getTracer(
'instrumentation-scope-name',
'instrumentation-scope-version',
// You can now use a 'tracer' to do tracing!
--- END CODE BLOCK ---
over
--- CODE BLOCK 62 ---
instrumentation-scope-name
--- END CODE BLOCK ---
Acquiring a tracer
Anywhere in your application where you write manual tracing code should call
--- CODE BLOCK 63 ---
instrumentation-scope-version
--- END CODE BLOCK ---
to acquire a tracer. For example:
TypeScript
JavaScript
--- CODE BLOCK 68 ---
/*app.ts*/
import { trace } from '@opentelemetry/api';
import express, { Express } from 'express';
import { rollTheDice } from './dice';
const tracer = trace.getTracer('dice-server', '0.1.0');
const PORT: number = parseInt(process.env.PORT || '8080');
const app: Express = express();
app.get('/rolldice', (req, res) => {
const rolls = req.query.rolls ? parseInt(req.query.rolls.toString()) : NaN;
if (isNaN(rolls)) {
.status(400)
.send("Request parameter 'rolls' is missing or not a number.");
return;
res.send(JSON.stringify(rollTheDice(rolls, 1, 6)));
app.listen(PORT, () => {
console.log(`Listening for requests on http://localhost:${PORT}`);
--- END CODE BLOCK ---
--- CODE BLOCK 70 ---
/*app.js*/
const { trace } = require('@opentelemetry/api');
const express = require('express');
const { rollTheDice } = require('./dice.js');
const tracer = trace.getTracer('dice-server', '0.1.0');
const PORT = parseInt(process.env.PORT || '8080');
const app = express();
app.get('/rolldice', (req, res) => {
const rolls = req.query.rolls ? parseInt(req.query.rolls.toString()) : NaN;
if (isNaN(rolls)) {
.status(400)
.send("Request parameter 'rolls' is missing or not a number.");
return;
res.send(JSON.stringify(rollTheDice(rolls, 1, 6)));
app.listen(PORT, () => {
console.log(`Listening for requests on http://localhost:${PORT}`);
--- END CODE BLOCK ---
The values of
--- CODE BLOCK 74 ---
/*dice.ts*/
import { trace } from '@opentelemetry/api';
const tracer = trace.getTracer('dice-lib');
function rollOnce(min: number, max: number) {
return Math.floor(Math.random() * (max - min + 1) + min);
export function rollTheDice(rolls: number, min: number, max: number) {
const result: number[] = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
return result;
--- END CODE BLOCK ---
--- CODE BLOCK 75 ---
/*dice.ts*/
import { trace } from '@opentelemetry/api';
const tracer = trace.getTracer('dice-lib');
function rollOnce(min: number, max: number) {
return Math.floor(Math.random() * (max - min + 1) + min);
export function rollTheDice(rolls: number, min: number, max: number) {
const result: number[] = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
return result;
--- END CODE BLOCK ---
should uniquely identify the
Instrumentation Scope
, such as the
package, module or class name. While the name is required, the version is still
recommended despite being optional.
It’s generally recommended to call
--- CODE BLOCK 76 ---
/*dice.js*/
const { trace } = require('@opentelemetry/api');
const tracer = trace.getTracer('dice-lib');
function rollOnce(min, max) {
return Math.floor(Math.random() * (max - min + 1) + min);
function rollTheDice(rolls, min, max) {
const result = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
return result;
module.exports = { rollTheDice };
--- END CODE BLOCK ---
in your app when you need it
rather than exporting the
--- CODE BLOCK 77 ---
/*dice.js*/
const { trace } = require('@opentelemetry/api');
const tracer = trace.getTracer('dice-lib');
function rollOnce(min, max) {
return Math.floor(Math.random() * (max - min + 1) + min);
function rollTheDice(rolls, min, max) {
const result = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
return result;
module.exports = { rollTheDice };
--- END CODE BLOCK ---
instance to the rest of your app. This helps
avoid trickier application load issues when other required dependencies are
involved.
In the case of the
example app
, there are two places where a
tracer may be acquired with an appropriate Instrumentation Scope:
First, in the
application file
--- CODE BLOCK 78 ---
tracer.startSpan
--- END CODE BLOCK ---
--- CODE BLOCK 79 ---
tracer.startActiveSpan
--- END CODE BLOCK ---
TypeScript
JavaScript
--- CODE BLOCK 80 ---
tracer.startActiveSpan
--- END CODE BLOCK ---
--- CODE BLOCK 82 ---
import { trace, Span } from '@opentelemetry/api';
/* ... */
export function rollTheDice(rolls: number, min: number, max: number) {
// Create a span. A span must be closed.
return tracer.startActiveSpan('rollTheDice', (span: Span) => {
const result: number[] = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
// Be sure to end the span!
span.end();
return result;
--- END CODE BLOCK ---
And second, in the
library file
--- CODE BLOCK 84 ---
function rollTheDice(rolls, min, max) {
// Create a span. A span must be closed.
return tracer.startActiveSpan('rollTheDice', (span) => {
const result = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
// Be sure to end the span!
span.end();
return result;
--- END CODE BLOCK ---
--- CODE BLOCK 88 ---
ts-node --require ./instrumentation.ts app.ts
--- END CODE BLOCK ---
TypeScript
JavaScript
--- CODE BLOCK 89 ---
ts-node --require ./instrumentation.ts app.ts
--- END CODE BLOCK ---
--- CODE BLOCK 91 ---
node --require ./instrumentation.js app.js
--- END CODE BLOCK ---
Create spans
Now that you have
tracers
initialized,
you can create
spans
The API of OpenTelemetry JavaScript exposes two methods that allow you to create
spans:
--- CODE BLOCK 93 ---
"traceId": "6cc927a05e7f573e63f806a2e9bb7da8",
"parentId": undefined,
"name": "rollTheDice",
"id": "117d98e8add5dc80",
"kind": 0,
"timestamp": 1688386291908349,
"duration": 501,
"attributes": {},
"status": { "code": 0 },
"events": [],
"links": []
--- END CODE BLOCK ---
Starts a new span without setting it on context.
--- CODE BLOCK 94 ---
"traceId": "6cc927a05e7f573e63f806a2e9bb7da8",
"parentId": undefined,
"name": "rollTheDice",
"id": "117d98e8add5dc80",
"kind": 0,
"timestamp": 1688386291908349,
"duration": 501,
"attributes": {},
"status": { "code": 0 },
"events": [],
"links": []
--- END CODE BLOCK ---
Starts a new span and calls the given callback function passing it the created
span as first argument. The new span gets set in context and this context is
activated for the duration of the function call.
In most cases you want to use the latter (
--- CODE BLOCK 97 ---
function rollOnce(i: number, min: number, max: number) {
return tracer.startActiveSpan(`rollOnce:${i}`, (span: Span) => {
const result = Math.floor(Math.random() * (max - min + 1) + min);
span.end();
return result;
export function rollTheDice(rolls: number, min: number, max: number) {
// Create a span. A span must be closed.
return tracer.startActiveSpan('rollTheDice', (parentSpan: Span) => {
const result: number[] = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(i, min, max));
// Be sure to end the span!
parentSpan.end();
return result;
--- END CODE BLOCK ---
), as it takes
care of setting the span and its context active.
The code below illustrates how to create an active span.
TypeScript
JavaScript
--- CODE BLOCK 98 ---
function rollOnce(i: number, min: number, max: number) {
return tracer.startActiveSpan(`rollOnce:${i}`, (span: Span) => {
const result = Math.floor(Math.random() * (max - min + 1) + min);
span.end();
return result;
export function rollTheDice(rolls: number, min: number, max: number) {
// Create a span. A span must be closed.
return tracer.startActiveSpan('rollTheDice', (parentSpan: Span) => {
const result: number[] = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(i, min, max));
// Be sure to end the span!
parentSpan.end();
return result;
--- END CODE BLOCK ---
--- CODE BLOCK 100 ---
function rollOnce(i, min, max) {
return tracer.startActiveSpan(`rollOnce:${i}`, (span) => {
const result = Math.floor(Math.random() * (max - min + 1) + min);
span.end();
return result;
function rollTheDice(rolls, min, max) {
// Create a span. A span must be closed.
return tracer.startActiveSpan('rollTheDice', (parentSpan) => {
const result = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(i, min, max));
// Be sure to end the span!
parentSpan.end();
return result;
--- END CODE BLOCK ---
If you followed the instructions using the
example app
up to
this point, you can copy the code above in your library file
--- CODE BLOCK 103 ---
"traceId": "ff1d39e648a3dc53ba710e1bf1b86e06",
"parentId": "9214ff209e6a8267",
"name": "rollOnce:4",
"id": "7eccf70703e2bccd",
"kind": 0,
"timestamp": 1688387049511591,
"duration": 22,
"attributes": {},
"status": { "code": 0 },
"events": [],
"links": []
"traceId": "ff1d39e648a3dc53ba710e1bf1b86e06",
"parentId": undefined,
"name": "rollTheDice",
"id": "9214ff209e6a8267",
"kind": 0,
"timestamp": 1688387049510303,
"duration": 1314,
"attributes": {},
"status": { "code": 0 },
"events": [],
"links": []
--- END CODE BLOCK ---
--- CODE BLOCK 104 ---
const doWork = () => {
const span1 = tracer.startSpan('work-1');
// do some work
const span2 = tracer.startSpan('work-2');
// do some more work
const span3 = tracer.startSpan('work-3');
// do even more work
span1.end();
span2.end();
span3.end();
--- END CODE BLOCK ---
). You should now be able to see spans emitted from your app.
Start your app as follows, and then send it requests by visiting
http://localhost:8080/rolldice?rolls=12
with your browser or
--- CODE BLOCK 105 ---
const doWork = () => {
const span1 = tracer.startSpan('work-1');
// do some work
const span2 = tracer.startSpan('work-2');
// do some more work
const span3 = tracer.startSpan('work-3');
// do even more work
span1.end();
span2.end();
span3.end();
--- END CODE BLOCK ---
TypeScript
JavaScript
--- CODE BLOCK 109 ---
const activeSpan = opentelemetry.trace.getActiveSpan();
// do something with the active span, optionally ending it if that is appropriate for your use case.
--- END CODE BLOCK ---
--- CODE BLOCK 111 ---
const ctx = getContextFromSomewhere();
const span = opentelemetry.trace.getSpan(ctx);
// do something with the acquired span, optionally ending it if that is appropriate for your use case.
--- END CODE BLOCK ---
After a while, you should see the spans printed in the console by the
--- CODE BLOCK 114 ---
function rollOnce(i: number, min: number, max: number) {
return tracer.startActiveSpan(`rollOnce:${i}`, (span: Span) => {
const result = Math.floor(Math.random() * (max - min + 1) + min);
// Add an attribute to the span
span.setAttribute('dicelib.rolled', result.toString());
span.end();
return result;
--- END CODE BLOCK ---
, something like this:
--- CODE BLOCK 115 ---
function rollOnce(i: number, min: number, max: number) {
return tracer.startActiveSpan(`rollOnce:${i}`, (span: Span) => {
const result = Math.floor(Math.random() * (max - min + 1) + min);
// Add an attribute to the span
span.setAttribute('dicelib.rolled', result.toString());
span.end();
return result;
--- END CODE BLOCK ---
Create nested spans
Nested
spans
let you track work that’s
nested in nature. For example, the
--- CODE BLOCK 117 ---
function rollOnce(i, min, max) {
return tracer.startActiveSpan(`rollOnce:${i}`, (span) => {
const result = Math.floor(Math.random() * (max - min + 1) + min);
// Add an attribute to the span
span.setAttribute('dicelib.rolled', result.toString());
span.end();
return result;
--- END CODE BLOCK ---
function below represents a
nested operation. The following sample creates a nested span that tracks
--- CODE BLOCK 118 ---
tracer.startActiveSpan(
'app.new-span',
{ attributes: { attribute1: 'value1' } },
(span) => {
// do some work...
span.end();
--- END CODE BLOCK ---
TypeScript
JavaScript
--- CODE BLOCK 119 ---
tracer.startActiveSpan(
'app.new-span',
{ attributes: { attribute1: 'value1' } },
(span) => {
// do some work...
span.end();
--- END CODE BLOCK ---
--- CODE BLOCK 121 ---
function rollTheDice(rolls: number, min: number, max: number) {
return tracer.startActiveSpan(
'rollTheDice',
{ attributes: { 'dicelib.rolls': rolls.toString() } },
(span: Span) => {
/* ... */
--- END CODE BLOCK ---
This code creates a child span for each
roll
that has
--- CODE BLOCK 123 ---
function rollTheDice(rolls, min, max) {
return tracer.startActiveSpan(
'rollTheDice',
{ attributes: { 'dicelib.rolls': rolls.toString() } },
(span) => {
/* ... */
--- END CODE BLOCK ---
’s ID as
their parent ID:
--- CODE BLOCK 124 ---
npm install --save @opentelemetry/semantic-conventions
--- END CODE BLOCK ---
Create independent spans
The previous examples showed how to create an active span. In some cases, you’ll
want to create inactive spans that are siblings of one another rather than being
nested.
--- CODE BLOCK 126 ---
import {
SEMATTRS_CODE_FUNCTION,
SEMATTRS_CODE_FILEPATH,
} from '@opentelemetry/semantic-conventions';
--- END CODE BLOCK ---
In this example,
--- CODE BLOCK 128 ---
const {
SEMATTRS_CODE_FUNCTION,
SEMATTRS_CODE_FILEPATH,
} = require('@opentelemetry/semantic-conventions');
--- END CODE BLOCK ---
--- CODE BLOCK 129 ---
const {
SEMATTRS_CODE_FUNCTION,
SEMATTRS_CODE_FILEPATH,
} = require('@opentelemetry/semantic-conventions');
--- END CODE BLOCK ---
, and
--- CODE BLOCK 130 ---
const doWork = () => {
tracer.startActiveSpan('app.doWork', (span) => {
span.setAttribute(SEMATTRS_CODE_FUNCTION, 'doWork');
span.setAttribute(SEMATTRS_CODE_FILEPATH, __filename);
// Do some work...
span.end();
--- END CODE BLOCK ---
are sibling spans and none of
them are considered the currently active span. They share the same parent rather
than being nested under one another.
This arrangement can be helpful if you have units of work that are grouped
together but are conceptually independent from one another.
Get the current span
Sometimes it’s helpful to do something with the current/active
span
at a particular point in program
execution.
--- CODE BLOCK 131 ---
const doWork = () => {
tracer.startActiveSpan('app.doWork', (span) => {
span.setAttribute(SEMATTRS_CODE_FUNCTION, 'doWork');
span.setAttribute(SEMATTRS_CODE_FILEPATH, __filename);
// Do some work...
span.end();
--- END CODE BLOCK ---
Get a span from context
It can also be helpful to get the
span
from a given context that isn’t necessarily the active span.
--- CODE BLOCK 134 ---
span.addEvent('Doing something');
const result = doWork();
--- END CODE BLOCK ---
Attributes
Attributes
let you attach key/value
pairs to a
--- CODE BLOCK 136 ---
span.addEvent('some log', {
'log.severity': 'error',
'log.message': 'Data not found',
'request.id': requestId,
--- END CODE BLOCK ---
so it carries more
information about the current operation that it’s tracking.
TypeScript
JavaScript
--- CODE BLOCK 139 ---
const someFunction = (spanToLinkFrom) => {
const options = {
links: [
context: spanToLinkFrom.spanContext(),
tracer.startActiveSpan('app.someFunction', options, (span) => {
// Do some work...
span.end();
--- END CODE BLOCK ---
--- CODE BLOCK 145 ---
import opentelemetry, { SpanStatusCode } from '@opentelemetry/api';
// ...
tracer.startActiveSpan('app.doWork', (span) => {
for (let i = 0; i <= Math.floor(Math.random() * 40000000); i += 1) {
if (i > 10000) {
span.setStatus({
code: SpanStatusCode.ERROR,
message: 'Error',
span.end();
--- END CODE BLOCK ---
You can also add attributes to a span as it’s created:
--- CODE BLOCK 147 ---
const opentelemetry = require('@opentelemetry/api');
// ...
tracer.startActiveSpan('app.doWork', (span) => {
for (let i = 0; i <= Math.floor(Math.random() * 40000000); i += 1) {
if (i > 10000) {
span.setStatus({
code: opentelemetry.SpanStatusCode.ERROR,
message: 'Error',
span.end();
--- END CODE BLOCK ---
TypeScript
JavaScript
--- CODE BLOCK 149 ---
import opentelemetry, { SpanStatusCode } from '@opentelemetry/api';
// ...
try {
doWork();
} catch (ex) {
if (ex instanceof Error) {
span.recordException(ex);
span.setStatus({ code: SpanStatusCode.ERROR });
--- END CODE BLOCK ---
--- CODE BLOCK 151 ---
const opentelemetry = require('@opentelemetry/api');
// ...
try {
doWork();
} catch (ex) {
if (ex instanceof Error) {
span.recordException(ex);
span.setStatus({ code: opentelemetry.SpanStatusCode.ERROR });
--- END CODE BLOCK ---
Semantic Attributes
There are semantic conventions for spans representing operations in well-known
protocols like HTTP or database calls. Semantic conventions for these spans are
defined in the specification at
Trace Semantic Conventions
. In the simple
example of this guide the source code attributes can be used.
First add the semantic conventions as a dependency to your application:
--- CODE BLOCK 153 ---
sdk-trace-base
--- END CODE BLOCK ---
Add the following to the top of your application file:
TypeScript
JavaScript
--- CODE BLOCK 155 ---
import opentelemetry from '@opentelemetry/api';
import {
CompositePropagator,
W3CTraceContextPropagator,
W3CBaggagePropagator,
} from '@opentelemetry/core';
import {
BasicTracerProvider,
BatchSpanProcessor,
ConsoleSpanExporter,
} from '@opentelemetry/sdk-trace-base';
opentelemetry.trace.setGlobalTracerProvider(
new BasicTracerProvider({
// Configure span processor to send spans to the exporter
spanProcessors: [new BatchSpanProcessor(new ConsoleSpanExporter())],
opentelemetry.propagation.setGlobalPropagator(
new CompositePropagator({
propagators: [new W3CTraceContextPropagator(), new W3CBaggagePropagator()],
// This is what we'll access in all instrumentation code
const tracer = opentelemetry.trace.getTracer('example-basic-tracer-node');
--- END CODE BLOCK ---
--- CODE BLOCK 157 ---
const opentelemetry = require('@opentelemetry/api');
const {
CompositePropagator,
W3CTraceContextPropagator,
W3CBaggagePropagator,
} = require('@opentelemetry/core');
const {
BasicTracerProvider,
ConsoleSpanExporter,
BatchSpanProcessor,
} = require('@opentelemetry/sdk-trace-base');
opentelemetry.trace.setGlobalTracerProvider(
new BasicTracerProvider({
// Configure span processor to send spans to the exporter
spanProcessors: [new BatchSpanProcessor(new ConsoleSpanExporter())],
opentelemetry.propagation.setGlobalPropagator(
new CompositePropagator({
propagators: [new W3CTraceContextPropagator(), new W3CBaggagePropagator()],
// This is what we'll access in all instrumentation code
const tracer = opentelemetry.trace.getTracer('example-basic-tracer-node');
--- END CODE BLOCK ---
Finally, you can update your file to include semantic attributes:
--- CODE BLOCK 159 ---
sdk-trace-base
--- END CODE BLOCK ---
Span events
Span Event
is a human-readable
message on an
--- CODE BLOCK 161 ---
const mainWork = () => {
const parentSpan = tracer.startSpan('main');
for (let i = 0; i < 3; i += 1) {
doWork(parentSpan, i);
// Be sure to end the parent span!
parentSpan.end();
const doWork = (parent, i) => {
// To create a child span, we need to mark the current (parent) span as the active span
// in the context, then use the resulting context to create a child span.
const ctx = opentelemetry.trace.setSpan(
opentelemetry.context.active(),
parent,
const span = tracer.startSpan(`doWork:${i}`, undefined, ctx);
// simulate some random work.
for (let i = 0; i <= Math.floor(Math.random() * 40000000); i += 1) {
// empty
// Make sure to end this child span! If you don't,
// it will continue to track work beyond 'doWork'!
span.end();
--- END CODE BLOCK ---
that represents a
discrete event with no duration that can be tracked by a single timestamp. You
can think of it like a primitive log.
--- CODE BLOCK 162 ---
const mainWork = () => {
const parentSpan = tracer.startSpan('main');
for (let i = 0; i < 3; i += 1) {
doWork(parentSpan, i);
// Be sure to end the parent span!
parentSpan.end();
const doWork = (parent, i) => {
// To create a child span, we need to mark the current (parent) span as the active span
// in the context, then use the resulting context to create a child span.
const ctx = opentelemetry.trace.setSpan(
opentelemetry.context.active(),
parent,
const span = tracer.startSpan(`doWork:${i}`, undefined, ctx);
// simulate some random work.
for (let i = 0; i <= Math.floor(Math.random() * 40000000); i += 1) {
// empty
// Make sure to end this child span! If you don't,
// it will continue to track work beyond 'doWork'!
span.end();
--- END CODE BLOCK ---
You can also create Span Events with additional
Attributes
--- CODE BLOCK 164 ---
MeterProvider
--- END CODE BLOCK ---
Span links
--- CODE BLOCK 167 ---
instrumentation.ts
--- END CODE BLOCK ---
can be created with zero or more
--- CODE BLOCK 168 ---
instrumentation.js
--- END CODE BLOCK ---
to other Spans that are
causally related. A common scenario is to correlate one or more traces with the
current span.
--- CODE BLOCK 169 ---
MeterProvider
--- END CODE BLOCK ---
Span Status
Status
can be set on a
Span
, typically used to specify that a
Span has not completed successfully -
--- CODE BLOCK 171 ---
@opentelemetry/sdk-metrics
--- END CODE BLOCK ---
. By default, all spans are
--- CODE BLOCK 172 ---
npm install @opentelemetry/sdk-metrics
--- END CODE BLOCK ---
, which means a span completed without error. The
--- CODE BLOCK 173 ---
npm install @opentelemetry/sdk-metrics
--- END CODE BLOCK ---
status is reserved
for when you need to explicitly mark a span as successful rather than stick with
the default of
--- CODE BLOCK 174 ---
instrumentation.ts
--- END CODE BLOCK ---
(i.e., “without error”).
The status can be set at any time before the span is finished.
TypeScript
JavaScript
--- CODE BLOCK 175 ---
instrumentation.js
--- END CODE BLOCK ---
--- CODE BLOCK 177 ---
import opentelemetry from '@opentelemetry/api';
import {
ConsoleMetricExporter,
MeterProvider,
PeriodicExportingMetricReader,
} from '@opentelemetry/sdk-metrics';
import {
defaultResource,
resourceFromAttributes,
} from '@opentelemetry/resources';
import {
ATTR_SERVICE_NAME,
ATTR_SERVICE_VERSION,
} from '@opentelemetry/semantic-conventions';
const resource = defaultResource().merge(
resourceFromAttributes({
[ATTR_SERVICE_NAME]: 'dice-server',
[ATTR_SERVICE_VERSION]: '0.1.0',
const metricReader = new PeriodicExportingMetricReader({
exporter: new ConsoleMetricExporter(),
// Default is 60000ms (60 seconds). Set to 10 seconds for demonstrative purposes only.
exportIntervalMillis: 10000,
const myServiceMeterProvider = new MeterProvider({
resource: resource,
readers: [metricReader],
// Set this MeterProvider to be global to the app being instrumented.
opentelemetry.metrics.setGlobalMeterProvider(myServiceMeterProvider);
--- END CODE BLOCK ---
Recording exceptions
It can be a good idea to record exceptions when they happen. It’s recommended to
do this in conjunction with setting
span status
TypeScript
JavaScript
--- CODE BLOCK 179 ---
const opentelemetry = require('@opentelemetry/api');
const {
MeterProvider,
PeriodicExportingMetricReader,
ConsoleMetricExporter,
} = require('@opentelemetry/sdk-metrics');
const {
defaultResource,
resourceFromAttributes,
} = require('@opentelemetry/resources');
const {
ATTR_SERVICE_NAME,
ATTR_SERVICE_VERSION,
} = require('@opentelemetry/semantic-conventions');
const resource = defaultResource().merge(
resourceFromAttributes({
[ATTR_SERVICE_NAME]: 'service-name-here',
[ATTR_SERVICE_VERSION]: '0.1.0',
const metricReader = new PeriodicExportingMetricReader({
exporter: new ConsoleMetricExporter(),
// Default is 60000ms (60 seconds). Set to 10 seconds for demonstrative purposes only.
exportIntervalMillis: 10000,
const myServiceMeterProvider = new MeterProvider({
resource: resource,
readers: [metricReader],
// Set this MeterProvider to be global to the app being instrumented.
opentelemetry.metrics.setGlobalMeterProvider(myServiceMeterProvider);
--- END CODE BLOCK ---
--- CODE BLOCK 182 ---
ts-node --require ./instrumentation.ts app.ts
--- END CODE BLOCK ---
Using
--- CODE BLOCK 184 ---
node --require ./instrumentation.js app.js
--- END CODE BLOCK ---
and manually propagating span context
In some cases, you may not be able to use either the Node.js SDK nor the Web
SDK. The biggest difference, aside from initialization code, is that you’ll have
to manually set spans as active in the current context to be able to create
nested spans.
Initializing tracing with
--- CODE BLOCK 185 ---
MeterProvider
--- END CODE BLOCK ---
Initializing tracing is similar to how you’d do it with Node.js or the Web SDK.
TypeScript
JavaScript
--- CODE BLOCK 188 ---
import opentelemetry from '@opentelemetry/api';
const myMeter = opentelemetry.metrics.getMeter(
'instrumentation-scope-name',
'instrumentation-scope-version',
// You can now use a 'meter' to create instruments!
--- END CODE BLOCK ---
--- CODE BLOCK 190 ---
const opentelemetry = require('@opentelemetry/api');
const myMeter = opentelemetry.metrics.getMeter(
'instrumentation-scope-name',
'instrumentation-scope-version',
// You can now use a 'meter' to create instruments!
--- END CODE BLOCK ---
Like the other examples in this document, this exports a tracer you can use
throughout the app.
Creating nested spans with
--- CODE BLOCK 192 ---
instrumentation-scope-name
--- END CODE BLOCK ---
To create nested spans, you need to set whatever the currently-created span is
as the active span in the current context. Don’t bother using
--- CODE BLOCK 193 ---
instrumentation-scope-version
--- END CODE BLOCK ---
because it won’t do this for you.
--- CODE BLOCK 197 ---
/*app.ts*/
import { metrics, trace } from '@opentelemetry/api';
import express, { Express } from 'express';
import { rollTheDice } from './dice';
const tracer = trace.getTracer('dice-server', '0.1.0');
const meter = metrics.getMeter('dice-server', '0.1.0');
const PORT: number = parseInt(process.env.PORT || '8080');
const app: Express = express();
app.get('/rolldice', (req, res) => {
const rolls = req.query.rolls ? parseInt(req.query.rolls.toString()) : NaN;
if (isNaN(rolls)) {
.status(400)
.send("Request parameter 'rolls' is missing or not a number.");
return;
res.send(JSON.stringify(rollTheDice(rolls, 1, 6)));
app.listen(PORT, () => {
console.log(`Listening for requests on http://localhost:${PORT}`);
--- END CODE BLOCK ---
All other APIs behave the same when you use
--- CODE BLOCK 199 ---
/*app.js*/
const { trace, metrics } = require('@opentelemetry/api');
const express = require('express');
const { rollTheDice } = require('./dice.js');
const tracer = trace.getTracer('dice-server', '0.1.0');
const meter = metrics.getMeter('dice-server', '0.1.0');
const PORT = parseInt(process.env.PORT || '8080');
const app = express();
app.get('/rolldice', (req, res) => {
const rolls = req.query.rolls ? parseInt(req.query.rolls.toString()) : NaN;
if (isNaN(rolls)) {
.status(400)
.send("Request parameter 'rolls' is missing or not a number.");
return;
res.send(JSON.stringify(rollTheDice(rolls, 1, 6)));
app.listen(PORT, () => {
console.log(`Listening for requests on http://localhost:${PORT}`);
--- END CODE BLOCK ---
compared with the
Node.js or Web SDKs.
Metrics
Metrics
combine individual measurements into
aggregates, and produce data which is constant as a function of system load.
Aggregates lack details required to diagnose low level issues, but complement
spans by helping to identify trends and providing application runtime telemetry.
Initialize Metrics
If you’re instrumenting a library, skip this step.
To enable
metrics
in your app, you’ll need to
have an initialized
--- CODE BLOCK 200 ---
/*app.js*/
const { trace, metrics } = require('@opentelemetry/api');
const express = require('express');
const { rollTheDice } = require('./dice.js');
const tracer = trace.getTracer('dice-server', '0.1.0');
const meter = metrics.getMeter('dice-server', '0.1.0');
const PORT = parseInt(process.env.PORT || '8080');
const app = express();
app.get('/rolldice', (req, res) => {
const rolls = req.query.rolls ? parseInt(req.query.rolls.toString()) : NaN;
if (isNaN(rolls)) {
.status(400)
.send("Request parameter 'rolls' is missing or not a number.");
return;
res.send(JSON.stringify(rollTheDice(rolls, 1, 6)));
app.listen(PORT, () => {
console.log(`Listening for requests on http://localhost:${PORT}`);
--- END CODE BLOCK ---
that will let
you create a
--- CODE BLOCK 203 ---
/*dice.ts*/
import { trace, metrics } from '@opentelemetry/api';
const tracer = trace.getTracer('dice-lib');
const meter = metrics.getMeter('dice-lib');
function rollOnce(min: number, max: number) {
return Math.floor(Math.random() * (max - min + 1) + min);
export function rollTheDice(rolls: number, min: number, max: number) {
const result: number[] = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
return result;
--- END CODE BLOCK ---
If a
--- CODE BLOCK 204 ---
/*dice.ts*/
import { trace, metrics } from '@opentelemetry/api';
const tracer = trace.getTracer('dice-lib');
const meter = metrics.getMeter('dice-lib');
function rollOnce(min: number, max: number) {
return Math.floor(Math.random() * (max - min + 1) + min);
export function rollTheDice(rolls: number, min: number, max: number) {
const result: number[] = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
return result;
--- END CODE BLOCK ---
is not created, the OpenTelemetry APIs for metrics will use
a no-op implementation and fail to generate data. As explained next, modify the
--- CODE BLOCK 205 ---
/*dice.js*/
const { trace, metrics } = require('@opentelemetry/api');
const tracer = trace.getTracer('dice-lib');
const meter = metrics.getMeter('dice-lib');
function rollOnce(min, max) {
return Math.floor(Math.random() * (max - min + 1) + min);
function rollTheDice(rolls, min, max) {
const result = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
return result;
module.exports = { rollTheDice };
--- END CODE BLOCK ---
--- CODE BLOCK 206 ---
/*dice.js*/
const { trace, metrics } = require('@opentelemetry/api');
const tracer = trace.getTracer('dice-lib');
const meter = metrics.getMeter('dice-lib');
function rollOnce(min, max) {
return Math.floor(Math.random() * (max - min + 1) + min);
function rollTheDice(rolls, min, max) {
const result = [];
for (let i = 0; i < rolls; i++) {
result.push(rollOnce(min, max));
return result;
module.exports = { rollTheDice };
--- END CODE BLOCK ---
) file to include all the SDK
initialization code in Node and the browser.
Node.js
If you followed the instructions to
initialize the SDK
above, you have a
--- CODE BLOCK 207 ---
/*dice.ts*/
const counter = meter.createCounter('dice-lib.rolls.counter');
function rollOnce(min: number, max: number) {
counter.add(1);
return Math.floor(Math.random() * (max - min + 1) + min);
--- END CODE BLOCK ---
setup for you already. You can continue with
acquiring a meter
Initializing metrics with
--- CODE BLOCK 208 ---
/*dice.ts*/
const counter = meter.createCounter('dice-lib.rolls.counter');
function rollOnce(min: number, max: number) {
counter.add(1);
return Math.floor(Math.random() * (max - min + 1) + min);
--- END CODE BLOCK ---
In some cases you may not be able or may not want to use the
full OpenTelemetry SDK for Node.js
This is also true if you want to use OpenTelemetry JavaScript in the browser.
If so, you can initialize metrics with the
--- CODE BLOCK 209 ---
/*dice.js*/
const counter = meter.createCounter('dice-lib.rolls.counter');
function rollOnce(min, max) {
counter.add(1);
return Math.floor(Math.random() * (max - min + 1) + min);
--- END CODE BLOCK ---
package:
--- CODE BLOCK 210 ---
/*dice.js*/
const counter = meter.createCounter('dice-lib.rolls.counter');
function rollOnce(min, max) {
counter.add(1);
return Math.floor(Math.random() * (max - min + 1) + min);
--- END CODE BLOCK ---
If you have not created it for tracing already, create a separate
--- CODE BLOCK 212 ---
const counter = myMeter.createUpDownCounter('events.counter');
//...
counter.add(1);
//...
counter.add(-1);
--- END CODE BLOCK ---
--- CODE BLOCK 213 ---
import express from 'express';
const app = express();
app.get('/', (_req, _res) => {
const histogram = myMeter.createHistogram('task.duration');
const startTime = new Date().getTime();
// do some work in an API call
const endTime = new Date().getTime();
const executionTime = endTime - startTime;
// Record the duration of the task operation
histogram.record(executionTime);
--- END CODE BLOCK ---
) file that has all the SDK
initialization code in it:
TypeScript
JavaScript
--- CODE BLOCK 214 ---
import express from 'express';
const app = express();
app.get('/', (_req, _res) => {
const histogram = myMeter.createHistogram('task.duration');
const startTime = new Date().getTime();
// do some work in an API call
const endTime = new Date().getTime();
const executionTime = endTime - startTime;
// Record the duration of the task operation
histogram.record(executionTime);
--- END CODE BLOCK ---
--- CODE BLOCK 216 ---
const express = require('express');
const app = express();
app.get('/', (_req, _res) => {
const histogram = myMeter.createHistogram('task.duration');
const startTime = new Date().getTime();
// do some work in an API call
const endTime = new Date().getTime();
const executionTime = endTime - startTime;
// Record the duration of the task operation
histogram.record(executionTime);
--- END CODE BLOCK ---
You’ll need to
--- CODE BLOCK 218 ---
const events = [];
const addEvent = (name) => {
events.push(name);
const counter = myMeter.createObservableCounter('events.counter');
counter.addCallback((result) => {
result.observe(events.length);
//... calls to addEvent
--- END CODE BLOCK ---
this file when you run your app, such as:
TypeScript
JavaScript
--- CODE BLOCK 219 ---
const events = [];
const addEvent = (name) => {
events.push(name);
const removeEvent = () => {
events.pop();
const counter = myMeter.createObservableUpDownCounter('events.counter');
counter.addCallback((result) => {
result.observe(events.length);
//... calls to addEvent and removeEvent
--- END CODE BLOCK ---
--- CODE BLOCK 221 ---
let temperature = 32;
const gauge = myMeter.createObservableGauge('temperature.gauge');
gauge.addCallback((result) => {
result.observe(temperature);
//... temperature variable is modified by a sensor
--- END CODE BLOCK ---
Now that a
--- CODE BLOCK 223 ---
const httpServerResponseDuration = myMeter.createHistogram(
'http.server.duration',
description: 'A distribution of the HTTP server response times',
unit: 'milliseconds',
valueType: ValueType.INT,
--- END CODE BLOCK ---
is configured, you can acquire a
--- CODE BLOCK 224 ---
const httpServerResponseDuration = myMeter.createHistogram(
'http.server.duration',
description: 'A distribution of the HTTP server response times',
unit: 'milliseconds',
valueType: ValueType.INT,
--- END CODE BLOCK ---
Acquiring a Meter
Anywhere in your application where you have manually instrumented code you can
call
--- CODE BLOCK 225 ---
description
--- END CODE BLOCK ---
to acquire a meter. For example:
TypeScript
JavaScript
--- CODE BLOCK 227 ---
milliseconds
--- END CODE BLOCK ---
--- CODE BLOCK 231 ---
const counter = myMeter.createCounter('my.counter');
counter.add(1, { 'some.optional.attribute': 'some value' });
--- END CODE BLOCK ---
The values of
--- CODE BLOCK 233 ---
instrumentName
--- END CODE BLOCK ---
--- CODE BLOCK 235 ---
meterVersion
--- END CODE BLOCK ---
should uniquely identify the
Instrumentation Scope
, such as the
package, module or class name. While the name is required, the version is still
recommended despite being optional.
It’s generally recommended to call
--- CODE BLOCK 236 ---
meterSchemaUrl
--- END CODE BLOCK ---
in your app when you need it
rather than exporting the meter instance to the rest of your app. This helps
avoid trickier application load issues when other required dependencies are
involved.
In the case of the
example app
, there are two places where a
tracer may be acquired with an appropriate Instrumentation Scope:
First, in the
application file
--- CODE BLOCK 237 ---
instrumentName
--- END CODE BLOCK ---
--- CODE BLOCK 241 ---
const limitAttributesView = {
// only export the attribute 'environment'
attributeKeys: ['environment'],
// apply the view to all instruments
instrumentName: '*',
--- END CODE BLOCK ---
TypeScript
JavaScript
--- CODE BLOCK 242 ---
const limitAttributesView = {
// only export the attribute 'environment'
attributeKeys: ['environment'],
// apply the view to all instruments
instrumentName: '*',
--- END CODE BLOCK ---
--- CODE BLOCK 245 ---
const dropView = {
aggregation: { type: AggrgationType.DROP },
meterName: 'pubsub',
--- END CODE BLOCK ---
And second, in the
library file
--- CODE BLOCK 247 ---
const histogramView = {
aggregation: {
type: AggregationType.EXPLICIT_BUCKET_HISTOGRAM,
options: { boundaries: [0, 1, 5, 10, 15, 20, 25, 30] },
instrumentName: 'http.server.duration',
instrumentType: InstrumentType.HISTOGRAM,
--- END CODE BLOCK ---
--- CODE BLOCK 248 ---
const histogramView = {
aggregation: {
type: AggregationType.EXPLICIT_BUCKET_HISTOGRAM,
options: { boundaries: [0, 1, 5, 10, 15, 20, 25, 30] },
instrumentName: 'http.server.duration',
instrumentType: InstrumentType.HISTOGRAM,
--- END CODE BLOCK ---
TypeScript
JavaScript
--- CODE BLOCK 249 ---
const meterProvider = new MeterProvider({
views: [limitAttributesView, dropView, histogramView],
--- END CODE BLOCK ---
[CODE_BLOCK_205]
Now that you have
meters
initialized.
you can create
metric instruments
Using counters
Counters can be used to measure a non-negative, increasing value.
In the case of our
example app
we can use this to count how
often the dice has been rolled:
TypeScript
JavaScript
[CODE_BLOCK_207]
[CODE_BLOCK_209]
Using UpDown Counters
UpDown counters can increment and decrement, allowing you to observe a
cumulative value that goes up or down.
[CODE_BLOCK_211]
Using Histograms
Histograms are used to measure a distribution of values over time.
For example, here’s how you report a distribution of response times for an API
route with Express:
TypeScript
JavaScript
[CODE_BLOCK_213]
[CODE_BLOCK_215]
Using Observable (Async) Counters
Observable counters can be used to measure an additive, non-negative,
monotonically increasing value.
[CODE_BLOCK_217]
Using Observable (Async) UpDown Counters
Observable UpDown counters can increment and decrement, allowing you to measure
an additive, non-negative, non-monotonically increasing cumulative value.
[CODE_BLOCK_219]
Using Observable (Async) Gauges
Observable Gauges should be used to measure non-additive values.
[CODE_BLOCK_221]
Describing instruments
When you create instruments like counters, histograms, etc. you can give them a
description.
[CODE_BLOCK_223]
In JavaScript, each configuration type means the following:
[CODE_BLOCK_225]
- a human-readable description for the instrument
[CODE_BLOCK_226]
- The description of the unit of measure that the value is intended to
represent. For example,
[CODE_BLOCK_227]
to measure duration, or
[CODE_BLOCK_228]
count number of bytes.
[CODE_BLOCK_229]
- The kind of numeric value used in measurements.
It’s generally recommended to describe each instrument you create.
Adding attributes
You can add Attributes to metrics when they are generated.
[CODE_BLOCK_230]
Configure Metric Views
A Metric View provides developers with the ability to customize metrics exposed
by the Metrics SDK.
Selectors
To instantiate a view, one must first select a target instrument. The following
are valid selectors for metrics:
[CODE_BLOCK_232]
[CODE_BLOCK_233]
[CODE_BLOCK_234]
[CODE_BLOCK_235]
[CODE_BLOCK_236]
Selecting by
[CODE_BLOCK_237]
(of type string) has support for wildcards, so you
can select all instruments using
[CODE_BLOCK_238]
or select all instruments whose name starts
with
[CODE_BLOCK_239]
by using
[CODE_BLOCK_240]
Examples
Filter attributes on all metric types:
[CODE_BLOCK_241]
Drop all instruments with the meter name
[CODE_BLOCK_243]
[CODE_BLOCK_244]
Define explicit bucket sizes for the Histogram named
[CODE_BLOCK_246]
[CODE_BLOCK_247]
Attach to meter provider
Once views have been configured, attach them to the corresponding meter
provider:
[CODE_BLOCK_249]
Logs
The logs API & SDK are currently under development.
Next steps
You’ll also want to configure an appropriate exporter to
export your telemetry data
to one or more
telemetry backends.
Feedback
Was this page helpful?
Thank you. Your feedback is appreciated!
Please let us know
how we can improve this page
. Your feedback is appreciated!
Last modified June 11, 2025:
Alert cleanup (#7090) (c392c714)