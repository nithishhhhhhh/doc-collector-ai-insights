SOURCE URL: https://jestjs.io/docs/configuration
SCRAPED: 2025-06-19 18:36:02
================================================================================

Version: 30.0
On this page
The Jest philosophy is to work great by default, but sometimes you just need more configuration power.
It is recommended to define the configuration in a dedicated JavaScript, TypeScript or JSON file. The file will be discovered automatically, if it is named
--- CODE BLOCK 1 ---
jest.config.js|ts|mjs|cjs|cts|json
--- END CODE BLOCK ---
. You can use
--- CODE BLOCK 3 ---
/** @type {import('jest').Config} */const config = {  verbose: true,};module.exports = config;
--- END CODE BLOCK ---
flag to pass an explicit path to the file.
note
Keep in mind that the resulting configuration object must always be JSON-serializable.
The configuration file should simply export an object:
JavaScript
TypeScript
--- CODE BLOCK 4 ---
/** @type {import('jest').Config} */const config = {  verbose: true,};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 6 ---
import type {Config} from 'jest';const config: Config = {  verbose: true,};export default config;
--- END CODE BLOCK ---
Or a function returning an object:
JavaScript
TypeScript
--- CODE BLOCK 8 ---
/** @returns {Promise<import('jest').Config>} */module.exports = async () => {  return {    verbose: true,  };};
--- END CODE BLOCK ---
--- CODE BLOCK 10 ---
import type {Config} from 'jest';export default async (): Promise<Config> => {  return {    verbose: true,  };};
--- END CODE BLOCK ---
To read TypeScript configuration files Jest by default requires
--- CODE BLOCK 14 ---
esbuild-register
--- END CODE BLOCK ---
. You can override this behavior by adding a
--- CODE BLOCK 16 ---
/** @jest-config-loader ts-node */// or/** @jest-config-loader esbuild-register */import type {Config} from 'jest';const config: Config = {  verbose: true,};export default config;
--- END CODE BLOCK ---
docblock at the top of the file. Currently,
--- CODE BLOCK 17 ---
/** @jest-config-loader ts-node */// or/** @jest-config-loader esbuild-register */import type {Config} from 'jest';const config: Config = {  verbose: true,};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 18 ---
transpileOnly
--- END CODE BLOCK ---
is supported. Make sure
--- CODE BLOCK 19 ---
/** @jest-config-loader ts-node *//** @jest-config-loader-options {"transpileOnly": true} */import type {Config} from 'jest';const config: Config = {  verbose: true,};export default config;
--- END CODE BLOCK ---
or the loader you specify is installed.
jest.config.ts
--- CODE BLOCK 20 ---
/** @jest-config-loader ts-node *//** @jest-config-loader-options {"transpileOnly": true} */import type {Config} from 'jest';const config: Config = {  verbose: true,};export default config;
--- END CODE BLOCK ---
You can also pass options to the loader, for instance to enable
--- CODE BLOCK 22 ---
{  "bail": 1,  "verbose": true}
--- END CODE BLOCK ---
jest.config.ts
--- CODE BLOCK 24 ---
package.json
--- END CODE BLOCK ---
The configuration also can be stored in a JSON file as a plain object:
jest.config.json
--- CODE BLOCK 26 ---
{  "name": "my-project",  "jest": {    "verbose": true  }}
--- END CODE BLOCK ---
Alternatively Jest's configuration can be defined through the
--- CODE BLOCK 29 ---
{  "name": "my-project",  "jest": "./path/to/config.json"}
--- END CODE BLOCK ---
key in the
--- CODE BLOCK 30 ---
{  "name": "my-project",  "jest": "./path/to/config.json"}
--- END CODE BLOCK ---
of your project:
package.json
--- CODE BLOCK 31 ---
jest-config
--- END CODE BLOCK ---
Also Jest's configuration json file can be referenced through the
--- CODE BLOCK 33 ---
const {defaults} = require('jest-config');/** @type {import('jest').Config} */const config = {  moduleDirectories: [...defaults.moduleDirectories, 'bower_components'],};module.exports = config;
--- END CODE BLOCK ---
key in the
--- CODE BLOCK 34 ---
import type {Config} from 'jest';import {defaults} from 'jest-config';const config: Config = {  moduleDirectories: [...defaults.moduleDirectories, 'bower_components'],};export default config;
--- END CODE BLOCK ---
of your project:
package.json
--- CODE BLOCK 35 ---
import type {Config} from 'jest';import {defaults} from 'jest-config';const config: Config = {  moduleDirectories: [...defaults.moduleDirectories, 'bower_components'],};export default config;
--- END CODE BLOCK ---
Options
info
You can retrieve Jest's defaults from
--- CODE BLOCK 40 ---
collectCoverage
--- END CODE BLOCK ---
to extend them if needed:
JavaScript
TypeScript
--- CODE BLOCK 41 ---
collectCoverageFrom
--- END CODE BLOCK ---
--- CODE BLOCK 43 ---
coveragePathIgnorePatterns
--- END CODE BLOCK ---
--- CODE BLOCK 45 ---
coverageReporters
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 46 ---
coverageThreshold
--- END CODE BLOCK ---
[number | boolean]
--- CODE BLOCK 47 ---
dependencyExtractor
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 48 ---
displayName
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 49 ---
errorOnDeprecated
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 50 ---
extensionsToTreatAsEsm
--- END CODE BLOCK ---
[array]
--- CODE BLOCK 52 ---
forceCoverageMatch
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 54 ---
globalSetup
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 55 ---
globalTeardown
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 57 ---
injectGlobals
--- END CODE BLOCK ---
[array<string | [string, options]>]
--- CODE BLOCK 58 ---
maxConcurrency
--- END CODE BLOCK ---
[object]
--- CODE BLOCK 60 ---
moduleDirectories
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 61 ---
moduleFileExtensions
--- END CODE BLOCK ---
[string, object]
--- CODE BLOCK 62 ---
moduleNameMapper
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 63 ---
modulePathIgnorePatterns
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 64 ---
modulePaths
--- END CODE BLOCK ---
[object]
--- CODE BLOCK 67 ---
openHandlesTimeout
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 69 ---
prettierPath
--- END CODE BLOCK ---
[object]
--- CODE BLOCK 74 ---
resetModules
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 76 ---
restoreMocks
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 80 ---
sandboxInjectedGlobals
--- END CODE BLOCK ---
[object]
--- CODE BLOCK 82 ---
setupFilesAfterEnv
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 84 ---
slowTestThreshold
--- END CODE BLOCK ---
[number]
--- CODE BLOCK 85 ---
snapshotFormat
--- END CODE BLOCK ---
[number | string]
--- CODE BLOCK 86 ---
snapshotResolver
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 87 ---
snapshotSerializers
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 88 ---
testEnvironment
--- END CODE BLOCK ---
[object<string, string | array<string>>]
--- CODE BLOCK 89 ---
testEnvironmentOptions
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 90 ---
testFailureExitCode
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 92 ---
testPathIgnorePatterns
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 94 ---
testResultsProcessor
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 96 ---
testSequencer
--- END CODE BLOCK ---
[number]
--- CODE BLOCK 97 ---
testTimeout
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 99 ---
transformIgnorePatterns
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 100 ---
unmockedModulePathPatterns
--- END CODE BLOCK ---
[array<string | ProjectConfig>]
--- CODE BLOCK 102 ---
waitForUnhandledRejections
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 103 ---
watchPathIgnorePatterns
--- END CODE BLOCK ---
[array<moduleName | [moduleName, options]>]
--- CODE BLOCK 104 ---
watchPlugins
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 106 ---
workerIdleMemoryLimit
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 108 ---
workerThreads
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 111 ---
export default {  authorize: () => 'token',  isAuthorized: secret => secret === 'wizard',};
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 112 ---
export default {  authorize: () => 'token',  isAuthorized: secret => secret === 'wizard',};
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 113 ---
import utils from '../utils';test('if utils mocked automatically', () => {  // Public methods of `utils` are now mock functions  expect(utils.authorize.mock).toBeTruthy();  expect(utils.isAuthorized.mock).toBeTruthy();  // You can provide them with your own implementation  // or pass the expected return value  utils.authorize.mockReturnValue('mocked_token');  utils.isAuthorized.mockReturnValue(true);  expect(utils.authorize()).toBe('mocked_token');  expect(utils.isAuthorized('not_wizard')).toBeTruthy();});
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 114 ---
import utils from '../utils';test('if utils mocked automatically', () => {  // Public methods of `utils` are now mock functions  expect(utils.authorize.mock).toBeTruthy();  expect(utils.isAuthorized.mock).toBeTruthy();  // You can provide them with your own implementation  // or pass the expected return value  utils.authorize.mockReturnValue('mocked_token');  utils.isAuthorized.mockReturnValue(true);  expect(utils.authorize()).toBe('mocked_token');  expect(utils.isAuthorized('not_wizard')).toBeTruthy();});
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 115 ---
__mocks__/lodash.js
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 117 ---
jest.mock('fs')
--- END CODE BLOCK ---
[array]
--- CODE BLOCK 123 ---
cacheDirectory
--- END CODE BLOCK ---
[array]
--- CODE BLOCK 124 ---
"/tmp/<path>"
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 127 ---
jest.clearAllMocks()
--- END CODE BLOCK ---
[number]
--- CODE BLOCK 128 ---
collectCoverage
--- END CODE BLOCK ---
[object]
--- CODE BLOCK 132 ---
coverageProvider
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 135 ---
/* istanbul ignore next */
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 136 ---
/* c8 ignore next */
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 139 ---
collectCoverageFrom
--- END CODE BLOCK ---
[Object]
--- CODE BLOCK 141 ---
/** @type {import('jest').Config} */const config = {  collectCoverageFrom: [    '**/*.{js,jsx}',    '!**/node_modules/**',    '!**/vendor/**',  ],};module.exports = config;
--- END CODE BLOCK ---
[number]
--- CODE BLOCK 142 ---
/** @type {import('jest').Config} */const config = {  collectCoverageFrom: [    '**/*.{js,jsx}',    '!**/node_modules/**',    '!**/vendor/**',  ],};module.exports = config;
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 143 ---
import type {Config} from 'jest';const config: Config = {  collectCoverageFrom: [    '**/*.{js,jsx}',    '!**/node_modules/**',    '!**/vendor/**',  ],};export default config;
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 144 ---
import type {Config} from 'jest';const config: Config = {  collectCoverageFrom: [    '**/*.{js,jsx}',    '!**/node_modules/**',    '!**/vendor/**',  ],};export default config;
--- END CODE BLOCK ---
[string | array<string>]
--- CODE BLOCK 146 ---
**/node_modules/**
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 147 ---
**/vendor/**
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 148 ---
["!**/__tests__/**", "**/*.js"]
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 151 ---
collectCoverage
--- END CODE BLOCK ---
[number]
--- CODE BLOCK 154 ---
=============================== Coverage summary ===============================Statements   : Unknown% ( 0/0 )Branches     : Unknown% ( 0/0 )Functions    : Unknown% ( 0/0 )Lines        : Unknown% ( 0/0 )================================================================================Jest: Coverage data for global was not found.
--- END CODE BLOCK ---
[object<string, pathToTransformer | [pathToTransformer, object]>]
--- CODE BLOCK 155 ---
=============================== Coverage summary ===============================Statements   : Unknown% ( 0/0 )Branches     : Unknown% ( 0/0 )Functions    : Unknown% ( 0/0 )Lines        : Unknown% ( 0/0 )================================================================================Jest: Coverage data for global was not found.
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 156 ---
coverageDirectory
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 158 ---
coveragePathIgnorePatterns
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 159 ---
["/node_modules/"]
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 161 ---
["<rootDir>/build/", "<rootDir>/node_modules/"]
--- END CODE BLOCK ---
[array<string>]
--- CODE BLOCK 162 ---
coverageProvider
--- END CODE BLOCK ---
[array<string | [string, Object]>]
--- CODE BLOCK 165 ---
coverageReporters
--- END CODE BLOCK ---
[boolean]
--- CODE BLOCK 166 ---
["clover", "json", "lcov", "text"]
--- END CODE BLOCK ---
[number|string]
--- CODE BLOCK 168 ---
"text-summary"
--- END CODE BLOCK ---
[string]
--- CODE BLOCK 169 ---
/** @type {import('jest').Config} */const config = {  coverageReporters: ['clover', 'json', 'lcov', ['text', {skipFull: true}]],};module.exports = config;
--- END CODE BLOCK ---
Reference
--- CODE BLOCK 170 ---
/** @type {import('jest').Config} */const config = {  coverageReporters: ['clover', 'json', 'lcov', ['text', {skipFull: true}]],};module.exports = config;
--- END CODE BLOCK ---
[boolean]
Default:
--- CODE BLOCK 171 ---
import type {Config} from 'jest';const config: Config = {  coverageReporters: ['clover', 'json', 'lcov', ['text', {skipFull: true}]],};export default config;
--- END CODE BLOCK ---
This option tells Jest that all imported modules in your tests should be mocked automatically. All modules used in your tests will have a replacement implementation, keeping the API surface.
Example:
utils.js
--- CODE BLOCK 172 ---
import type {Config} from 'jest';const config: Config = {  coverageReporters: ['clover', 'json', 'lcov', ['text', {skipFull: true}]],};export default config;
--- END CODE BLOCK ---
__tests__/automock.test.js
--- CODE BLOCK 174 ---
coverageThreshold
--- END CODE BLOCK ---
note
Node modules are automatically mocked when you have a manual mock in place (e.g.:
--- CODE BLOCK 178 ---
/** @type {import('jest').Config} */const config = {  coverageThreshold: {    global: {      branches: 80,      functions: 80,      lines: 80,      statements: -10,    },  },};module.exports = config;
--- END CODE BLOCK ---
). More info
here
Node.js core modules, like
--- CODE BLOCK 179 ---
import type {Config} from 'jest';const config: Config = {  coverageThreshold: {    global: {      branches: 80,      functions: 80,      lines: 80,      statements: -10,    },  },};export default config;
--- END CODE BLOCK ---
, are not mocked by default. They can be mocked explicitly, like
--- CODE BLOCK 180 ---
import type {Config} from 'jest';const config: Config = {  coverageThreshold: {    global: {      branches: 80,      functions: 80,      lines: 80,      statements: -10,    },  },};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 182 ---
/** @type {import('jest').Config} */const config = {  coverageThreshold: {    global: {      branches: 50,      functions: 50,      lines: 50,      statements: 50,    },    './src/components/': {      branches: 40,      statements: 40,    },    './src/reducers/**/*.js': {      statements: 90,    },    './src/api/very-important-module.js': {      branches: 100,      functions: 100,      lines: 100,      statements: 100,    },  },};module.exports = config;
--- END CODE BLOCK ---
[number | boolean]
Default:
--- CODE BLOCK 183 ---
/** @type {import('jest').Config} */const config = {  coverageThreshold: {    global: {      branches: 50,      functions: 50,      lines: 50,      statements: 50,    },    './src/components/': {      branches: 40,      statements: 40,    },    './src/reducers/**/*.js': {      statements: 90,    },    './src/api/very-important-module.js': {      branches: 100,      functions: 100,      lines: 100,      statements: 100,    },  },};module.exports = config;
--- END CODE BLOCK ---
By default, Jest runs all tests and produces all errors into the console upon completion. The bail config option can be used here to have Jest stop running tests after
--- CODE BLOCK 184 ---
import type {Config} from 'jest';const config: Config = {  coverageThreshold: {    global: {      branches: 50,      functions: 50,      lines: 50,      statements: 50,    },    './src/components/': {      branches: 40,      statements: 40,    },    './src/reducers/**/*.js': {      statements: 90,    },    './src/api/very-important-module.js': {      branches: 100,      functions: 100,      lines: 100,      statements: 100,    },  },};export default config;
--- END CODE BLOCK ---
failures. Setting bail to
--- CODE BLOCK 185 ---
import type {Config} from 'jest';const config: Config = {  coverageThreshold: {    global: {      branches: 50,      functions: 50,      lines: 50,      statements: 50,    },    './src/components/': {      branches: 40,      statements: 40,    },    './src/reducers/**/*.js': {      statements: 90,    },    './src/api/very-important-module.js': {      branches: 100,      functions: 100,      lines: 100,      statements: 100,    },  },};export default config;
--- END CODE BLOCK ---
is the same as setting bail to
--- CODE BLOCK 186 ---
./src/components
--- END CODE BLOCK ---
--- CODE BLOCK 187 ---
./src/reducers/**/*.js
--- END CODE BLOCK ---
[string]
Default:
--- CODE BLOCK 188 ---
./src/api/very-important-module.js
--- END CODE BLOCK ---
The directory where Jest should store its cached dependency information.
Jest attempts to scan your dependency tree once (up-front) and cache it in order to ease some of the filesystem churn that needs to happen while running tests. This config option lets you customize where Jest stores that cache data on disk.
--- CODE BLOCK 190 ---
dependencyExtractor
--- END CODE BLOCK ---
[boolean]
Default:
--- CODE BLOCK 193 ---
const crypto = require('crypto');const fs = require('fs');module.exports = {  extract(code, filePath, defaultExtract) {    const deps = defaultExtract(code, filePath);    // Scan the file and add dependencies in `deps` (which is a `Set`)    return deps;  },  getCacheKey() {    return crypto      .createHash('md5')      .update(fs.readFileSync(__filename))      .digest('hex');  },};
--- END CODE BLOCK ---
Automatically clear mock calls, instances, contexts and results before every test. Equivalent to calling
--- CODE BLOCK 194 ---
const crypto = require('crypto');const fs = require('fs');module.exports = {  extract(code, filePath, defaultExtract) {    const deps = defaultExtract(code, filePath);    // Scan the file and add dependencies in `deps` (which is a `Set`)    return deps;  },  getCacheKey() {    return crypto      .createHash('md5')      .update(fs.readFileSync(__filename))      .digest('hex');  },};
--- END CODE BLOCK ---
before each test. This does not remove any mock implementation that may have been provided.
--- CODE BLOCK 198 ---
getCacheKey
--- END CODE BLOCK ---
[boolean]
Default:
--- CODE BLOCK 199 ---
displayName
--- END CODE BLOCK ---
Indicates whether the coverage information should be collected while executing the test. Because this retrofits all executed files with coverage collection statements, it may significantly slow down your tests.
Jest ships with two coverage providers:
--- CODE BLOCK 201 ---
/** @type {import('jest').Config} */const config = {  displayName: 'CLIENT',};module.exports = config;
--- END CODE BLOCK ---
(default) and
--- CODE BLOCK 202 ---
/** @type {import('jest').Config} */const config = {  displayName: 'CLIENT',};module.exports = config;
--- END CODE BLOCK ---
. See the
--- CODE BLOCK 203 ---
import type {Config} from 'jest';const config: Config = {  displayName: 'CLIENT',};export default config;
--- END CODE BLOCK ---
option for more details.
info
--- CODE BLOCK 204 ---
import type {Config} from 'jest';const config: Config = {  displayName: 'CLIENT',};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 207 ---
displayName
--- END CODE BLOCK ---
coverage providers use
--- CODE BLOCK 210 ---
/** @type {import('jest').Config} */const config = {  displayName: {    name: 'CLIENT',    color: 'blue',  },};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 211 ---
/** @type {import('jest').Config} */const config = {  displayName: {    name: 'CLIENT',    color: 'blue',  },};module.exports = config;
--- END CODE BLOCK ---
comments to exclude lines from coverage reports, respectively. For more information, you can view the
--- CODE BLOCK 212 ---
import type {Config} from 'jest';const config: Config = {  displayName: {    name: 'CLIENT',    color: 'blue',  },};export default config;
--- END CODE BLOCK ---
documentation
and the
--- CODE BLOCK 213 ---
import type {Config} from 'jest';const config: Config = {  displayName: {    name: 'CLIENT',    color: 'blue',  },};export default config;
--- END CODE BLOCK ---
documentation
--- CODE BLOCK 214 ---
errorOnDeprecated
--- END CODE BLOCK ---
[array]
Default:
--- CODE BLOCK 216 ---
extensionsToTreatAsEsm
--- END CODE BLOCK ---
An array of
glob patterns
indicating a set of files for which coverage information should be collected. If a file matches the specified glob pattern, coverage information will be collected for it even if no tests exist for this file and it's never required in the test suite.
JavaScript
TypeScript
--- CODE BLOCK 220 ---
package.json
--- END CODE BLOCK ---
--- CODE BLOCK 224 ---
/** @type {import('jest').Config} */const config = {  extensionsToTreatAsEsm: ['.ts'],};module.exports = config;
--- END CODE BLOCK ---
This will collect coverage information for all the files inside the project's
--- CODE BLOCK 226 ---
import type {Config} from 'jest';const config: Config = {  extensionsToTreatAsEsm: ['.ts'],};export default config;
--- END CODE BLOCK ---
, except the ones that match
--- CODE BLOCK 229 ---
jest.useFakeTimers()
--- END CODE BLOCK ---
--- CODE BLOCK 230 ---
process.nextTick()
--- END CODE BLOCK ---
Each glob pattern is applied in the order they are specified in the config. For example
--- CODE BLOCK 231 ---
/** @type {import('jest').Config} */const config = {  fakeTimers: {    doNotFake: ['nextTick'],    timerLimit: 1000,  },};module.exports = config;
--- END CODE BLOCK ---
will not exclude
--- CODE BLOCK 232 ---
/** @type {import('jest').Config} */const config = {  fakeTimers: {    doNotFake: ['nextTick'],    timerLimit: 1000,  },};module.exports = config;
--- END CODE BLOCK ---
because the negation is overwritten with the second pattern. In order to make the negated glob work in this example it has to come after
--- CODE BLOCK 233 ---
import type {Config} from 'jest';const config: Config = {  fakeTimers: {    doNotFake: ['nextTick'],    timerLimit: 1000,  },};export default config;
--- END CODE BLOCK ---
note
This option requires
--- CODE BLOCK 234 ---
import type {Config} from 'jest';const config: Config = {  fakeTimers: {    doNotFake: ['nextTick'],    timerLimit: 1000,  },};export default config;
--- END CODE BLOCK ---
to be set to
--- CODE BLOCK 235 ---
// install fake timers for this file using the options from Jest configurationjest.useFakeTimers();test('increase the limit of recursive timers for this and following tests', () => {  jest.useFakeTimers({timerLimit: 5000});  // ...});
--- END CODE BLOCK ---
or Jest to be invoked with
--- CODE BLOCK 236 ---
// install fake timers for this file using the options from Jest configurationjest.useFakeTimers();test('increase the limit of recursive timers for this and following tests', () => {  jest.useFakeTimers({timerLimit: 5000});  // ...});
--- END CODE BLOCK ---
Help:
If you are seeing coverage output such as...
--- CODE BLOCK 237 ---
jest.useFakeTimers()
--- END CODE BLOCK ---
Most likely your glob patterns are not matching any files. Refer to the
micromatch
documentation to ensure your globs are compatible.
--- CODE BLOCK 239 ---
/** @type {import('jest').Config} */const config = {  fakeTimers: {    enableGlobally: true,  },};module.exports = config;
--- END CODE BLOCK ---
[string]
Default:
--- CODE BLOCK 240 ---
import type {Config} from 'jest';const config: Config = {  fakeTimers: {    enableGlobally: true,  },};export default config;
--- END CODE BLOCK ---
The directory where Jest should output its coverage files.
--- CODE BLOCK 241 ---
import type {Config} from 'jest';const config: Config = {  fakeTimers: {    enableGlobally: true,  },};export default config;
--- END CODE BLOCK ---
[array<string>]
Default:
--- CODE BLOCK 242 ---
type FakeableAPI =  | 'Date'  | 'hrtime'  | 'nextTick'  | 'performance'  | 'queueMicrotask'  | 'requestAnimationFrame'  | 'cancelAnimationFrame'  | 'requestIdleCallback'  | 'cancelIdleCallback'  | 'setImmediate'  | 'clearImmediate'  | 'setInterval'  | 'clearInterval'  | 'setTimeout'  | 'clearTimeout';type ModernFakeTimersConfig = {  /**   * If set to `true` all timers will be advanced automatically by 20 milliseconds   * every 20 milliseconds. A custom time delta may be provided by passing a number.   * The default is `false`.   */  advanceTimers?: boolean | number;  /**   * List of names of APIs that should not be faked. The default is `[]`, meaning   * all APIs are faked.   */  doNotFake?: Array<FakeableAPI>;  /** Whether fake timers should be enabled for all test files. The default is `false`. */  enableGlobally?: boolean;  /**   * Use the old fake timers implementation instead of one backed by `@sinonjs/fake-timers`.   * The default is `false`.   */  legacyFakeTimers?: boolean;  /** Sets current system time to be used by fake timers, in milliseconds. The default is `Date.now()`. */  now?: number;  /** Maximum number of recursive timers that will be run. The default is `100_000` timers. */  timerLimit?: number;};
--- END CODE BLOCK ---
An array of regexp pattern strings that are matched against all file paths before executing the test. If the file path matches any of the patterns, coverage information will be skipped.
These pattern strings match against the full path. Use the
--- CODE BLOCK 243 ---
type FakeableAPI =  | 'Date'  | 'hrtime'  | 'nextTick'  | 'performance'  | 'queueMicrotask'  | 'requestAnimationFrame'  | 'cancelAnimationFrame'  | 'requestIdleCallback'  | 'cancelIdleCallback'  | 'setImmediate'  | 'clearImmediate'  | 'setInterval'  | 'clearInterval'  | 'setTimeout'  | 'clearTimeout';type ModernFakeTimersConfig = {  /**   * If set to `true` all timers will be advanced automatically by 20 milliseconds   * every 20 milliseconds. A custom time delta may be provided by passing a number.   * The default is `false`.   */  advanceTimers?: boolean | number;  /**   * List of names of APIs that should not be faked. The default is `[]`, meaning   * all APIs are faked.   */  doNotFake?: Array<FakeableAPI>;  /** Whether fake timers should be enabled for all test files. The default is `false`. */  enableGlobally?: boolean;  /**   * Use the old fake timers implementation instead of one backed by `@sinonjs/fake-timers`.   * The default is `false`.   */  legacyFakeTimers?: boolean;  /** Sets current system time to be used by fake timers, in milliseconds. The default is `Date.now()`. */  now?: number;  /** Maximum number of recursive timers that will be run. The default is `100_000` timers. */  timerLimit?: number;};
--- END CODE BLOCK ---
string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example:
--- CODE BLOCK 244 ---
/** @type {import('jest').Config} */const config = {  fakeTimers: {    enableGlobally: true,    legacyFakeTimers: true,  },};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 245 ---
/** @type {import('jest').Config} */const config = {  fakeTimers: {    enableGlobally: true,    legacyFakeTimers: true,  },};module.exports = config;
--- END CODE BLOCK ---
[string]
Indicates which provider should be used to instrument code for coverage. Allowed values are
--- CODE BLOCK 246 ---
import type {Config} from 'jest';const config: Config = {  fakeTimers: {    enableGlobally: true,    legacyFakeTimers: true,  },};export default config;
--- END CODE BLOCK ---
(default) or
--- CODE BLOCK 247 ---
import type {Config} from 'jest';const config: Config = {  fakeTimers: {    enableGlobally: true,    legacyFakeTimers: true,  },};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 248 ---
forceCoverageMatch
--- END CODE BLOCK ---
[array<string | [string, options]>]
Default:
--- CODE BLOCK 251 ---
export function sum(a, b) {  return a + b;}if (process.env.NODE_ENV === 'test') {  test('sum', () => {    expect(sum(1, 2)).toBe(3);  });}
--- END CODE BLOCK ---
A list of reporter names that Jest uses when writing coverage reports. Any
istanbul reporter
can be used.
Setting this option overwrites the default values. Add
--- CODE BLOCK 252 ---
export function sum(a, b) {  return a + b;}if (process.env.NODE_ENV === 'test') {  test('sum', () => {    expect(sum(1, 2)).toBe(3);  });}
--- END CODE BLOCK ---
--- CODE BLOCK 253 ---
forceCoverageMatch
--- END CODE BLOCK ---
to see a coverage summary in the console output.
Additional options can be passed using the tuple form. For example, you may hide coverage report lines for all fully-covered files:
JavaScript
TypeScript
--- CODE BLOCK 254 ---
/** @type {import('jest').Config} */const config = {  forceCoverageMatch: ['**/*.t.js'],};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 256 ---
import type {Config} from 'jest';const config: Config = {  forceCoverageMatch: ['**/*.t.js'],};export default config;
--- END CODE BLOCK ---
For more information about the options object shape refer to
--- CODE BLOCK 262 ---
/** @type {import('jest').Config} */const config = {  globals: {    __DEV__: true,  },};module.exports = config;
--- END CODE BLOCK ---
type in the
type definitions
--- CODE BLOCK 263 ---
/** @type {import('jest').Config} */const config = {  globals: {    __DEV__: true,  },};module.exports = config;
--- END CODE BLOCK ---
[object]
Default:
--- CODE BLOCK 264 ---
import type {Config} from 'jest';const config: Config = {  globals: {    __DEV__: true,  },};export default config;
--- END CODE BLOCK ---
This will be used to configure minimum threshold enforcement for coverage results. Thresholds can be specified as
--- CODE BLOCK 265 ---
import type {Config} from 'jest';const config: Config = {  globals: {    __DEV__: true,  },};export default config;
--- END CODE BLOCK ---
, as a
glob
, and as a directory or file path. If thresholds aren't met, jest will fail. Thresholds specified as a positive number are taken to be the minimum percentage required. Thresholds specified as a negative number represent the maximum number of uncovered entities allowed.
For example, with the following configuration jest will fail if there is less than 80% branch, line, and function coverage, or if there are more than 10 uncovered statements:
JavaScript
TypeScript
--- CODE BLOCK 268 ---
globalSetup
--- END CODE BLOCK ---
--- CODE BLOCK 271 ---
projectConfig
--- END CODE BLOCK ---
If globs or paths are specified alongside
--- CODE BLOCK 273 ---
globalTeardown
--- END CODE BLOCK ---
, coverage data for matching paths will be subtracted from overall coverage and thresholds will be applied independently. Thresholds for globs are applied to all files matching the glob. If the file specified by path is not found, an error is returned.
For example, with the following configuration:
JavaScript
TypeScript
--- CODE BLOCK 274 ---
node_modules
--- END CODE BLOCK ---
--- CODE BLOCK 278 ---
module.exports = async function (globalConfig, projectConfig) {  console.log(globalConfig.testPathPatterns);  console.log(projectConfig.cache);  // Set reference to mongod in order to close the server during teardown.  globalThis.__MONGOD__ = mongod;};
--- END CODE BLOCK ---
Jest will fail if:
--- CODE BLOCK 280 ---
module.exports = async function (globalConfig, projectConfig) {  console.log(globalConfig.testPathPatterns);  console.log(projectConfig.cache);  await globalThis.__MONGOD__.stop();};
--- END CODE BLOCK ---
directory has less than 40% branch or statement coverage.
One of the files matching the
--- CODE BLOCK 281 ---
globalTeardown
--- END CODE BLOCK ---
glob has less than 90% statement coverage.
--- CODE BLOCK 283 ---
globalConfig
--- END CODE BLOCK ---
file has less than 100% coverage.
Every remaining file combined has less than 50% coverage (
--- CODE BLOCK 284 ---
projectConfig
--- END CODE BLOCK ---
--- CODE BLOCK 285 ---
node_modules
--- END CODE BLOCK ---
[string]
Default:
--- CODE BLOCK 286 ---
globalSetup
--- END CODE BLOCK ---
This option allows the use of a custom dependency extractor. It must be a node module that exports an object with an
--- CODE BLOCK 287 ---
globalTeardown
--- END CODE BLOCK ---
function. E.g.:
--- CODE BLOCK 290 ---
jest-haste-map
--- END CODE BLOCK ---
--- CODE BLOCK 292 ---
type HasteConfig = {  /** Whether to hash files using SHA-1. */  computeSha1?: boolean;  /** The platform to use as the default, e.g. 'ios'. */  defaultPlatform?: string | null;  /** Force use of Node's `fs` APIs rather than shelling out to `find` */  forceNodeFilesystemAPI?: boolean;  /**   * Whether to follow symlinks when crawling for files.   *   This options cannot be used in projects which use watchman.   *   Projects with `watchman` set to true will error if this option is set to true.   */  enableSymlinks?: boolean;  /** Path to a custom implementation of Haste. */  hasteImplModulePath?: string;  /** All platforms to target, e.g ['ios', 'android']. */  platforms?: Array<string>;  /** Whether to throw an error on module collision. */  throwOnModuleCollision?: boolean;  /** Custom HasteMap module */  hasteMapModulePath?: string;  /** Whether to retain all files, allowing e.g. search for tests in `node_modules`. */  retainAllFiles?: boolean;};
--- END CODE BLOCK ---
function should return an iterable (
--- CODE BLOCK 293 ---
injectGlobals
--- END CODE BLOCK ---
--- CODE BLOCK 300 ---
@jest/globals
--- END CODE BLOCK ---
, etc.) with the dependencies found in the code.
That module can also contain a
--- CODE BLOCK 301 ---
import {expect, jest, test} from '@jest/globals';jest.useFakeTimers();test('some test', () => {  expect(Date.now()).toBe(0);});
--- END CODE BLOCK ---
function to generate a cache key to determine if the logic has changed and any cached artifacts relying on it should be discarded.
--- CODE BLOCK 302 ---
import {expect, jest, test} from '@jest/globals';jest.useFakeTimers();test('some test', () => {  expect(Date.now()).toBe(0);});
--- END CODE BLOCK ---
[string, object]
default:
--- CODE BLOCK 303 ---
jest-circus
--- END CODE BLOCK ---
Allows for a label to be printed alongside a test while it is running. This becomes more useful in multi-project repositories where there can be many jest configuration files. This visually tells which project a test belongs to.
JavaScript
TypeScript
--- CODE BLOCK 304 ---
maxConcurrency
--- END CODE BLOCK ---
--- CODE BLOCK 308 ---
/** @type {import('jest').Config} */const config = {  maxWorkers: '50%',};module.exports = config;
--- END CODE BLOCK ---
Alternatively, an object with the properties
--- CODE BLOCK 310 ---
import type {Config} from 'jest';const config: Config = {  maxWorkers: '50%',};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 311 ---
import type {Config} from 'jest';const config: Config = {  maxWorkers: '50%',};export default config;
--- END CODE BLOCK ---
can be passed. This allows for a custom configuration of the background color of the displayName.
--- CODE BLOCK 312 ---
moduleDirectories
--- END CODE BLOCK ---
defaults to white when its value is a string. Jest uses
--- CODE BLOCK 313 ---
["node_modules"]
--- END CODE BLOCK ---
to provide the color. As such, all of the valid options for colors supported by
--- CODE BLOCK 314 ---
node_modules
--- END CODE BLOCK ---
are also supported by Jest.
JavaScript
TypeScript
--- CODE BLOCK 315 ---
/** @type {import('jest').Config} */const config = {  moduleDirectories: ['node_modules', 'bower_components'],};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 317 ---
import type {Config} from 'jest';const config: Config = {  moduleDirectories: ['node_modules', 'bower_components'],};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 320 ---
moduleDirectories
--- END CODE BLOCK ---
[boolean]
Default:
--- CODE BLOCK 321 ---
@emotion/react
--- END CODE BLOCK ---
Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.
--- CODE BLOCK 323 ---
moduleFileExtensions
--- END CODE BLOCK ---
[array<string>]
Default:
--- CODE BLOCK 324 ---
["js", "mjs", "cjs", "jsx", "ts", "mts", "cts", "tsx", "json", "node"]
--- END CODE BLOCK ---
Jest will run
--- CODE BLOCK 325 ---
moduleNameMapper
--- END CODE BLOCK ---
--- CODE BLOCK 329 ---
/** @type {import('jest').Config} */const config = {  moduleNameMapper: {    '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',    '^[./a-zA-Z0-9$_-]+\\.png$': '<rootDir>/RelativeImageStub.js',    'module_name_(.*)': '<rootDir>/substituted_module_$1.js',    'assets/(.*)': [      '<rootDir>/images/$1',      '<rootDir>/photos/$1',      '<rootDir>/recipes/$1',    ],  },};module.exports = config;
--- END CODE BLOCK ---
files with nearest
--- CODE BLOCK 330 ---
/** @type {import('jest').Config} */const config = {  moduleNameMapper: {    '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',    '^[./a-zA-Z0-9$_-]+\\.png$': '<rootDir>/RelativeImageStub.js',    'module_name_(.*)': '<rootDir>/substituted_module_$1.js',    'assets/(.*)': [      '<rootDir>/images/$1',      '<rootDir>/photos/$1',      '<rootDir>/recipes/$1',    ],  },};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 331 ---
import type {Config} from 'jest';const config: Config = {  moduleNameMapper: {    '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',    '^[./a-zA-Z0-9$_-]+\\.png$': '<rootDir>/RelativeImageStub.js',    'module_name_(.*)': '<rootDir>/substituted_module_$1.js',    'assets/(.*)': [      '<rootDir>/images/$1',      '<rootDir>/photos/$1',      '<rootDir>/recipes/$1',    ],  },};export default config;
--- END CODE BLOCK ---
field set to
--- CODE BLOCK 332 ---
import type {Config} from 'jest';const config: Config = {  moduleNameMapper: {    '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',    '^[./a-zA-Z0-9$_-]+\\.png$': '<rootDir>/RelativeImageStub.js',    'module_name_(.*)': '<rootDir>/substituted_module_$1.js',    'assets/(.*)': [      '<rootDir>/images/$1',      '<rootDir>/photos/$1',      '<rootDir>/recipes/$1',    ],  },};export default config;
--- END CODE BLOCK ---
as ECMAScript Modules. If you have any other files that should run with native ESM, you need to specify their file extension here.
JavaScript
TypeScript
--- CODE BLOCK 337 ---
react-relay
--- END CODE BLOCK ---
--- CODE BLOCK 339 ---
modulePathIgnorePatterns
--- END CODE BLOCK ---
caution
Jest's ESM support is still experimental, see
its docs for more details
--- CODE BLOCK 344 ---
/** @type {import('jest').Config} */const config = {  modulePathIgnorePatterns: ['<rootDir>/build/'],};module.exports = config;
--- END CODE BLOCK ---
[object]
Default:
--- CODE BLOCK 345 ---
import type {Config} from 'jest';const config: Config = {  modulePathIgnorePatterns: ['<rootDir>/build/'],};export default config;
--- END CODE BLOCK ---
The fake timers may be useful when a piece of code sets a long timeout that we don't want to wait for in a test. For additional details see
Fake Timers guide
API documentation
This option provides the default configuration of fake timers for all tests. Calling
--- CODE BLOCK 346 ---
import type {Config} from 'jest';const config: Config = {  modulePathIgnorePatterns: ['<rootDir>/build/'],};export default config;
--- END CODE BLOCK ---
in a test file will use these options or will override them if a configuration object is passed. For example, you can tell Jest to keep the original implementation of
--- CODE BLOCK 347 ---
modulePaths
--- END CODE BLOCK ---
and adjust the limit of recursive timers that will be run:
JavaScript
TypeScript
--- CODE BLOCK 350 ---
modulePaths
--- END CODE BLOCK ---
--- CODE BLOCK 353 ---
/** @type {import('jest').Config} */const config = {  modulePaths: ['<rootDir>/app/'],};module.exports = config;
--- END CODE BLOCK ---
fakeTime.test.js
--- CODE BLOCK 355 ---
import type {Config} from 'jest';const config: Config = {  modulePaths: ['<rootDir>/app/'],};export default config;
--- END CODE BLOCK ---
Instead of including
--- CODE BLOCK 359 ---
npm install --save-dev node-notifier
--- END CODE BLOCK ---
in each test file, you can enable fake timers globally for all tests in your Jest configuration:
JavaScript
TypeScript
--- CODE BLOCK 360 ---
npm install --save-dev node-notifier
--- END CODE BLOCK ---
--- CODE BLOCK 362 ---
yarn add --dev node-notifier
--- END CODE BLOCK ---
Configuration options:
--- CODE BLOCK 364 ---
pnpm add --save-dev node-notifier
--- END CODE BLOCK ---
Legacy Fake Timers
For some reason you might have to use legacy implementation of fake timers. Here is how to enable it globally (additional options are not supported):
JavaScript
TypeScript
--- CODE BLOCK 366 ---
node-notifier
--- END CODE BLOCK ---
--- CODE BLOCK 369 ---
notify: true
--- END CODE BLOCK ---
--- CODE BLOCK 375 ---
failure-change
--- END CODE BLOCK ---
[array<string>]
Default:
--- CODE BLOCK 376 ---
openHandlesTimeout
--- END CODE BLOCK ---
Test files are normally ignored from collecting code coverage. With this option, you can overwrite this behavior and include otherwise ignored files in code coverage.
For example, if you have tests in source files named with
--- CODE BLOCK 381 ---
jest-preset.json
--- END CODE BLOCK ---
extension as following:
sum.t.js
--- CODE BLOCK 382 ---
jest-preset.js
--- END CODE BLOCK ---
You can collect coverage from those files with setting
--- CODE BLOCK 384 ---
jest-preset.mjs
--- END CODE BLOCK ---
JavaScript
TypeScript
--- CODE BLOCK 385 ---
foo-bar/jest-preset.js
--- END CODE BLOCK ---
--- CODE BLOCK 387 ---
/** @type {import('jest').Config} */const config = {  preset: 'foo-bar',};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 389 ---
import type {Config} from 'jest';const config: Config = {  preset: 'foo-bar',};export default config;
--- END CODE BLOCK ---
[object]
Default:
--- CODE BLOCK 390 ---
/** @type {import('jest').Config} */const config = {  preset: './node_modules/foo-bar/jest-preset.js',};module.exports = config;
--- END CODE BLOCK ---
A set of global variables that need to be available in all test environments.
For example, the following would create a global
--- CODE BLOCK 391 ---
/** @type {import('jest').Config} */const config = {  preset: './node_modules/foo-bar/jest-preset.js',};module.exports = config;
--- END CODE BLOCK ---
variable set to
--- CODE BLOCK 392 ---
import type {Config} from 'jest';const config: Config = {  preset: './node_modules/foo-bar/jest-preset.js',};export default config;
--- END CODE BLOCK ---
in all test environments:
JavaScript
TypeScript
--- CODE BLOCK 393 ---
import type {Config} from 'jest';const config: Config = {  preset: './node_modules/foo-bar/jest-preset.js',};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 401 ---
/** @type {import('jest').Config} */const config = {  projects: ['<rootDir>', '<rootDir>/examples/*'],};module.exports = config;
--- END CODE BLOCK ---
note
If you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will
be persisted across test runs for other test files. In addition, the
--- CODE BLOCK 403 ---
import type {Config} from 'jest';const config: Config = {  projects: ['<rootDir>', '<rootDir>/examples/*'],};export default config;
--- END CODE BLOCK ---
object must be json-serializable, so it can't be used to specify global functions. For that, you should use
--- CODE BLOCK 404 ---
import type {Config} from 'jest';const config: Config = {  projects: ['<rootDir>', '<rootDir>/examples/*'],};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 405 ---
/** @type {import('jest').Config} */const config = {  projects: [    {      displayName: 'test',    },    {      displayName: 'lint',      runner: 'jest-runner-eslint',      testMatch: ['<rootDir>/**/*.js'],    },  ],};module.exports = config;
--- END CODE BLOCK ---
[string]
Default:
--- CODE BLOCK 406 ---
/** @type {import('jest').Config} */const config = {  projects: [    {      displayName: 'test',    },    {      displayName: 'lint',      runner: 'jest-runner-eslint',      testMatch: ['<rootDir>/**/*.js'],    },  ],};module.exports = config;
--- END CODE BLOCK ---
This option allows the use of a custom global setup module, which must export a function (it can be sync or async). The function will be triggered once before all test suites and it will receive two arguments: Jest's
--- CODE BLOCK 407 ---
import type {Config} from 'jest';const config: Config = {  projects: [    {      displayName: 'test',    },    {      displayName: 'lint',      runner: 'jest-runner-eslint',      testMatch: ['<rootDir>/**/*.js'],    },  ],};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 408 ---
import type {Config} from 'jest';const config: Config = {  projects: [    {      displayName: 'test',    },    {      displayName: 'lint',      runner: 'jest-runner-eslint',      testMatch: ['<rootDir>/**/*.js'],    },  ],};export default config;
--- END CODE BLOCK ---
info
A global setup module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.
Any global variables that are defined through
--- CODE BLOCK 409 ---
displayName
--- END CODE BLOCK ---
can only be read in
--- CODE BLOCK 410 ---
displayName
--- END CODE BLOCK ---
. You cannot retrieve globals defined here in your test suites.
While code transformation is applied to the linked setup-file, Jest will
transform any code in
--- CODE BLOCK 415 ---
--randomize
--- END CODE BLOCK ---
. This is due to the need to load the actual transformers (e.g.
--- CODE BLOCK 418 ---
/** @type {import('jest').Config} */const config = {  reporters: [    'default',    ['<rootDir>/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],  ],};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 419 ---
/** @type {import('jest').Config} */const config = {  reporters: [    'default',    ['<rootDir>/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],  ],};module.exports = config;
--- END CODE BLOCK ---
) to perform transformation.
setup.js
--- CODE BLOCK 420 ---
import type {Config} from 'jest';const config: Config = {  reporters: [    'default',    ['<rootDir>/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],  ],};export default config;
--- END CODE BLOCK ---
teardown.js
--- CODE BLOCK 423 ---
/** @type {import('jest').Config} */const config = {  reporters: [    'default',    ['jest-junit', {outputDirectory: 'reports', outputName: 'report.xml'}],  ],};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 425 ---
import type {Config} from 'jest';const config: Config = {  reporters: [    'default',    ['jest-junit', {outputDirectory: 'reports', outputName: 'report.xml'}],  ],};export default config;
--- END CODE BLOCK ---
[string]
Default:
--- CODE BLOCK 426 ---
import type {Config} from 'jest';const config: Config = {  reporters: [    'default',    ['jest-junit', {outputDirectory: 'reports', outputName: 'report.xml'}],  ],};export default config;
--- END CODE BLOCK ---
This option allows the use of a custom global teardown module which must export a function (it can be sync or async). The function will be triggered once after all test suites and it will receive two arguments: Jest's
--- CODE BLOCK 427 ---
'silent: false'
--- END CODE BLOCK ---
--- CODE BLOCK 429 ---
'github-actions'
--- END CODE BLOCK ---
info
A global teardown module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.
The same caveat concerning transformation of
--- CODE BLOCK 433 ---
/** @type {import('jest').Config} */const config = {  reporters: [['github-actions', {silent: false}], 'summary'],};module.exports = config;
--- END CODE BLOCK ---
as for
--- CODE BLOCK 434 ---
/** @type {import('jest').Config} */const config = {  reporters: [['github-actions', {silent: false}], 'summary'],};module.exports = config;
--- END CODE BLOCK ---
applies to
--- CODE BLOCK 435 ---
import type {Config} from 'jest';const config: Config = {  reporters: [['github-actions', {silent: false}], 'summary'],};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 436 ---
import type {Config} from 'jest';const config: Config = {  reporters: [['github-actions', {silent: false}], 'summary'],};export default config;
--- END CODE BLOCK ---
[object]
Default:
--- CODE BLOCK 438 ---
/** @type {import('jest').Config} */const config = {  reporters: ['jest-silent-reporter', 'summary'],};module.exports = config;
--- END CODE BLOCK ---
This will be used to configure the behavior of
--- CODE BLOCK 439 ---
/** @type {import('jest').Config} */const config = {  reporters: ['jest-silent-reporter', 'summary'],};module.exports = config;
--- END CODE BLOCK ---
, Jest's internal file crawler/cache system. The following options are supported:
--- CODE BLOCK 440 ---
import type {Config} from 'jest';const config: Config = {  reporters: ['jest-silent-reporter', 'summary'],};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 444 ---
/** @type {import('jest').Config} */const config = {  reporters: [['default', {summaryThreshold: 10}]],};module.exports = config;
--- END CODE BLOCK ---
[boolean]
Default:
--- CODE BLOCK 445 ---
/** @type {import('jest').Config} */const config = {  reporters: [['default', {summaryThreshold: 10}]],};module.exports = config;
--- END CODE BLOCK ---
Insert Jest's globals (
--- CODE BLOCK 446 ---
import type {Config} from 'jest';const config: Config = {  reporters: [['default', {summaryThreshold: 10}]],};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 447 ---
import type {Config} from 'jest';const config: Config = {  reporters: [['default', {summaryThreshold: 10}]],};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 448 ---
summaryThreshold
--- END CODE BLOCK ---
--- CODE BLOCK 450 ---
globalConfig
--- END CODE BLOCK ---
etc.) into the global environment. If you set this to
--- CODE BLOCK 451 ---
reporterOptions
--- END CODE BLOCK ---
, you should import from
--- CODE BLOCK 452 ---
reporterContext
--- END CODE BLOCK ---
, e.g.
--- CODE BLOCK 453 ---
class CustomReporter {  constructor(globalConfig, reporterOptions, reporterContext) {    this._globalConfig = globalConfig;    this._options = reporterOptions;    this._context = reporterContext;  }  onRunComplete(testContexts, results) {    console.log('Custom reporter output:');    console.log('global config:', this._globalConfig);    console.log('options for this reporter from Jest config:', this._options);    console.log('reporter context passed from test scheduler:', this._context);  }  // Optionally, reporters can force Jest to exit with non zero code by returning  // an `Error` from `getLastError()` method.  getLastError() {    if (this._shouldFail) {      return new Error('Custom error reported!');    }  }}module.exports = CustomReporter;
--- END CODE BLOCK ---
note
This option is only supported using the default
--- CODE BLOCK 458 ---
jest.resetAllMocks()
--- END CODE BLOCK ---
test runner.
--- CODE BLOCK 459 ---
resetModules
--- END CODE BLOCK ---
[number]
Default:
--- CODE BLOCK 461 ---
resetModules
--- END CODE BLOCK ---
A number limiting the number of tests that are allowed to run at the same time when using
--- CODE BLOCK 462 ---
jest.resetModules()
--- END CODE BLOCK ---
. Any test above this limit will be queued and executed once a slot is released.
--- CODE BLOCK 469 ---
type ResolverOptions = {  /** Directory to begin resolving from. */  basedir: string;  /** List of export conditions. */  conditions?: Array<string>;  /** Instance of default resolver. */  defaultResolver: (path: string, options: ResolverOptions) => string;  /** List of file extensions to search in order. */  extensions?: Array<string>;  /** List of directory names to be looked up for modules recursively. */  moduleDirectory?: Array<string>;  /** List of `require.paths` to use if nothing is found in `node_modules`. */  paths?: Array<string>;  /** Current root directory. */  rootDir?: string;};
--- END CODE BLOCK ---
[number | string]
Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.
For environments with variable CPUs available, you can use percentage based configuration:
JavaScript
TypeScript
--- CODE BLOCK 470 ---
type ResolverOptions = {  /** Directory to begin resolving from. */  basedir: string;  /** List of export conditions. */  conditions?: Array<string>;  /** Instance of default resolver. */  defaultResolver: (path: string, options: ResolverOptions) => string;  /** List of file extensions to search in order. */  extensions?: Array<string>;  /** List of directory names to be looked up for modules recursively. */  moduleDirectory?: Array<string>;  /** List of `require.paths` to use if nothing is found in `node_modules`. */  paths?: Array<string>;  /** Current root directory. */  rootDir?: string;};
--- END CODE BLOCK ---
--- CODE BLOCK 472 ---
(path, options)
--- END CODE BLOCK ---
--- CODE BLOCK 475 ---
const browserResolve = require('browser-resolve');module.exports = browserResolve.sync;
--- END CODE BLOCK ---
[array<string>]
Default:
--- CODE BLOCK 476 ---
/** @type {import('jest').Config} */const config = {  resolver: '<rootDir>/resolver.js',};module.exports = config;
--- END CODE BLOCK ---
An array of directory names to be searched recursively up from the requiring module's location. Setting this option will
override
the default, if you wish to still search
--- CODE BLOCK 477 ---
/** @type {import('jest').Config} */const config = {  resolver: '<rootDir>/resolver.js',};module.exports = config;
--- END CODE BLOCK ---
for packages include it along with any other options:
JavaScript
TypeScript
--- CODE BLOCK 478 ---
import type {Config} from 'jest';const config: Config = {  resolver: '<rootDir>/resolver.js',};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 480 ---
defaultResolver
--- END CODE BLOCK ---
caution
It is discouraged to use
--- CODE BLOCK 482 ---
package.json
--- END CODE BLOCK ---
as one of the
--- CODE BLOCK 485 ---
module.exports = (path, options) => {  // Call the defaultResolver, so we leverage its cache, error handling, etc.  return options.defaultResolver(path, {    ...options,    // Use packageFilter to process parsed `package.json` before the resolution (see https://www.npmjs.com/package/resolve#resolveid-opts-cb)    packageFilter: pkg => {      return {        ...pkg,        // Alter the value of `main` before resolving the package        main: pkg.module || pkg.main,      };    },  });};
--- END CODE BLOCK ---
, because this prevents scoped packages such as
--- CODE BLOCK 486 ---
module.exports = (path, options) => {  // Call the defaultResolver, so we leverage its cache, error handling, etc.  return options.defaultResolver(path, {    ...options,    // Use packageFilter to process parsed `package.json` before the resolution (see https://www.npmjs.com/package/resolve#resolveid-opts-cb)    packageFilter: pkg => {      return {        ...pkg,        // Alter the value of `main` before resolving the package        main: pkg.module || pkg.main,      };    },  });};
--- END CODE BLOCK ---
from accessing packages with the same subdirectory name (
--- CODE BLOCK 487 ---
restoreMocks
--- END CODE BLOCK ---
). See
this issue
for more details. In most cases, it is preferable to use the
moduleNameMapper
configuration instead.
--- CODE BLOCK 489 ---
jest.restoreAllMocks()
--- END CODE BLOCK ---
[array<string>]
Default:
--- CODE BLOCK 491 ---
package.json
--- END CODE BLOCK ---
An array of file extensions your modules use. If you require modules without specifying a file extension, these are the extensions Jest will look for, in left-to-right order.
We recommend placing the extensions most commonly used in your project on the left, so if you are using TypeScript, you may want to consider moving "ts" and/or "tsx" to the beginning of the array.
--- CODE BLOCK 493 ---
package.json
--- END CODE BLOCK ---
[object<string, string | array<string>>]
Default:
--- CODE BLOCK 494 ---
package.json
--- END CODE BLOCK ---
A map from regular expressions to module names or to arrays of module names that allow to stub out resources, like images or styles with a single module.
Modules that are mapped to an alias are unmocked by default, regardless of whether automocking is enabled or not.
--- CODE BLOCK 495 ---
package.json
--- END CODE BLOCK ---
string token to refer to
--- CODE BLOCK 498 ---
'<rootDir>'
--- END CODE BLOCK ---
value if you want to use file paths.
Additionally, you can substitute captured regex groups using numbered backreferences.
JavaScript
TypeScript
--- CODE BLOCK 500 ---
some-setup.js
--- END CODE BLOCK ---
--- CODE BLOCK 503 ---
["<rootDir>"]
--- END CODE BLOCK ---
The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first. This is true for arrays of module names as well.
info
If you provide module names without boundaries
--- CODE BLOCK 512 ---
roots: ["<rootDir>/src/", "<rootDir>/tests/"]
--- END CODE BLOCK ---
it may cause hard to spot errors. E.g.
--- CODE BLOCK 514 ---
"jest-runner"
--- END CODE BLOCK ---
will replace all modules which contain
--- CODE BLOCK 515 ---
jest-runner-eslint
--- END CODE BLOCK ---
as a substring in its name:
--- CODE BLOCK 516 ---
jest-runner-mocha
--- END CODE BLOCK ---
--- CODE BLOCK 517 ---
jest-runner-tsc
--- END CODE BLOCK ---
--- CODE BLOCK 518 ---
jest-runner-prettier
--- END CODE BLOCK ---
will all be pointed to your stub.
--- CODE BLOCK 520 ---
jest-runner-
--- END CODE BLOCK ---
[array<string>]
Default:
--- CODE BLOCK 521 ---
globalConfig
--- END CODE BLOCK ---
An array of regexp pattern strings that are matched against all module paths before those paths are to be considered 'visible' to the module loader. If a given module's path matches any of the patterns, it will not be
--- CODE BLOCK 523 ---
async function runTests(  tests: Array<Test>,  watcher: TestWatcher,  onStart: OnTestStart,  onResult: OnTestSuccess,  onFailure: OnTestFailure,  options: TestRunnerOptions,): Promise<void>;
--- END CODE BLOCK ---
-able in the test environment.
These pattern strings match against the full path. Use the
--- CODE BLOCK 524 ---
async function runTests(  tests: Array<Test>,  watcher: TestWatcher,  onStart: OnTestStart,  onResult: OnTestSuccess,  onFailure: OnTestFailure,  options: TestRunnerOptions,): Promise<void>;
--- END CODE BLOCK ---
string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.
JavaScript
TypeScript
--- CODE BLOCK 527 ---
sandboxInjectedGlobals
--- END CODE BLOCK ---
--- CODE BLOCK 532 ---
sandboxInjectedGlobals
--- END CODE BLOCK ---
--- CODE BLOCK 534 ---
/** @type {import('jest').Config} */const config = {  sandboxInjectedGlobals: ['Math'],};module.exports = config;
--- END CODE BLOCK ---
[array<string>]
Default:
--- CODE BLOCK 535 ---
import type {Config} from 'jest';const config: Config = {  sandboxInjectedGlobals: ['Math'],};export default config;
--- END CODE BLOCK ---
An alternative API to setting the
--- CODE BLOCK 536 ---
import type {Config} from 'jest';const config: Config = {  sandboxInjectedGlobals: ['Math'],};export default config;
--- END CODE BLOCK ---
env variable,
--- CODE BLOCK 539 ---
setupFilesAfterEnv
--- END CODE BLOCK ---
is an array of absolute paths to additional locations to search when resolving modules. Use the
--- CODE BLOCK 540 ---
setupFilesAfterEnv
--- END CODE BLOCK ---
string token to include the path to your project's root directory.
JavaScript
TypeScript
--- CODE BLOCK 543 ---
setupFilesAfterEnv
--- END CODE BLOCK ---
--- CODE BLOCK 547 ---
const matchers = require('jest-extended');expect.extend(matchers);afterEach(() => {  jest.useRealTimers();});
--- END CODE BLOCK ---
--- CODE BLOCK 549 ---
/** @type {import('jest').Config} */const config = {  setupFilesAfterEnv: ['<rootDir>/setup-jest.js'],};module.exports = config;
--- END CODE BLOCK ---
[boolean]
Default:
--- CODE BLOCK 550 ---
/** @type {import('jest').Config} */const config = {  setupFilesAfterEnv: ['<rootDir>/setup-jest.js'],};module.exports = config;
--- END CODE BLOCK ---
Activates native OS notifications for test results. To display the notifications Jest needs
--- CODE BLOCK 551 ---
import type {Config} from 'jest';const config: Config = {  setupFilesAfterEnv: ['<rootDir>/setup-jest.js'],};export default config;
--- END CODE BLOCK ---
package, which must be installed additionally:
Yarn
pnpm
--- CODE BLOCK 552 ---
import type {Config} from 'jest';const config: Config = {  setupFilesAfterEnv: ['<rootDir>/setup-jest.js'],};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 558 ---
snapshotFormat
--- END CODE BLOCK ---
--- CODE BLOCK 560 ---
compareKeys
--- END CODE BLOCK ---
On macOS, remember to allow notifications from
--- CODE BLOCK 563 ---
/** @type {import('jest').Config} */const config = {  snapshotFormat: {    printBasicPrototype: false,  },};module.exports = config;
--- END CODE BLOCK ---
under System Preferences > Notifications & Focus.
On Windows,
--- CODE BLOCK 564 ---
import type {Config} from 'jest';const config: Config = {  snapshotFormat: {    printBasicPrototype: false,  },};export default config;
--- END CODE BLOCK ---
creates a new start menu entry on the first use and not display the notification. Notifications will be properly displayed on subsequent runs.
--- CODE BLOCK 565 ---
import type {Config} from 'jest';const config: Config = {  snapshotFormat: {    printBasicPrototype: false,  },};export default config;
--- END CODE BLOCK ---
[string]
Default:
--- CODE BLOCK 566 ---
test('does not show prototypes for object and array inline', () => {  const object = {    array: [{hello: 'Danger'}],  };  expect(object).toMatchInlineSnapshot(`    {      "array": [        {          "hello": "Danger",        },      ],    }  `);});
--- END CODE BLOCK ---
Specifies notification mode. Requires
--- CODE BLOCK 567 ---
test('does not show prototypes for object and array inline', () => {  const object = {    array: [{hello: 'Danger'}],  };  expect(object).toMatchInlineSnapshot(`    {      "array": [        {          "hello": "Danger",        },      ],    }  `);});
--- END CODE BLOCK ---
Modes
--- CODE BLOCK 568 ---
snapshotResolver
--- END CODE BLOCK ---
: always send a notification.
--- CODE BLOCK 570 ---
module.exports = {  // resolves from test to snapshot path  resolveSnapshotPath: (testPath, snapshotExtension) =>    testPath.replace('__tests__', '__snapshots__') + snapshotExtension,  // resolves from snapshot to test path  resolveTestPath: (snapshotFilePath, snapshotExtension) =>    snapshotFilePath      .replace('__snapshots__', '__tests__')      .slice(0, -snapshotExtension.length),  // Example test path, used for preflight consistency check of the implementation above  testPathForConsistencyCheck: 'some/__tests__/example.test.js',};
--- END CODE BLOCK ---
: send a notification when tests fail.
--- CODE BLOCK 571 ---
module.exports = {  // resolves from test to snapshot path  resolveSnapshotPath: (testPath, snapshotExtension) =>    testPath.replace('__tests__', '__snapshots__') + snapshotExtension,  // resolves from snapshot to test path  resolveTestPath: (snapshotFilePath, snapshotExtension) =>    snapshotFilePath      .replace('__snapshots__', '__tests__')      .slice(0, -snapshotExtension.length),  // Example test path, used for preflight consistency check of the implementation above  testPathForConsistencyCheck: 'some/__tests__/example.test.js',};
--- END CODE BLOCK ---
: send a notification when tests pass.
--- CODE BLOCK 572 ---
snapshotSerializers
--- END CODE BLOCK ---
: send a notification when the status changed.
--- CODE BLOCK 574 ---
module.exports = {  serialize(val, config, indentation, depth, refs, printer) {    return `Pretty foo: ${printer(val.foo)}`;  },  test(val) {    return val && Object.prototype.hasOwnProperty.call(val, 'foo');  },};
--- END CODE BLOCK ---
: send a notification when tests pass or once when it fails.
--- CODE BLOCK 575 ---
module.exports = {  serialize(val, config, indentation, depth, refs, printer) {    return `Pretty foo: ${printer(val.foo)}`;  },  test(val) {    return val && Object.prototype.hasOwnProperty.call(val, 'foo');  },};
--- END CODE BLOCK ---
: send a notification when tests fail or once when it passes.
--- CODE BLOCK 577 ---
custom-serializer
--- END CODE BLOCK ---
[number]
Default:
--- CODE BLOCK 578 ---
/** @type {import('jest').Config} */const config = {  snapshotSerializers: ['path/to/custom-serializer.js'],};module.exports = config;
--- END CODE BLOCK ---
Print a warning indicating that there are probable open handles if Jest does not exit cleanly this number of milliseconds after it completes. Use
--- CODE BLOCK 579 ---
/** @type {import('jest').Config} */const config = {  snapshotSerializers: ['path/to/custom-serializer.js'],};module.exports = config;
--- END CODE BLOCK ---
to disable the warning.
--- CODE BLOCK 580 ---
import type {Config} from 'jest';const config: Config = {  snapshotSerializers: ['path/to/custom-serializer.js'],};export default config;
--- END CODE BLOCK ---
[string]
Default:
--- CODE BLOCK 581 ---
import type {Config} from 'jest';const config: Config = {  snapshotSerializers: ['path/to/custom-serializer.js'],};export default config;
--- END CODE BLOCK ---
A preset that is used as a base for Jest's configuration. A preset should point to an npm module that has a
--- CODE BLOCK 582 ---
test(() => {  const bar = {    foo: {      x: 1,      y: 2,    },  };  expect(bar).toMatchSnapshot();});
--- END CODE BLOCK ---
--- CODE BLOCK 583 ---
test(() => {  const bar = {    foo: {      x: 1,      y: 2,    },  };  expect(bar).toMatchSnapshot();});
--- END CODE BLOCK ---
--- CODE BLOCK 584 ---
Pretty foo: Object {  "x": 1,  "y": 2,}
--- END CODE BLOCK ---
--- CODE BLOCK 585 ---
Pretty foo: Object {  "x": 1,  "y": 2,}
--- END CODE BLOCK ---
file at the root.
For example, this preset
--- CODE BLOCK 586 ---
expect.addSnapshotSerializer
--- END CODE BLOCK ---
will be configured as follows:
JavaScript
TypeScript
--- CODE BLOCK 587 ---
snapshotSerializers
--- END CODE BLOCK ---
--- CODE BLOCK 591 ---
@jest-environment
--- END CODE BLOCK ---
Presets may also be relative to filesystem paths:
JavaScript
TypeScript
--- CODE BLOCK 593 ---
/** * @jest-environment jsdom */test('use jsdom in this test file', () => {  const element = document.createElement('div');  expect(element).not.toBeNull();});
--- END CODE BLOCK ---
--- CODE BLOCK 597 ---
this.global
--- END CODE BLOCK ---
info
If you also have specified
--- CODE BLOCK 599 ---
projectConfig
--- END CODE BLOCK ---
, the resolution of this file will be relative to that root directory.
--- CODE BLOCK 600 ---
testEnvironmentContext
--- END CODE BLOCK ---
[string]
Default:
--- CODE BLOCK 601 ---
handleTestEvent
--- END CODE BLOCK ---
Sets the path to the
--- CODE BLOCK 602 ---
jest-circus
--- END CODE BLOCK ---
node module used to update inline snapshots.
--- CODE BLOCK 603 ---
jest-circus
--- END CODE BLOCK ---
[array<string | ProjectConfig>]
Default:
--- CODE BLOCK 604 ---
handleTestEvent
--- END CODE BLOCK ---
When the
--- CODE BLOCK 605 ---
start_describe_definition
--- END CODE BLOCK ---
configuration is provided with an array of paths or glob patterns, Jest will run tests in all of the specified projects at the same time. This is great for monorepos or when working on multiple projects at the same time.
JavaScript
TypeScript
--- CODE BLOCK 606 ---
finish_describe_definition
--- END CODE BLOCK ---
--- CODE BLOCK 611 ---
my-custom-environment.js
--- END CODE BLOCK ---
This example configuration will run Jest in the root directory as well as in every folder in the examples directory. You can have an unlimited amount of projects running in the same Jest instance.
The projects feature can also be used to run multiple configurations or multiple
runners
. For this purpose, you can pass an array of configuration objects. For example, to run both tests and ESLint (via
jest-runner-eslint
) in the same invocation of Jest:
JavaScript
TypeScript
--- CODE BLOCK 613 ---
/** * @jest-environment ./src/test/my-custom-environment */
--- END CODE BLOCK ---
--- CODE BLOCK 615 ---
// my-custom-environmentconst NodeEnvironment = require('jest-environment-node').TestEnvironment;class CustomEnvironment extends NodeEnvironment {  constructor(config, context) {    super(config, context);    console.log(config.globalConfig);    console.log(config.projectConfig);    this.testPath = context.testPath;    this.docblockPragmas = context.docblockPragmas;  }  async setup() {    await super.setup();    await someSetupTasks(this.testPath);    this.global.someGlobalObject = createGlobalObject();    // Will trigger if docblock contains @my-custom-pragma my-pragma-value    if (this.docblockPragmas['my-custom-pragma'] === 'my-pragma-value') {      // ...    }  }  async teardown() {    this.global.someGlobalObject = destroyGlobalObject();    await someTeardownTasks();    await super.teardown();  }  getVmContext() {    return super.getVmContext();  }  async handleTestEvent(event, state) {    if (event.name === 'test_start') {      // ...    }  }}module.exports = CustomEnvironment;
--- END CODE BLOCK ---
When using multi-project runner, it's recommended to add a
--- CODE BLOCK 617 ---
// my-test-suite/** * @jest-environment ./my-custom-environment */let someGlobalObject;beforeAll(() => {  someGlobalObject = globalThis.someGlobalObject;});
--- END CODE BLOCK ---
for each project. This will show the
--- CODE BLOCK 618 ---
testEnvironmentOptions
--- END CODE BLOCK ---
of a project next to its tests.
note
With the
--- CODE BLOCK 620 ---
testEnvironment
--- END CODE BLOCK ---
option enabled, Jest will copy the root-level configuration options to each individual child configuration during the test run, resolving its values in the child's context. This means that string tokens like
--- CODE BLOCK 622 ---
/** @type {import('jest').Config} */const config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    html: '<html lang="zh-cmn-Hant"></html>',    url: 'https://jestjs.io/',    userAgent: 'Agent/007',  },};module.exports = config;
--- END CODE BLOCK ---
will point to the
child's root directory
even if they are defined in the root-level configuration.
--- CODE BLOCK 623 ---
/** @type {import('jest').Config} */const config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    html: '<html lang="zh-cmn-Hant"></html>',    url: 'https://jestjs.io/',    userAgent: 'Agent/007',  },};module.exports = config;
--- END CODE BLOCK ---
[boolean]
Default:
--- CODE BLOCK 624 ---
import type {Config} from 'jest';const config: Config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    html: '<html lang="zh-cmn-Hant"></html>',    url: 'https://jestjs.io/',    userAgent: 'Agent/007',  },};export default config;
--- END CODE BLOCK ---
The equivalent of the
--- CODE BLOCK 625 ---
import type {Config} from 'jest';const config: Config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    html: '<html lang="zh-cmn-Hant"></html>',    url: 'https://jestjs.io/',    userAgent: 'Agent/007',  },};export default config;
--- END CODE BLOCK ---
flag to randomize the order of the tests in a file.
--- CODE BLOCK 626 ---
jest-environment-jsdom
--- END CODE BLOCK ---
[array<moduleName | [moduleName, options]>]
Default:
--- CODE BLOCK 627 ---
jest-environment-node
--- END CODE BLOCK ---
Use this configuration option to add reporters to Jest. It must be a list of reporter names, additional options can be passed to a reporter using the tuple form:
JavaScript
TypeScript
--- CODE BLOCK 628 ---
customExportConditions
--- END CODE BLOCK ---
--- CODE BLOCK 631 ---
jest-environment-jsdom
--- END CODE BLOCK ---
Default Reporter
If custom reporters are specified, the default Jest reporter will be overridden. If you wish to keep it,
--- CODE BLOCK 633 ---
jest-environment-node
--- END CODE BLOCK ---
must be passed as a reporters name:
JavaScript
TypeScript
--- CODE BLOCK 634 ---
['node', 'node-addons']
--- END CODE BLOCK ---
--- CODE BLOCK 636 ---
/** @type {import('jest').Config} */const config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    customExportConditions: ['react-native'],  },};module.exports = config;
--- END CODE BLOCK ---
GitHub Actions Reporter
If included in the list, the built-in GitHub Actions Reporter will annotate changed files with test failure messages and (if used with
--- CODE BLOCK 638 ---
import type {Config} from 'jest';const config: Config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    customExportConditions: ['react-native'],  },};export default config;
--- END CODE BLOCK ---
) print logs with github group features for easy navigation. Note that
--- CODE BLOCK 639 ---
testEnvironment
--- END CODE BLOCK ---
should not be used in this case as
--- CODE BLOCK 641 ---
/** * @jest-environment jsdom * @jest-environment-options {"url": "https://jestjs.io/"} */test('use jsdom and set the URL in this test file', () => {  expect(window.location.href).toBe('https://jestjs.io/');});
--- END CODE BLOCK ---
will handle that already, so remember to also include
--- CODE BLOCK 642 ---
/** * @jest-environment jsdom * @jest-environment-options {"url": "https://jestjs.io/"} */test('use jsdom and set the URL in this test file', () => {  expect(window.location.href).toBe('https://jestjs.io/');});
--- END CODE BLOCK ---
. If you wish to use it only for annotations simply leave only the reporter without options as the default value of
--- CODE BLOCK 643 ---
testFailureExitCode
--- END CODE BLOCK ---
--- CODE BLOCK 646 ---
[ "**/__tests__/**/*.?([mc])[jt]s?(x)", "**/?(*.)+(spec|test).?([mc])[jt]s?(x)" ]
--- END CODE BLOCK ---
JavaScript
TypeScript
--- CODE BLOCK 654 ---
Component.test.js
--- END CODE BLOCK ---
--- CODE BLOCK 659 ---
["!**/__fixtures__/**", "**/__tests__/**/*.js"]
--- END CODE BLOCK ---
Summary Reporter
Summary reporter prints out summary of all tests. It is a part of default reporter, hence it will be enabled if
--- CODE BLOCK 661 ---
**/__tests__/**/*.js
--- END CODE BLOCK ---
is included in the list. For instance, you might want to use it as stand-alone reporter instead of the default one, or together with
Silent Reporter
JavaScript
TypeScript
--- CODE BLOCK 662 ---
testPathIgnorePatterns
--- END CODE BLOCK ---
--- CODE BLOCK 665 ---
["<rootDir>/build/", "<rootDir>/node_modules/"]
--- END CODE BLOCK ---
--- CODE BLOCK 675 ---
Component.test.js
--- END CODE BLOCK ---
reporter accepts options. Since it is included in the
--- CODE BLOCK 676 ---
Component.spec.js
--- END CODE BLOCK ---
reporter you may also pass the options there.
JavaScript
TypeScript
--- CODE BLOCK 680 ---
 __tests__    component.spec.js # test    anything # test package.json # not test foo.test.js # test bar.spec.jsx # test component.js # not test
--- END CODE BLOCK ---
--- CODE BLOCK 683 ---
testResultsProcessor
--- END CODE BLOCK ---
--- CODE BLOCK 686 ---
{  "success": boolean,  "startTime": epoch,  "numTotalTestSuites": number,  "numPassedTestSuites": number,  "numFailedTestSuites": number,  "numRuntimeErrorTestSuites": number,  "numTotalTests": number,  "numPassedTests": number,  "numFailedTests": number,  "numPendingTests": number,  "numTodoTests": number,  "openHandles": Array<Error>,  "testResults": [{    "numFailingTests": number,    "numPassingTests": number,    "numPendingTests": number,    "testResults": [{      "title": string (message in it block),      "status": "failed" | "pending" | "passed",      "ancestorTitles": [string (message in describe blocks)],      "failureMessages": [string],      "numPassingAsserts": number,      "location": {        "column": number,        "line": number      },      "duration": number | null,      "startAt": epoch | null    },    ...    ],    "perfStats": {      "end": epoch,      "loadTestEnvironmentEnd": epoch,      "loadTestEnvironmentStart": epoch,      "runtime": number,      "setupAfterEnvEnd": epoch,      "setupAfterEnvStart": epoch,      "setupFilesEnd": epoch,      "setupFilesStart": epoch,      "slow": boolean,      "start": epoch    },    "testFilePath": absolute path to test file,    "coverage": {}  },  "testExecError:" (exists if there was a top-level failure) {    "message": string    "stack": string  }  ...  ]}
--- END CODE BLOCK ---
option behaves in the following way, if the total number of test suites surpasses this threshold, a detailed summary of all failed tests will be printed after executing all the tests. It defaults to
--- CODE BLOCK 687 ---
testResultsProcessor
--- END CODE BLOCK ---
Custom Reporters
Hungry for reporters? Take a look at long list of
awesome reporters
from Awesome Jest.
Custom reporter module must export a class that takes
--- CODE BLOCK 690 ---
jest-circus/runner
--- END CODE BLOCK ---
--- CODE BLOCK 691 ---
jest-circus
--- END CODE BLOCK ---
--- CODE BLOCK 692 ---
function testRunner(  globalConfig: GlobalConfig,  config: ProjectConfig,  environment: Environment,  runtime: Runtime,  testPath: string,): Promise<TestResult>;
--- END CODE BLOCK ---
as constructor arguments:
custom-reporter.js
--- CODE BLOCK 693 ---
function testRunner(  globalConfig: GlobalConfig,  config: ProjectConfig,  environment: Environment,  runtime: Runtime,  testPath: string,): Promise<TestResult>;
--- END CODE BLOCK ---
note
For the full list of hooks and argument types see the
--- CODE BLOCK 695 ---
@jest/test-sequencer
--- END CODE BLOCK ---
interface in
packages/jest-reporters/src/types.ts
--- CODE BLOCK 699 ---
const Sequencer = require('@jest/test-sequencer').default;class CustomSequencer extends Sequencer {  /**   * Select tests for shard requested via --shard=shardIndex/shardCount   * Sharding is applied before sorting   */  shard(tests, {shardIndex, shardCount}) {    const shardSize = Math.ceil(tests.length / shardCount);    const shardStart = shardSize * (shardIndex - 1);    const shardEnd = shardSize * shardIndex;    return [...tests]      .sort((a, b) => (a.path > b.path ? 1 : -1))      .slice(shardStart, shardEnd);  }  /**   * Sort test to determine order of execution   * Sorting is applied after sharding   */  sort(tests) {    // Test structure information    // https://github.com/jestjs/jest/blob/6b8b1404a1d9254e7d5d90a8934087a9c9899dab/packages/jest-runner/src/types.ts#L17-L21    const copyTests = [...tests];    return copyTests.sort((testA, testB) => (testA.path > testB.path ? 1 : -1));  }}module.exports = CustomSequencer;
--- END CODE BLOCK ---
[boolean]
Default:
--- CODE BLOCK 700 ---
const Sequencer = require('@jest/test-sequencer').default;class CustomSequencer extends Sequencer {  /**   * Select tests for shard requested via --shard=shardIndex/shardCount   * Sharding is applied before sorting   */  shard(tests, {shardIndex, shardCount}) {    const shardSize = Math.ceil(tests.length / shardCount);    const shardStart = shardSize * (shardIndex - 1);    const shardEnd = shardSize * shardIndex;    return [...tests]      .sort((a, b) => (a.path > b.path ? 1 : -1))      .slice(shardStart, shardEnd);  }  /**   * Sort test to determine order of execution   * Sorting is applied after sharding   */  sort(tests) {    // Test structure information    // https://github.com/jestjs/jest/blob/6b8b1404a1d9254e7d5d90a8934087a9c9899dab/packages/jest-runner/src/types.ts#L17-L21    const copyTests = [...tests];    return copyTests.sort((testA, testB) => (testA.path > testB.path ? 1 : -1));  }}module.exports = CustomSequencer;
--- END CODE BLOCK ---
Automatically reset mock state before every test. Equivalent to calling
--- CODE BLOCK 701 ---
custom-sequencer
--- END CODE BLOCK ---
before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.
--- CODE BLOCK 702 ---
/** @type {import('jest').Config} */const config = {  testSequencer: 'path/to/custom-sequencer.js',};module.exports = config;
--- END CODE BLOCK ---
[boolean]
Default:
--- CODE BLOCK 703 ---
/** @type {import('jest').Config} */const config = {  testSequencer: 'path/to/custom-sequencer.js',};module.exports = config;
--- END CODE BLOCK ---
By default, each test file gets its own independent module registry. Enabling
--- CODE BLOCK 704 ---
import type {Config} from 'jest';const config: Config = {  testSequencer: 'path/to/custom-sequencer.js',};export default config;
--- END CODE BLOCK ---
goes a step further and resets the module registry before running each individual test. This is useful to isolate modules for every test so that the local module state doesn't conflict between tests. This can be done programmatically using
--- CODE BLOCK 705 ---
import type {Config} from 'jest';const config: Config = {  testSequencer: 'path/to/custom-sequencer.js',};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 706 ---
testTimeout
--- END CODE BLOCK ---
[string]
Default:
--- CODE BLOCK 709 ---
{"\\.[jt]sx?$": "babel-jest"}
--- END CODE BLOCK ---
This option allows the use of a custom resolver. This resolver must be a module that exports
either
a function expecting a string as the first argument for the path to resolve and an options object as the second argument. The function should either return a path to the module that should be resolved or throw an error if the module can't be found.
an object containing
--- CODE BLOCK 710 ---
{filePattern: ['path-to-transformer', {options}]}
--- END CODE BLOCK ---
and/or
--- CODE BLOCK 712 ---
{'\\.js$': ['babel-jest', {rootMode: 'upward'}]}
--- END CODE BLOCK ---
properties. The
--- CODE BLOCK 714 ---
/\.[jt]sx?$/
--- END CODE BLOCK ---
property should be a function with the shape explained above, and the
--- CODE BLOCK 721 ---
/** @type {import('jest').Config} */const config = {  transform: {    '\\.[jt]sx?$': 'babel-jest',    '\\.css$': 'some-css-transformer',  },};module.exports = config;
--- END CODE BLOCK ---
property should also be a function that accepts the same arguments, but returns a promise which resolves with the path to the module or rejects with an error.
The options object provided to resolvers has the shape:
--- CODE BLOCK 722 ---
/** @type {import('jest').Config} */const config = {  transform: {    '\\.[jt]sx?$': 'babel-jest',    '\\.css$': 'some-css-transformer',  },};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 724 ---
import type {Config} from 'jest';const config: Config = {  transform: {    '\\.[jt]sx?$': 'babel-jest',    '\\.css$': 'some-css-transformer',  },};export default config;
--- END CODE BLOCK ---
passed as an option is the Jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom synchronous one, e.g.
--- CODE BLOCK 725 ---
transformIgnorePatterns
--- END CODE BLOCK ---
and returns a string or throws.
For example, if you want to respect Browserify's
--- CODE BLOCK 726 ---
["/node_modules/", "\\.pnp\\.[^\\\/]+$"]
--- END CODE BLOCK ---
field
, you can use the following resolver:
resolver.js
--- CODE BLOCK 727 ---
/** @type {import('jest').Config} */const config = {  transformIgnorePatterns: ['/node_modules/(?!(foo|bar)/)', '/bar/'],};module.exports = config;
--- END CODE BLOCK ---
And add it to Jest configuration:
JavaScript
TypeScript
--- CODE BLOCK 729 ---
import type {Config} from 'jest';const config: Config = {  transformIgnorePatterns: ['/node_modules/(?!(foo|bar)/)', '/bar/'],};export default config;
--- END CODE BLOCK ---
--- CODE BLOCK 731 ---
/node_modules
--- END CODE BLOCK ---
By combining
--- CODE BLOCK 733 ---
/node_modules/bar/
--- END CODE BLOCK ---
--- CODE BLOCK 735 ---
/node_modules/bar/
--- END CODE BLOCK ---
we can implement a
--- CODE BLOCK 736 ---
node_modules
--- END CODE BLOCK ---
"pre-processor" that allows us to change how the default resolver will resolve modules. For example, imagine we want to use the field
--- CODE BLOCK 737 ---
transformIgnorePatterns
--- END CODE BLOCK ---
if it is present, otherwise fallback to
--- CODE BLOCK 739 ---
/** @type {import('jest').Config} */const config = {  transformIgnorePatterns: [    '<rootDir>/bower_components/',    '<rootDir>/node_modules/',  ],};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 740 ---
/** @type {import('jest').Config} */const config = {  transformIgnorePatterns: [    '<rootDir>/bower_components/',    '<rootDir>/node_modules/',  ],};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 742 ---
import type {Config} from 'jest';const config: Config = {  transformIgnorePatterns: [    '<rootDir>/bower_components/',    '<rootDir>/node_modules/',  ],};export default config;
--- END CODE BLOCK ---
[boolean]
Default:
--- CODE BLOCK 744 ---
node_modules
--- END CODE BLOCK ---
Automatically restore mock state and implementation before every test. Equivalent to calling
--- CODE BLOCK 745 ---
node_modules/package-a/
--- END CODE BLOCK ---
before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.
--- CODE BLOCK 747 ---
node_modules/.pnpm/package-a@x.x.x/node_modules/package-a/
--- END CODE BLOCK ---
[string]
Default: The root of the directory containing your Jest
config file
--- CODE BLOCK 748 ---
<rootDir>/node_modules/(?!(package-a|@scope/pkg-b)/)
--- END CODE BLOCK ---
--- CODE BLOCK 749 ---
/** @type {import('jest').Config} */const config = {  transformIgnorePatterns: [    '<rootDir>/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)',    /* if config file is under '~/packages/lib-a/' */    `${path.join(      __dirname,      '../..',    )}/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)`,    /* or using relative pattern to match the second 'node_modules/' in 'node_modules/.pnpm/@scope+pkg-b@x.x.x/node_modules/@scope/pkg-b/' */    'node_modules/(?!.pnpm|package-a|@scope/pkg-b)',  ],};module.exports = config;
--- END CODE BLOCK ---
if no
--- CODE BLOCK 750 ---
/** @type {import('jest').Config} */const config = {  transformIgnorePatterns: [    '<rootDir>/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)',    /* if config file is under '~/packages/lib-a/' */    `${path.join(      __dirname,      '../..',    )}/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)`,    /* or using relative pattern to match the second 'node_modules/' in 'node_modules/.pnpm/@scope+pkg-b@x.x.x/node_modules/@scope/pkg-b/' */    'node_modules/(?!.pnpm|package-a|@scope/pkg-b)',  ],};module.exports = config;
--- END CODE BLOCK ---
is found
The root directory that Jest should scan for tests and modules within. If you put your Jest config inside your
--- CODE BLOCK 751 ---
import type {Config} from 'jest';const config: Config = {  transformIgnorePatterns: [    '<rootDir>/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)',    /* if config file is under '~/packages/lib-a/' */    `${path.join(      __dirname,      '../..',    )}/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)`,    /* or using relative path to match the second 'node_modules/' in 'node_modules/.pnpm/@scope+pkg-b@x.x.x/node_modules/@scope/pkg-b/' */    'node_modules/(?!.pnpm|package-a|@scope/pkg-b)',  ],};export default config;
--- END CODE BLOCK ---
and want the root directory to be the root of your repo, the value for this config param will default to the directory of the
--- CODE BLOCK 752 ---
import type {Config} from 'jest';const config: Config = {  transformIgnorePatterns: [    '<rootDir>/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)',    /* if config file is under '~/packages/lib-a/' */    `${path.join(      __dirname,      '../..',    )}/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)`,    /* or using relative path to match the second 'node_modules/' in 'node_modules/.pnpm/@scope+pkg-b@x.x.x/node_modules/@scope/pkg-b/' */    'node_modules/(?!.pnpm|package-a|@scope/pkg-b)',  ],};export default config;
--- END CODE BLOCK ---
Oftentimes, you'll want to set this to
--- CODE BLOCK 757 ---
unmockedModulePathPatterns
--- END CODE BLOCK ---
--- CODE BLOCK 761 ---
jest.mock()
--- END CODE BLOCK ---
, corresponding to where in your repository the code is stored.
Using
--- CODE BLOCK 762 ---
jest.unmock()
--- END CODE BLOCK ---
as a string token in any other path-based configuration settings will refer back to this value. For example, if you want a
--- CODE BLOCK 763 ---
jest.mock()
--- END CODE BLOCK ---
entry to point at the
--- CODE BLOCK 767 ---
waitForUnhandledRejections
--- END CODE BLOCK ---
file at the root of the project, set its value to:
--- CODE BLOCK 768 ---
rejectionHandled
--- END CODE BLOCK ---
--- CODE BLOCK 769 ---
uncaughtException
--- END CODE BLOCK ---
[array<string>]
Default:
--- CODE BLOCK 770 ---
unhandledRejection
--- END CODE BLOCK ---
A list of paths to directories that Jest should use to search for files in.
There are times where you only want Jest to search in a single sub-directory (such as cases where you have a
--- CODE BLOCK 771 ---
watchPathIgnorePatterns
--- END CODE BLOCK ---
directory in your repo), but prevent it from accessing the rest of the repo.
info
While
--- CODE BLOCK 774 ---
["<rootDir>/node_modules/"]
--- END CODE BLOCK ---
is mostly used as a token to be re-used in other configuration options,
--- CODE BLOCK 776 ---
watchPathIgnorePatterns
--- END CODE BLOCK ---
is used by the internals of Jest to locate
test files and source files
. This applies also when searching for manual mocks for modules from
--- CODE BLOCK 777 ---
/** @type {import('jest').Config} */const config = {  watchPathIgnorePatterns: ['<rootDir>/\\.tmp/', '<rootDir>/bar/'],};module.exports = config;
--- END CODE BLOCK ---
--- CODE BLOCK 778 ---
/** @type {import('jest').Config} */const config = {  watchPathIgnorePatterns: ['<rootDir>/\\.tmp/', '<rootDir>/bar/'],};module.exports = config;
--- END CODE BLOCK ---
will need to live in one of the
--- CODE BLOCK 779 ---
import type {Config} from 'jest';const config: Config = {  watchPathIgnorePatterns: ['<rootDir>/\\.tmp/', '<rootDir>/bar/'],};export default config;
--- END CODE BLOCK ---
By default,
--- CODE BLOCK 780 ---
import type {Config} from 'jest';const config: Config = {  watchPathIgnorePatterns: ['<rootDir>/\\.tmp/', '<rootDir>/bar/'],};export default config;
--- END CODE BLOCK ---
has a single entry
--- CODE BLOCK 781 ---
watchPlugins
--- END CODE BLOCK ---
but there are cases where you may want to have multiple roots within one project, for example
--- CODE BLOCK 783 ---
jest-watch-master
--- END CODE BLOCK ---
--- CODE BLOCK 784 ---
jest-watch-select-projects
--- END CODE BLOCK ---
[string]
Default:
--- CODE BLOCK 785 ---
jest-watch-suspend
--- END CODE BLOCK ---
This option allows you to use a custom runner instead of Jest's default test runner. Examples of runners include:
--- CODE BLOCK 786 ---
jest-watch-typeahead
--- END CODE BLOCK ---
--- CODE BLOCK 787 ---
jest-watch-yarn-workspaces
--- END CODE BLOCK ---
--- CODE BLOCK 788 ---
watchPlugins
--- END CODE BLOCK ---
--- CODE BLOCK 789 ---
jest-watch-
--- END CODE BLOCK ---
info
--- CODE BLOCK 793 ---
workerIdleMemoryLimit
--- END CODE BLOCK ---
property value can omit the
--- CODE BLOCK 811 ---
/** @type {import('jest').Config} */const config = {  workerIdleMemoryLimit: 0.2,};module.exports = config;
--- END CODE BLOCK ---
prefix of the package name.
To write a test-runner, export a class with which accepts
--- CODE BLOCK 812 ---
/** @type {import('jest').Config} */const config = {  workerIdleMemoryLimit: 0.2,};module.exports = config;
--- END CODE BLOCK ---
in the constructor, and has a
--- CODE BLOCK 813 ---
import type {Config} from 'jest';const config: Config = {  workerIdleMemoryLimit: 0.2,};export default config;
--- END CODE BLOCK ---
method with the signature:
--- CODE BLOCK 814 ---
import type {Config} from 'jest';const config: Config = {  workerIdleMemoryLimit: 0.2,};export default config;
--- END CODE BLOCK ---
If you need to restrict your test-runner to only run in serial rather than being executed in parallel your class should have the property
--- CODE BLOCK 817 ---
{  "name": "my-project",  "jest": {    "//": "Comment goes here",    "verbose": true  }}
--- END CODE BLOCK ---
to be set as
--- CODE BLOCK 818 ---
{  "name": "my-project",  "jest": {    "//": "Comment goes here",    "verbose": true  }}
--- END CODE BLOCK ---
--- CODE BLOCK 819 ---
workerThreads
--- END CODE BLOCK ---
[array<string>]
Renamed from
--- CODE BLOCK 821 ---
JSON.stringify()
--- END CODE BLOCK ---
in Jest 28.
Default:
--- CODE BLOCK 830 ---
cacheDirectory
--- END CODE BLOCK ---
Test files run inside a
, which slows calls to global context properties (e.g.
--- CODE BLOCK 832 ---
collectCoverage
--- END CODE BLOCK ---
). With this option you can specify extra properties to be defined inside the vm for faster lookups.
For example, if your tests call
--- CODE BLOCK 833 ---
collectCoverageFrom
--- END CODE BLOCK ---
often, you can pass it by setting
--- CODE BLOCK 834 ---
coverageDirectory
--- END CODE BLOCK ---
JavaScript
TypeScript
--- CODE BLOCK 835 ---
coveragePathIgnorePatterns
--- END CODE BLOCK ---
--- CODE BLOCK 837 ---
coverageReporters
--- END CODE BLOCK ---
note
This option has no effect if you use
native ESM
--- CODE BLOCK 839 ---
dependencyExtractor
--- END CODE BLOCK ---
[array]
Default:
--- CODE BLOCK 840 ---
displayName
--- END CODE BLOCK ---
A list of paths to modules that run some code to configure or set up the testing environment. Each setupFile will be run once per test file. Since every test runs in its own environment, these scripts will be executed in the testing environment before executing
--- CODE BLOCK 841 ---
errorOnDeprecated
--- END CODE BLOCK ---
and before the test code itself.
If your setup script is a CJS module, it may export an async function. Jest will call the function and await its result. This might be useful to fetch some data asynchronously. If the file is an ESM module, simply use top-level await to achieve the same result.
--- CODE BLOCK 842 ---
extensionsToTreatAsEsm
--- END CODE BLOCK ---
[array]
Default:
--- CODE BLOCK 844 ---
forceCoverageMatch
--- END CODE BLOCK ---
A list of paths to modules that run some code to configure or set up the testing framework before each test file in the suite is executed. Since
--- CODE BLOCK 846 ---
globalSetup
--- END CODE BLOCK ---
executes before the test framework is installed in the environment, this script file presents you the opportunity of running some code immediately after the test framework has been installed in the environment but before the test code itself.
In other words,
--- CODE BLOCK 847 ---
globalTeardown
--- END CODE BLOCK ---
modules are meant for code which is repeating in each test file. Having the test framework installed makes Jest
globals
--- CODE BLOCK 849 ---
injectGlobals
--- END CODE BLOCK ---
object
--- CODE BLOCK 850 ---
maxConcurrency
--- END CODE BLOCK ---
accessible in the modules. For example, you can add extra matchers from
--- CODE BLOCK 852 ---
moduleDirectories
--- END CODE BLOCK ---
library or call
setup and teardown
hooks:
setup-jest.js
--- CODE BLOCK 853 ---
moduleFileExtensions
--- END CODE BLOCK ---
JavaScript
TypeScript
--- CODE BLOCK 855 ---
modulePathIgnorePatterns
--- END CODE BLOCK ---
--- CODE BLOCK 859 ---
openHandlesTimeout
--- END CODE BLOCK ---
If your setup script is a CJS module, it may export an async function. Jest will call the function and await its result. This might be useful to fetch some data asynchronously. If the file is an ESM module, simply use top-level await to achieve the same result.
--- CODE BLOCK 866 ---
resetModules
--- END CODE BLOCK ---
[boolean]
Default:
--- CODE BLOCK 868 ---
restoreMocks
--- END CODE BLOCK ---
The equivalent of the
--- CODE BLOCK 872 ---
sandboxInjectedGlobals
--- END CODE BLOCK ---
flag to print the seed in the test report summary.
--- CODE BLOCK 874 ---
setupFilesAfterEnv
--- END CODE BLOCK ---
[number]
Default:
--- CODE BLOCK 876 ---
slowTestThreshold
--- END CODE BLOCK ---
The number of seconds after which a test is considered as slow and reported as such in the results.
--- CODE BLOCK 877 ---
snapshotFormat
--- END CODE BLOCK ---
[object]
Default:
--- CODE BLOCK 878 ---
snapshotResolver
--- END CODE BLOCK ---
Allows overriding specific snapshot formatting options documented in the
pretty-format readme
, with the exceptions of
--- CODE BLOCK 879 ---
snapshotSerializers
--- END CODE BLOCK ---
--- CODE BLOCK 880 ---
testEnvironment
--- END CODE BLOCK ---
. For example, this config would have the snapshot formatter not print a prefix for "Object" and "Array":
JavaScript
TypeScript
--- CODE BLOCK 881 ---
testEnvironmentOptions
--- END CODE BLOCK ---
--- CODE BLOCK 884 ---
testPathIgnorePatterns
--- END CODE BLOCK ---
some.test.js
--- CODE BLOCK 888 ---
testSequencer
--- END CODE BLOCK ---
--- CODE BLOCK 891 ---
transformIgnorePatterns
--- END CODE BLOCK ---
[string]
Default:
--- CODE BLOCK 892 ---
unmockedModulePathPatterns
--- END CODE BLOCK ---
The path to a module that can resolve test<->snapshot path. This config option lets you customize where Jest stores snapshot files on disk.
custom-resolver.js
--- CODE BLOCK 894 ---
waitForUnhandledRejections
--- END CODE BLOCK ---
--- CODE BLOCK 896 ---
watchPlugins
--- END CODE BLOCK ---
[array<string>]
Default:
--- CODE BLOCK 898 ---
workerIdleMemoryLimit
--- END CODE BLOCK ---
A list of paths to snapshot serializer modules Jest should use for snapshot testing.
Jest has default serializers for built-in JavaScript types, HTML elements (Jest 20.0.0+), ImmutableJS (Jest 20.0.0+) and for React elements. See
snapshot test tutorial
for more information.
custom-serializer.js
--- CODE BLOCK 900 ---
workerThreads
--- END CODE BLOCK ---
[CODE_BLOCK_576]
is a function that serializes a value using existing plugins.
[CODE_BLOCK_577]
to your Jest configuration:
JavaScript
TypeScript
[CODE_BLOCK_578]
[CODE_BLOCK_580]
Finally tests would look as follows:
[CODE_BLOCK_582]
Rendered snapshot:
[CODE_BLOCK_584]
To make a dependency explicit instead of implicit, you can call
[CODE_BLOCK_586]
to add a module for an individual test file instead of adding its path to
[CODE_BLOCK_587]
in Jest configuration.
More about serializers API can be found
here
[CODE_BLOCK_588]
[string]
Default:
[CODE_BLOCK_589]
The test environment that will be used for testing. The default environment in Jest is a Node.js environment. If you are building a web app, you can use a browser-like environment through
[CODE_BLOCK_590]
instead.
By adding a
[CODE_BLOCK_591]
docblock at the top of the file, you can specify another environment to be used for all tests in that file:
[CODE_BLOCK_592]
You can create your own module that will be used for setting up the test environment. The module must export a class with
[CODE_BLOCK_594]
[CODE_BLOCK_595]
[CODE_BLOCK_596]
methods. You can also pass variables from this module to your test suites by assigning them to
[CODE_BLOCK_597]
object  this will make them available in your test suites as global variables. The constructor is passed
[CODE_BLOCK_598]
[CODE_BLOCK_599]
as its first argument, and
[CODE_BLOCK_600]
as its second.
The class may optionally expose an asynchronous
[CODE_BLOCK_601]
method to bind to events fired by
[CODE_BLOCK_602]
. Normally,
[CODE_BLOCK_603]
test runner would pause until a promise returned from
[CODE_BLOCK_604]
gets fulfilled,
except for the next events
[CODE_BLOCK_605]
[CODE_BLOCK_606]
[CODE_BLOCK_607]
[CODE_BLOCK_608]
[CODE_BLOCK_609]
(for the up-to-date list you can look at
SyncEvent type in the types definitions
). That is caused by backward compatibility reasons and
[CODE_BLOCK_610]
signature, but that usually should not be a problem for most of the use cases.
Any docblock pragmas in test files will be passed to the environment constructor and can be used for per-test configuration. If the pragma does not have a value, it will be present in the object with its value set to an empty string. If the pragma is not present, it will not be present in the object.
To use this class as your custom environment, refer to it by its full path within the project. For example, if your class is stored in
[CODE_BLOCK_611]
in some subfolder of your project, then the annotation might look like this:
[CODE_BLOCK_612]
info
TestEnvironment is sandboxed. Each test suite will trigger setup/teardown in their own TestEnvironment.
Example:
[CODE_BLOCK_614]
[CODE_BLOCK_616]
[CODE_BLOCK_618]
[Object]
Default:
[CODE_BLOCK_619]
Test environment options that will be passed to the
[CODE_BLOCK_620]
. The relevant options depend on the environment.
For example, you can override options passed to
[CODE_BLOCK_621]
JavaScript
TypeScript
[CODE_BLOCK_622]
[CODE_BLOCK_624]
Both
[CODE_BLOCK_626]
[CODE_BLOCK_627]
allow specifying
[CODE_BLOCK_628]
, which allow you to control which versions of a library are loaded from
[CODE_BLOCK_629]
[CODE_BLOCK_630]
[CODE_BLOCK_631]
defaults to
[CODE_BLOCK_632]
[CODE_BLOCK_633]
defaults to
[CODE_BLOCK_634]
JavaScript
TypeScript
[CODE_BLOCK_635]
[CODE_BLOCK_637]
These options can also be passed in a docblock, similar to
[CODE_BLOCK_639]
. The string with options must be parseable by
[CODE_BLOCK_640]
[CODE_BLOCK_641]
[CODE_BLOCK_643]
[number]
Default:
[CODE_BLOCK_644]
The exit code Jest returns on test failure.
info
This does not change the exit code in the case of Jest errors (e.g. invalid configuration).
[CODE_BLOCK_645]
[array<string>]
(default:
[CODE_BLOCK_646]
The glob patterns Jest uses to detect test files. By default it looks for
[CODE_BLOCK_647]
[CODE_BLOCK_648]
[CODE_BLOCK_649]
[CODE_BLOCK_650]
files inside of
[CODE_BLOCK_651]
folders, as well as any files with a suffix of
[CODE_BLOCK_652]
[CODE_BLOCK_653]
(e.g.
[CODE_BLOCK_654]
[CODE_BLOCK_655]
). It will also find files called
[CODE_BLOCK_656]
[CODE_BLOCK_657]
See the
micromatch
package for details of the patterns you can specify.
See also
[CODE_BLOCK_658]
[string | array<string>]
, but note that you cannot specify both options.
Each glob pattern is applied in the order they are specified in the config. For example
[CODE_BLOCK_659]
will not exclude
[CODE_BLOCK_660]
because the negation is overwritten with the second pattern. In order to make the negated glob work in this example it has to come after
[CODE_BLOCK_661]
[CODE_BLOCK_662]
[array<string>]
Default:
[CODE_BLOCK_663]
An array of regexp pattern strings that are matched against all test paths before executing the test. If the test path matches any of the patterns, it will be skipped.
These pattern strings match against the full path. Use the
[CODE_BLOCK_664]
string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example:
[CODE_BLOCK_665]
[CODE_BLOCK_666]
[string | array<string>]
Default:
[CODE_BLOCK_667]
The pattern or patterns Jest uses to detect test files. By default it looks for
[CODE_BLOCK_668]
[CODE_BLOCK_669]
[CODE_BLOCK_670]
[CODE_BLOCK_671]
files inside of
[CODE_BLOCK_672]
folders, as well as any files with a suffix of
[CODE_BLOCK_673]
[CODE_BLOCK_674]
(e.g.
[CODE_BLOCK_675]
[CODE_BLOCK_676]
). It will also find files called
[CODE_BLOCK_677]
[CODE_BLOCK_678]
. See also
[CODE_BLOCK_679]
[array<string>]
, but note that you cannot specify both options.
The following is a visualization of the default regex:
[CODE_BLOCK_680]
info
[CODE_BLOCK_682]
will try to detect test files using the
absolute file path
, therefore, having a folder with a name that matches it will run all the files as tests.
[CODE_BLOCK_683]
[string]
Default:
[CODE_BLOCK_684]
This option allows the use of a custom results processor. This processor must be a node module that exports a function expecting an object with the following structure as the first argument and return it:
[CODE_BLOCK_685]
[CODE_BLOCK_687]
[CODE_BLOCK_688]
are very similar to each other. One difference is that a test result processor only gets called after all tests finished. Whereas a reporter has the ability to receive test results after individual tests and/or test suites are finished.
[CODE_BLOCK_689]
[string]
Default:
[CODE_BLOCK_690]
This option allows the use of a custom test runner. The default is
[CODE_BLOCK_691]
. A custom test runner can be provided by specifying a path to a test runner implementation.
The test runner module must export a function with the following signature:
[CODE_BLOCK_692]
An example of such function can be found in our default
jasmine2 test runner package
[CODE_BLOCK_694]
[string]
Default:
[CODE_BLOCK_695]
This option allows you to use a custom sequencer instead of Jest's default.
Both
[CODE_BLOCK_696]
[CODE_BLOCK_697]
may optionally return a
[CODE_BLOCK_698]
For example, you may sort test paths alphabetically:
custom-sequencer.js
[CODE_BLOCK_699]
[CODE_BLOCK_701]
to your Jest configuration:
JavaScript
TypeScript
[CODE_BLOCK_702]
[CODE_BLOCK_704]
[CODE_BLOCK_706]
[number]
Default:
[CODE_BLOCK_707]
Default timeout of a test in milliseconds.
[CODE_BLOCK_708]
[object<string, pathToTransformer | [pathToTransformer, object]>]
Default:
[CODE_BLOCK_709]
A map from regular expressions to paths to transformers. Optionally, a tuple with configuration options can be passed as second argument:
[CODE_BLOCK_710]
. For example, here is how you can configure
[CODE_BLOCK_711]
for non-default behavior:
[CODE_BLOCK_712]
Jest runs the code of your project as JavaScript, hence a transformer is needed if you use some syntax not supported by Node out of the box (such as JSX, TypeScript, Vue templates). By default, Jest will use
[CODE_BLOCK_713]
transformer, which will load your project's Babel configuration and transform any file matching the
[CODE_BLOCK_714]
RegExp (in other words, any
[CODE_BLOCK_715]
[CODE_BLOCK_716]
[CODE_BLOCK_717]
[CODE_BLOCK_718]
file). In addition,
[CODE_BLOCK_719]
will inject the Babel plugin necessary for mock hoisting talked about in
ES Module mocking
See the
Code Transformation
section for more details and instructions on building your own transformer.
Keep in mind that a transformer only runs once per file unless the file has changed.
Remember to include the default
[CODE_BLOCK_720]
transformer explicitly, if you wish to use it alongside with additional code preprocessors:
JavaScript
TypeScript
[CODE_BLOCK_721]
[CODE_BLOCK_723]
[CODE_BLOCK_725]
[array<string>]
Default:
[CODE_BLOCK_726]
An array of regexp pattern strings that are matched against all source file paths before transformation. If the file path matches
of the patterns, it will not be transformed.
Providing regexp patterns that overlap with each other may result in files not being transformed that you expected to be transformed. For example:
JavaScript
TypeScript
[CODE_BLOCK_727]
[CODE_BLOCK_729]
The first pattern will match (and therefore not transform) files inside
[CODE_BLOCK_731]
except for those in
[CODE_BLOCK_732]
[CODE_BLOCK_733]
. The second pattern will match (and therefore not transform) files inside any path with
[CODE_BLOCK_734]
in it. With the two together, files in
[CODE_BLOCK_735]
will not be transformed because it does match the second pattern, even though it was excluded by the first.
Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled code. Since all files inside
[CODE_BLOCK_736]
are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use
[CODE_BLOCK_737]
to allow transpiling such modules. You'll find a good example of this use case in
React Native Guide
These pattern strings match against the full path. Use the
[CODE_BLOCK_738]
string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.
JavaScript
TypeScript
[CODE_BLOCK_739]
[CODE_BLOCK_741]
If you use
[CODE_BLOCK_743]
and need to convert some packages under
[CODE_BLOCK_744]
, you need to note that the packages in this folder (e.g.
[CODE_BLOCK_745]
) have been symlinked to the path under
[CODE_BLOCK_746]
(e.g.
[CODE_BLOCK_747]
), so using
[CODE_BLOCK_748]
directly will not be recognized, while is to use:
JavaScript
TypeScript
[CODE_BLOCK_749]
[CODE_BLOCK_751]
It should be noted that the folder name of pnpm under
[CODE_BLOCK_753]
is the package name plus
[CODE_BLOCK_754]
and version number, so writing
[CODE_BLOCK_755]
will not be recognized, but using
[CODE_BLOCK_756]
can.
[CODE_BLOCK_757]
[array<string>]
Default:
[CODE_BLOCK_758]
An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them. If a module's path matches any of the patterns in this list, it will not be automatically mocked by the module loader.
This is useful for some commonly used 'utility' modules that are almost always used as implementation details almost all the time (like
[CODE_BLOCK_759]
[CODE_BLOCK_760]
, etc). It's generally a best practice to keep this list as small as possible and always use explicit
[CODE_BLOCK_761]
[CODE_BLOCK_762]
calls in individual tests. Explicit per-test setup is far easier for other readers of the test to reason about the environment the test will run in.
It is possible to override this setting in individual tests by explicitly calling
[CODE_BLOCK_763]
at the top of the test file.
[CODE_BLOCK_764]
[boolean]
Default:
[CODE_BLOCK_765]
[CODE_BLOCK_766]
if there is only one test file to run
Indicates whether each individual test should be reported during the run. All errors will also still be shown on the bottom after execution.
[CODE_BLOCK_767]
[boolean]
Gives one event loop turn to handle
[CODE_BLOCK_768]
[CODE_BLOCK_769]
[CODE_BLOCK_770]
Without this flag Jest may report false-positive errors (e.g. actually handled rejection reported) or not report actually unhandled rejection (or report it for different test case).
This option may add a noticeable overhead for fast test suites.
[CODE_BLOCK_771]
[array<string>]
Default:
[CODE_BLOCK_772]
An array of RegExp patterns that are matched against all source file paths before re-running tests in watch mode. If the file path matches any of the patterns, when it is updated, it will not trigger a re-run of tests.
These patterns match against the full path. Use the
[CODE_BLOCK_773]
string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example:
[CODE_BLOCK_774]
Even if nothing is specified here, the watcher will ignore changes to the version control folders (.git, .hg, .sl). Other hidden files and directories, i.e. those that begin with a dot (
[CODE_BLOCK_775]
), are watched by default. Remember to escape the dot when you add them to
[CODE_BLOCK_776]
as it is a special RegExp character.
JavaScript
TypeScript
[CODE_BLOCK_777]
[CODE_BLOCK_779]
[CODE_BLOCK_781]
[array<string | [string, Object]>]
Default:
[CODE_BLOCK_782]
This option allows you to use custom watch plugins. Read more about watch plugins
here
Examples of watch plugins include:
[CODE_BLOCK_783]
[CODE_BLOCK_784]
[CODE_BLOCK_785]
[CODE_BLOCK_786]
[CODE_BLOCK_787]
info
The values in the
[CODE_BLOCK_788]
property value can omit the
[CODE_BLOCK_789]
prefix of the package name.
[CODE_BLOCK_790]
[boolean]
Default:
[CODE_BLOCK_791]
Whether to use
[CODE_BLOCK_792]
for file crawling.
[CODE_BLOCK_793]
[number|string]
Default:
[CODE_BLOCK_794]
Specifies the memory limit for workers before they are recycled and is primarily a work-around for
this issue
After the worker has executed a test the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. The limit can be specified in a number of different ways and whatever the result is
[CODE_BLOCK_795]
is used to turn it into an integer value:
[CODE_BLOCK_796]
- The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory
[CODE_BLOCK_797]
- Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use
[CODE_BLOCK_798]
With units
[CODE_BLOCK_799]
- As above, a percentage of total system memory
[CODE_BLOCK_800]
[CODE_BLOCK_801]
, etc - With units to denote a fixed memory limit.
[CODE_BLOCK_802]
[CODE_BLOCK_803]
- Kilobytes (x1000)
[CODE_BLOCK_804]
- Kibibytes (x1024)
[CODE_BLOCK_805]
[CODE_BLOCK_806]
- Megabytes
[CODE_BLOCK_807]
- Mebibytes
[CODE_BLOCK_808]
[CODE_BLOCK_809]
- Gigabytes
[CODE_BLOCK_810]
- Gibibytes
caution
Percentage based memory limit
does not work on Linux CircleCI workers
due to incorrect system memory being reported.
JavaScript
TypeScript
[CODE_BLOCK_811]
[CODE_BLOCK_813]
[CODE_BLOCK_815]
[string]
This option allows comments in
[CODE_BLOCK_816]
. Include the comment text as the value of this key:
package.json
[CODE_BLOCK_817]
[CODE_BLOCK_819]
Default:
[CODE_BLOCK_820]
Whether to use
worker threads
for parallelization.
Child processes
are used by default.
Using worker threads may help to improve
performance
caution
This is
experimental feature
. Keep in mind that the worker threads use structured clone instead of
[CODE_BLOCK_821]
to serialize messages. This means that built-in JavaScript objects as
[CODE_BLOCK_822]
[CODE_BLOCK_823]
[CODE_BLOCK_824]
will get serialized properly. However extra properties set on
[CODE_BLOCK_825]
[CODE_BLOCK_826]
[CODE_BLOCK_827]
will not be passed on through the serialization step. For more details see the article on
structured clone
Options
Reference
[CODE_BLOCK_828]
[boolean]
[CODE_BLOCK_829]
[number | boolean]
[CODE_BLOCK_830]
[string]
[CODE_BLOCK_831]
[boolean]
[CODE_BLOCK_832]
[boolean]
[CODE_BLOCK_833]
[array]
[CODE_BLOCK_834]
[string]
[CODE_BLOCK_835]
[array<string>]
[CODE_BLOCK_836]
[string]
[CODE_BLOCK_837]
[array<string | [string, options]>]
[CODE_BLOCK_838]
[object]
[CODE_BLOCK_839]
[string]
[CODE_BLOCK_840]
[string, object]
[CODE_BLOCK_841]
[boolean]
[CODE_BLOCK_842]
[array<string>]
[CODE_BLOCK_843]
[object]
[CODE_BLOCK_844]
[array<string>]
[CODE_BLOCK_845]
[object]
[CODE_BLOCK_846]
[string]
[CODE_BLOCK_847]
[string]
[CODE_BLOCK_848]
[object]
[CODE_BLOCK_849]
[boolean]
[CODE_BLOCK_850]
[number]
[CODE_BLOCK_851]
[number | string]
[CODE_BLOCK_852]
[array<string>]
[CODE_BLOCK_853]
[array<string>]
[CODE_BLOCK_854]
[object<string, string | array<string>>]
[CODE_BLOCK_855]
[array<string>]
[CODE_BLOCK_856]
[array<string>]
[CODE_BLOCK_857]
[boolean]
[CODE_BLOCK_858]
[string]
[CODE_BLOCK_859]
[number]
[CODE_BLOCK_860]
[string]
[CODE_BLOCK_861]
[string]
[CODE_BLOCK_862]
[array<string | ProjectConfig>]
[CODE_BLOCK_863]
[boolean]
[CODE_BLOCK_864]
[array<moduleName | [moduleName, options]>]
[CODE_BLOCK_865]
[boolean]
[CODE_BLOCK_866]
[boolean]
[CODE_BLOCK_867]
[string]
[CODE_BLOCK_868]
[boolean]
[CODE_BLOCK_869]
[string]
[CODE_BLOCK_870]
[array<string>]
[CODE_BLOCK_871]
[string]
[CODE_BLOCK_872]
[array<string>]
[CODE_BLOCK_873]
[array]
[CODE_BLOCK_874]
[array]
[CODE_BLOCK_875]
[boolean]
[CODE_BLOCK_876]
[number]
[CODE_BLOCK_877]
[object]
[CODE_BLOCK_878]
[string]
[CODE_BLOCK_879]
[array<string>]
[CODE_BLOCK_880]
[string]
[CODE_BLOCK_881]
[Object]
[CODE_BLOCK_882]
[number]
[CODE_BLOCK_883]
[array<string>]
[CODE_BLOCK_884]
[array<string>]
[CODE_BLOCK_885]
[string | array<string>]
[CODE_BLOCK_886]
[string]
[CODE_BLOCK_887]
[string]
[CODE_BLOCK_888]
[string]
[CODE_BLOCK_889]
[number]
[CODE_BLOCK_890]
[object<string, pathToTransformer | [pathToTransformer, object]>]
[CODE_BLOCK_891]
[array<string>]
[CODE_BLOCK_892]
[array<string>]
[CODE_BLOCK_893]
[boolean]
[CODE_BLOCK_894]
[boolean]
[CODE_BLOCK_895]
[array<string>]
[CODE_BLOCK_896]
[array<string | [string, Object]>]
[CODE_BLOCK_897]
[boolean]
[CODE_BLOCK_898]
[number|string]
[CODE_BLOCK_899]
[string]
[CODE_BLOCK_900]