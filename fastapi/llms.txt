# FASTAPI DOCUMENTATION
Generated: 2025-06-19 21:28:25
Files processed: 162
Total characters: 3,039,930
Source: Auto-scraped documentation

## OVERVIEW
This file contains the complete documentation for fastapi, minified and optimized for LLM consumption.
All content has been cleaned, deduplicated, and formatted for maximum information density.

---


## 001_INDEX
FastAPI¶
---

FastAPI
FastAPI framework, high performance, easy to learn, fast to code, ready for production
Documentation
:
https://fastapi.tiangolo.com
Source Code
:
https://github.com/fastapi/fastapi
FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints.
The key features are:
Fast
: Very high performance, on par with
NodeJS
and
Go
(thanks to Starlette and Pydantic).
One of the fastest Python frameworks available
.
Fast to code
: Increase the speed to develop features by about 200% to 300%. *
Fewer bugs
: Reduce about 40% of human (developer) induced errors. *
Intuitive
: Great editor support.
Completion
everywhere. Less time debugging.
Easy
: Designed to be easy to use and learn. Less time reading docs.
Short
: Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs.
Robust
: Get production-ready code. With automatic interactive documentation.
Standards-based
: Based on (and fully compatible with) the open standards for APIs:
OpenAPI
(previously known as Swagger) and
JSON Schema
.
* estimation based on tests on an internal development team, building production applications.
Sponsors
Other sponsors
Opinions
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I’m over the moon excited about
FastAPI
. It’s so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
If anyone is looking to build a production Python API, I would highly recommend
FastAPI
. It is
beautifully designed
,
simple to use
and
highly scalable
, it has become a
key component
in our API first development strategy and is driving many automations and services such as our Virtual TAC Engineer.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, the FastAPI of CLIs
If you are building a
CLI
app to be used in the terminal instead of a web API, check out
Typer
.
Typer
is FastAPI's little sibling. And it's intended to be the
FastAPI of CLIs
. ⌨️ 🚀
Requirements
FastAPI stands on the shoulders of giants:
Starlette
for the web parts.
Pydantic
for the data parts.
Installation
Create and activate a
virtual environment
and then install FastAPI:
fast →
pip install "fastapi[standard]"
restart ↻
Note
: Make sure you put
"fastapi[standard]"
in quotes to ensure it works in all terminals.
Example
Create it
Create a file
main.py
with:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Or use
async def
...
If your code uses
async
/
await
, use
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Note
:
If you don't know, check the
"In a hurry?"
section about
async
and
await
in the docs
.
Run it
Run the server with:
fast →
fastapi dev main.py
╭────────── FastAPI CLI - Development mode ───────────╮
│ │
│ Serving at: http://127.0.0.1:8000 │
│ │
│ API docs: http://127.0.0.1:8000/docs │
│ │
│ Running in development mode, for production use: │
│ │
│ fastapi run │
│ │
╰─────────────────────────────────────────────────────╯
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
About the command
fastapi dev main.py
...
The command
fastapi dev
reads your
main.py
file, detects the
FastAPI
app in it, and starts a server using
Uvicorn
.
By default,
fastapi dev
will start with auto-reload enabled for local development.
You can read more about it in the
FastAPI CLI docs
.
Check it
Open your browser at
http://127.0.0.1:8000/items/5?q=somequery
.
You will see the JSON response as:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
You already created an API that:
Receives HTTP requests in the
paths
/
and
/items/{item_id}
.
Both
paths
take
GET
operations
(also known as HTTP
methods
).
The
path
/items/{item_id}
has a
path parameter
item_id
that should be an
int
.
The
path
/items/{item_id}
has an optional
str
query parameter
q
.
Interactive API docs
Now go to
http://127.0.0.1:8000/docs
.
You will see the automatic interactive API documentation (provided by
Swagger UI
):
Alternative API docs
And now, go to
http://127.0.0.1:8000/redoc
.
You will see the alternative automatic documentation (provided by
ReDoc
):
Example upgrade
Now modify the file
main.py
to receive a body from a
PUT
request.
Declare the body using standard Python types, thanks to Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
The
fastapi dev
server should reload automatically.
Interactive API docs upgrade
Now go to
http://127.0.0.1:8000/docs
.
The interactive API documentation will be automatically updated, including the new body:
Click on the button "Try it out", it allows you to fill the parameters and directly interact with the API:
Then click on the "Execute" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen:
Alternative API docs upgrade
And now, go to
http://127.0.0.1:8000/redoc
.
The alternative documentation will also reflect the new query parameter and body:
Recap
In summary, you declare
once
the types of parameters, body, etc. as function parameters.
You do that with standard modern Python types.
You don't have to learn a new syntax, the methods or classes of a specific library, etc.
Just standard
Python
.
For example, for an
int
:
item_id
:
int
or for a more complex
Item
model:
item
:
Item
...and with that single declaration you get:
Editor support, including:
Completion.
Type checks.
Validation of data:
Automatic and clear errors when the data is invalid.
Validation even for deeply nested JSON objects.
Conversion
of input data: coming from the network to Python data and types. Reading from:
JSON.
Path parameters.
Query parameters.
Cookies.
Headers.
Forms.
Files.
Conversion
of output data: converting from Python data and types to network data (as JSON):
Convert Python types (
str
,
int
,
float
,
bool
,
list
, etc).
datetime
objects.
UUID
objects.
Database models.
...and many more.
Automatic interactive API documentation, including 2 alternative user interfaces:
Swagger UI.
ReDoc.
Coming back to the previous code example,
FastAPI
will:
Validate that there is an
item_id
in the path for
GET
and
PUT
requests.
Validate that the
item_id
is of type
int
for
GET
and
PUT
requests.
If it is not, the client will see a useful, clear error.
Check if there is an optional query parameter named
q
(as in
http://127.0.0.1:8000/items/foo?q=somequery
) for
GET
requests.
As the
q
parameter is declared with
= None
, it is optional.
Without the
None
it would be required (as is the body in the case with
PUT
).
For
PUT
requests to
/items/{item_id}
, read the body as JSON:
Check that it has a required attribute
name
that should be a
str
.
Check that it has a required attribute
price
that has to be a
float
.
Check that it has an optional attribute
is_offer
, that should be a
bool
, if present.
All this would also work for deeply nested JSON objects.
Convert from and to JSON automatically.
Document everything with OpenAPI, that can be used by:
Interactive documentation systems.
Automatic client code generation systems, for many languages.
Provide 2 interactive documentation web interfaces directly.
We just scratched the surface, but you already get the idea of how it all works.
Try changing the line with:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...from:
...
"item_name"
:
item
.
name
...
...to:
...
"item_price"
:
item
.
price
...
...and see how your editor will auto-complete the attributes and know their types:
For a more complete example including more features, see the
Tutorial - User Guide
.
Spoiler alert
: the tutorial - user guide includes:
Declaration of
parameters
from other different places as:
headers
,
cookies
,
form fields
and
files
.
How to set
validation constraints
as
maximum_length
or
regex
.
A very powerful and easy to use
Dependency Injection
system.
Security and authentication, including support for
OAuth2
with
JWT tokens
and
HTTP Basic
auth.
More advanced (but equally easy) techniques for declaring
deeply nested JSON models
(thanks to Pydantic).
GraphQL
integration with
Strawberry
and other libraries.
Many extra features (thanks to Starlette) as:
WebSockets
extremely easy tests based on HTTPX and
pytest
CORS
Cookie Sessions
...and more.
Performance
Independent TechEmpower benchmarks show
FastAPI
applications running under Uvicorn as
one of the fastest Python frameworks available
, only below Starlette and Uvicorn themselves (used internally by FastAPI). (*)
To understand more about it, see the section
Benchmarks
.
Dependencies
FastAPI depends on Pydantic and Starlette.
standard
Dependencies
When you install FastAPI with
pip install "fastapi[standard]"
it comes with the
standard
group of optional dependencies:
Used by Pydantic:
email-validator
- for email validation.
Used by Starlette:
httpx
- Required if you want to use the
TestClient
.
jinja2
- Required if you want to use the default template configuration.
python-multipart
- Required if you want to support form
"parsing"
, with
request.form()
.
Used by FastAPI / Starlette:
uvicorn
- for the server that loads and serves your application. This includes
uvicorn[standard]
, which includes some dependencies (e.g.
uvloop
) needed for high performance serving.
fastapi-cli
- to provide the
fastapi
command.
Without
standard
Dependencies
If you don't want to include the
standard
optional dependencies, you can install with
pip install fastapi
instead of
pip install "fastapi[standard]"
.
Additional Optional Dependencies
There are some additional dependencies you might want to install.
Additional optional Pydantic dependencies:
pydantic-settings
- for settings management.
pydantic-extra-types
- for extra types to be used with Pydantic.
Additional optional FastAPI dependencies:
orjson
- Required if you want to use
ORJSONResponse
.
ujson
- Required if you want to use
UJSONResponse
.
License
This project is licensed under the terms of the MIT license.

## 002_ADVANCED
Advanced User Guide¶
---

Advanced User Guide
Additional Features
The main
Tutorial - User Guide
should be enough to give you a tour through all the main features of
FastAPI
.
In the next sections you will see other options, configurations, and additional features.
Tip
The next sections are
not necessarily "advanced"
.
And it's possible that for your use case, the solution is in one of them.
Read the Tutorial first
You could still use most of the features in
FastAPI
with the knowledge from the main
Tutorial - User Guide
.
And the next sections assume you already read it, and assume that you know those main ideas.

## 003_ADVANCED_ADDITIONAL_RESPONSES
Additional Responses in OpenAPI¶
---

Additional Responses in OpenAPI
Warning
This is a rather advanced topic.
If you are starting with
FastAPI
, you might not need this.
You can declare additional responses, with additional status codes, media types, descriptions, etc.
Those additional responses will be included in the OpenAPI schema, so they will also appear in the API docs.
But for those additional responses you have to make sure you return a
Response
like
JSONResponse
directly, with your status code and content.
Additional Response with
model
You can pass to your
path operation decorators
a parameter
responses
.
It receives a
dict
: the keys are status codes for each response (like
200
), and the values are other
dict
s with the information for each of them.
Each of those response
dict
s can have a key
model
, containing a Pydantic model, just like
response_model
.
FastAPI
will take that model, generate its JSON Schema and include it in the correct place in OpenAPI.
For example, to declare another response with a status code
404
and a Pydantic model
Message
, you can write:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
JSONResponse
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
id
:
str
value
:
str
class
Message
(
BaseModel
):
message
:
str
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
responses
=
{
404
:
{
"model"
:
Message
}})
async
def
read_item
(
item_id
:
str
):
if
item_id
==
"foo"
:
return
{
"id"
:
"foo"
,
"value"
:
"there goes my hero"
}
return
JSONResponse
(
status_code
=
404
,
content
=
{
"message"
:
"Item not found"
})
Note
Keep in mind that you have to return the
JSONResponse
directly.
Info
The
model
key is not part of OpenAPI.
FastAPI
will take the Pydantic model from there, generate the JSON Schema, and put it in the correct place.
The correct place is:
In the key
content
, that has as value another JSON object (
dict
) that contains:
A key with the media type, e.g.
application/json
, that contains as value another JSON object, that contains:
A key
schema
, that has as the value the JSON Schema from the model, here's the correct place.
FastAPI
adds a reference here to the global JSON Schemas in another place in your OpenAPI instead of including it directly. This way, other applications and clients can use those JSON Schemas directly, provide better code generation tools, etc.
The generated responses in the OpenAPI for this
path operation
will be:
{
"responses"
:
{
"404"
:
{
"description"
:
"Additional Response"
,
"content"
:
{
"application/json"
:
{
"schema"
:
{
"$ref"
:
"#/components/schemas/Message"
}
}
}
},
"200"
:
{
"description"
:
"Successful Response"
,
"content"
:
{
"application/json"
:
{
"schema"
:
{
"$ref"
:
"#/components/schemas/Item"
}
}
}
},
"422"
:
{
"description"
:
"Validation Error"
,
"content"
:
{
"application/json"
:
{
"schema"
:
{
"$ref"
:
"#/components/schemas/HTTPValidationError"
}
}
}
}
}
}
The schemas are referenced to another place inside the OpenAPI schema:
{
"components"
:
{
"schemas"
:
{
"Message"
:
{
"title"
:
"Message"
,
"required"
:
[
"message"
],
"type"
:
"object"
,
"properties"
:
{
"message"
:
{
"title"
:
"Message"
,
"type"
:
"string"
}
}
},
"Item"
:
{
"title"
:
"Item"
,
"required"
:
[
"id"
,
"value"
],
"type"
:
"object"
,
"properties"
:
{
"id"
:
{
"title"
:
"Id"
,
"type"
:
"string"
},
"value"
:
{
"title"
:
"Value"
,
"type"
:
"string"
}
}
},
"ValidationError"
:
{
"title"
:
"ValidationError"
,
"required"
:
[
"loc"
,
"msg"
,
"type"
],
"type"
:
"object"
,
"properties"
:
{
"loc"
:
{
"title"
:
"Location"
,
"type"
:
"array"
,
"items"
:
{
"type"
:
"string"
}
},
"msg"
:
{
"title"
:
"Message"
,
"type"
:
"string"
},
"type"
:
{
"title"
:
"Error Type"
,
"type"
:
"string"
}
}
},
"HTTPValidationError"
:
{
"title"
:
"HTTPValidationError"
,
"type"
:
"object"
,
"properties"
:
{
"detail"
:
{
"title"
:
"Detail"
,
"type"
:
"array"
,
"items"
:
{
"$ref"
:
"#/components/schemas/ValidationError"
}
}
}
}
}
}
}
Additional media types for the main response
You can use this same
responses
parameter to add different media types for the same main response.
For example, you can add an additional media type of
image/png
, declaring that your
path operation
can return a JSON object (with media type
application/json
) or a PNG image:
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.responses
import
FileResponse
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
id
:
str
value
:
str
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
responses
=
{
200
:
{
"content"
:
{
"image/png"
:
{}},
"description"
:
"Return the JSON item or an image."
,
}
},
)
async
def
read_item
(
item_id
:
str
,
img
:
Union
[
bool
,
None
]
=
None
):
if
img
:
return
FileResponse
(
"image.png"
,
media_type
=
"image/png"
)
else
:
return
{
"id"
:
"foo"
,
"value"
:
"there goes my hero"
}
Note
Notice that you have to return the image using a
FileResponse
directly.
Info
Unless you specify a different media type explicitly in your
responses
parameter, FastAPI will assume the response has the same media type as the main response class (default
application/json
).
But if you have specified a custom response class with
None
as its media type, FastAPI will use
application/json
for any additional response that has an associated model.
Combining information
You can also combine response information from multiple places, including the
response_model
,
status_code
, and
responses
parameters.
You can declare a
response_model
, using the default status code
200
(or a custom one if you need), and then declare additional information for that same response in
responses
, directly in the OpenAPI schema.
FastAPI
will keep the additional information from
responses
, and combine it with the JSON Schema from your model.
For example, you can declare a response with a status code
404
that uses a Pydantic model and has a custom
description
.
And a response with a status code
200
that uses your
response_model
, but includes a custom
example
:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
JSONResponse
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
id
:
str
value
:
str
class
Message
(
BaseModel
):
message
:
str
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
responses
=
{
404
:
{
"model"
:
Message
,
"description"
:
"The item was not found"
},
200
:
{
"description"
:
"Item requested by ID"
,
"content"
:
{
"application/json"
:
{
"example"
:
{
"id"
:
"bar"
,
"value"
:
"The bar tenders"
}
}
},
},
},
)
async
def
read_item
(
item_id
:
str
):
if
item_id
==
"foo"
:
return
{
"id"
:
"foo"
,
"value"
:
"there goes my hero"
}
else
:
return
JSONResponse
(
status_code
=
404
,
content
=
{
"message"
:
"Item not found"
})
It will all be combined and included in your OpenAPI, and shown in the API docs:
Combine predefined responses and custom ones
You might want to have some predefined responses that apply to many
path operations
, but you want to combine them with custom responses needed by each
path operation
.
For those cases, you can use the Python technique of "unpacking" a
dict
with
**dict_to_unpack
:
old_dict
=
{
"old key"
:
"old value"
,
"second old key"
:
"second old value"
,
}
new_dict
=
{
**
old_dict
,
"new key"
:
"new value"
}
Here,
new_dict
will contain all the key-value pairs from
old_dict
plus the new key-value pair:
{
"old key"
:
"old value"
,
"second old key"
:
"second old value"
,
"new key"
:
"new value"
,
}
You can use that technique to reuse some predefined responses in your
path operations
and combine them with additional custom ones.
For example:
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.responses
import
FileResponse
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
id
:
str
value
:
str
responses
=
{
404
:
{
"description"
:
"Item not found"
},
302
:
{
"description"
:
"The item was moved"
},
403
:
{
"description"
:
"Not enough privileges"
},
}
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
responses
=
{
**
responses
,
200
:
{
"content"
:
{
"image/png"
:
{}}}},
)
async
def
read_item
(
item_id
:
str
,
img
:
Union
[
bool
,
None
]
=
None
):
if
img
:
return
FileResponse
(
"image.png"
,
media_type
=
"image/png"
)
else
:
return
{
"id"
:
"foo"
,
"value"
:
"there goes my hero"
}
More information about OpenAPI responses
To see what exactly you can include in the responses, you can check these sections in the OpenAPI specification:
OpenAPI Responses Object
, it includes the
Response Object
.
OpenAPI Response Object
, you can include anything from this directly in each response inside your
responses
parameter. Including
description
,
headers
,
content
(inside of this is that you declare different media types and JSON Schemas), and
links
.

## 004_ADVANCED_ADDITIONAL_STATUS_CODES
Additional Status Codes¶
---

Additional Status Codes
By default,
FastAPI
will return the responses using a
JSONResponse
, putting the content you return from your
path operation
inside of that
JSONResponse
.
It will use the default status code or the one you set in your
path operation
.
Additional status codes
If you want to return additional status codes apart from the main one, you can do that by returning a
Response
directly, like a
JSONResponse
, and set the additional status code directly.
For example, let's say that you want to have a
path operation
that allows to update items, and returns HTTP status codes of 200 "OK" when successful.
But you also want it to accept new items. And when the items didn't exist before, it creates them, and returns an HTTP status code of 201 "Created".
To achieve that, import
JSONResponse
, and return your content there directly, setting the
status_code
that you want:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
,
status
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
items
=
{
"foo"
:
{
"name"
:
"Fighters"
,
"size"
:
6
},
"bar"
:
{
"name"
:
"Tenders"
,
"size"
:
3
}}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
upsert_item
(
item_id
:
str
,
name
:
Annotated
[
str
|
None
,
Body
()]
=
None
,
size
:
Annotated
[
int
|
None
,
Body
()]
=
None
,
):
if
item_id
in
items
:
item
=
items
[
item_id
]
item
[
"name"
]
=
name
item
[
"size"
]
=
size
return
item
else
:
item
=
{
"name"
:
name
,
"size"
:
size
}
items
[
item_id
]
=
item
return
JSONResponse
(
status_code
=
status
.
HTTP_201_CREATED
,
content
=
item
)
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
,
status
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
items
=
{
"foo"
:
{
"name"
:
"Fighters"
,
"size"
:
6
},
"bar"
:
{
"name"
:
"Tenders"
,
"size"
:
3
}}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
upsert_item
(
item_id
:
str
,
name
:
Annotated
[
Union
[
str
,
None
],
Body
()]
=
None
,
size
:
Annotated
[
Union
[
int
,
None
],
Body
()]
=
None
,
):
if
item_id
in
items
:
item
=
items
[
item_id
]
item
[
"name"
]
=
name
item
[
"size"
]
=
size
return
item
else
:
item
=
{
"name"
:
name
,
"size"
:
size
}
items
[
item_id
]
=
item
return
JSONResponse
(
status_code
=
status
.
HTTP_201_CREATED
,
content
=
item
)
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
,
status
from
fastapi.responses
import
JSONResponse
from
typing_extensions
import
Annotated
app
=
FastAPI
()
items
=
{
"foo"
:
{
"name"
:
"Fighters"
,
"size"
:
6
},
"bar"
:
{
"name"
:
"Tenders"
,
"size"
:
3
}}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
upsert_item
(
item_id
:
str
,
name
:
Annotated
[
Union
[
str
,
None
],
Body
()]
=
None
,
size
:
Annotated
[
Union
[
int
,
None
],
Body
()]
=
None
,
):
if
item_id
in
items
:
item
=
items
[
item_id
]
item
[
"name"
]
=
name
item
[
"size"
]
=
size
return
item
else
:
item
=
{
"name"
:
name
,
"size"
:
size
}
items
[
item_id
]
=
item
return
JSONResponse
(
status_code
=
status
.
HTTP_201_CREATED
,
content
=
item
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
,
status
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
items
=
{
"foo"
:
{
"name"
:
"Fighters"
,
"size"
:
6
},
"bar"
:
{
"name"
:
"Tenders"
,
"size"
:
3
}}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
upsert_item
(
item_id
:
str
,
name
:
str
|
None
=
Body
(
default
=
None
),
size
:
int
|
None
=
Body
(
default
=
None
),
):
if
item_id
in
items
:
item
=
items
[
item_id
]
item
[
"name"
]
=
name
item
[
"size"
]
=
size
return
item
else
:
item
=
{
"name"
:
name
,
"size"
:
size
}
items
[
item_id
]
=
item
return
JSONResponse
(
status_code
=
status
.
HTTP_201_CREATED
,
content
=
item
)
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
,
status
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
items
=
{
"foo"
:
{
"name"
:
"Fighters"
,
"size"
:
6
},
"bar"
:
{
"name"
:
"Tenders"
,
"size"
:
3
}}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
upsert_item
(
item_id
:
str
,
name
:
Union
[
str
,
None
]
=
Body
(
default
=
None
),
size
:
Union
[
int
,
None
]
=
Body
(
default
=
None
),
):
if
item_id
in
items
:
item
=
items
[
item_id
]
item
[
"name"
]
=
name
item
[
"size"
]
=
size
return
item
else
:
item
=
{
"name"
:
name
,
"size"
:
size
}
items
[
item_id
]
=
item
return
JSONResponse
(
status_code
=
status
.
HTTP_201_CREATED
,
content
=
item
)
Warning
When you return a
Response
directly, like in the example above, it will be returned directly.
It won't be serialized with a model, etc.
Make sure it has the data you want it to have, and that the values are valid JSON (if you are using
JSONResponse
).
Technical Details
You could also use
from starlette.responses import JSONResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with
status
.
OpenAPI and API docs
If you return additional status codes and responses directly, they won't be included in the OpenAPI schema (the API docs), because FastAPI doesn't have a way to know beforehand what you are going to return.
But you can document that in your code, using:
Additional Responses
.

## 005_ADVANCED_ADVANCED_DEPENDENCIES
Advanced Dependencies¶
---

Advanced Dependencies
Parameterized dependencies
All the dependencies we have seen are a fixed function or class.
But there could be cases where you want to be able to set parameters on the dependency, without having to declare many different functions or classes.
Let's imagine that we want to have a dependency that checks if the query parameter
q
contains some fixed content.
But we want to be able to parameterize that fixed content.
A "callable" instance
In Python there's a way to make an instance of a class a "callable".
Not the class itself (which is already a callable), but an instance of that class.
To do that, we declare a method
__call__
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
bool
=
Depends
(
checker
)):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
In this case, this
__call__
is what
FastAPI
will use to check for additional parameters and sub-dependencies, and this is what will be called to pass a value to the parameter in your
path operation function
later.
Parameterize the instance
And now, we can use
__init__
to declare the parameters of the instance that we can use to "parameterize" the dependency:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
bool
=
Depends
(
checker
)):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
In this case,
FastAPI
won't ever touch or care about
__init__
, we will use it directly in our code.
Create an instance
We could create an instance of this class with:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
bool
=
Depends
(
checker
)):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
And that way we are able to "parameterize" our dependency, that now has
"bar"
inside of it, as the attribute
checker.fixed_content
.
Use the instance as a dependency
Then, we could use this
checker
in a
Depends(checker)
, instead of
Depends(FixedContentQueryChecker)
, because the dependency is the instance,
checker
, not the class itself.
And when solving the dependency,
FastAPI
will call this
checker
like:
checker
(
q
=
"somequery"
)
...and pass whatever that returns as the value of the dependency in our
path operation function
as the parameter
fixed_content_included
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
bool
=
Depends
(
checker
)):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
Tip
All this might seem contrived. And it might not be very clear how is it useful yet.
These examples are intentionally simple, but show how it all works.
In the chapters about security, there are utility functions that are implemented in this same way.
If you understood all this, you already know how those utility tools for security work underneath.

## 006_ADVANCED_ASYNC_TESTS
Async Tests¶
---

Async Tests
You have already seen how to test your
FastAPI
applications using the provided
TestClient
. Up to now, you have only seen how to write synchronous tests, without using
async
functions.
Being able to use asynchronous functions in your tests could be useful, for example, when you're querying your database asynchronously. Imagine you want to test sending requests to your FastAPI application and then verify that your backend successfully wrote the correct data in the database, while using an async database library.
Let's look at how we can make that work.
pytest.mark.anyio
If we want to call asynchronous functions in our tests, our test functions have to be asynchronous. AnyIO provides a neat plugin for this, that allows us to specify that some test functions are to be called asynchronously.
HTTPX
Even if your
FastAPI
application uses normal
def
functions instead of
async def
, it is still an
async
application underneath.
The
TestClient
does some magic inside to call the asynchronous FastAPI application in your normal
def
test functions, using standard pytest. But that magic doesn't work anymore when we're using it inside asynchronous functions. By running our tests asynchronously, we can no longer use the
TestClient
inside our test functions.
The
TestClient
is based on
HTTPX
, and luckily, we can use it directly to test the API.
Example
For a simple example, let's consider a file structure similar to the one described in
Bigger Applications
and
Testing
:
.
├── app
│   ├── __init__.py
│   ├── main.py
│   └── test_main.py
The file
main.py
would have:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Tomato"
}
The file
test_main.py
would have the tests for
main.py
, it could look like this now:
Python 3.8+
import
pytest
from
httpx
import
ASGITransport
,
AsyncClient
from
.main
import
app
@pytest
.
mark
.
anyio
async
def
test_root
():
async
with
AsyncClient
(
transport
=
ASGITransport
(
app
=
app
),
base_url
=
"http://test"
)
as
ac
:
response
=
await
ac
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Tomato"
}
Run it
You can run your tests as usual via:
fast →
pytest
restart ↻
In Detail
The marker
@pytest.mark.anyio
tells pytest that this test function should be called asynchronously:
Python 3.8+
import
pytest
from
httpx
import
ASGITransport
,
AsyncClient
from
.main
import
app
@pytest
.
mark
.
anyio
async
def
test_root
():
async
with
AsyncClient
(
transport
=
ASGITransport
(
app
=
app
),
base_url
=
"http://test"
)
as
ac
:
response
=
await
ac
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Tomato"
}
Tip
Note that the test function is now
async def
instead of just
def
as before when using the
TestClient
.
Then we can create an
AsyncClient
with the app, and send async requests to it, using
await
.
Python 3.8+
import
pytest
from
httpx
import
ASGITransport
,
AsyncClient
from
.main
import
app
@pytest
.
mark
.
anyio
async
def
test_root
():
async
with
AsyncClient
(
transport
=
ASGITransport
(
app
=
app
),
base_url
=
"http://test"
)
as
ac
:
response
=
await
ac
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Tomato"
}
This is the equivalent to:
response
=
client
.
get
(
'/'
)
...that we used to make our requests with the
TestClient
.
Tip
Note that we're using async/await with the new
AsyncClient
- the request is asynchronous.
Warning
If your application relies on lifespan events, the
AsyncClient
won't trigger these events. To ensure they are triggered, use
LifespanManager
from
florimondmanca/asgi-lifespan
.
Other Asynchronous Function Calls
As the testing function is now asynchronous, you can now also call (and
await
) other
async
functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.
Tip
If you encounter a
RuntimeError: Task attached to a different loop
when integrating asynchronous function calls in your tests (e.g. when using
MongoDB's MotorClient
), remember to instantiate objects that need an event loop only within async functions, e.g. an
'@app.on_event("startup")
callback.

## 007_ADVANCED_BEHIND_A_PROXY
Behind a Proxy¶
---

Behind a Proxy
In some situations, you might need to use a
proxy
server like Traefik or Nginx with a configuration that adds an extra path prefix that is not seen by your application.
In these cases you can use
root_path
to configure your application.
The
root_path
is a mechanism provided by the ASGI specification (that FastAPI is built on, through Starlette).
The
root_path
is used to handle these specific cases.
And it's also used internally when mounting sub-applications.
Proxy with a stripped path prefix
Having a proxy with a stripped path prefix, in this case, means that you could declare a path at
/app
in your code, but then, you add a layer on top (the proxy) that would put your
FastAPI
application under a path like
/api/v1
.
In this case, the original path
/app
would actually be served at
/api/v1/app
.
Even though all your code is written assuming there's just
/app
.
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
@app
.
get
(
"/app"
)
def
read_main
(
request
:
Request
):
return
{
"message"
:
"Hello World"
,
"root_path"
:
request
.
scope
.
get
(
"root_path"
)}
And the proxy would be
"stripping"
the
path prefix
on the fly before transmitting the request to the app server (probably Uvicorn via FastAPI CLI), keeping your application convinced that it is being served at
/app
, so that you don't have to update all your code to include the prefix
/api/v1
.
Up to here, everything would work as normally.
But then, when you open the integrated docs UI (the frontend), it would expect to get the OpenAPI schema at
/openapi.json
, instead of
/api/v1/openapi.json
.
So, the frontend (that runs in the browser) would try to reach
/openapi.json
and wouldn't be able to get the OpenAPI schema.
Because we have a proxy with a path prefix of
/api/v1
for our app, the frontend needs to fetch the OpenAPI schema at
/api/v1/openapi.json
.
Tip
The IP
0.0.0.0
is commonly used to mean that the program listens on all the IPs available in that machine/server.
The docs UI would also need the OpenAPI schema to declare that this API
server
is located at
/api/v1
(behind the proxy). For example:
{
"openapi"
:
"3.1.0"
,
// More stuff here
"servers"
:
[
{
"url"
:
"/api/v1"
}
],
"paths"
:
{
// More stuff here
}
}
In this example, the "Proxy" could be something like
Traefik
. And the server would be something like FastAPI CLI with
Uvicorn
, running your FastAPI application.
Providing the
root_path
To achieve this, you can use the command line option
--root-path
like:
fast →
fastapi run main.py --root-path /api/v1
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
If you use Hypercorn, it also has the option
--root-path
.
Technical Details
The ASGI specification defines a
root_path
for this use case.
And the
--root-path
command line option provides that
root_path
.
Checking the current
root_path
You can get the current
root_path
used by your application for each request, it is part of the
scope
dictionary (that's part of the ASGI spec).
Here we are including it in the message just for demonstration purposes.
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
@app
.
get
(
"/app"
)
def
read_main
(
request
:
Request
):
return
{
"message"
:
"Hello World"
,
"root_path"
:
request
.
scope
.
get
(
"root_path"
)}
Then, if you start Uvicorn with:
fast →
fastapi run main.py --root-path /api/v1
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
The response would be something like:
{
"message"
:
"Hello World"
,
"root_path"
:
"/api/v1"
}
Setting the
root_path
in the FastAPI app
Alternatively, if you don't have a way to provide a command line option like
--root-path
or equivalent, you can set the
root_path
parameter when creating your FastAPI app:
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
(
root_path
=
"/api/v1"
)
@app
.
get
(
"/app"
)
def
read_main
(
request
:
Request
):
return
{
"message"
:
"Hello World"
,
"root_path"
:
request
.
scope
.
get
(
"root_path"
)}
Passing the
root_path
to
FastAPI
would be the equivalent of passing the
--root-path
command line option to Uvicorn or Hypercorn.
About
root_path
Keep in mind that the server (Uvicorn) won't use that
root_path
for anything else than passing it to the app.
But if you go with your browser to
http://127.0.0.1:8000/app
you will see the normal response:
{
"message"
:
"Hello World"
,
"root_path"
:
"/api/v1"
}
So, it won't expect to be accessed at
http://127.0.0.1:8000/api/v1/app
.
Uvicorn will expect the proxy to access Uvicorn at
http://127.0.0.1:8000/app
, and then it would be the proxy's responsibility to add the extra
/api/v1
prefix on top.
About proxies with a stripped path prefix
Keep in mind that a proxy with stripped path prefix is only one of the ways to configure it.
Probably in many cases the default will be that the proxy doesn't have a stripped path prefix.
In a case like that (without a stripped path prefix), the proxy would listen on something like
https://myawesomeapp.com
, and then if the browser goes to
https://myawesomeapp.com/api/v1/app
and your server (e.g. Uvicorn) listens on
http://127.0.0.1:8000
the proxy (without a stripped path prefix) would access Uvicorn at the same path:
http://127.0.0.1:8000/api/v1/app
.
Testing locally with Traefik
You can easily run the experiment locally with a stripped path prefix using
Traefik
.
Download Traefik
, it's a single binary, you can extract the compressed file and run it directly from the terminal.
Then create a file
traefik.toml
with:
[entryPoints]
[entryPoints.http]
address
=
":9999"
[providers]
[providers.file]
filename
=
"routes.toml"
This tells Traefik to listen on port 9999 and to use another file
routes.toml
.
Tip
We are using port 9999 instead of the standard HTTP port 80 so that you don't have to run it with admin (
sudo
) privileges.
Now create that other file
routes.toml
:
[http]
[http.middlewares]
[http.middlewares.api-stripprefix.stripPrefix]
prefixes
=
[
"/api/v1"
]
[http.routers]
[http.routers.app-http]
entryPoints
=
[
"http"
]
service
=
"app"
rule
=
"PathPrefix(`/api/v1`)"
middlewares
=
[
"api-stripprefix"
]
[http.services]
[http.services.app]
[http.services.app.loadBalancer]
[[http.services.app.loadBalancer.servers]]
url
=
"http://127.0.0.1:8000"
This file configures Traefik to use the path prefix
/api/v1
.
And then Traefik will redirect its requests to your Uvicorn running on
http://127.0.0.1:8000
.
Now start Traefik:
fast →
./traefik --configFile=traefik.toml
INFO[0000] Configuration loaded from file: /home/user/awesomeapi/traefik.toml
restart ↻
And now start your app, using the
--root-path
option:
fast →
fastapi run main.py --root-path /api/v1
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
Check the responses
Now, if you go to the URL with the port for Uvicorn:
http://127.0.0.1:8000/app
, you will see the normal response:
{
"message"
:
"Hello World"
,
"root_path"
:
"/api/v1"
}
Tip
Notice that even though you are accessing it at
http://127.0.0.1:8000/app
it shows the
root_path
of
/api/v1
, taken from the option
--root-path
.
And now open the URL with the port for Traefik, including the path prefix:
http://127.0.0.1:9999/api/v1/app
.
We get the same response:
{
"message"
:
"Hello World"
,
"root_path"
:
"/api/v1"
}
but this time at the URL with the prefix path provided by the proxy:
/api/v1
.
Of course, the idea here is that everyone would access the app through the proxy, so the version with the path prefix
/api/v1
is the "correct" one.
And the version without the path prefix (
http://127.0.0.1:8000/app
), provided by Uvicorn directly, would be exclusively for the
proxy
(Traefik) to access it.
That demonstrates how the Proxy (Traefik) uses the path prefix and how the server (Uvicorn) uses the
root_path
from the option
--root-path
.
Check the docs UI
But here's the fun part. ✨
The "official" way to access the app would be through the proxy with the path prefix that we defined. So, as we would expect, if you try the docs UI served by Uvicorn directly, without the path prefix in the URL, it won't work, because it expects to be accessed through the proxy.
You can check it at
http://127.0.0.1:8000/docs
:
But if we access the docs UI at the "official" URL using the proxy with port
9999
, at
/api/v1/docs
, it works correctly! 🎉
You can check it at
http://127.0.0.1:9999/api/v1/docs
:
Right as we wanted it. ✔️
This is because FastAPI uses this
root_path
to create the default
server
in OpenAPI with the URL provided by
root_path
.
Additional servers
Warning
This is a more advanced use case. Feel free to skip it.
By default,
FastAPI
will create a
server
in the OpenAPI schema with the URL for the
root_path
.
But you can also provide other alternative
servers
, for example if you want
the same
docs UI to interact with both a staging and a production environment.
If you pass a custom list of
servers
and there's a
root_path
(because your API lives behind a proxy),
FastAPI
will insert a "server" with this
root_path
at the beginning of the list.
For example:
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
(
servers
=
[
{
"url"
:
"https://stag.example.com"
,
"description"
:
"Staging environment"
},
{
"url"
:
"https://prod.example.com"
,
"description"
:
"Production environment"
},
],
root_path
=
"/api/v1"
,
)
@app
.
get
(
"/app"
)
def
read_main
(
request
:
Request
):
return
{
"message"
:
"Hello World"
,
"root_path"
:
request
.
scope
.
get
(
"root_path"
)}
Will generate an OpenAPI schema like:
{
"openapi"
:
"3.1.0"
,
// More stuff here
"servers"
:
[
{
"url"
:
"/api/v1"
},
{
"url"
:
"https://stag.example.com"
,
"description"
:
"Staging environment"
},
{
"url"
:
"https://prod.example.com"
,
"description"
:
"Production environment"
}
],
"paths"
:
{
// More stuff here
}
}
Tip
Notice the auto-generated server with a
url
value of
/api/v1
, taken from the
root_path
.
In the docs UI at
http://127.0.0.1:9999/api/v1/docs
it would look like:
Tip
The docs UI will interact with the server that you select.
Disable automatic server from
root_path
If you don't want
FastAPI
to include an automatic server using the
root_path
, you can use the parameter
root_path_in_servers=False
:
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
(
servers
=
[
{
"url"
:
"https://stag.example.com"
,
"description"
:
"Staging environment"
},
{
"url"
:
"https://prod.example.com"
,
"description"
:
"Production environment"
},
],
root_path
=
"/api/v1"
,
root_path_in_servers
=
False
,
)
@app
.
get
(
"/app"
)
def
read_main
(
request
:
Request
):
return
{
"message"
:
"Hello World"
,
"root_path"
:
request
.
scope
.
get
(
"root_path"
)}
and then it won't include it in the OpenAPI schema.
Mounting a sub-application
If you need to mount a sub-application (as described in
Sub Applications - Mounts
) while also using a proxy with
root_path
, you can do it normally, as you would expect.
FastAPI will internally use the
root_path
smartly, so it will just work. ✨

## 008_ADVANCED_CUSTOM_RESPONSE
Custom Response - HTML, Stream, File, others¶
---

Custom Response - HTML, Stream, File, others
By default,
FastAPI
will return the responses using
JSONResponse
.
You can override it by returning a
Response
directly as seen in
Return a Response directly
.
But if you return a
Response
directly (or any subclass, like
JSONResponse
), the data won't be automatically converted (even if you declare a
response_model
), and the documentation won't be automatically generated (for example, including the specific "media type", in the HTTP header
Content-Type
as part of the generated OpenAPI).
But you can also declare the
Response
that you want to be used (e.g. any
Response
subclass), in the
path operation decorator
using the
response_class
parameter.
The contents that you return from your
path operation function
will be put inside of that
Response
.
And if that
Response
has a JSON media type (
application/json
), like is the case with the
JSONResponse
and
UJSONResponse
, the data you return will be automatically converted (and filtered) with any Pydantic
response_model
that you declared in the
path operation decorator
.
Note
If you use a response class with no media type, FastAPI will expect your response to have no content, so it will not document the response format in its generated OpenAPI docs.
Use
ORJSONResponse
For example, if you are squeezing performance, you can install and use
orjson
and set the response to be
ORJSONResponse
.
Import the
Response
class (sub-class) you want to use and declare it in the
path operation decorator
.
For large responses, returning a
Response
directly is much faster than returning a dictionary.
This is because by default, FastAPI will inspect every item inside and make sure it is serializable as JSON, using the same
JSON Compatible Encoder
explained in the tutorial. This is what allows you to return
arbitrary objects
, for example database models.
But if you are certain that the content that you are returning is
serializable with JSON
, you can pass it directly to the response class and avoid the extra overhead that FastAPI would have by passing your return content through the
jsonable_encoder
before passing it to the response class.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
ORJSONResponse
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
response_class
=
ORJSONResponse
)
async
def
read_items
():
return
ORJSONResponse
([{
"item_id"
:
"Foo"
}])
Info
The parameter
response_class
will also be used to define the "media type" of the response.
In this case, the HTTP header
Content-Type
will be set to
application/json
.
And it will be documented as such in OpenAPI.
Tip
The
ORJSONResponse
is only available in FastAPI, not in Starlette.
HTML Response
To return a response with HTML directly from
FastAPI
, use
HTMLResponse
.
Import
HTMLResponse
.
Pass
HTMLResponse
as the parameter
response_class
of your
path operation decorator
.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
response_class
=
HTMLResponse
)
async
def
read_items
():
return
"""
<html>
<head>
<title>Some HTML in here</title>
</head>
<body>
<h1>Look ma! HTML!</h1>
</body>
</html>
"""
Info
The parameter
response_class
will also be used to define the "media type" of the response.
In this case, the HTTP header
Content-Type
will be set to
text/html
.
And it will be documented as such in OpenAPI.
Return a
Response
As seen in
Return a Response directly
, you can also override the response directly in your
path operation
, by returning it.
The same example from above, returning an
HTMLResponse
, could look like:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
html_content
=
"""
<html>
<head>
<title>Some HTML in here</title>
</head>
<body>
<h1>Look ma! HTML!</h1>
</body>
</html>
"""
return
HTMLResponse
(
content
=
html_content
,
status_code
=
200
)
Warning
A
Response
returned directly by your
path operation function
won't be documented in OpenAPI (for example, the
Content-Type
won't be documented) and won't be visible in the automatic interactive docs.
Info
Of course, the actual
Content-Type
header, status code, etc, will come from the
Response
object you returned.
Document in OpenAPI and override
Response
If you want to override the response from inside of the function but at the same time document the "media type" in OpenAPI, you can use the
response_class
parameter AND return a
Response
object.
The
response_class
will then be used only to document the OpenAPI
path operation
, but your
Response
will be used as is.
Return an
HTMLResponse
directly
For example, it could be something like:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
def
generate_html_response
():
html_content
=
"""
<html>
<head>
<title>Some HTML in here</title>
</head>
<body>
<h1>Look ma! HTML!</h1>
</body>
</html>
"""
return
HTMLResponse
(
content
=
html_content
,
status_code
=
200
)
@app
.
get
(
"/items/"
,
response_class
=
HTMLResponse
)
async
def
read_items
():
return
generate_html_response
()
In this example, the function
generate_html_response()
already generates and returns a
Response
instead of returning the HTML in a
str
.
By returning the result of calling
generate_html_response()
, you are already returning a
Response
that will override the default
FastAPI
behavior.
But as you passed the
HTMLResponse
in the
response_class
too,
FastAPI
will know how to document it in OpenAPI and the interactive docs as HTML with
text/html
:
Available responses
Here are some of the available responses.
Keep in mind that you can use
Response
to return anything else, or even create a custom sub-class.
Technical Details
You could also use
from starlette.responses import HTMLResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
Response
The main
Response
class, all the other responses inherit from it.
You can return it directly.
It accepts the following parameters:
content
- A
str
or
bytes
.
status_code
- An
int
HTTP status code.
headers
- A
dict
of strings.
media_type
- A
str
giving the media type. E.g.
"text/html"
.
FastAPI (actually Starlette) will automatically include a Content-Length header. It will also include a Content-Type header, based on the
media_type
and appending a charset for text types.
Python 3.8+
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
@app
.
get
(
"/legacy/"
)
def
get_legacy_data
():
data
=
"""<?xml version="1.0"?>
<shampoo>
<Header>
Apply shampoo here.
</Header>
<Body>
You'll have to use soap here.
</Body>
</shampoo>
"""
return
Response
(
content
=
data
,
media_type
=
"application/xml"
)
HTMLResponse
Takes some text or bytes and returns an HTML response, as you read above.
PlainTextResponse
Takes some text or bytes and returns a plain text response.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
PlainTextResponse
app
=
FastAPI
()
@app
.
get
(
"/"
,
response_class
=
PlainTextResponse
)
async
def
main
():
return
"Hello World"
JSONResponse
Takes some data and returns an
application/json
encoded response.
This is the default response used in
FastAPI
, as you read above.
ORJSONResponse
A fast alternative JSON response using
orjson
, as you read above.
Info
This requires installing
orjson
for example with
pip install orjson
.
UJSONResponse
An alternative JSON response using
ujson
.
Info
This requires installing
ujson
for example with
pip install ujson
.
Warning
ujson
is less careful than Python's built-in implementation in how it handles some edge-cases.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
UJSONResponse
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
response_class
=
UJSONResponse
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
Tip
It's possible that
ORJSONResponse
might be a faster alternative.
RedirectResponse
Returns an HTTP redirect. Uses a 307 status code (Temporary Redirect) by default.
You can return a
RedirectResponse
directly:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/typer"
)
async
def
redirect_typer
():
return
RedirectResponse
(
"https://typer.tiangolo.com"
)
Or you can use it in the
response_class
parameter:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/fastapi"
,
response_class
=
RedirectResponse
)
async
def
redirect_fastapi
():
return
"https://fastapi.tiangolo.com"
If you do that, then you can return the URL directly from your
path operation
function.
In this case, the
status_code
used will be the default one for the
RedirectResponse
, which is
307
.
You can also use the
status_code
parameter combined with the
response_class
parameter:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/pydantic"
,
response_class
=
RedirectResponse
,
status_code
=
302
)
async
def
redirect_pydantic
():
return
"https://docs.pydantic.dev/"
StreamingResponse
Takes an async generator or a normal generator/iterator and streams the response body.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
StreamingResponse
app
=
FastAPI
()
async
def
fake_video_streamer
():
for
i
in
range
(
10
):
yield
b
"some fake video bytes"
@app
.
get
(
"/"
)
async
def
main
():
return
StreamingResponse
(
fake_video_streamer
())
Using
StreamingResponse
with file-like objects
If you have a file-like object (e.g. the object returned by
open()
), you can create a generator function to iterate over that file-like object.
That way, you don't have to read it all first in memory, and you can pass that generator function to the
StreamingResponse
, and return it.
This includes many libraries to interact with cloud storage, video processing, and others.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
StreamingResponse
some_file_path
=
"large-video-file.mp4"
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
main
():
def
iterfile
():
## (1)
with
open
(
some_file_path
,
mode
=
"rb"
)
as
file_like
:
## (2)
yield from
file_like
## (3)
return
StreamingResponse
(
iterfile
(),
media_type
=
"video/mp4"
)
This is the generator function. It's a "generator function" because it contains
yield
statements inside.
By using a
with
block, we make sure that the file-like object is closed after the generator function is done. So, after it finishes sending the response.
This
yield from
tells the function to iterate over that thing named
file_like
. And then, for each part iterated, yield that part as coming from this generator function (
iterfile
).
So, it is a generator function that transfers the "generating" work to something else internally.
By doing it this way, we can put it in a
with
block, and that way, ensure that the file-like object is closed after finishing.
Tip
Notice that here as we are using standard
open()
that doesn't support
async
and
await
, we declare the path operation with normal
def
.
FileResponse
Asynchronously streams a file as the response.
Takes a different set of arguments to instantiate than the other response types:
path
- The file path to the file to stream.
headers
- Any custom headers to include, as a dictionary.
media_type
- A string giving the media type. If unset, the filename or path will be used to infer a media type.
filename
- If set, this will be included in the response
Content-Disposition
.
File responses will include appropriate
Content-Length
,
Last-Modified
and
ETag
headers.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
FileResponse
some_file_path
=
"large-video-file.mp4"
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
main
():
return
FileResponse
(
some_file_path
)
You can also use the
response_class
parameter:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
FileResponse
some_file_path
=
"large-video-file.mp4"
app
=
FastAPI
()
@app
.
get
(
"/"
,
response_class
=
FileResponse
)
async
def
main
():
return
some_file_path
In this case, you can return the file path directly from your
path operation
function.
Custom response class
You can create your own custom response class, inheriting from
Response
and using it.
For example, let's say that you want to use
orjson
, but with some custom settings not used in the included
ORJSONResponse
class.
Let's say you want it to return indented and formatted JSON, so you want to use the orjson option
orjson.OPT_INDENT_2
.
You could create a
CustomORJSONResponse
. The main thing you have to do is create a
Response.render(content)
method that returns the content as
bytes
:
Python 3.8+
from
typing
import
Any
import
orjson
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
class
CustomORJSONResponse
(
Response
):
media_type
=
"application/json"
def
render
(
self
,
content
:
Any
)
->
bytes
:
assert
orjson
is
not
None
,
"orjson must be installed"
return
orjson
.
dumps
(
content
,
option
=
orjson
.
OPT_INDENT_2
)
@app
.
get
(
"/"
,
response_class
=
CustomORJSONResponse
)
async
def
main
():
return
{
"message"
:
"Hello World"
}
Now instead of returning:
{
"message"
:
"Hello World"
}
...this response will return:
{
"message"
:
"Hello World"
}
Of course, you will probably find much better ways to take advantage of this than formatting JSON. 😉
Default response class
When creating a
FastAPI
class instance or an
APIRouter
you can specify which response class to use by default.
The parameter that defines this is
default_response_class
.
In the example below,
FastAPI
will use
ORJSONResponse
by default, in all
path operations
, instead of
JSONResponse
.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
ORJSONResponse
app
=
FastAPI
(
default_response_class
=
ORJSONResponse
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
Tip
You can still override
response_class
in
path operations
as before.
Additional documentation
You can also declare the media type and many other details in OpenAPI using
responses
:
Additional Responses in OpenAPI
.

## 009_ADVANCED_DATACLASSES
Using Dataclasses¶
---

Using Dataclasses
FastAPI is built on top of
Pydantic
, and I have been showing you how to use Pydantic models to declare requests and responses.
But FastAPI also supports using
dataclasses
the same way:
Python 3.8+
from
dataclasses
import
dataclass
from
typing
import
Union
from
fastapi
import
FastAPI
@dataclass
class
Item
:
name
:
str
price
:
float
description
:
Union
[
str
,
None
]
=
None
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
This is still supported thanks to
Pydantic
, as it has
internal support for
dataclasses
.
So, even with the code above that doesn't use Pydantic explicitly, FastAPI is using Pydantic to convert those standard dataclasses to Pydantic's own flavor of dataclasses.
And of course, it supports the same:
data validation
data serialization
data documentation, etc.
This works the same way as with Pydantic models. And it is actually achieved in the same way underneath, using Pydantic.
Info
Keep in mind that dataclasses can't do everything Pydantic models can do.
So, you might still need to use Pydantic models.
But if you have a bunch of dataclasses laying around, this is a nice trick to use them to power a web API using FastAPI. 🤓
Dataclasses in
response_model
You can also use
dataclasses
in the
response_model
parameter:
Python 3.8+
from
dataclasses
import
dataclass
,
field
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
@dataclass
class
Item
:
name
:
str
price
:
float
tags
:
List
[
str
]
=
field
(
default_factory
=
list
)
description
:
Union
[
str
,
None
]
=
None
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
get
(
"/items/next"
,
response_model
=
Item
)
async
def
read_next_item
():
return
{
"name"
:
"Island In The Moon"
,
"price"
:
12.99
,
"description"
:
"A place to be playin' and havin' fun"
,
"tags"
:
[
"breater"
],
}
The dataclass will be automatically converted to a Pydantic dataclass.
This way, its schema will show up in the API docs user interface:
Dataclasses in Nested Data Structures
You can also combine
dataclasses
with other type annotations to make nested data structures.
In some cases, you might still have to use Pydantic's version of
dataclasses
. For example, if you have errors with the automatically generated API documentation.
In that case, you can simply swap the standard
dataclasses
with
pydantic.dataclasses
, which is a drop-in replacement:
Python 3.8+
from
dataclasses
import
field
## (1)
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic.dataclasses
import
dataclass
## (2)
@dataclass
class
Item
:
name
:
str
description
:
Union
[
str
,
None
]
=
None
@dataclass
class
Author
:
name
:
str
items
:
List
[
Item
]
=
field
(
default_factory
=
list
)
## (3)
app
=
FastAPI
()
@app
.
post
(
"/authors/
{author_id}
/items/"
,
response_model
=
Author
)
## (4)
async
def
create_author_items
(
author_id
:
str
,
items
:
List
[
Item
]):
## (5)
return
{
"name"
:
author_id
,
"items"
:
items
}
## (6)
@app
.
get
(
"/authors/"
,
response_model
=
List
[
Author
])
## (7)
def
get_authors
():
## (8)
return
[
## (9)
{
"name"
:
"Breaters"
,
"items"
:
[
{
"name"
:
"Island In The Moon"
,
"description"
:
"A place to be playin' and havin' fun"
,
},
{
"name"
:
"Holy Buddies"
},
],
},
{
"name"
:
"System of an Up"
,
"items"
:
[
{
"name"
:
"Salt"
,
"description"
:
"The kombucha mushroom people's favorite"
,
},
{
"name"
:
"Pad Thai"
},
{
"name"
:
"Lonely Night"
,
"description"
:
"The mostests lonliest nightiest of allest"
,
},
],
},
]
We still import
field
from standard
dataclasses
.
pydantic.dataclasses
is a drop-in replacement for
dataclasses
.
The
Author
dataclass includes a list of
Item
dataclasses.
The
Author
dataclass is used as the
response_model
parameter.
You can use other standard type annotations with dataclasses as the request body.
In this case, it's a list of
Item
dataclasses.
Here we are returning a dictionary that contains
items
which is a list of dataclasses.
FastAPI is still capable of
serializing
the data to JSON.
Here the
response_model
is using a type annotation of a list of
Author
dataclasses.
Again, you can combine
dataclasses
with standard type annotations.
Notice that this
path operation function
uses regular
def
instead of
async def
.
As always, in FastAPI you can combine
def
and
async def
as needed.
If you need a refresher about when to use which, check out the section
"In a hurry?"
in the docs about
async
and
await
.
This
path operation function
is not returning dataclasses (although it could), but a list of dictionaries with internal data.
FastAPI will use the
response_model
parameter (that includes dataclasses) to convert the response.
You can combine
dataclasses
with other type annotations in many different combinations to form complex data structures.
Check the in-code annotation tips above to see more specific details.
Learn More
You can also combine
dataclasses
with other Pydantic models, inherit from them, include them in your own models, etc.
To learn more, check the
Pydantic docs about dataclasses
.
Version
This is available since FastAPI version
0.67.0
. 🔖

## 010_ADVANCED_EVENTS
Lifespan Events¶
---

Lifespan Events
You can define logic (code) that should be executed before the application
starts up
. This means that this code will be executed
once
,
before
the application
starts receiving requests
.
The same way, you can define logic (code) that should be executed when the application is
shutting down
. In this case, this code will be executed
once
,
after
having handled possibly
many requests
.
Because this code is executed before the application
starts
taking requests, and right after it
finishes
handling requests, it covers the whole application
lifespan
(the word "lifespan" will be important in a second 😉).
This can be very useful for setting up
resources
that you need to use for the whole app, and that are
shared
among requests, and/or that you need to
clean up
afterwards. For example, a database connection pool, or loading a shared machine learning model.
Use Case
Let's start with an example
use case
and then see how to solve it with this.
Let's imagine that you have some
machine learning models
that you want to use to handle requests. 🤖
The same models are shared among requests, so, it's not one model per request, or one per user or something similar.
Let's imagine that loading the model can
take quite some time
, because it has to read a lot of
data from disk
. So you don't want to do it for every request.
You could load it at the top level of the module/file, but that would also mean that it would
load the model
even if you are just running a simple automated test, then that test would be
slow
because it would have to wait for the model to load before being able to run an independent part of the code.
That's what we'll solve, let's load the model before the requests are handled, but only right before the application starts receiving requests, not while the code is being loaded.
Lifespan
You can define this
startup
and
shutdown
logic using the
lifespan
parameter of the
FastAPI
app, and a "context manager" (I'll show you what that is in a second).
Let's start with an example and then see it in detail.
We create an async function
lifespan()
with
yield
like this:
Python 3.8+
from
contextlib
import
asynccontextmanager
from
fastapi
import
FastAPI
def
fake_answer_to_everything_ml_model
(
x
:
float
):
return
x
*
42
ml_models
=
{}
@asynccontextmanager
async
def
lifespan
(
app
:
FastAPI
):
## Load the ML model
ml_models
[
"answer_to_everything"
]
=
fake_answer_to_everything_ml_model
yield
## Clean up the ML models and release the resources
ml_models
.
clear
()
app
=
FastAPI
(
lifespan
=
lifespan
)
@app
.
get
(
"/predict"
)
async
def
predict
(
x
:
float
):
result
=
ml_models
[
"answer_to_everything"
](
x
)
return
{
"result"
:
result
}
Here we are simulating the expensive
startup
operation of loading the model by putting the (fake) model function in the dictionary with machine learning models before the
yield
. This code will be executed
before
the application
starts taking requests
, during the
startup
.
And then, right after the
yield
, we unload the model. This code will be executed
after
the application
finishes handling requests
, right before the
shutdown
. This could, for example, release resources like memory or a GPU.
Tip
The
shutdown
would happen when you are
stopping
the application.
Maybe you need to start a new version, or you just got tired of running it. 🤷
Lifespan function
The first thing to notice, is that we are defining an async function with
yield
. This is very similar to Dependencies with
yield
.
Python 3.8+
from
contextlib
import
asynccontextmanager
from
fastapi
import
FastAPI
def
fake_answer_to_everything_ml_model
(
x
:
float
):
return
x
*
42
ml_models
=
{}
@asynccontextmanager
async
def
lifespan
(
app
:
FastAPI
):
## Load the ML model
ml_models
[
"answer_to_everything"
]
=
fake_answer_to_everything_ml_model
yield
## Clean up the ML models and release the resources
ml_models
.
clear
()
app
=
FastAPI
(
lifespan
=
lifespan
)
@app
.
get
(
"/predict"
)
async
def
predict
(
x
:
float
):
result
=
ml_models
[
"answer_to_everything"
](
x
)
return
{
"result"
:
result
}
The first part of the function, before the
yield
, will be executed
before
the application starts.
And the part after the
yield
will be executed
after
the application has finished.
Async Context Manager
If you check, the function is decorated with an
@asynccontextmanager
.
That converts the function into something called an "
async context manager
".
Python 3.8+
from
contextlib
import
asynccontextmanager
from
fastapi
import
FastAPI
def
fake_answer_to_everything_ml_model
(
x
:
float
):
return
x
*
42
ml_models
=
{}
@asynccontextmanager
async
def
lifespan
(
app
:
FastAPI
):
## Load the ML model
ml_models
[
"answer_to_everything"
]
=
fake_answer_to_everything_ml_model
yield
## Clean up the ML models and release the resources
ml_models
.
clear
()
app
=
FastAPI
(
lifespan
=
lifespan
)
@app
.
get
(
"/predict"
)
async
def
predict
(
x
:
float
):
result
=
ml_models
[
"answer_to_everything"
](
x
)
return
{
"result"
:
result
}
A
context manager
in Python is something that you can use in a
with
statement, for example,
open()
can be used as a context manager:
with
open
(
"file.txt"
)
as
file
:
file
.
read
()
In recent versions of Python, there's also an
async context manager
. You would use it with
async with
:
async
with
lifespan
(
app
):
await
do_stuff
()
When you create a context manager or an async context manager like above, what it does is that, before entering the
with
block, it will execute the code before the
yield
, and after exiting the
with
block, it will execute the code after the
yield
.
In our code example above, we don't use it directly, but we pass it to FastAPI for it to use it.
The
lifespan
parameter of the
FastAPI
app takes an
async context manager
, so we can pass our new
lifespan
async context manager to it.
Python 3.8+
from
contextlib
import
asynccontextmanager
from
fastapi
import
FastAPI
def
fake_answer_to_everything_ml_model
(
x
:
float
):
return
x
*
42
ml_models
=
{}
@asynccontextmanager
async
def
lifespan
(
app
:
FastAPI
):
## Load the ML model
ml_models
[
"answer_to_everything"
]
=
fake_answer_to_everything_ml_model
yield
## Clean up the ML models and release the resources
ml_models
.
clear
()
app
=
FastAPI
(
lifespan
=
lifespan
)
@app
.
get
(
"/predict"
)
async
def
predict
(
x
:
float
):
result
=
ml_models
[
"answer_to_everything"
](
x
)
return
{
"result"
:
result
}
Alternative Events (deprecated)
Warning
The recommended way to handle the
startup
and
shutdown
is using the
lifespan
parameter of the
FastAPI
app as described above. If you provide a
lifespan
parameter,
startup
and
shutdown
event handlers will no longer be called. It's all
lifespan
or all events, not both.
You can probably skip this part.
There's an alternative way to define this logic to be executed during
startup
and during
shutdown
.
You can define event handlers (functions) that need to be executed before the application starts up, or when the application is shutting down.
These functions can be declared with
async def
or normal
def
.
startup
event
To add a function that should be run before the application starts, declare it with the event
"startup"
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
items
=
{}
@app
.
on_event
(
"startup"
)
async
def
startup_event
():
items
[
"foo"
]
=
{
"name"
:
"Fighters"
}
items
[
"bar"
]
=
{
"name"
:
"Tenders"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
str
):
return
items
[
item_id
]
In this case, the
startup
event handler function will initialize the items "database" (just a
dict
) with some values.
You can add more than one event handler function.
And your application won't start receiving requests until all the
startup
event handlers have completed.
shutdown
event
To add a function that should be run when the application is shutting down, declare it with the event
"shutdown"
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
on_event
(
"shutdown"
)
def
shutdown_event
():
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
"Application shutdown"
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
Here, the
shutdown
event handler function will write a text line
"Application shutdown"
to a file
log.txt
.
Info
In the
open()
function, the
mode="a"
means "append", so, the line will be added after whatever is on that file, without overwriting the previous contents.
Tip
Notice that in this case we are using a standard Python
open()
function that interacts with a file.
So, it involves I/O (input/output), that requires "waiting" for things to be written to disk.
But
open()
doesn't use
async
and
await
.
So, we declare the event handler function with standard
def
instead of
async def
.
startup
and
shutdown
together
There's a high chance that the logic for your
startup
and
shutdown
is connected, you might want to start something and then finish it, acquire a resource and then release it, etc.
Doing that in separated functions that don't share logic or variables together is more difficult as you would need to store values in global variables or similar tricks.
Because of that, it's now recommended to instead use the
lifespan
as explained above.
Technical Details
Just a technical detail for the curious nerds. 🤓
Underneath, in the ASGI technical specification, this is part of the
Lifespan Protocol
, and it defines events called
startup
and
shutdown
.
Info
You can read more about the Starlette
lifespan
handlers in
Starlette's Lifespan' docs
.
Including how to handle lifespan state that can be used in other areas of your code.
Sub Applications
🚨 Keep in mind that these lifespan events (startup and shutdown) will only be executed for the main application, not for
Sub Applications - Mounts
.

## 011_ADVANCED_GENERATE_CLIENTS
Generate Clients¶
---

Generate Clients
As
FastAPI
is based on the OpenAPI specification, you get automatic compatibility with many tools, including the automatic API docs (provided by Swagger UI).
One particular advantage that is not necessarily obvious is that you can
generate clients
(sometimes called
SDKs
) for your API, for many different
programming languages
.
OpenAPI Client Generators
There are many tools to generate clients from
OpenAPI
.
A common tool is
OpenAPI Generator
.
If you are building a
frontend
, a very interesting alternative is
openapi-ts
.
Client and SDK Generators - Sponsor
There are also some
company-backed
Client and SDK generators based on OpenAPI (FastAPI), in some cases they can offer you
additional features
on top of high-quality generated SDKs/clients.
Some of them also ✨
sponsor FastAPI
✨, this ensures the continued and healthy
development
of FastAPI and its
ecosystem
.
And it shows their true commitment to FastAPI and its
community
(you), as they not only want to provide you a
good service
but also want to make sure you have a
good and healthy framework
, FastAPI. 🙇
For example, you might want to try:
Speakeasy
Stainless
liblab
There are also several other companies offering similar services that you can search and find online. 🤓
Generate a TypeScript Frontend Client
Let's start with a simple FastAPI application:
Python 3.9+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
)
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"item received"
}
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
🤓 Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
)
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"item received"
}
@app
.
get
(
"/items/"
,
response_model
=
List
[
Item
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
Notice that the
path operations
define the models they use for request payload and response payload, using the models
Item
and
ResponseMessage
.
API Docs
If you go to the API docs, you will see that it has the
schemas
for the data to be sent in requests and received in responses:
You can see those schemas because they were declared with the models in the app.
That information is available in the app's
OpenAPI schema
, and then shown in the API docs (by Swagger UI).
And that same information from the models that is included in OpenAPI is what can be used to
generate the client code
.
Generate a TypeScript Client
Now that we have the app with the models, we can generate the client code for the frontend.
Install
openapi-ts
You can install
openapi-ts
in your frontend code with:
fast →
npm install @hey-api/openapi-ts --save-dev
restart ↻
Generate Client Code
To generate the client code you can use the command line application
openapi-ts
that would now be installed.
Because it is installed in the local project, you probably wouldn't be able to call that command directly, but you would put it on your
package.json
file.
It could look like this:
{
"name"
:
"frontend-app"
,
"version"
:
"1.0.0"
,
"description"
:
""
,
"main"
:
"index.js"
,
"scripts"
:
{
"generate-client"
:
"openapi-ts --input http://localhost:8000/openapi.json --output ./src/client --client axios"
},
"author"
:
""
,
"license"
:
""
,
"devDependencies"
:
{
"@hey-api/openapi-ts"
:
"^0.27.38"
,
"typescript"
:
"^4.6.2"
}
}
After having that NPM
generate-client
script there, you can run it with:
fast →
npm run generate-client
frontend-app@1.0.0 generate-client /home/user/code/frontend-app
> openapi-ts --input http://localhost:8000/openapi.json --output ./src/client --client axios
restart ↻
That command will generate code in
./src/client
and will use
axios
(the frontend HTTP library) internally.
Try Out the Client Code
Now you can import and use the client code, it could look like this, notice that you get autocompletion for the methods:
You will also get autocompletion for the payload to send:
Tip
Notice the autocompletion for
name
and
price
, that was defined in the FastAPI application, in the
Item
model.
You will have inline errors for the data that you send:
The response object will also have autocompletion:
FastAPI App with Tags
In many cases your FastAPI app will be bigger, and you will probably use tags to separate different groups of
path operations
.
For example, you could have a section for
items
and another section for
users
, and they could be separated by tags:
Python 3.9+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
class
User
(
BaseModel
):
username
:
str
email
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item received"
}
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
],
tags
=
[
"items"
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
@app
.
post
(
"/users/"
,
response_model
=
ResponseMessage
,
tags
=
[
"users"
])
async
def
create_user
(
user
:
User
):
return
{
"message"
:
"User received"
}
🤓 Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
class
User
(
BaseModel
):
username
:
str
email
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item received"
}
@app
.
get
(
"/items/"
,
response_model
=
List
[
Item
],
tags
=
[
"items"
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
@app
.
post
(
"/users/"
,
response_model
=
ResponseMessage
,
tags
=
[
"users"
])
async
def
create_user
(
user
:
User
):
return
{
"message"
:
"User received"
}
Generate a TypeScript Client with Tags
If you generate a client for a FastAPI app using tags, it will normally also separate the client code based on the tags.
This way you will be able to have things ordered and grouped correctly for the client code:
In this case you have:
ItemsService
UsersService
Client Method Names
Right now the generated method names like
createItemItemsPost
don't look very clean:
ItemsService
.
createItemItemsPost
({
name
:
"Plumbus"
,
price
:
5
})
...that's because the client generator uses the OpenAPI internal
operation ID
for each
path operation
.
OpenAPI requires that each operation ID is unique across all the
path operations
, so FastAPI uses the
function name
, the
path
, and the
HTTP method/operation
to generate that operation ID, because that way it can make sure that the operation IDs are unique.
But I'll show you how to improve that next. 🤓
Custom Operation IDs and Better Method Names
You can
modify
the way these operation IDs are
generated
to make them simpler and have
simpler method names
in the clients.
In this case you will have to ensure that each operation ID is
unique
in some other way.
For example, you could make sure that each
path operation
has a tag, and then generate the operation ID based on the
tag
and the
path operation
name
(the function name).
Custom Generate Unique ID Function
FastAPI uses a
unique ID
for each
path operation
, it is used for the
operation ID
and also for the names of any needed custom models, for requests or responses.
You can customize that function. It takes an
APIRoute
and outputs a string.
For example, here it is using the first tag (you will probably have only one tag) and the
path operation
name (the function name).
You can then pass that custom function to
FastAPI
as the
generate_unique_id_function
parameter:
Python 3.9+
from
fastapi
import
FastAPI
from
fastapi.routing
import
APIRoute
from
pydantic
import
BaseModel
def
custom_generate_unique_id
(
route
:
APIRoute
):
return
f
"
{
route
.
tags
[
0
]
}
-
{
route
.
name
}
"
app
=
FastAPI
(
generate_unique_id_function
=
custom_generate_unique_id
)
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
class
User
(
BaseModel
):
username
:
str
email
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item received"
}
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
],
tags
=
[
"items"
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
@app
.
post
(
"/users/"
,
response_model
=
ResponseMessage
,
tags
=
[
"users"
])
async
def
create_user
(
user
:
User
):
return
{
"message"
:
"User received"
}
🤓 Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
from
fastapi.routing
import
APIRoute
from
pydantic
import
BaseModel
def
custom_generate_unique_id
(
route
:
APIRoute
):
return
f
"
{
route
.
tags
[
0
]
}
-
{
route
.
name
}
"
app
=
FastAPI
(
generate_unique_id_function
=
custom_generate_unique_id
)
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
class
User
(
BaseModel
):
username
:
str
email
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item received"
}
@app
.
get
(
"/items/"
,
response_model
=
List
[
Item
],
tags
=
[
"items"
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
@app
.
post
(
"/users/"
,
response_model
=
ResponseMessage
,
tags
=
[
"users"
])
async
def
create_user
(
user
:
User
):
return
{
"message"
:
"User received"
}
Generate a TypeScript Client with Custom Operation IDs
Now if you generate the client again, you will see that it has the improved method names:
As you see, the method names now have the tag and then the function name, now they don't include information from the URL path and the HTTP operation.
Preprocess the OpenAPI Specification for the Client Generator
The generated code still has some
duplicated information
.
We already know that this method is related to the
items
because that word is in the
ItemsService
(taken from the tag), but we still have the tag name prefixed in the method name too. 😕
We will probably still want to keep it for OpenAPI in general, as that will ensure that the operation IDs are
unique
.
But for the generated client we could
modify
the OpenAPI operation IDs right before generating the clients, just to make those method names nicer and
cleaner
.
We could download the OpenAPI JSON to a file
openapi.json
and then we could
remove that prefixed tag
with a script like this:
Python 3.8+
Node.js
import
json
from
pathlib
import
Path
file_path
=
Path
(
"./openapi.json"
)
openapi_content
=
json
.
loads
(
file_path
.
read_text
())
for
path_data
in
openapi_content
[
"paths"
]
.
values
():
for
operation
in
path_data
.
values
():
tag
=
operation
[
"tags"
][
0
]
operation_id
=
operation
[
"operationId"
]
to_remove
=
f
"
{
tag
}
-"
new_operation_id
=
operation_id
[
len
(
to_remove
)
:]
operation
[
"operationId"
]
=
new_operation_id
file_path
.
write_text
(
json
.
dumps
(
openapi_content
))
import
*
as
fs
from
'fs'
async
function
modifyOpenAPIFile
(
filePath
)
{
try
{
const
data
=
await
fs
.
promises
.
readFile
(
filePath
)
const
openapiContent
=
JSON
.
parse
(
data
)
const
paths
=
openapiContent
.
paths
for
(
const
pathKey
of
Object
.
keys
(
paths
))
{
const
pathData
=
paths
[
pathKey
]
for
(
const
method
of
Object
.
keys
(
pathData
))
{
const
operation
=
pathData
[
method
]
if
(
operation
.
tags
&&
operation
.
tags
.
length
>
0
)
{
const
tag
=
operation
.
tags
[
0
]
const
operationId
=
operation
.
operationId
const
toRemove
=
`
${
tag
}
-`
if
(
operationId
.
startsWith
(
toRemove
))
{
const
newOperationId
=
operationId
.
substring
(
toRemove
.
length
)
operation
.
operationId
=
newOperationId
}
}
}
}
await
fs
.
promises
.
writeFile
(
filePath
,
JSON
.
stringify
(
openapiContent
,
null
,
2
),
)
console
.
log
(
'File successfully modified'
)
}
catch
(
err
)
{
console
.
error
(
'Error:'
,
err
)
}
}
const
filePath
=
'./openapi.json'
modifyOpenAPIFile
(
filePath
)
With that, the operation IDs would be renamed from things like
items-get_items
to just
get_items
, that way the client generator can generate simpler method names.
Generate a TypeScript Client with the Preprocessed OpenAPI
Now as the end result is in a file
openapi.json
, you would modify the
package.json
to use that local file, for example:
{
"name"
:
"frontend-app"
,
"version"
:
"1.0.0"
,
"description"
:
""
,
"main"
:
"index.js"
,
"scripts"
:
{
"generate-client"
:
"openapi-ts --input ./openapi.json --output ./src/client --client axios"
},
"author"
:
""
,
"license"
:
""
,
"devDependencies"
:
{
"@hey-api/openapi-ts"
:
"^0.27.38"
,
"typescript"
:
"^4.6.2"
}
}
After generating the new client, you would now have
clean method names
, with all the
autocompletion
,
inline errors
, etc:
Benefits
When using the automatically generated clients you would get
autocompletion
for:
Methods.
Request payloads in the body, query parameters, etc.
Response payloads.
You would also have
inline errors
for everything.
And whenever you update the backend code, and
regenerate
the frontend, it would have any new
path operations
available as methods, the old ones removed, and any other change would be reflected on the generated code. 🤓
This also means that if something changed it will be
reflected
on the client code automatically. And if you
build
the client it will error out if you have any
mismatch
in the data used.
So, you would
detect many errors
very early in the development cycle instead of having to wait for the errors to show up to your final users in production and then trying to debug where the problem is. ✨

## 012_ADVANCED_MIDDLEWARE
Advanced Middleware¶
---

Advanced Middleware
In the main tutorial you read how to add
Custom Middleware
to your application.
And then you also read how to handle
CORS with the
CORSMiddleware
.
In this section we'll see how to use other middlewares.
Adding ASGI middlewares
As
FastAPI
is based on Starlette and implements the
ASGI
specification, you can use any ASGI middleware.
A middleware doesn't have to be made for FastAPI or Starlette to work, as long as it follows the ASGI spec.
In general, ASGI middlewares are classes that expect to receive an ASGI app as the first argument.
So, in the documentation for third-party ASGI middlewares they will probably tell you to do something like:
from
unicorn
import
UnicornMiddleware
app
=
SomeASGIApp
()
new_app
=
UnicornMiddleware
(
app
,
some_config
=
"rainbow"
)
But FastAPI (actually Starlette) provides a simpler way to do it that makes sure that the internal middlewares handle server errors and custom exception handlers work properly.
For that, you use
app.add_middleware()
(as in the example for CORS).
from
fastapi
import
FastAPI
from
unicorn
import
UnicornMiddleware
app
=
FastAPI
()
app
.
add_middleware
(
UnicornMiddleware
,
some_config
=
"rainbow"
)
app.add_middleware()
receives a middleware class as the first argument and any additional arguments to be passed to the middleware.
Integrated middlewares
FastAPI
includes several middlewares for common use cases, we'll see next how to use them.
Technical Details
For the next examples, you could also use
from starlette.middleware.something import SomethingMiddleware
.
FastAPI
provides several middlewares in
fastapi.middleware
just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette.
HTTPSRedirectMiddleware
Enforces that all incoming requests must either be
https
or
wss
.
Any incoming request to
http
or
ws
will be redirected to the secure scheme instead.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.middleware.httpsredirect
import
HTTPSRedirectMiddleware
app
=
FastAPI
()
app
.
add_middleware
(
HTTPSRedirectMiddleware
)
@app
.
get
(
"/"
)
async
def
main
():
return
{
"message"
:
"Hello World"
}
TrustedHostMiddleware
Enforces that all incoming requests have a correctly set
Host
header, in order to guard against HTTP Host Header attacks.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.middleware.trustedhost
import
TrustedHostMiddleware
app
=
FastAPI
()
app
.
add_middleware
(
TrustedHostMiddleware
,
allowed_hosts
=
[
"example.com"
,
"*.example.com"
]
)
@app
.
get
(
"/"
)
async
def
main
():
return
{
"message"
:
"Hello World"
}
The following arguments are supported:
allowed_hosts
- A list of domain names that should be allowed as hostnames. Wildcard domains such as
*.example.com
are supported for matching subdomains. To allow any hostname either use
allowed_hosts=["*"]
or omit the middleware.
If an incoming request does not validate correctly then a
400
response will be sent.
GZipMiddleware
Handles GZip responses for any request that includes
"gzip"
in the
Accept-Encoding
header.
The middleware will handle both standard and streaming responses.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.middleware.gzip
import
GZipMiddleware
app
=
FastAPI
()
app
.
add_middleware
(
GZipMiddleware
,
minimum_size
=
1000
,
compresslevel
=
5
)
@app
.
get
(
"/"
)
async
def
main
():
return
"somebigcontent"
The following arguments are supported:
minimum_size
- Do not GZip responses that are smaller than this minimum size in bytes. Defaults to
500
.
compresslevel
- Used during GZip compression. It is an integer ranging from 1 to 9. Defaults to
9
. Lower value results in faster compression but larger file sizes, while higher value results in slower compression but smaller file sizes.
Other middlewares
There are many other ASGI middlewares.
For example:
Uvicorn's
ProxyHeadersMiddleware
MessagePack
To see other available middlewares check
Starlette's Middleware docs
and the
ASGI Awesome List
.

## 013_ADVANCED_OPENAPI_CALLBACKS
OpenAPI Callbacks¶
---

OpenAPI Callbacks
You could create an API with a
path operation
that could trigger a request to an
external API
created by someone else (probably the same developer that would be
using
your API).
The process that happens when your API app calls the
external API
is named a "callback". Because the software that the external developer wrote sends a request to your API and then your API
calls back
, sending a request to an
external API
(that was probably created by the same developer).
In this case, you could want to document how that external API
should
look like. What
path operation
it should have, what body it should expect, what response it should return, etc.
An app with callbacks
Let's see all this with an example.
Imagine you develop an app that allows creating invoices.
These invoices will have an
id
,
title
(optional),
customer
, and
total
.
The user of your API (an external developer) will create an invoice in your API with a POST request.
Then your API will (let's imagine):
Send the invoice to some customer of the external developer.
Collect the money.
Send a notification back to the API user (the external developer).
This will be done by sending a POST request (from
your API
) to some
external API
provided by that external developer (this is the "callback").
The normal
FastAPI
app
Let's first see how the normal API app would look like before adding the callback.
It will have a
path operation
that will receive an
Invoice
body, and a query parameter
callback_url
that will contain the URL for the callback.
This part is pretty normal, most of the code is probably already familiar to you:
Python 3.8+
from
typing
import
Union
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Invoice
(
BaseModel
):
id
:
str
title
:
Union
[
str
,
None
]
=
None
customer
:
str
total
:
float
class
InvoiceEvent
(
BaseModel
):
description
:
str
paid
:
bool
class
InvoiceEventReceived
(
BaseModel
):
ok
:
bool
invoices_callback_router
=
APIRouter
()
@invoices_callback_router
.
post
(
"{$callback_url}/invoices/{$request.body.id}"
,
response_model
=
InvoiceEventReceived
)
def
invoice_notification
(
body
:
InvoiceEvent
):
pass
@app
.
post
(
"/invoices/"
,
callbacks
=
invoices_callback_router
.
routes
)
def
create_invoice
(
invoice
:
Invoice
,
callback_url
:
Union
[
HttpUrl
,
None
]
=
None
):
"""
Create an invoice.
This will (let's imagine) let the API user (some external developer) create an
invoice.
And this path operation will:
* Send the invoice to the client.
* Collect the money from the client.
* Send a notification back to the API user (the external developer), as a callback.
* At this point is that the API will somehow send a POST request to the
external API with the notification of the invoice event
(e.g. "payment successful").
"""
## Send the invoice, collect the money, send the notification (the callback)
return
{
"msg"
:
"Invoice received"
}
Tip
The
callback_url
query parameter uses a Pydantic
Url
type.
The only new thing is the
callbacks=invoices_callback_router.routes
as an argument to the
path operation decorator
. We'll see what that is next.
Documenting the callback
The actual callback code will depend heavily on your own API app.
And it will probably vary a lot from one app to the next.
It could be just one or two lines of code, like:
callback_url
=
"https://example.com/api/v1/invoices/events/"
httpx
.
post
(
callback_url
,
json
=
{
"description"
:
"Invoice paid"
,
"paid"
:
True
})
But possibly the most important part of the callback is making sure that your API user (the external developer) implements the
external API
correctly, according to the data that
your API
is going to send in the request body of the callback, etc.
So, what we will do next is add the code to document how that
external API
should look like to receive the callback from
your API
.
That documentation will show up in the Swagger UI at
/docs
in your API, and it will let external developers know how to build the
external API
.
This example doesn't implement the callback itself (that could be just a line of code), only the documentation part.
Tip
The actual callback is just an HTTP request.
When implementing the callback yourself, you could use something like
HTTPX
or
Requests
.
Write the callback documentation code
This code won't be executed in your app, we only need it to
document
how that
external API
should look like.
But, you already know how to easily create automatic documentation for an API with
FastAPI
.
So we are going to use that same knowledge to document how the
external API
should look like... by creating the
path operation(s)
that the external API should implement (the ones your API will call).
Tip
When writing the code to document a callback, it might be useful to imagine that you are that
external developer
. And that you are currently implementing the
external API
, not
your API
.
Temporarily adopting this point of view (of the
external developer
) can help you feel like it's more obvious where to put the parameters, the Pydantic model for the body, for the response, etc. for that
external API
.
Create a callback
APIRouter
First create a new
APIRouter
that will contain one or more callbacks.
Python 3.8+
from
typing
import
Union
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Invoice
(
BaseModel
):
id
:
str
title
:
Union
[
str
,
None
]
=
None
customer
:
str
total
:
float
class
InvoiceEvent
(
BaseModel
):
description
:
str
paid
:
bool
class
InvoiceEventReceived
(
BaseModel
):
ok
:
bool
invoices_callback_router
=
APIRouter
()
@invoices_callback_router
.
post
(
"{$callback_url}/invoices/{$request.body.id}"
,
response_model
=
InvoiceEventReceived
)
def
invoice_notification
(
body
:
InvoiceEvent
):
pass
@app
.
post
(
"/invoices/"
,
callbacks
=
invoices_callback_router
.
routes
)
def
create_invoice
(
invoice
:
Invoice
,
callback_url
:
Union
[
HttpUrl
,
None
]
=
None
):
"""
Create an invoice.
This will (let's imagine) let the API user (some external developer) create an
invoice.
And this path operation will:
* Send the invoice to the client.
* Collect the money from the client.
* Send a notification back to the API user (the external developer), as a callback.
* At this point is that the API will somehow send a POST request to the
external API with the notification of the invoice event
(e.g. "payment successful").
"""
## Send the invoice, collect the money, send the notification (the callback)
return
{
"msg"
:
"Invoice received"
}
Create the callback
path operation
To create the callback
path operation
use the same
APIRouter
you created above.
It should look just like a normal FastAPI
path operation
:
It should probably have a declaration of the body it should receive, e.g.
body: InvoiceEvent
.
And it could also have a declaration of the response it should return, e.g.
response_model=InvoiceEventReceived
.
Python 3.8+
from
typing
import
Union
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Invoice
(
BaseModel
):
id
:
str
title
:
Union
[
str
,
None
]
=
None
customer
:
str
total
:
float
class
InvoiceEvent
(
BaseModel
):
description
:
str
paid
:
bool
class
InvoiceEventReceived
(
BaseModel
):
ok
:
bool
invoices_callback_router
=
APIRouter
()
@invoices_callback_router
.
post
(
"{$callback_url}/invoices/{$request.body.id}"
,
response_model
=
InvoiceEventReceived
)
def
invoice_notification
(
body
:
InvoiceEvent
):
pass
@app
.
post
(
"/invoices/"
,
callbacks
=
invoices_callback_router
.
routes
)
def
create_invoice
(
invoice
:
Invoice
,
callback_url
:
Union
[
HttpUrl
,
None
]
=
None
):
"""
Create an invoice.
This will (let's imagine) let the API user (some external developer) create an
invoice.
And this path operation will:
* Send the invoice to the client.
* Collect the money from the client.
* Send a notification back to the API user (the external developer), as a callback.
* At this point is that the API will somehow send a POST request to the
external API with the notification of the invoice event
(e.g. "payment successful").
"""
## Send the invoice, collect the money, send the notification (the callback)
return
{
"msg"
:
"Invoice received"
}
There are 2 main differences from a normal
path operation
:
It doesn't need to have any actual code, because your app will never call this code. It's only used to document the
external API
. So, the function could just have
pass
.
The
path
can contain an
OpenAPI 3 expression
(see more below) where it can use variables with parameters and parts of the original request sent to
your API
.
The callback path expression
The callback
path
can have an
OpenAPI 3 expression
that can contain parts of the original request sent to
your API
.
In this case, it's the
str
:
"{$callback_url}/invoices/{$request.body.id}"
So, if your API user (the external developer) sends a request to
your API
to:
https://yourapi.com/invoices/?callback_url=https://www.external.org/events
with a JSON body of:
{
"id"
:
"2expen51ve"
,
"customer"
:
"Mr. Richie Rich"
,
"total"
:
"9999"
}
then
your API
will process the invoice, and at some point later, send a callback request to the
callback_url
(the
external API
):
https://www.external.org/events/invoices/2expen51ve
with a JSON body containing something like:
{
"description"
:
"Payment celebration"
,
"paid"
:
true
}
and it would expect a response from that
external API
with a JSON body like:
{
"ok"
:
true
}
Tip
Notice how the callback URL used contains the URL received as a query parameter in
callback_url
(
https://www.external.org/events
) and also the invoice
id
from inside of the JSON body (
2expen51ve
).
Add the callback router
At this point you have the
callback path operation(s)
needed (the one(s) that the
external developer
should implement in the
external API
) in the callback router you created above.
Now use the parameter
callbacks
in
your API's path operation decorator
to pass the attribute
.routes
(that's actually just a
list
of routes/
path operations
) from that callback router:
Python 3.8+
from
typing
import
Union
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Invoice
(
BaseModel
):
id
:
str
title
:
Union
[
str
,
None
]
=
None
customer
:
str
total
:
float
class
InvoiceEvent
(
BaseModel
):
description
:
str
paid
:
bool
class
InvoiceEventReceived
(
BaseModel
):
ok
:
bool
invoices_callback_router
=
APIRouter
()
@invoices_callback_router
.
post
(
"{$callback_url}/invoices/{$request.body.id}"
,
response_model
=
InvoiceEventReceived
)
def
invoice_notification
(
body
:
InvoiceEvent
):
pass
@app
.
post
(
"/invoices/"
,
callbacks
=
invoices_callback_router
.
routes
)
def
create_invoice
(
invoice
:
Invoice
,
callback_url
:
Union
[
HttpUrl
,
None
]
=
None
):
"""
Create an invoice.
This will (let's imagine) let the API user (some external developer) create an
invoice.
And this path operation will:
* Send the invoice to the client.
* Collect the money from the client.
* Send a notification back to the API user (the external developer), as a callback.
* At this point is that the API will somehow send a POST request to the
external API with the notification of the invoice event
(e.g. "payment successful").
"""
## Send the invoice, collect the money, send the notification (the callback)
return
{
"msg"
:
"Invoice received"
}
Tip
Notice that you are not passing the router itself (
invoices_callback_router
) to
callback=
, but the attribute
.routes
, as in
invoices_callback_router.routes
.
Check the docs
Now you can start your app and go to
http://127.0.0.1:8000/docs
.
You will see your docs including a "Callbacks" section for your
path operation
that shows how the
external API
should look like:

## 014_ADVANCED_OPENAPI_WEBHOOKS
OpenAPI Webhooks¶
---

OpenAPI Webhooks
There are cases where you want to tell your API
users
that your app could call
their
app (sending a request) with some data, normally to
notify
of some type of
event
.
This means that instead of the normal process of your users sending requests to your API, it's
your API
(or your app) that could
send requests to their system
(to their API, their app).
This is normally called a
webhook
.
Webhooks steps
The process normally is that
you define
in your code what is the message that you will send, the
body of the request
.
You also define in some way at which
moments
your app will send those requests or events.
And
your users
define in some way (for example in a web dashboard somewhere) the
URL
where your app should send those requests.
All the
logic
about how to register the URLs for webhooks and the code to actually send those requests is up to you. You write it however you want to in
your own code
.
Documenting webhooks with
FastAPI
and OpenAPI
With
FastAPI
, using OpenAPI, you can define the names of these webhooks, the types of HTTP operations that your app can send (e.g.
POST
,
PUT
, etc.) and the request
bodies
that your app would send.
This can make it a lot easier for your users to
implement their APIs
to receive your
webhook
requests, they might even be able to autogenerate some of their own API code.
Info
Webhooks are available in OpenAPI 3.1.0 and above, supported by FastAPI
0.99.0
and above.
An app with webhooks
When you create a
FastAPI
application, there is a
webhooks
attribute that you can use to define
webhooks
, the same way you would define
path operations
, for example with
@app.webhooks.post()
.
Python 3.8+
from
datetime
import
datetime
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Subscription
(
BaseModel
):
username
:
str
monthly_fee
:
float
start_date
:
datetime
@app
.
webhooks
.
post
(
"new-subscription"
)
def
new_subscription
(
body
:
Subscription
):
"""
When a new user subscribes to your service we'll send you a POST request with this
data to the URL that you register for the event `new-subscription` in the dashboard.
"""
@app
.
get
(
"/users/"
)
def
read_users
():
return
[
"Rick"
,
"Morty"
]
The webhooks that you define will end up in the
OpenAPI
schema and the automatic
docs UI
.
Info
The
app.webhooks
object is actually just an
APIRouter
, the same type you would use when structuring your app with multiple files.
Notice that with webhooks you are actually not declaring a
path
(like
/items/
), the text you pass there is just an
identifier
of the webhook (the name of the event), for example in
@app.webhooks.post("new-subscription")
, the webhook name is
new-subscription
.
This is because it is expected that
your users
would define the actual
URL path
where they want to receive the webhook request in some other way (e.g. a web dashboard).
Check the docs
Now you can start your app and go to
http://127.0.0.1:8000/docs
.
You will see your docs have the normal
path operations
and now also some
webhooks
:

## 015_ADVANCED_PATH_OPERATION_ADVANCED_CONFIGURATION
Path Operation Advanced Configuration¶
---

Path Operation Advanced Configuration
OpenAPI operationId
Warning
If you are not an "expert" in OpenAPI, you probably don't need this.
You can set the OpenAPI
operationId
to be used in your
path operation
with the parameter
operation_id
.
You would have to make sure that it is unique for each operation.
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
operation_id
=
"some_specific_id_you_define"
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
Using the
path operation function
name as the operationId
If you want to use your APIs' function names as
operationId
s, you can iterate over all of them and override each
path operation's
operation_id
using their
APIRoute.name
.
You should do it after adding all your
path operations
.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.routing
import
APIRoute
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
def
use_route_names_as_operation_ids
(
app
:
FastAPI
)
->
None
:
"""
Simplify operation IDs so that generated API clients have simpler function
names.
Should be called only after all routes have been added.
"""
for
route
in
app
.
routes
:
if
isinstance
(
route
,
APIRoute
):
route
.
operation_id
=
route
.
name
## in this case, 'read_items'
use_route_names_as_operation_ids
(
app
)
Tip
If you manually call
app.openapi()
, you should update the
operationId
s before that.
Warning
If you do this, you have to make sure each one of your
path operation functions
has a unique name.
Even if they are in different modules (Python files).
Exclude from OpenAPI
To exclude a
path operation
from the generated OpenAPI schema (and thus, from the automatic documentation systems), use the parameter
include_in_schema
and set it to
False
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
include_in_schema
=
False
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
Advanced description from docstring
You can limit the lines used from the docstring of a
path operation function
for OpenAPI.
Adding an
\f
(an escaped "form feed" character) causes
FastAPI
to truncate the output used for OpenAPI at this point.
It won't show up in the documentation, but other tools (such as Sphinx) will be able to use the rest.
Python 3.8+
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
\f
:param item: User input.
"""
return
item
Additional Responses
You probably have seen how to declare the
response_model
and
status_code
for a
path operation
.
That defines the metadata about the main response of a
path operation
.
You can also declare additional responses with their models, status codes, etc.
There's a whole chapter here in the documentation about it, you can read it at
Additional Responses in OpenAPI
.
OpenAPI Extra
When you declare a
path operation
in your application,
FastAPI
automatically generates the relevant metadata about that
path operation
to be included in the OpenAPI schema.
Technical details
In the OpenAPI specification it is called the
Operation Object
.
It has all the information about the
path operation
and is used to generate the automatic documentation.
It includes the
tags
,
parameters
,
requestBody
,
responses
, etc.
This
path operation
-specific OpenAPI schema is normally generated automatically by
FastAPI
, but you can also extend it.
Tip
This is a low level extension point.
If you only need to declare additional responses, a more convenient way to do it is with
Additional Responses in OpenAPI
.
You can extend the OpenAPI schema for a
path operation
using the parameter
openapi_extra
.
OpenAPI Extensions
This
openapi_extra
can be helpful, for example, to declare
OpenAPI Extensions
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
openapi_extra
=
{
"x-aperture-labs-portal"
:
"blue"
})
async
def
read_items
():
return
[{
"item_id"
:
"portal-gun"
}]
If you open the automatic API docs, your extension will show up at the bottom of the specific
path operation
.
And if you see the resulting OpenAPI (at
/openapi.json
in your API), you will see your extension as part of the specific
path operation
too:
{
"openapi"
:
"3.1.0"
,
"info"
:
{
"title"
:
"FastAPI"
,
"version"
:
"0.1.0"
},
"paths"
:
{
"/items/"
:
{
"get"
:
{
"summary"
:
"Read Items"
,
"operationId"
:
"read_items_items__get"
,
"responses"
:
{
"200"
:
{
"description"
:
"Successful Response"
,
"content"
:
{
"application/json"
:
{
"schema"
:
{}
}
}
}
},
"x-aperture-labs-portal"
:
"blue"
}
}
}
}
Custom OpenAPI
path operation
schema
The dictionary in
openapi_extra
will be deeply merged with the automatically generated OpenAPI schema for the
path operation
.
So, you could add additional data to the automatically generated schema.
For example, you could decide to read and validate the request with your own code, without using the automatic features of FastAPI with Pydantic, but you could still want to define the request in the OpenAPI schema.
You could do that with
openapi_extra
:
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
def
magic_data_reader
(
raw_body
:
bytes
):
return
{
"size"
:
len
(
raw_body
),
"content"
:
{
"name"
:
"Maaaagic"
,
"price"
:
42
,
"description"
:
"Just kiddin', no magic here. ✨"
,
},
}
@app
.
post
(
"/items/"
,
openapi_extra
=
{
"requestBody"
:
{
"content"
:
{
"application/json"
:
{
"schema"
:
{
"required"
:
[
"name"
,
"price"
],
"type"
:
"object"
,
"properties"
:
{
"name"
:
{
"type"
:
"string"
},
"price"
:
{
"type"
:
"number"
},
"description"
:
{
"type"
:
"string"
},
},
}
}
},
"required"
:
True
,
},
},
)
async
def
create_item
(
request
:
Request
):
raw_body
=
await
request
.
body
()
data
=
magic_data_reader
(
raw_body
)
return
data
In this example, we didn't declare any Pydantic model. In fact, the request body is not even
parsed
as JSON, it is read directly as
bytes
, and the function
magic_data_reader()
would be in charge of parsing it in some way.
Nevertheless, we can declare the expected schema for the request body.
Custom OpenAPI content type
Using this same trick, you could use a Pydantic model to define the JSON Schema that is then included in the custom OpenAPI schema section for the
path operation
.
And you could do this even if the data type in the request is not JSON.
For example, in this application we don't use FastAPI's integrated functionality to extract the JSON Schema from Pydantic models nor the automatic validation for JSON. In fact, we are declaring the request content type as YAML, not JSON:
Pydantic v2
Pydantic v1
Python 3.8+
from
typing
import
List
import
yaml
from
fastapi
import
FastAPI
,
HTTPException
,
Request
from
pydantic
import
BaseModel
,
ValidationError
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
tags
:
List
[
str
]
@app
.
post
(
"/items/"
,
openapi_extra
=
{
"requestBody"
:
{
"content"
:
{
"application/x-yaml"
:
{
"schema"
:
Item
.
model_json_schema
()}},
"required"
:
True
,
},
},
)
async
def
create_item
(
request
:
Request
):
raw_body
=
await
request
.
body
()
try
:
data
=
yaml
.
safe_load
(
raw_body
)
except
yaml
.
YAMLError
:
raise
HTTPException
(
status_code
=
422
,
detail
=
"Invalid YAML"
)
try
:
item
=
Item
.
model_validate
(
data
)
except
ValidationError
as
e
:
raise
HTTPException
(
status_code
=
422
,
detail
=
e
.
errors
(
include_url
=
False
))
return
item
Python 3.8+
from
typing
import
List
import
yaml
from
fastapi
import
FastAPI
,
HTTPException
,
Request
from
pydantic
import
BaseModel
,
ValidationError
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
tags
:
List
[
str
]
@app
.
post
(
"/items/"
,
openapi_extra
=
{
"requestBody"
:
{
"content"
:
{
"application/x-yaml"
:
{
"schema"
:
Item
.
schema
()}},
"required"
:
True
,
},
},
)
async
def
create_item
(
request
:
Request
):
raw_body
=
await
request
.
body
()
try
:
data
=
yaml
.
safe_load
(
raw_body
)
except
yaml
.
YAMLError
:
raise
HTTPException
(
status_code
=
422
,
detail
=
"Invalid YAML"
)
try
:
item
=
Item
.
parse_obj
(
data
)
except
ValidationError
as
e
:
raise
HTTPException
(
status_code
=
422
,
detail
=
e
.
errors
())
return
item
Info
In Pydantic version 1 the method to get the JSON Schema for a model was called
Item.schema()
, in Pydantic version 2, the method is called
Item.model_json_schema()
.
Nevertheless, although we are not using the default integrated functionality, we are still using a Pydantic model to manually generate the JSON Schema for the data that we want to receive in YAML.
Then we use the request directly, and extract the body as
bytes
. This means that FastAPI won't even try to parse the request payload as JSON.
And then in our code, we parse that YAML content directly, and then we are again using the same Pydantic model to validate the YAML content:
Pydantic v2
Pydantic v1
Python 3.8+
from
typing
import
List
import
yaml
from
fastapi
import
FastAPI
,
HTTPException
,
Request
from
pydantic
import
BaseModel
,
ValidationError
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
tags
:
List
[
str
]
@app
.
post
(
"/items/"
,
openapi_extra
=
{
"requestBody"
:
{
"content"
:
{
"application/x-yaml"
:
{
"schema"
:
Item
.
model_json_schema
()}},
"required"
:
True
,
},
},
)
async
def
create_item
(
request
:
Request
):
raw_body
=
await
request
.
body
()
try
:
data
=
yaml
.
safe_load
(
raw_body
)
except
yaml
.
YAMLError
:
raise
HTTPException
(
status_code
=
422
,
detail
=
"Invalid YAML"
)
try
:
item
=
Item
.
model_validate
(
data
)
except
ValidationError
as
e
:
raise
HTTPException
(
status_code
=
422
,
detail
=
e
.
errors
(
include_url
=
False
))
return
item
Python 3.8+
from
typing
import
List
import
yaml
from
fastapi
import
FastAPI
,
HTTPException
,
Request
from
pydantic
import
BaseModel
,
ValidationError
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
tags
:
List
[
str
]
@app
.
post
(
"/items/"
,
openapi_extra
=
{
"requestBody"
:
{
"content"
:
{
"application/x-yaml"
:
{
"schema"
:
Item
.
schema
()}},
"required"
:
True
,
},
},
)
async
def
create_item
(
request
:
Request
):
raw_body
=
await
request
.
body
()
try
:
data
=
yaml
.
safe_load
(
raw_body
)
except
yaml
.
YAMLError
:
raise
HTTPException
(
status_code
=
422
,
detail
=
"Invalid YAML"
)
try
:
item
=
Item
.
parse_obj
(
data
)
except
ValidationError
as
e
:
raise
HTTPException
(
status_code
=
422
,
detail
=
e
.
errors
())
return
item
Info
In Pydantic version 1 the method to parse and validate an object was
Item.parse_obj()
, in Pydantic version 2, the method is called
Item.model_validate()
.
Tip
Here we reuse the same Pydantic model.
But the same way, we could have validated it in some other way.

## 016_ADVANCED_RESPONSE_CHANGE_STATUS_CODE
Response - Change Status Code¶
---

Response - Change Status Code
You probably read before that you can set a default
Response Status Code
.
But in some cases you need to return a different status code than the default.
Use case
For example, imagine that you want to return an HTTP status code of "OK"
200
by default.
But if the data didn't exist, you want to create it, and return an HTTP status code of "CREATED"
201
.
But you still want to be able to filter and convert the data you return with a
response_model
.
For those cases, you can use a
Response
parameter.
Use a
Response
parameter
You can declare a parameter of type
Response
in your
path operation function
(as you can do for cookies and headers).
And then you can set the
status_code
in that
temporal
response object.
Python 3.8+
from
fastapi
import
FastAPI
,
Response
,
status
app
=
FastAPI
()
tasks
=
{
"foo"
:
"Listen to the Bar Fighters"
}
@app
.
put
(
"/get-or-create-task/
{task_id}
"
,
status_code
=
200
)
def
get_or_create_task
(
task_id
:
str
,
response
:
Response
):
if
task_id
not
in
tasks
:
tasks
[
task_id
]
=
"This didn't exist before"
response
.
status_code
=
status
.
HTTP_201_CREATED
return
tasks
[
task_id
]
And then you can return any object you need, as you normally would (a
dict
, a database model, etc).
And if you declared a
response_model
, it will still be used to filter and convert the object you returned.
FastAPI
will use that
temporal
response to extract the status code (also cookies and headers), and will put them in the final response that contains the value you returned, filtered by any
response_model
.
You can also declare the
Response
parameter in dependencies, and set the status code in them. But keep in mind that the last one to be set will win.

## 017_ADVANCED_RESPONSE_COOKIES
Response Cookies¶
---

Response Cookies
Use a
Response
parameter
You can declare a parameter of type
Response
in your
path operation function
.
And then you can set cookies in that
temporal
response object.
Python 3.8+
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
@app
.
post
(
"/cookie-and-object/"
)
def
create_cookie
(
response
:
Response
):
response
.
set_cookie
(
key
=
"fakesession"
,
value
=
"fake-cookie-session-value"
)
return
{
"message"
:
"Come to the dark side, we have cookies"
}
And then you can return any object you need, as you normally would (a
dict
, a database model, etc).
And if you declared a
response_model
, it will still be used to filter and convert the object you returned.
FastAPI
will use that
temporal
response to extract the cookies (also headers and status code), and will put them in the final response that contains the value you returned, filtered by any
response_model
.
You can also declare the
Response
parameter in dependencies, and set cookies (and headers) in them.
Return a
Response
directly
You can also create cookies when returning a
Response
directly in your code.
To do that, you can create a response as described in
Return a Response Directly
.
Then set Cookies in it, and then return it:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
@app
.
post
(
"/cookie/"
)
def
create_cookie
():
content
=
{
"message"
:
"Come to the dark side, we have cookies"
}
response
=
JSONResponse
(
content
=
content
)
response
.
set_cookie
(
key
=
"fakesession"
,
value
=
"fake-cookie-session-value"
)
return
response
Tip
Keep in mind that if you return a response directly instead of using the
Response
parameter, FastAPI will return it directly.
So, you will have to make sure your data is of the correct type. E.g. it is compatible with JSON, if you are returning a
JSONResponse
.
And also that you are not sending any data that should have been filtered by a
response_model
.
More info
Technical Details
You could also use
from starlette.responses import Response
or
from starlette.responses import JSONResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
And as the
Response
can be used frequently to set headers and cookies,
FastAPI
also provides it at
fastapi.Response
.
To see all the available parameters and options, check the
documentation in Starlette
.

## 018_ADVANCED_RESPONSE_DIRECTLY
Return a Response Directly¶
---

Return a Response Directly
When you create a
FastAPI
path operation
you can normally return any data from it: a
dict
, a
list
, a Pydantic model, a database model, etc.
By default,
FastAPI
would automatically convert that return value to JSON using the
jsonable_encoder
explained in
JSON Compatible Encoder
.
Then, behind the scenes, it would put that JSON-compatible data (e.g. a
dict
) inside of a
JSONResponse
that would be used to send the response to the client.
But you can return a
JSONResponse
directly from your
path operations
.
It might be useful, for example, to return custom headers or cookies.
Return a
Response
In fact, you can return any
Response
or any sub-class of it.
Tip
JSONResponse
itself is a sub-class of
Response
.
And when you return a
Response
,
FastAPI
will pass it directly.
It won't do any data conversion with Pydantic models, it won't convert the contents to any type, etc.
This gives you a lot of flexibility. You can return any data type, override any data declaration or validation, etc.
Using the
jsonable_encoder
in a
Response
Because
FastAPI
doesn't make any changes to a
Response
you return, you have to make sure its contents are ready for it.
For example, you cannot put a Pydantic model in a
JSONResponse
without first converting it to a
dict
with all the data types (like
datetime
,
UUID
, etc) converted to JSON-compatible types.
For those cases, you can use the
jsonable_encoder
to convert your data before passing it to a response:
Python 3.8+
from
datetime
import
datetime
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
fastapi.responses
import
JSONResponse
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
title
:
str
timestamp
:
datetime
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{id}
"
)
def
update_item
(
id
:
str
,
item
:
Item
):
json_compatible_item_data
=
jsonable_encoder
(
item
)
return
JSONResponse
(
content
=
json_compatible_item_data
)
Technical Details
You could also use
from starlette.responses import JSONResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
Returning a custom
Response
The example above shows all the parts you need, but it's not very useful yet, as you could have just returned the
item
directly, and
FastAPI
would put it in a
JSONResponse
for you, converting it to a
dict
, etc. All that by default.
Now, let's see how you could use that to return a custom response.
Let's say that you want to return an
XML
response.
You could put your XML content in a string, put that in a
Response
, and return it:
Python 3.8+
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
@app
.
get
(
"/legacy/"
)
def
get_legacy_data
():
data
=
"""<?xml version="1.0"?>
<shampoo>
<Header>
Apply shampoo here.
</Header>
<Body>
You'll have to use soap here.
</Body>
</shampoo>
"""
return
Response
(
content
=
data
,
media_type
=
"application/xml"
)
Notes
When you return a
Response
directly its data is not validated, converted (serialized), or documented automatically.
But you can still document it as described in
Additional Responses in OpenAPI
.
You can see in later sections how to use/declare these custom
Response
s while still having automatic data conversion, documentation, etc.

## 019_ADVANCED_RESPONSE_HEADERS
Response Headers¶
---

Response Headers
Use a
Response
parameter
You can declare a parameter of type
Response
in your
path operation function
(as you can do for cookies).
And then you can set headers in that
temporal
response object.
Python 3.8+
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
@app
.
get
(
"/headers-and-object/"
)
def
get_headers
(
response
:
Response
):
response
.
headers
[
"X-Cat-Dog"
]
=
"alone in the world"
return
{
"message"
:
"Hello World"
}
And then you can return any object you need, as you normally would (a
dict
, a database model, etc).
And if you declared a
response_model
, it will still be used to filter and convert the object you returned.
FastAPI
will use that
temporal
response to extract the headers (also cookies and status code), and will put them in the final response that contains the value you returned, filtered by any
response_model
.
You can also declare the
Response
parameter in dependencies, and set headers (and cookies) in them.
Return a
Response
directly
You can also add headers when you return a
Response
directly.
Create a response as described in
Return a Response Directly
and pass the headers as an additional parameter:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
@app
.
get
(
"/headers/"
)
def
get_headers
():
content
=
{
"message"
:
"Hello World"
}
headers
=
{
"X-Cat-Dog"
:
"alone in the world"
,
"Content-Language"
:
"en-US"
}
return
JSONResponse
(
content
=
content
,
headers
=
headers
)
Technical Details
You could also use
from starlette.responses import Response
or
from starlette.responses import JSONResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
And as the
Response
can be used frequently to set headers and cookies,
FastAPI
also provides it at
fastapi.Response
.
Custom Headers
Keep in mind that custom proprietary headers can be added
using the 'X-' prefix
.
But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (read more in
CORS (Cross-Origin Resource Sharing)
), using the parameter
expose_headers
documented in
Starlette's CORS docs
.

## 020_ADVANCED_SECURITY
Advanced Security¶
---

Advanced Security
Additional Features
There are some extra features to handle security apart from the ones covered in the
Tutorial - User Guide: Security
.
Tip
The next sections are
not necessarily "advanced"
.
And it's possible that for your use case, the solution is in one of them.
Read the Tutorial first
The next sections assume you already read the main
Tutorial - User Guide: Security
.
They are all based on the same concepts, but allow some extra functionalities.

## 021_ADVANCED_SECURITY_HTTP_BASIC_AUTH
HTTP Basic Auth¶
---

HTTP Basic Auth
For the simplest cases, you can use HTTP Basic Auth.
In HTTP Basic Auth, the application expects a header that contains a username and a password.
If it doesn't receive it, it returns an HTTP 401 "Unauthorized" error.
And returns a header
WWW-Authenticate
with a value of
Basic
, and an optional
realm
parameter.
That tells the browser to show the integrated prompt for a username and password.
Then, when you type that username and password, the browser sends them in the header automatically.
Simple HTTP Basic Auth
Import
HTTPBasic
and
HTTPBasicCredentials
.
Create a "
security
scheme" using
HTTPBasic
.
Use that
security
with a dependency in your
path operation
.
It returns an object of type
HTTPBasicCredentials
:
It contains the
username
and
password
sent.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)]):
return
{
"username"
:
credentials
.
username
,
"password"
:
credentials
.
password
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
from
typing_extensions
import
Annotated
app
=
FastAPI
()
security
=
HTTPBasic
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)]):
return
{
"username"
:
credentials
.
username
,
"password"
:
credentials
.
password
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
HTTPBasicCredentials
=
Depends
(
security
)):
return
{
"username"
:
credentials
.
username
,
"password"
:
credentials
.
password
}
When you try to open the URL for the first time (or click the "Execute" button in the docs) the browser will ask you for your username and password:
Check the username
Here's a more complete example.
Use a dependency to check if the username and password are correct.
For this, use the Python standard module
secrets
to check the username and password.
secrets.compare_digest()
needs to take
bytes
or a
str
that only contains ASCII characters (the ones in English), this means it wouldn't work with characters like
á
, as in
Sebastián
.
To handle that, we first convert the
username
and
password
to
bytes
encoding them with UTF-8.
Then we can use
secrets.compare_digest()
to ensure that
credentials.username
is
"stanleyjobson"
, and that
credentials.password
is
"swordfish"
.
Python 3.9+
import
secrets
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)],
):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
Annotated
[
str
,
Depends
(
get_current_username
)]):
return
{
"username"
:
username
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
import
secrets
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
from
typing_extensions
import
Annotated
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)],
):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
Annotated
[
str
,
Depends
(
get_current_username
)]):
return
{
"username"
:
username
}
Tip
Prefer to use the
Annotated
version if possible.
import
secrets
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
HTTPBasicCredentials
=
Depends
(
security
)):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
str
=
Depends
(
get_current_username
)):
return
{
"username"
:
username
}
This would be similar to:
if
not
(
credentials
.
username
==
"stanleyjobson"
)
or
not
(
credentials
.
password
==
"swordfish"
):
## Return some error
...
But by using the
secrets.compare_digest()
it will be secure against a type of attacks called "timing attacks".
Timing Attacks
But what's a "timing attack"?
Let's imagine some attackers are trying to guess the username and password.
And they send a request with a username
johndoe
and a password
love123
.
Then the Python code in your application would be equivalent to something like:
if
"johndoe"
==
"stanleyjobson"
and
"love123"
==
"swordfish"
:
...
But right at the moment Python compares the first
j
in
johndoe
to the first
s
in
stanleyjobson
, it will return
False
, because it already knows that those two strings are not the same, thinking that "there's no need to waste more computation comparing the rest of the letters". And your application will say "Incorrect username or password".
But then the attackers try with username
stanleyjobsox
and password
love123
.
And your application code does something like:
if
"stanleyjobsox"
==
"stanleyjobson"
and
"love123"
==
"swordfish"
:
...
Python will have to compare the whole
stanleyjobso
in both
stanleyjobsox
and
stanleyjobson
before realizing that both strings are not the same. So it will take some extra microseconds to reply back "Incorrect username or password".
The time to answer helps the attackers
At that point, by noticing that the server took some microseconds longer to send the "Incorrect username or password" response, the attackers will know that they got
something
right, some of the initial letters were right.
And then they can try again knowing that it's probably something more similar to
stanleyjobsox
than to
johndoe
.
A "professional" attack
Of course, the attackers would not try all this by hand, they would write a program to do it, possibly with thousands or millions of tests per second. And they would get just one extra correct letter at a time.
But doing that, in some minutes or hours the attackers would have guessed the correct username and password, with the "help" of our application, just using the time taken to answer.
Fix it with
secrets.compare_digest()
But in our code we are actually using
secrets.compare_digest()
.
In short, it will take the same time to compare
stanleyjobsox
to
stanleyjobson
than it takes to compare
johndoe
to
stanleyjobson
. And the same for the password.
That way, using
secrets.compare_digest()
in your application code, it will be safe against this whole range of security attacks.
Return the error
After detecting that the credentials are incorrect, return an
HTTPException
with a status code 401 (the same returned when no credentials are provided) and add the header
WWW-Authenticate
to make the browser show the login prompt again:
Python 3.9+
import
secrets
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)],
):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
Annotated
[
str
,
Depends
(
get_current_username
)]):
return
{
"username"
:
username
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
import
secrets
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
from
typing_extensions
import
Annotated
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)],
):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
Annotated
[
str
,
Depends
(
get_current_username
)]):
return
{
"username"
:
username
}
Tip
Prefer to use the
Annotated
version if possible.
import
secrets
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
HTTPBasicCredentials
=
Depends
(
security
)):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
str
=
Depends
(
get_current_username
)):
return
{
"username"
:
username
}

## 022_ADVANCED_SECURITY_OAUTH2_SCOPES
OAuth2 scopes¶
---

OAuth2 scopes
You can use OAuth2 scopes directly with
FastAPI
, they are integrated to work seamlessly.
This would allow you to have a more fine-grained permission system, following the OAuth2 standard, integrated into your OpenAPI application (and the API docs).
OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. They use it to provide specific permissions to users and applications.
Every time you "log in with" Facebook, Google, GitHub, Microsoft, Twitter, that application is using OAuth2 with scopes.
In this section you will see how to manage authentication and authorization with the same OAuth2 with scopes in your
FastAPI
application.
Warning
This is a more or less advanced section. If you are just starting, you can skip it.
You don't necessarily need OAuth2 scopes, and you can handle authentication and authorization however you want.
But OAuth2 with scopes can be nicely integrated into your API (with OpenAPI) and your API docs.
Nevertheless, you still enforce those scopes, or any other security/authorization requirement, however you need, in your code.
In many cases, OAuth2 with scopes can be an overkill.
But if you know you need it, or you are curious, keep reading.
OAuth2 scopes and OpenAPI
The OAuth2 specification defines "scopes" as a list of strings separated by spaces.
The content of each of these strings can have any format, but should not contain spaces.
These scopes represent "permissions".
In OpenAPI (e.g. the API docs), you can define "security schemes".
When one of these security schemes uses OAuth2, you can also declare and use scopes.
Each "scope" is just a string (without spaces).
They are normally used to declare specific security permissions, for example:
users:read
or
users:write
are common examples.
instagram_basic
is used by Facebook / Instagram.
https://www.googleapis.com/auth/drive
is used by Google.
Info
In OAuth2 a "scope" is just a string that declares a specific permission required.
It doesn't matter if it has other characters like
:
or if it is a URL.
Those details are implementation specific.
For OAuth2 they are just strings.
Global view
First, let's quickly see the parts that change from the examples in the main
Tutorial - User Guide
for
OAuth2 with Password (and hashing), Bearer with JWT tokens
. Now using OAuth2 scopes:
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Now let's review those changes step by step.
OAuth2 Security scheme
The first change is that now we are declaring the OAuth2 security scheme with two available scopes,
me
and
items
.
The
scopes
parameter receives a
dict
with each scope as a key and the description as the value:
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Because we are now declaring those scopes, they will show up in the API docs when you log-in/authorize.
And you will be able to select which scopes you want to give access to:
me
and
items
.
This is the same mechanism used when you give permissions while logging in with Facebook, Google, GitHub, etc:
JWT token with scopes
Now, modify the token
path operation
to return the scopes requested.
We are still using the same
OAuth2PasswordRequestForm
. It includes a property
scopes
with a
list
of
str
, with each scope it received in the request.
And we return the scopes as part of the JWT token.
Danger
For simplicity, here we are just adding the scopes received directly to the token.
But in your application, for security, you should make sure you only add the scopes that the user is actually able to have, or the ones you have predefined.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Declare scopes in
path operations
and dependencies
Now we declare that the
path operation
for
/users/me/items/
requires the scope
items
.
For this, we import and use
Security
from
fastapi
.
You can use
Security
to declare dependencies (just like
Depends
), but
Security
also receives a parameter
scopes
with a list of scopes (strings).
In this case, we pass a dependency function
get_current_active_user
to
Security
(the same way we would do with
Depends
).
But we also pass a
list
of scopes, in this case with just one scope:
items
(it could have more).
And the dependency function
get_current_active_user
can also declare sub-dependencies, not only with
Depends
but also with
Security
. Declaring its own sub-dependency function (
get_current_user
), and more scope requirements.
In this case, it requires the scope
me
(it could require more than one scope).
Note
You don't necessarily need to add different scopes in different places.
We are doing it here to demonstrate how
FastAPI
handles scopes declared at different levels.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Technical Details
Security
is actually a subclass of
Depends
, and it has just one extra parameter that we'll see later.
But by using
Security
instead of
Depends
,
FastAPI
will know that it can declare security scopes, use them internally, and document the API with OpenAPI.
But when you import
Query
,
Path
,
Depends
,
Security
and others from
fastapi
, those are actually functions that return special classes.
Use
SecurityScopes
Now update the dependency
get_current_user
.
This is the one used by the dependencies above.
Here's where we are using the same OAuth2 scheme we created before, declaring it as a dependency:
oauth2_scheme
.
Because this dependency function doesn't have any scope requirements itself, we can use
Depends
with
oauth2_scheme
, we don't have to use
Security
when we don't need to specify security scopes.
We also declare a special parameter of type
SecurityScopes
, imported from
fastapi.security
.
This
SecurityScopes
class is similar to
Request
(
Request
was used to get the request object directly).
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Use the
scopes
The parameter
security_scopes
will be of type
SecurityScopes
.
It will have a property
scopes
with a list containing all the scopes required by itself and all the dependencies that use this as a sub-dependency. That means, all the "dependants"... this might sound confusing, it is explained again later below.
The
security_scopes
object (of class
SecurityScopes
) also provides a
scope_str
attribute with a single string, containing those scopes separated by spaces (we are going to use it).
We create an
HTTPException
that we can reuse (
raise
) later at several points.
In this exception, we include the scopes required (if any) as a string separated by spaces (using
scope_str
). We put that string containing the scopes in the
WWW-Authenticate
header (this is part of the spec).
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Verify the
username
and data shape
We verify that we get a
username
, and extract the scopes.
And then we validate that data with the Pydantic model (catching the
ValidationError
exception), and if we get an error reading the JWT token or validating the data with Pydantic, we raise the
HTTPException
we created before.
For that, we update the Pydantic model
TokenData
with a new property
scopes
.
By validating the data with Pydantic we can make sure that we have, for example, exactly a
list
of
str
with the scopes and a
str
with the
username
.
Instead of, for example, a
dict
, or something else, as it could break the application at some point later, making it a security risk.
We also verify that we have a user with that username, and if not, we raise that same exception we created before.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Verify the
scopes
We now verify that all the scopes required, by this dependency and all the dependants (including
path operations
), are included in the scopes provided in the token received, otherwise raise an
HTTPException
.
For this, we use
security_scopes.scopes
, that contains a
list
with all these scopes as
str
.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Dependency tree and scopes
Let's review again this dependency tree and the scopes.
As the
get_current_active_user
dependency has as a sub-dependency on
get_current_user
, the scope
"me"
declared at
get_current_active_user
will be included in the list of required scopes in the
security_scopes.scopes
passed to
get_current_user
.
The
path operation
itself also declares a scope,
"items"
, so this will also be in the list of
security_scopes.scopes
passed to
get_current_user
.
Here's how the hierarchy of dependencies and scopes looks like:
The
path operation
read_own_items
has:
Required scopes
["items"]
with the dependency:
get_current_active_user
:
The dependency function
get_current_active_user
has:
Required scopes
["me"]
with the dependency:
get_current_user
:
The dependency function
get_current_user
has:
No scopes required by itself.
A dependency using
oauth2_scheme
.
A
security_scopes
parameter of type
SecurityScopes
:
This
security_scopes
parameter has a property
scopes
with a
list
containing all these scopes declared above, so:
security_scopes.scopes
will contain
["me", "items"]
for the
path operation
read_own_items
.
security_scopes.scopes
will contain
["me"]
for the
path operation
read_users_me
, because it is declared in the dependency
get_current_active_user
.
security_scopes.scopes
will contain
[]
(nothing) for the
path operation
read_system_status
, because it didn't declare any
Security
with
scopes
, and its dependency,
get_current_user
, doesn't declare any
scopes
either.
Tip
The important and "magic" thing here is that
get_current_user
will have a different list of
scopes
to check for each
path operation
.
All depending on the
scopes
declared in each
path operation
and each dependency in the dependency tree for that specific
path operation
.
More details about
SecurityScopes
You can use
SecurityScopes
at any point, and in multiple places, it doesn't have to be at the "root" dependency.
It will always have the security scopes declared in the current
Security
dependencies and all the dependants for
that specific
path operation
and
that specific
dependency tree.
Because the
SecurityScopes
will have all the scopes declared by dependants, you can use it to verify that a token has the required scopes in a central dependency function, and then declare different scope requirements in different
path operations
.
They will be checked independently for each
path operation
.
Check it
If you open the API docs, you can authenticate and specify which scopes you want to authorize.
If you don't select any scope, you will be "authenticated", but when you try to access
/users/me/
or
/users/me/items/
you will get an error saying that you don't have enough permissions. You will still be able to access
/status/
.
And if you select the scope
me
but not the scope
items
, you will be able to access
/users/me/
but not
/users/me/items/
.
That's what would happen to a third party application that tried to access one of these
path operations
with a token provided by a user, depending on how many permissions the user gave the application.
About third party integrations
In this example we are using the OAuth2 "password" flow.
This is appropriate when we are logging in to our own application, probably with our own frontend.
Because we can trust it to receive the
username
and
password
, as we control it.
But if you are building an OAuth2 application that others would connect to (i.e., if you are building an authentication provider equivalent to Facebook, Google, GitHub, etc.) you should use one of the other flows.
The most common is the implicit flow.
The most secure is the code flow, but it's more complex to implement as it requires more steps. As it is more complex, many providers end up suggesting the implicit flow.
Note
It's common that each authentication provider names their flows in a different way, to make it part of their brand.
But in the end, they are implementing the same OAuth2 standard.
FastAPI
includes utilities for all these OAuth2 authentication flows in
fastapi.security.oauth2
.
Security
in decorator
dependencies
The same way you can define a
list
of
Depends
in the decorator's
dependencies
parameter (as explained in
Dependencies in path operation decorators
), you could also use
Security
with
scopes
there.

## 023_ADVANCED_SETTINGS
Settings and Environment Variables¶
---

Settings and Environment Variables
In many cases your application could need some external settings or configurations, for example secret keys, database credentials, credentials for email services, etc.
Most of these settings are variable (can change), like database URLs. And many could be sensitive, like secrets.
For this reason it's common to provide them in environment variables that are read by the application.
Tip
To understand environment variables you can read
Environment Variables
.
Types and validation
These environment variables can only handle text strings, as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS).
That means that any value read in Python from an environment variable will be a
str
, and any conversion to a different type or any validation has to be done in code.
Pydantic
Settings
Fortunately, Pydantic provides a great utility to handle these settings coming from environment variables with
Pydantic: Settings management
.
Install
pydantic-settings
First, make sure you create your
virtual environment
, activate it, and then install the
pydantic-settings
package:
fast →
pip install pydantic-settings
restart ↻
It also comes included when you install the
all
extras with:
fast →
pip install "fastapi[all]"
restart ↻
Info
In Pydantic v1 it came included with the main package. Now it is distributed as this independent package so that you can choose to install it or not if you don't need that functionality.
Create the
Settings
object
Import
BaseSettings
from Pydantic and create a sub-class, very much like with a Pydantic model.
The same way as with Pydantic models, you declare class attributes with type annotations, and possibly default values.
You can use all the same validation features and tools you use for Pydantic models, like different data types and additional validations with
Field()
.
Pydantic v2
Pydantic v1
Python 3.8+
from
fastapi
import
FastAPI
from
pydantic_settings
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
settings
=
Settings
()
app
=
FastAPI
()
@app
.
get
(
"/info"
)
async
def
info
():
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Info
In Pydantic v1 you would import
BaseSettings
directly from
pydantic
instead of from
pydantic_settings
.
Python 3.8+
from
fastapi
import
FastAPI
from
pydantic
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
settings
=
Settings
()
app
=
FastAPI
()
@app
.
get
(
"/info"
)
async
def
info
():
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Tip
If you want something quick to copy and paste, don't use this example, use the last one below.
Then, when you create an instance of that
Settings
class (in this case, in the
settings
object), Pydantic will read the environment variables in a case-insensitive way, so, an upper-case variable
APP_NAME
will still be read for the attribute
app_name
.
Next it will convert and validate the data. So, when you use that
settings
object, you will have data of the types you declared (e.g.
items_per_user
will be an
int
).
Use the
settings
Then you can use the new
settings
object in your application:
Python 3.8+
from
fastapi
import
FastAPI
from
pydantic_settings
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
settings
=
Settings
()
app
=
FastAPI
()
@app
.
get
(
"/info"
)
async
def
info
():
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Run the server
Next, you would run the server passing the configurations as environment variables, for example you could set an
ADMIN_EMAIL
and
APP_NAME
with:
fast →
ADMIN_EMAIL="deadpool@example.com" APP_NAME="ChimichangApp" fastapi run main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
Tip
To set multiple env vars for a single command just separate them with a space, and put them all before the command.
And then the
admin_email
setting would be set to
"deadpool@example.com"
.
The
app_name
would be
"ChimichangApp"
.
And the
items_per_user
would keep its default value of
50
.
Settings in another module
You could put those settings in another module file as you saw in
Bigger Applications - Multiple Files
.
For example, you could have a file
config.py
with:
Python 3.8+
from
pydantic_settings
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
settings
=
Settings
()
And then use it in a file
main.py
:
Python 3.8+
from
fastapi
import
FastAPI
from
.config
import
settings
app
=
FastAPI
()
@app
.
get
(
"/info"
)
async
def
info
():
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Tip
You would also need a file
__init__.py
as you saw in
Bigger Applications - Multiple Files
.
Settings in a dependency
In some occasions it might be useful to provide the settings from a dependency, instead of having a global object with
settings
that is used everywhere.
This could be especially useful during testing, as it's very easy to override a dependency with your own custom settings.
The config file
Coming from the previous example, your
config.py
file could look like:
Python 3.8+
from
pydantic_settings
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
Notice that now we don't create a default instance
settings = Settings()
.
The main app file
Now we create a dependency that returns a new
config.Settings()
.
Python 3.8+
from
functools
import
lru_cache
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
.config
import
Settings
app
=
FastAPI
()
@lru_cache
def
get_settings
():
return
Settings
()
@app
.
get
(
"/info"
)
async
def
info
(
settings
:
Annotated
[
Settings
,
Depends
(
get_settings
)]):
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Tip
We'll discuss the
@lru_cache
in a bit.
For now you can assume
get_settings()
is a normal function.
And then we can require it from the
path operation function
as a dependency and use it anywhere we need it.
Python 3.8+
from
functools
import
lru_cache
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
.config
import
Settings
app
=
FastAPI
()
@lru_cache
def
get_settings
():
return
Settings
()
@app
.
get
(
"/info"
)
async
def
info
(
settings
:
Annotated
[
Settings
,
Depends
(
get_settings
)]):
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Settings and testing
Then it would be very easy to provide a different settings object during testing by creating a dependency override for
get_settings
:
Python 3.8+
from
fastapi.testclient
import
TestClient
from
.config
import
Settings
from
.main
import
app
,
get_settings
client
=
TestClient
(
app
)
def
get_settings_override
():
return
Settings
(
admin_email
=
"testing_admin@example.com"
)
app
.
dependency_overrides
[
get_settings
]
=
get_settings_override
def
test_app
():
response
=
client
.
get
(
"/info"
)
data
=
response
.
json
()
assert
data
==
{
"app_name"
:
"Awesome API"
,
"admin_email"
:
"testing_admin@example.com"
,
"items_per_user"
:
50
,
}
In the dependency override we set a new value for the
admin_email
when creating the new
Settings
object, and then we return that new object.
Then we can test that it is used.
Reading a
.env
file
If you have many settings that possibly change a lot, maybe in different environments, it might be useful to put them on a file and then read them from it as if they were environment variables.
This practice is common enough that it has a name, these environment variables are commonly placed in a file
.env
, and the file is called a "dotenv".
Tip
A file starting with a dot (
.
) is a hidden file in Unix-like systems, like Linux and macOS.
But a dotenv file doesn't really have to have that exact filename.
Pydantic has support for reading from these types of files using an external library. You can read more at
Pydantic Settings: Dotenv (.env) support
.
Tip
For this to work, you need to
pip install python-dotenv
.
The
.env
file
You could have a
.env
file with:
ADMIN_EMAIL
=
"deadpool@example.com"
APP_NAME
=
"ChimichangApp"
Read settings from
.env
And then update your
config.py
with:
Pydantic v2
Pydantic v1
Python 3.8+
from
pydantic_settings
import
BaseSettings
,
SettingsConfigDict
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
model_config
=
SettingsConfigDict
(
env_file
=
".env"
)
Tip
The
model_config
attribute is used just for Pydantic configuration. You can read more at
Pydantic: Concepts: Configuration
.
Python 3.8+
from
pydantic
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
class
Config
:
env_file
=
".env"
Tip
The
Config
class is used just for Pydantic configuration. You can read more at
Pydantic Model Config
.
Info
In Pydantic version 1 the configuration was done in an internal class
Config
, in Pydantic version 2 it's done in an attribute
model_config
. This attribute takes a
dict
, and to get autocompletion and inline errors you can import and use
SettingsConfigDict
to define that
dict
.
Here we define the config
env_file
inside of your Pydantic
Settings
class, and set the value to the filename with the dotenv file we want to use.
Creating the
Settings
only once with
lru_cache
Reading a file from disk is normally a costly (slow) operation, so you probably want to do it only once and then reuse the same settings object, instead of reading it for each request.
But every time we do:
Settings
()
a new
Settings
object would be created, and at creation it would read the
.env
file again.
If the dependency function was just like:
def
get_settings
():
return
Settings
()
we would create that object for each request, and we would be reading the
.env
file for each request. ⚠️
But as we are using the
@lru_cache
decorator on top, the
Settings
object will be created only once, the first time it's called. ✔️
Python 3.8+
from
functools
import
lru_cache
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
from
.
import
config
app
=
FastAPI
()
@lru_cache
def
get_settings
():
return
config
.
Settings
()
@app
.
get
(
"/info"
)
async
def
info
(
settings
:
Annotated
[
config
.
Settings
,
Depends
(
get_settings
)]):
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Then for any subsequent call of
get_settings()
in the dependencies for the next requests, instead of executing the internal code of
get_settings()
and creating a new
Settings
object, it will return the same object that was returned on the first call, again and again.
lru_cache
Technical Details
@lru_cache
modifies the function it decorates to return the same value that was returned the first time, instead of computing it again, executing the code of the function every time.
So, the function below it will be executed once for each combination of arguments. And then the values returned by each of those combinations of arguments will be used again and again whenever the function is called with exactly the same combination of arguments.
For example, if you have a function:
@lru_cache
def
say_hi
(
name
:
str
,
salutation
:
str
=
"Ms."
):
return
f
"Hello
{
salutation
}
{
name
}
"
your program could execute like this:
In the case of our dependency
get_settings()
, the function doesn't even take any arguments, so it always returns the same value.
That way, it behaves almost as if it was just a global variable. But as it uses a dependency function, then we can override it easily for testing.
@lru_cache
is part of
functools
which is part of Python's standard library, you can read more about it in the
Python docs for
@lru_cache
.
Recap
You can use Pydantic Settings to handle the settings or configurations for your application, with all the power of Pydantic models.
By using a dependency you can simplify testing.
You can use
.env
files with it.
Using
@lru_cache
lets you avoid reading the dotenv file again and again for each request, while allowing you to override it during testing.

## 024_ADVANCED_SUB_APPLICATIONS
Sub Applications - Mounts¶
---

Sub Applications - Mounts
If you need to have two independent FastAPI applications, with their own independent OpenAPI and their own docs UIs, you can have a main app and "mount" one (or more) sub-application(s).
Mounting a
FastAPI
application
"Mounting" means adding a completely "independent" application in a specific path, that then takes care of handling everything under that path, with the
path operations
declared in that sub-application.
Top-level application
First, create the main, top-level,
FastAPI
application, and its
path operations
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/app"
)
def
read_main
():
return
{
"message"
:
"Hello World from main app"
}
subapi
=
FastAPI
()
@subapi
.
get
(
"/sub"
)
def
read_sub
():
return
{
"message"
:
"Hello World from sub API"
}
app
.
mount
(
"/subapi"
,
subapi
)
Sub-application
Then, create your sub-application, and its
path operations
.
This sub-application is just another standard FastAPI application, but this is the one that will be "mounted":
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/app"
)
def
read_main
():
return
{
"message"
:
"Hello World from main app"
}
subapi
=
FastAPI
()
@subapi
.
get
(
"/sub"
)
def
read_sub
():
return
{
"message"
:
"Hello World from sub API"
}
app
.
mount
(
"/subapi"
,
subapi
)
Mount the sub-application
In your top-level application,
app
, mount the sub-application,
subapi
.
In this case, it will be mounted at the path
/subapi
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/app"
)
def
read_main
():
return
{
"message"
:
"Hello World from main app"
}
subapi
=
FastAPI
()
@subapi
.
get
(
"/sub"
)
def
read_sub
():
return
{
"message"
:
"Hello World from sub API"
}
app
.
mount
(
"/subapi"
,
subapi
)
Check the automatic API docs
Now, run the
fastapi
command with your file:
fast →
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
And open the docs at
http://127.0.0.1:8000/docs
.
You will see the automatic API docs for the main app, including only its own
path operations
:
And then, open the docs for the sub-application, at
http://127.0.0.1:8000/subapi/docs
.
You will see the automatic API docs for the sub-application, including only its own
path operations
, all under the correct sub-path prefix
/subapi
:
If you try interacting with any of the two user interfaces, they will work correctly, because the browser will be able to talk to each specific app or sub-app.
Technical Details:
root_path
When you mount a sub-application as described above, FastAPI will take care of communicating the mount path for the sub-application using a mechanism from the ASGI specification called a
root_path
.
That way, the sub-application will know to use that path prefix for the docs UI.
And the sub-application could also have its own mounted sub-applications and everything would work correctly, because FastAPI handles all these
root_path
s automatically.
You will learn more about the
root_path
and how to use it explicitly in the section about
Behind a Proxy
.

## 025_ADVANCED_TEMPLATES
Templates¶
---

Templates
You can use any template engine you want with
FastAPI
.
A common choice is Jinja2, the same one used by Flask and other tools.
There are utilities to configure it easily that you can use directly in your
FastAPI
application (provided by Starlette).
Install dependencies
Make sure you create a
virtual environment
, activate it, and install
jinja2
:
fast →
pip install jinja2
███ 8%
Using
Jinja2Templates
Import
Jinja2Templates
.
Create a
templates
object that you can reuse later.
Declare a
Request
parameter in the
path operation
that will return a template.
Use the
templates
you created to render and return a
TemplateResponse
, pass the name of the template, the request object, and a "context" dictionary with key-value pairs to be used inside of the Jinja2 template.
Python 3.8+
from
fastapi
import
FastAPI
,
Request
from
fastapi.responses
import
HTMLResponse
from
fastapi.staticfiles
import
StaticFiles
from
fastapi.templating
import
Jinja2Templates
app
=
FastAPI
()
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
templates
=
Jinja2Templates
(
directory
=
"templates"
)
@app
.
get
(
"/items/
{id}
"
,
response_class
=
HTMLResponse
)
async
def
read_item
(
request
:
Request
,
id
:
str
):
return
templates
.
TemplateResponse
(
request
=
request
,
name
=
"item.html"
,
context
=
{
"id"
:
id
}
)
Note
Before FastAPI 0.108.0, Starlette 0.29.0, the
name
was the first parameter.
Also, before that, in previous versions, the
request
object was passed as part of the key-value pairs in the context for Jinja2.
Tip
By declaring
response_class=HTMLResponse
the docs UI will be able to know that the response will be HTML.
Technical Details
You could also use
from starlette.templating import Jinja2Templates
.
FastAPI
provides the same
starlette.templating
as
fastapi.templating
just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with
Request
and
StaticFiles
.
Writing templates
Then you can write a template at
templates/item.html
with, for example:
<html>
<head>
<title>Item Details</title>
<link href="
{{
url_for
(
'static'
,
path
=
'/styles.css'
)
}}
" rel="stylesheet">
</head>
<body>
<h1><a href="
{{
url_for
(
'read_item'
,
id
=
id
)
}}
">Item ID:
{{
id
}}
</a></h1>
</body>
</html>
Template Context Values
In the HTML that contains:
Item ID:
{{
id
}}
...it will show the
id
taken from the "context"
dict
you passed:
{
"id"
:
id
}
For example, with an ID of
42
, this would render:
Item ID: 42
Template
url_for
Arguments
You can also use
url_for()
inside of the template, it takes as arguments the same arguments that would be used by your
path operation function
.
So, the section with:
<a href="
{{
url_for
(
'read_item'
,
id
=
id
)
}}
">
...will generate a link to the same URL that would be handled by the
path operation function
read_item(id=id)
.
For example, with an ID of
42
, this would render:
<
a
href
=
"/items/42"
>
Templates and static files
You can also use
url_for()
inside of the template, and use it, for example, with the
StaticFiles
you mounted with the
name="static"
.
<html>
<head>
<title>Item Details</title>
<link href="
{{
url_for
(
'static'
,
path
=
'/styles.css'
)
}}
" rel="stylesheet">
</head>
<body>
<h1><a href="
{{
url_for
(
'read_item'
,
id
=
id
)
}}
">Item ID:
{{
id
}}
</a></h1>
</body>
</html>
In this example, it would link to a CSS file at
static/styles.css
with:
h1
{
color
:
green
;
}
And because you are using
StaticFiles
, that CSS file would be served automatically by your
FastAPI
application at the URL
/static/styles.css
.
More details
For more details, including how to test templates, check
Starlette's docs on templates
.

## 026_ADVANCED_TESTING_DEPENDENCIES
Testing Dependencies with Overrides¶
---

Testing Dependencies with Overrides
Overriding dependencies during testing
There are some scenarios where you might want to override a dependency during testing.
You don't want the original dependency to run (nor any of the sub-dependencies it might have).
Instead, you want to provide a different dependency that will be used only during tests (possibly only some specific tests), and will provide a value that can be used where the value of the original dependency was used.
Use cases: external service
An example could be that you have an external authentication provider that you need to call.
You send it a token and it returns an authenticated user.
This provider might be charging you per request, and calling it might take some extra time than if you had a fixed mock user for tests.
You probably want to test the external provider once, but not necessarily call it for every test that runs.
In this case, you can override the dependency that calls that provider, and use a custom dependency that returns a mock user, only for your tests.
Use the
app.dependency_overrides
attribute
For these cases, your
FastAPI
application has an attribute
app.dependency_overrides
, it is a simple
dict
.
To override a dependency for testing, you put as a key the original dependency (a function), and as the value, your dependency override (another function).
And then
FastAPI
will call that override instead of the original dependency.
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Items!"
,
"params"
:
commons
}
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Users!"
,
"params"
:
commons
}
client
=
TestClient
(
app
)
async
def
override_dependency
(
q
:
str
|
None
=
None
):
return
{
"q"
:
q
,
"skip"
:
5
,
"limit"
:
10
}
app
.
dependency_overrides
[
common_parameters
]
=
override_dependency
def
test_override_in_items
():
response
=
client
.
get
(
"/items/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
None
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_q
():
response
=
client
.
get
(
"/items/?q=foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_params
():
response
=
client
.
get
(
"/items/?q=foo&skip=100&limit=200"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Items!"
,
"params"
:
commons
}
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Users!"
,
"params"
:
commons
}
client
=
TestClient
(
app
)
async
def
override_dependency
(
q
:
Union
[
str
,
None
]
=
None
):
return
{
"q"
:
q
,
"skip"
:
5
,
"limit"
:
10
}
app
.
dependency_overrides
[
common_parameters
]
=
override_dependency
def
test_override_in_items
():
response
=
client
.
get
(
"/items/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
None
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_q
():
response
=
client
.
get
(
"/items/?q=foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_params
():
response
=
client
.
get
(
"/items/?q=foo&skip=100&limit=200"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.testclient
import
TestClient
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Items!"
,
"params"
:
commons
}
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Users!"
,
"params"
:
commons
}
client
=
TestClient
(
app
)
async
def
override_dependency
(
q
:
Union
[
str
,
None
]
=
None
):
return
{
"q"
:
q
,
"skip"
:
5
,
"limit"
:
10
}
app
.
dependency_overrides
[
common_parameters
]
=
override_dependency
def
test_override_in_items
():
response
=
client
.
get
(
"/items/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
None
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_q
():
response
=
client
.
get
(
"/items/?q=foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_params
():
response
=
client
.
get
(
"/items/?q=foo&skip=100&limit=200"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
{
"message"
:
"Hello Items!"
,
"params"
:
commons
}
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
{
"message"
:
"Hello Users!"
,
"params"
:
commons
}
client
=
TestClient
(
app
)
async
def
override_dependency
(
q
:
str
|
None
=
None
):
return
{
"q"
:
q
,
"skip"
:
5
,
"limit"
:
10
}
app
.
dependency_overrides
[
common_parameters
]
=
override_dependency
def
test_override_in_items
():
response
=
client
.
get
(
"/items/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
None
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_q
():
response
=
client
.
get
(
"/items/?q=foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_params
():
response
=
client
.
get
(
"/items/?q=foo&skip=100&limit=200"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
{
"message"
:
"Hello Items!"
,
"params"
:
commons
}
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
{
"message"
:
"Hello Users!"
,
"params"
:
commons
}
client
=
TestClient
(
app
)
async
def
override_dependency
(
q
:
Union
[
str
,
None
]
=
None
):
return
{
"q"
:
q
,
"skip"
:
5
,
"limit"
:
10
}
app
.
dependency_overrides
[
common_parameters
]
=
override_dependency
def
test_override_in_items
():
response
=
client
.
get
(
"/items/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
None
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_q
():
response
=
client
.
get
(
"/items/?q=foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_params
():
response
=
client
.
get
(
"/items/?q=foo&skip=100&limit=200"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
Tip
You can set a dependency override for a dependency used anywhere in your
FastAPI
application.
The original dependency could be used in a
path operation function
, a
path operation decorator
(when you don't use the return value), a
.include_router()
call, etc.
FastAPI will still be able to override it.
Then you can reset your overrides (remove them) by setting
app.dependency_overrides
to be an empty
dict
:
app
.
dependency_overrides
=
{}
Tip
If you want to override a dependency only during some tests, you can set the override at the beginning of the test (inside the test function) and reset it at the end (at the end of the test function).

## 027_ADVANCED_TESTING_EVENTS
Testing Events: startup - shutdown¶
---

Testing Events: startup - shutdown
When you need your event handlers (
startup
and
shutdown
) to run in your tests, you can use the
TestClient
with a
with
statement:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
items
=
{}
@app
.
on_event
(
"startup"
)
async
def
startup_event
():
items
[
"foo"
]
=
{
"name"
:
"Fighters"
}
items
[
"bar"
]
=
{
"name"
:
"Tenders"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
str
):
return
items
[
item_id
]
def
test_read_items
():
with
TestClient
(
app
)
as
client
:
response
=
client
.
get
(
"/items/foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"name"
:
"Fighters"
}

## 028_ADVANCED_TESTING_WEBSOCKETS
Testing WebSockets¶
---

Testing WebSockets
You can use the same
TestClient
to test WebSockets.
For this, you use the
TestClient
in a
with
statement, connecting to the WebSocket:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.testclient
import
TestClient
from
fastapi.websockets
import
WebSocket
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_main
():
return
{
"msg"
:
"Hello World"
}
@app
.
websocket
(
"/ws"
)
async
def
websocket
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
await
websocket
.
send_json
({
"msg"
:
"Hello WebSocket"
})
await
websocket
.
close
()
def
test_read_main
():
client
=
TestClient
(
app
)
response
=
client
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"msg"
:
"Hello World"
}
def
test_websocket
():
client
=
TestClient
(
app
)
with
client
.
websocket_connect
(
"/ws"
)
as
websocket
:
data
=
websocket
.
receive_json
()
assert
data
==
{
"msg"
:
"Hello WebSocket"
}
Note
For more details, check Starlette's documentation for
testing WebSockets
.

## 029_ADVANCED_USING_REQUEST_DIRECTLY
Using the Request Directly¶
---

Using the Request Directly
Up to now, you have been declaring the parts of the request that you need with their types.
Taking data from:
The path as parameters.
Headers.
Cookies.
etc.
And by doing so,
FastAPI
is validating that data, converting it and generating documentation for your API automatically.
But there are situations where you might need to access the
Request
object directly.
Details about the
Request
object
As
FastAPI
is actually
Starlette
underneath, with a layer of several tools on top, you can use Starlette's
Request
object directly when you need to.
It would also mean that if you get data from the
Request
object directly (for example, read the body) it won't be validated, converted or documented (with OpenAPI, for the automatic API user interface) by FastAPI.
Although any other parameter declared normally (for example, the body with a Pydantic model) would still be validated, converted, annotated, etc.
But there are specific cases where it's useful to get the
Request
object.
Use the
Request
object directly
Let's imagine you want to get the client's IP address/host inside of your
path operation function
.
For that you need to access the request directly.
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
def
read_root
(
item_id
:
str
,
request
:
Request
):
client_host
=
request
.
client
.
host
return
{
"client_host"
:
client_host
,
"item_id"
:
item_id
}
By declaring a
path operation function
parameter with the type being the
Request
FastAPI
will know to pass the
Request
in that parameter.
Tip
Note that in this case, we are declaring a path parameter beside the request parameter.
So, the path parameter will be extracted, validated, converted to the specified type and annotated with OpenAPI.
The same way, you can declare any other parameter as normally, and additionally, get the
Request
too.
Request
documentation
You can read more details about the
Request
object in the official Starlette documentation site
.
Technical Details
You could also use
from starlette.requests import Request
.
FastAPI
provides it directly just as a convenience for you, the developer. But it comes directly from Starlette.

## 030_ADVANCED_WEBSOCKETS
WebSockets¶
---

WebSockets
You can use
WebSockets
with
FastAPI
.
Install
WebSockets
Make sure you create a
virtual environment
, activate it, and install
websockets
:
fast →
pip install websockets
WebSockets client
In production
In your production system, you probably have a frontend created with a modern framework like React, Vue.js or Angular.
And to communicate using WebSockets with your backend you would probably use your frontend's utilities.
Or you might have a native mobile application that communicates with your WebSocket backend directly, in native code.
Or you might have any other way to communicate with the WebSocket endpoint.
But for this example, we'll use a very simple HTML document with some JavaScript, all inside a long string.
This, of course, is not optimal and you wouldn't use it for production.
In production you would have one of the options above.
But it's the simplest way to focus on the server-side of WebSockets and have a working example:
Python 3.8+
from
fastapi
import
FastAPI
,
WebSocket
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<input type="text" id="messageText" autocomplete="off"/>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = new WebSocket("ws://localhost:8000/ws");
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
@app
.
websocket
(
"/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
"
)
Create a
websocket
In your
FastAPI
application, create a
websocket
:
Python 3.8+
from
fastapi
import
FastAPI
,
WebSocket
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<input type="text" id="messageText" autocomplete="off"/>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = new WebSocket("ws://localhost:8000/ws");
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
@app
.
websocket
(
"/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
"
)
Technical Details
You could also use
from starlette.websockets import WebSocket
.
FastAPI
provides the same
WebSocket
directly just as a convenience for you, the developer. But it comes directly from Starlette.
Await for messages and send messages
In your WebSocket route you can
await
for messages and send messages.
Python 3.8+
from
fastapi
import
FastAPI
,
WebSocket
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<input type="text" id="messageText" autocomplete="off"/>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = new WebSocket("ws://localhost:8000/ws");
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
@app
.
websocket
(
"/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
"
)
You can receive and send binary, text, and JSON data.
Try it
If your file is named
main.py
, run your application with:
fast →
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
Open your browser at
http://127.0.0.1:8000
.
You will see a simple page like:
You can type messages in the input box, and send them:
And your
FastAPI
application with WebSockets will respond back:
You can send (and receive) many messages:
And all of them will use the same WebSocket connection.
Using
Depends
and others
In WebSocket endpoints you can import from
fastapi
and use:
Depends
Security
Cookie
Header
Path
Query
They work the same way as for other FastAPI endpoints/
path operations
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
(
Cookie
,
Depends
,
FastAPI
,
Query
,
WebSocket
,
WebSocketException
,
status
,
)
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
<label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
<button onclick="connect(event)">Connect</button>
<hr>
<label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = null;
function connect(event) {
var itemId = document.getElementById("itemId")
var token = document.getElementById("token")
ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
event.preventDefault()
}
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
async
def
get_cookie_or_token
(
websocket
:
WebSocket
,
session
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
,
token
:
Annotated
[
str
|
None
,
Query
()]
=
None
,
):
if
session
is
None
and
token
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
return
session
or
token
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
*
,
websocket
:
WebSocket
,
item_id
:
str
,
q
:
int
|
None
=
None
,
cookie_or_token
:
Annotated
[
str
,
Depends
(
get_cookie_or_token
)],
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie or query token value is:
{
cookie_or_token
}
"
)
if
q
is
not
None
:
await
websocket
.
send_text
(
f
"Query parameter q is:
{
q
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
(
Cookie
,
Depends
,
FastAPI
,
Query
,
WebSocket
,
WebSocketException
,
status
,
)
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
<label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
<button onclick="connect(event)">Connect</button>
<hr>
<label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = null;
function connect(event) {
var itemId = document.getElementById("itemId")
var token = document.getElementById("token")
ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
event.preventDefault()
}
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
async
def
get_cookie_or_token
(
websocket
:
WebSocket
,
session
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
token
:
Annotated
[
Union
[
str
,
None
],
Query
()]
=
None
,
):
if
session
is
None
and
token
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
return
session
or
token
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
*
,
websocket
:
WebSocket
,
item_id
:
str
,
q
:
Union
[
int
,
None
]
=
None
,
cookie_or_token
:
Annotated
[
str
,
Depends
(
get_cookie_or_token
)],
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie or query token value is:
{
cookie_or_token
}
"
)
if
q
is
not
None
:
await
websocket
.
send_text
(
f
"Query parameter q is:
{
q
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
from
typing
import
Union
from
fastapi
import
(
Cookie
,
Depends
,
FastAPI
,
Query
,
WebSocket
,
WebSocketException
,
status
,
)
from
fastapi.responses
import
HTMLResponse
from
typing_extensions
import
Annotated
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
<label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
<button onclick="connect(event)">Connect</button>
<hr>
<label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = null;
function connect(event) {
var itemId = document.getElementById("itemId")
var token = document.getElementById("token")
ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
event.preventDefault()
}
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
async
def
get_cookie_or_token
(
websocket
:
WebSocket
,
session
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
token
:
Annotated
[
Union
[
str
,
None
],
Query
()]
=
None
,
):
if
session
is
None
and
token
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
return
session
or
token
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
*
,
websocket
:
WebSocket
,
item_id
:
str
,
q
:
Union
[
int
,
None
]
=
None
,
cookie_or_token
:
Annotated
[
str
,
Depends
(
get_cookie_or_token
)],
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie or query token value is:
{
cookie_or_token
}
"
)
if
q
is
not
None
:
await
websocket
.
send_text
(
f
"Query parameter q is:
{
q
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
(
Cookie
,
Depends
,
FastAPI
,
Query
,
WebSocket
,
WebSocketException
,
status
,
)
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
<label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
<button onclick="connect(event)">Connect</button>
<hr>
<label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = null;
function connect(event) {
var itemId = document.getElementById("itemId")
var token = document.getElementById("token")
ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
event.preventDefault()
}
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
async
def
get_cookie_or_token
(
websocket
:
WebSocket
,
session
:
str
|
None
=
Cookie
(
default
=
None
),
token
:
str
|
None
=
Query
(
default
=
None
),
):
if
session
is
None
and
token
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
return
session
or
token
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
,
item_id
:
str
,
q
:
int
|
None
=
None
,
cookie_or_token
:
str
=
Depends
(
get_cookie_or_token
),
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie or query token value is:
{
cookie_or_token
}
"
)
if
q
is
not
None
:
await
websocket
.
send_text
(
f
"Query parameter q is:
{
q
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
(
Cookie
,
Depends
,
FastAPI
,
Query
,
WebSocket
,
WebSocketException
,
status
,
)
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
<label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
<button onclick="connect(event)">Connect</button>
<hr>
<label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = null;
function connect(event) {
var itemId = document.getElementById("itemId")
var token = document.getElementById("token")
ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
event.preventDefault()
}
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
async
def
get_cookie_or_token
(
websocket
:
WebSocket
,
session
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
),
token
:
Union
[
str
,
None
]
=
Query
(
default
=
None
),
):
if
session
is
None
and
token
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
return
session
or
token
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
,
item_id
:
str
,
q
:
Union
[
int
,
None
]
=
None
,
cookie_or_token
:
str
=
Depends
(
get_cookie_or_token
),
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie or query token value is:
{
cookie_or_token
}
"
)
if
q
is
not
None
:
await
websocket
.
send_text
(
f
"Query parameter q is:
{
q
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
Info
As this is a WebSocket it doesn't really make sense to raise an
HTTPException
, instead we raise a
WebSocketException
.
You can use a closing code from the
valid codes defined in the specification
.
Try the WebSockets with dependencies
If your file is named
main.py
, run your application with:
fast →
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
Open your browser at
http://127.0.0.1:8000
.
There you can set:
The "Item ID", used in the path.
The "Token" used as a query parameter.
Tip
Notice that the query
token
will be handled by a dependency.
With that you can connect the WebSocket and then send and receive messages:
Handling disconnections and multiple clients
When a WebSocket connection is closed, the
await websocket.receive_text()
will raise a
WebSocketDisconnect
exception, which you can then catch and handle like in this example.
Python 3.9+
from
fastapi
import
FastAPI
,
WebSocket
,
WebSocketDisconnect
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<h2>Your ID: <span id="ws-id"></span></h2>
<form action="" onsubmit="sendMessage(event)">
<input type="text" id="messageText" autocomplete="off"/>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var client_id = Date.now()
document.querySelector("#ws-id").textContent = client_id;
var ws = new WebSocket(`ws://localhost:8000/ws/$
{client_id}
`);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
class
ConnectionManager
:
def
__init__
(
self
):
self
.
active_connections
:
list
[
WebSocket
]
=
[]
async
def
connect
(
self
,
websocket
:
WebSocket
):
await
websocket
.
accept
()
self
.
active_connections
.
append
(
websocket
)
def
disconnect
(
self
,
websocket
:
WebSocket
):
self
.
active_connections
.
remove
(
websocket
)
async
def
send_personal_message
(
self
,
message
:
str
,
websocket
:
WebSocket
):
await
websocket
.
send_text
(
message
)
async
def
broadcast
(
self
,
message
:
str
):
for
connection
in
self
.
active_connections
:
await
connection
.
send_text
(
message
)
manager
=
ConnectionManager
()
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
@app
.
websocket
(
"/ws/
{client_id}
"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
,
client_id
:
int
):
await
manager
.
connect
(
websocket
)
try
:
while
True
:
data
=
await
websocket
.
receive_text
()
await
manager
.
send_personal_message
(
f
"You wrote:
{
data
}
"
,
websocket
)
await
manager
.
broadcast
(
f
"Client #
{
client_id
}
says:
{
data
}
"
)
except
WebSocketDisconnect
:
manager
.
disconnect
(
websocket
)
await
manager
.
broadcast
(
f
"Client #
{
client_id
}
left the chat"
)
🤓 Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
,
WebSocket
,
WebSocketDisconnect
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<h2>Your ID: <span id="ws-id"></span></h2>
<form action="" onsubmit="sendMessage(event)">
<input type="text" id="messageText" autocomplete="off"/>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var client_id = Date.now()
document.querySelector("#ws-id").textContent = client_id;
var ws = new WebSocket(`ws://localhost:8000/ws/$
{client_id}
`);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
class
ConnectionManager
:
def
__init__
(
self
):
self
.
active_connections
:
List
[
WebSocket
]
=
[]
async
def
connect
(
self
,
websocket
:
WebSocket
):
await
websocket
.
accept
()
self
.
active_connections
.
append
(
websocket
)
def
disconnect
(
self
,
websocket
:
WebSocket
):
self
.
active_connections
.
remove
(
websocket
)
async
def
send_personal_message
(
self
,
message
:
str
,
websocket
:
WebSocket
):
await
websocket
.
send_text
(
message
)
async
def
broadcast
(
self
,
message
:
str
):
for
connection
in
self
.
active_connections
:
await
connection
.
send_text
(
message
)
manager
=
ConnectionManager
()
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
@app
.
websocket
(
"/ws/
{client_id}
"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
,
client_id
:
int
):
await
manager
.
connect
(
websocket
)
try
:
while
True
:
data
=
await
websocket
.
receive_text
()
await
manager
.
send_personal_message
(
f
"You wrote:
{
data
}
"
,
websocket
)
await
manager
.
broadcast
(
f
"Client #
{
client_id
}
says:
{
data
}
"
)
except
WebSocketDisconnect
:
manager
.
disconnect
(
websocket
)
await
manager
.
broadcast
(
f
"Client #
{
client_id
}
left the chat"
)
To try it out:
Open the app with several browser tabs.
Write messages from them.
Then close one of the tabs.
That will raise the
WebSocketDisconnect
exception, and all the other clients will receive a message like:
Client #1596980209979 left the chat
Tip
The app above is a minimal and simple example to demonstrate how to handle and broadcast messages to several WebSocket connections.
But keep in mind that, as everything is handled in memory, in a single list, it will only work while the process is running, and will only work with a single process.
If you need something easy to integrate with FastAPI but that is more robust, supported by Redis, PostgreSQL or others, check
encode/broadcaster
.
More info
To learn more about the options, check Starlette's documentation for:
The
WebSocket
class
.
Class-based WebSocket handling
.

## 031_ADVANCED_WSGI
Including WSGI - Flask, Django, others¶
---

Including WSGI - Flask, Django, others
You can mount WSGI applications as you saw with
Sub Applications - Mounts
,
Behind a Proxy
.
For that, you can use the
WSGIMiddleware
and use it to wrap your WSGI application, for example, Flask, Django, etc.
Using
WSGIMiddleware
You need to import
WSGIMiddleware
.
Then wrap the WSGI (e.g. Flask) app with the middleware.
And then mount that under a path.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.middleware.wsgi
import
WSGIMiddleware
from
flask
import
Flask
,
request
from
markupsafe
import
escape
flask_app
=
Flask
(
__name__
)
@flask_app
.
route
(
"/"
)
def
flask_main
():
name
=
request
.
args
.
get
(
"name"
,
"World"
)
return
f
"Hello,
{
escape
(
name
)
}
from Flask!"
app
=
FastAPI
()
@app
.
get
(
"/v2"
)
def
read_main
():
return
{
"message"
:
"Hello World"
}
app
.
mount
(
"/v1"
,
WSGIMiddleware
(
flask_app
))
Check it
Now, every request under the path
/v1/
will be handled by the Flask application.
And the rest will be handled by
FastAPI
.
If you run it and go to
http://localhost:8000/v1/
you will see the response from Flask:
Hello, World from Flask!
And if you go to
http://localhost:8000/v2
you will see the response from FastAPI:
{
"message"
:
"Hello World"
}

## 032_ALTERNATIVES
Alternatives, Inspiration and Comparisons¶
---

Alternatives, Inspiration and Comparisons
What inspired
FastAPI
, how it compares to alternatives and what it learned from them.
Intro
FastAPI
wouldn't exist if not for the previous work of others.
There have been many tools created before that have helped inspire its creation.
I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by
FastAPI
using many different frameworks, plug-ins, and tools.
But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints).
Previous tools
Django
It's the most popular Python framework and is widely trusted. It is used to build systems like Instagram.
It's relatively tightly coupled with relational databases (like MySQL or PostgreSQL), so, having a NoSQL database (like Couchbase, MongoDB, Cassandra, etc) as the main store engine is not very easy.
It was created to generate the HTML in the backend, not to create APIs used by a modern frontend (like React, Vue.js and Angular) or by other systems (like
IoT
devices) communicating with it.
Django REST Framework
Django REST framework was created to be a flexible toolkit for building Web APIs using Django underneath, to improve its API capabilities.
It is used by many companies including Mozilla, Red Hat and Eventbrite.
It was one of the first examples of
automatic API documentation
, and this was specifically one of the first ideas that inspired "the search for"
FastAPI
.
Note
Django REST Framework was created by Tom Christie. The same creator of Starlette and Uvicorn, on which
FastAPI
is based.
Inspired
FastAPI
to
Have an automatic API documentation web user interface.
Flask
Flask is a "microframework", it doesn't include database integrations nor many of the things that come by default in Django.
This simplicity and flexibility allow doing things like using NoSQL databases as the main data storage system.
As it is very simple, it's relatively intuitive to learn, although the documentation gets somewhat technical at some points.
It is also commonly used for other applications that don't necessarily need a database, user management, or any of the many features that come pre-built in Django. Although many of these features can be added with plug-ins.
This decoupling of parts, and being a "microframework" that could be extended to cover exactly what is needed was a key feature that I wanted to keep.
Given the simplicity of Flask, it seemed like a good match for building APIs. The next thing to find was a "Django REST Framework" for Flask.
Inspired
FastAPI
to
Be a micro-framework. Making it easy to mix and match the tools and parts needed.
Have a simple and easy to use routing system.
Requests
FastAPI
is not actually an alternative to
Requests
. Their scope is very different.
It would actually be common to use Requests
inside
of a FastAPI application.
But still, FastAPI got quite some inspiration from Requests.
Requests
is a library to
interact
with APIs (as a client), while
FastAPI
is a library to
build
APIs (as a server).
They are, more or less, at opposite ends, complementing each other.
Requests has a very simple and intuitive design, it's very easy to use, with sensible defaults. But at the same time, it's very powerful and customizable.
That's why, as said in the official website:
Requests is one of the most downloaded Python packages of all time
The way you use it is very simple. For example, to do a
GET
request, you would write:
response
=
requests
.
get
(
"http://example.com/some/url"
)
The FastAPI counterpart API
path operation
could look like:
@app
.
get
(
"/some/url"
)
def
read_url
():
return
{
"message"
:
"Hello World"
}
See the similarities in
requests.get(...)
and
@app.get(...)
.
Inspired
FastAPI
to
Have a simple and intuitive API.
Use HTTP method names (operations) directly, in a straightforward and intuitive way.
Have sensible defaults, but powerful customizations.
Swagger
/
OpenAPI
The main feature I wanted from Django REST Framework was the automatic API documentation.
Then I found that there was a standard to document APIs, using JSON (or YAML, an extension of JSON) called Swagger.
And there was a web user interface for Swagger APIs already created. So, being able to generate Swagger documentation for an API would allow using this web user interface automatically.
At some point, Swagger was given to the Linux Foundation, to be renamed OpenAPI.
That's why when talking about version 2.0 it's common to say "Swagger", and for version 3+ "OpenAPI".
Inspired
FastAPI
to
Adopt and use an open standard for API specifications, instead of a custom schema.
And integrate standards-based user interface tools:
Swagger UI
ReDoc
These two were chosen for being fairly popular and stable, but doing a quick search, you could find dozens of alternative user interfaces for OpenAPI (that you can use with
FastAPI
).
Flask REST frameworks
There are several Flask REST frameworks, but after investing the time and work into investigating them, I found that many are discontinued or abandoned, with several standing issues that made them unfit.
Marshmallow
One of the main features needed by API systems is data "
serialization
" which is taking data from the code (Python) and converting it into something that can be sent through the network. For example, converting an object containing data from a database into a JSON object. Converting
datetime
objects into strings, etc.
Another big feature needed by APIs is data validation, making sure that the data is valid, given certain parameters. For example, that some field is an
int
, and not some random string. This is especially useful for incoming data.
Without a data validation system, you would have to do all the checks by hand, in code.
These features are what Marshmallow was built to provide. It is a great library, and I have used it a lot before.
But it was created before there existed Python type hints. So, to define every
schema
you need to use specific utils and classes provided by Marshmallow.
Inspired
FastAPI
to
Use code to define "schemas" that provide data types and validation, automatically.
Webargs
Another big feature required by APIs is
parsing
data from incoming requests.
Webargs is a tool that was made to provide that on top of several frameworks, including Flask.
It uses Marshmallow underneath to do the data validation. And it was created by the same developers.
It's a great tool and I have used it a lot too, before having
FastAPI
.
Info
Webargs was created by the same Marshmallow developers.
Inspired
FastAPI
to
Have automatic validation of incoming request data.
APISpec
Marshmallow and Webargs provide validation, parsing and serialization as plug-ins.
But documentation is still missing. Then APISpec was created.
It is a plug-in for many frameworks (and there's a plug-in for Starlette too).
The way it works is that you write the definition of the schema using YAML format inside the docstring of each function handling a route.
And it generates OpenAPI schemas.
That's how it works in Flask, Starlette, Responder, etc.
But then, we have again the problem of having a micro-syntax, inside of a Python string (a big YAML).
The editor can't help much with that. And if we modify parameters or Marshmallow schemas and forget to also modify that YAML docstring, the generated schema would be obsolete.
Info
APISpec was created by the same Marshmallow developers.
Inspired
FastAPI
to
Support the open standard for APIs, OpenAPI.
Flask-apispec
It's a Flask plug-in, that ties together Webargs, Marshmallow and APISpec.
It uses the information from Webargs and Marshmallow to automatically generate OpenAPI schemas, using APISpec.
It's a great tool, very underrated. It should be way more popular than many Flask plug-ins out there. It might be due to its documentation being too concise and abstract.
This solved having to write YAML (another syntax) inside of Python docstrings.
This combination of Flask, Flask-apispec with Marshmallow and Webargs was my favorite backend stack until building
FastAPI
.
Using it led to the creation of several Flask full-stack generators. These are the main stacks I (and several external teams) have been using up to now:
https://github.com/tiangolo/full-stack
https://github.com/tiangolo/full-stack-flask-couchbase
https://github.com/tiangolo/full-stack-flask-couchdb
And these same full-stack generators were the base of the
FastAPI
Project Generators
.
Info
Flask-apispec was created by the same Marshmallow developers.
Inspired
FastAPI
to
Generate the OpenAPI schema automatically, from the same code that defines serialization and validation.
NestJS
(and
Angular
)
This isn't even Python, NestJS is a JavaScript (TypeScript) NodeJS framework inspired by Angular.
It achieves something somewhat similar to what can be done with Flask-apispec.
It has an integrated dependency injection system, inspired by Angular 2. It requires pre-registering the "injectables" (like all the other dependency injection systems I know), so, it adds to the verbosity and code repetition.
As the parameters are described with TypeScript types (similar to Python type hints), editor support is quite good.
But as TypeScript data is not preserved after compilation to JavaScript, it cannot rely on the types to define validation, serialization and documentation at the same time. Due to this and some design decisions, to get validation, serialization and automatic schema generation, it's needed to add decorators in many places. So, it becomes quite verbose.
It can't handle nested models very well. So, if the JSON body in the request is a JSON object that has inner fields that in turn are nested JSON objects, it cannot be properly documented and validated.
Inspired
FastAPI
to
Use Python types to have great editor support.
Have a powerful dependency injection system. Find a way to minimize code repetition.
Sanic
It was one of the first extremely fast Python frameworks based on
asyncio
. It was made to be very similar to Flask.
Technical Details
It used
uvloop
instead of the default Python
asyncio
loop. That's what made it so fast.
It clearly inspired Uvicorn and Starlette, that are currently faster than Sanic in open benchmarks.
Inspired
FastAPI
to
Find a way to have a crazy performance.
That's why
FastAPI
is based on Starlette, as it is the fastest framework available (tested by third-party benchmarks).
Falcon
Falcon is another high performance Python framework, it is designed to be minimal, and work as the foundation of other frameworks like Hug.
It is designed to have functions that receive two parameters, one "request" and one "response". Then you "read" parts from the request, and "write" parts to the response. Because of this design, it is not possible to declare request parameters and bodies with standard Python type hints as function parameters.
So, data validation, serialization, and documentation, have to be done in code, not automatically. Or they have to be implemented as a framework on top of Falcon, like Hug. This same distinction happens in other frameworks that are inspired by Falcon's design, of having one request object and one response object as parameters.
Inspired
FastAPI
to
Find ways to get great performance.
Along with Hug (as Hug is based on Falcon) inspired
FastAPI
to declare a
response
parameter in functions.
Although in FastAPI it's optional, and is used mainly to set headers, cookies, and alternative status codes.
Molten
I discovered Molten in the first stages of building
FastAPI
. And it has quite similar ideas:
Based on Python type hints.
Validation and documentation from these types.
Dependency Injection system.
It doesn't use a data validation, serialization and documentation third-party library like Pydantic, it has its own. So, these data type definitions would not be reusable as easily.
It requires a little bit more verbose configurations. And as it is based on WSGI (instead of ASGI), it is not designed to take advantage of the high performance provided by tools like Uvicorn, Starlette and Sanic.
The dependency injection system requires pre-registration of the dependencies and the dependencies are solved based on the declared types. So, it's not possible to declare more than one "component" that provides a certain type.
Routes are declared in a single place, using functions declared in other places (instead of using decorators that can be placed right on top of the function that handles the endpoint). This is closer to how Django does it than to how Flask (and Starlette) does it. It separates in the code things that are relatively tightly coupled.
Inspired
FastAPI
to
Define extra validations for data types using the "default" value of model attributes. This improves editor support, and it was not available in Pydantic before.
This actually inspired updating parts of Pydantic, to support the same validation declaration style (all this functionality is now already available in Pydantic).
Hug
Hug was one of the first frameworks to implement the declaration of API parameter types using Python type hints. This was a great idea that inspired other tools to do the same.
It used custom types in its declarations instead of standard Python types, but it was still a huge step forward.
It also was one of the first frameworks to generate a custom schema declaring the whole API in JSON.
It was not based on a standard like OpenAPI and JSON Schema. So it wouldn't be straightforward to integrate it with other tools, like Swagger UI. But again, it was a very innovative idea.
It has an interesting, uncommon feature: using the same framework, it's possible to create APIs and also CLIs.
As it is based on the previous standard for synchronous Python web frameworks (WSGI), it can't handle Websockets and other things, although it still has high performance too.
Info
Hug was created by Timothy Crosley, the same creator of
isort
, a great tool to automatically sort imports in Python files.
Ideas inspiring
FastAPI
Hug inspired parts of APIStar, and was one of the tools I found most promising, alongside APIStar.
Hug helped inspiring
FastAPI
to use Python type hints to declare parameters, and to generate a schema defining the API automatically.
Hug inspired
FastAPI
to declare a
response
parameter in functions to set headers and cookies.
APIStar
(<= 0.5)
Right before deciding to build
FastAPI
I found
APIStar
server. It had almost everything I was looking for and had a great design.
It was one of the first implementations of a framework using Python type hints to declare parameters and requests that I ever saw (before NestJS and Molten). I found it more or less at the same time as Hug. But APIStar used the OpenAPI standard.
It had automatic data validation, data serialization and OpenAPI schema generation based on the same type hints in several places.
Body schema definitions didn't use the same Python type hints like Pydantic, it was a bit more similar to Marshmallow, so, editor support wouldn't be as good, but still, APIStar was the best available option.
It had the best performance benchmarks at the time (only surpassed by Starlette).
At first, it didn't have an automatic API documentation web UI, but I knew I could add Swagger UI to it.
It had a dependency injection system. It required pre-registration of components, as other tools discussed above. But still, it was a great feature.
I was never able to use it in a full project, as it didn't have security integration, so, I couldn't replace all the features I was having with the full-stack generators based on Flask-apispec. I had in my backlog of projects to create a pull request adding that functionality.
But then, the project's focus shifted.
It was no longer an API web framework, as the creator needed to focus on Starlette.
Now APIStar is a set of tools to validate OpenAPI specifications, not a web framework.
Info
APIStar was created by Tom Christie. The same guy that created:
Django REST Framework
Starlette (in which
FastAPI
is based)
Uvicorn (used by Starlette and
FastAPI
)
Inspired
FastAPI
to
Exist.
The idea of declaring multiple things (data validation, serialization and documentation) with the same Python types, that at the same time provided great editor support, was something I considered a brilliant idea.
And after searching for a long time for a similar framework and testing many different alternatives, APIStar was the best option available.
Then APIStar stopped to exist as a server and Starlette was created, and was a new better foundation for such a system. That was the final inspiration to build
FastAPI
.
I consider
FastAPI
a "spiritual successor" to APIStar, while improving and increasing the features, typing system, and other parts, based on the learnings from all these previous tools.
Used by
FastAPI
Pydantic
Pydantic is a library to define data validation, serialization and documentation (using JSON Schema) based on Python type hints.
That makes it extremely intuitive.
It is comparable to Marshmallow. Although it's faster than Marshmallow in benchmarks. And as it is based on the same Python type hints, the editor support is great.
FastAPI
uses it to
Handle all the data validation, data serialization and automatic model documentation (based on JSON Schema).
FastAPI
then takes that JSON Schema data and puts it in OpenAPI, apart from all the other things it does.
Starlette
Starlette is a lightweight
ASGI
framework/toolkit, which is ideal for building high-performance asyncio services.
It is very simple and intuitive. It's designed to be easily extensible, and have modular components.
It has:
Seriously impressive performance.
WebSocket support.
In-process background tasks.
Startup and shutdown events.
Test client built on HTTPX.
CORS, GZip, Static Files, Streaming responses.
Session and Cookie support.
100% test coverage.
100% type annotated codebase.
Few hard dependencies.
Starlette is currently the fastest Python framework tested. Only surpassed by Uvicorn, which is not a framework, but a server.
Starlette provides all the basic web microframework functionality.
But it doesn't provide automatic data validation, serialization or documentation.
That's one of the main things that
FastAPI
adds on top, all based on Python type hints (using Pydantic). That, plus the dependency injection system, security utilities, OpenAPI schema generation, etc.
Technical Details
ASGI is a new "standard" being developed by Django core team members. It is still not a "Python standard" (a PEP), although they are in the process of doing that.
Nevertheless, it is already being used as a "standard" by several tools. This greatly improves interoperability, as you could switch Uvicorn for any other ASGI server (like Daphne or Hypercorn), or you could add ASGI compatible tools, like
python-socketio
.
FastAPI
uses it to
Handle all the core web parts. Adding features on top.
The class
FastAPI
itself inherits directly from the class
Starlette
.
So, anything that you can do with Starlette, you can do it directly with
FastAPI
, as it is basically Starlette on steroids.
Uvicorn
Uvicorn is a lightning-fast ASGI server, built on uvloop and httptools.
It is not a web framework, but a server. For example, it doesn't provide tools for routing by paths. That's something that a framework like Starlette (or
FastAPI
) would provide on top.
It is the recommended server for Starlette and
FastAPI
.
FastAPI
recommends it as
The main web server to run
FastAPI
applications.
You can also use the
--workers
command line option to have an asynchronous multi-process server.
Check more details in the
Deployment
section.
Benchmarks and speed
To understand, compare, and see the difference between Uvicorn, Starlette and FastAPI, check the section about
Benchmarks
.

## 033_ASYNC
Concurrency and async / await¶
---

Concurrency and async / await
Details about the
async def
syntax for
path operation functions
and some background about asynchronous code, concurrency, and parallelism.
In a hurry?
TL;DR:
If you are using third party libraries that tell you to call them with
await
, like:
results
=
await
some_library
()
Then, declare your
path operation functions
with
async def
like:
@app
.
get
(
'/'
)
async
def
read_results
():
results
=
await
some_library
()
return
results
Note
You can only use
await
inside of functions created with
async def
.
If you are using a third party library that communicates with something (a database, an API, the file system, etc.) and doesn't have support for using
await
, (this is currently the case for most database libraries), then declare your
path operation functions
as normally, with just
def
, like:
@app
.
get
(
'/'
)
def
results
():
results
=
some_library
()
return
results
If your application (somehow) doesn't have to communicate with anything else and wait for it to respond, use
async def
, even if you don't need to use
await
inside.
If you just don't know, use normal
def
.
Note
: You can mix
def
and
async def
in your
path operation functions
as much as you need and define each one using the best option for you. FastAPI will do the right thing with them.
Anyway, in any of the cases above, FastAPI will still work asynchronously and be extremely fast.
But by following the steps above, it will be able to do some performance optimizations.
Technical Details
Modern versions of Python have support for
"asynchronous code"
using something called
"coroutines"
, with
async
and
await
syntax.
Let's see that phrase by parts in the sections below:
Asynchronous Code
async
and
await
Coroutines
Asynchronous Code
Asynchronous code just means that the language 💬 has a way to tell the computer / program 🤖 that at some point in the code, it 🤖 will have to wait for
something else
to finish somewhere else. Let's say that
something else
is called "slow-file" 📝.
So, during that time, the computer can go and do some other work, while "slow-file" 📝 finishes.
Then the computer / program 🤖 will come back every time it has a chance because it's waiting again, or whenever it 🤖 finished all the work it had at that point. And it 🤖 will see if any of the tasks it was waiting for have already finished, doing whatever it had to do.
Next, it 🤖 takes the first task to finish (let's say, our "slow-file" 📝) and continues whatever it had to do with it.
That "wait for something else" normally refers to
I/O
operations that are relatively "slow" (compared to the speed of the processor and the RAM memory), like waiting for:
the data from the client to be sent through the network
the data sent by your program to be received by the client through the network
the contents of a file in the disk to be read by the system and given to your program
the contents your program gave to the system to be written to disk
a remote API operation
a database operation to finish
a database query to return the results
etc.
As the execution time is consumed mostly by waiting for
I/O
operations, they call them "I/O bound" operations.
It's called "asynchronous" because the computer / program doesn't have to be "synchronized" with the slow task, waiting for the exact moment that the task finishes, while doing nothing, to be able to take the task result and continue the work.
Instead of that, by being an "asynchronous" system, once finished, the task can wait in line a little bit (some microseconds) for the computer / program to finish whatever it went to do, and then come back to take the results and continue working with them.
For "synchronous" (contrary to "asynchronous") they commonly also use the term "sequential", because the computer / program follows all the steps in sequence before switching to a different task, even if those steps involve waiting.
Concurrency and Burgers
This idea of
asynchronous
code described above is also sometimes called
"concurrency"
. It is different from
"parallelism"
.
Concurrency
and
parallelism
both relate to "different things happening more or less at the same time".
But the details between
concurrency
and
parallelism
are quite different.
To see the difference, imagine the following story about burgers:
Concurrent Burgers
You go with your crush to get fast food, you stand in line while the cashier takes the orders from the people in front of you. 😍
Then it's your turn, you place your order of 2 very fancy burgers for your crush and you. 🍔🍔
The cashier says something to the cook in the kitchen so they know they have to prepare your burgers (even though they are currently preparing the ones for the previous clients).
You pay. 💸
The cashier gives you the number of your turn.
While you are waiting, you go with your crush and pick a table, you sit and talk with your crush for a long time (as your burgers are very fancy and take some time to prepare).
As you are sitting at the table with your crush, while you wait for the burgers, you can spend that time admiring how awesome, cute and smart your crush is ✨😍✨.
While waiting and talking to your crush, from time to time, you check the number displayed on the counter to see if it's your turn already.
Then at some point, it finally is your turn. You go to the counter, get your burgers and come back to the table.
You and your crush eat the burgers and have a nice time. ✨
Info
Beautiful illustrations by
Ketrina Thompson
. 🎨
Imagine you are the computer / program 🤖 in that story.
While you are at the line, you are just idle 😴, waiting for your turn, not doing anything very "productive". But the line is fast because the cashier is only taking the orders (not preparing them), so that's fine.
Then, when it's your turn, you do actual "productive" work, you process the menu, decide what you want, get your crush's choice, pay, check that you give the correct bill or card, check that you are charged correctly, check that the order has the correct items, etc.
But then, even though you still don't have your burgers, your work with the cashier is "on pause" ⏸, because you have to wait 🕙 for your burgers to be ready.
But as you go away from the counter and sit at the table with a number for your turn, you can switch 🔀 your attention to your crush, and "work" ⏯ 🤓 on that. Then you are again doing something very "productive" as is flirting with your crush 😍.
Then the cashier 💁 says "I'm finished with doing the burgers" by putting your number on the counter's display, but you don't jump like crazy immediately when the displayed number changes to your turn number. You know no one will steal your burgers because you have the number of your turn, and they have theirs.
So you wait for your crush to finish the story (finish the current work ⏯ / task being processed 🤓), smile gently and say that you are going for the burgers ⏸.
Then you go to the counter 🔀, to the initial task that is now finished ⏯, pick the burgers, say thanks and take them to the table. That finishes that step / task of interaction with the counter ⏹. That in turn, creates a new task, of "eating burgers" 🔀 ⏯, but the previous one of "getting burgers" is finished ⏹.
Parallel Burgers
Now let's imagine these aren't "Concurrent Burgers", but "Parallel Burgers".
You go with your crush to get parallel fast food.
You stand in line while several (let's say 8) cashiers that at the same time are cooks take the orders from the people in front of you.
Everyone before you is waiting for their burgers to be ready before leaving the counter because each of the 8 cashiers goes and prepares the burger right away before getting the next order.
Then it's finally your turn, you place your order of 2 very fancy burgers for your crush and you.
You pay 💸.
The cashier goes to the kitchen.
You wait, standing in front of the counter 🕙, so that no one else takes your burgers before you do, as there are no numbers for turns.
As you and your crush are busy not letting anyone get in front of you and take your burgers whenever they arrive, you cannot pay attention to your crush. 😞
This is "synchronous" work, you are "synchronized" with the cashier/cook 👨‍🍳. You have to wait 🕙 and be there at the exact moment that the cashier/cook 👨‍🍳 finishes the burgers and gives them to you, or otherwise, someone else might take them.
Then your cashier/cook 👨‍🍳 finally comes back with your burgers, after a long time waiting 🕙 there in front of the counter.
You take your burgers and go to the table with your crush.
You just eat them, and you are done. ⏹
There was not much talk or flirting as most of the time was spent waiting 🕙 in front of the counter. 😞
Info
Beautiful illustrations by
Ketrina Thompson
. 🎨
In this scenario of the parallel burgers, you are a computer / program 🤖 with two processors (you and your crush), both waiting 🕙 and dedicating their attention ⏯ to be "waiting on the counter" 🕙 for a long time.
The fast food store has 8 processors (cashiers/cooks). While the concurrent burgers store might have had only 2 (one cashier and one cook).
But still, the final experience is not the best. 😞
This would be the parallel equivalent story for burgers. 🍔
For a more "real life" example of this, imagine a bank.
Up to recently, most of the banks had multiple cashiers 👨‍💼👨‍💼👨‍💼👨‍💼 and a big line 🕙🕙🕙🕙🕙🕙🕙🕙.
All of the cashiers doing all the work with one client after the other 👨‍💼⏯.
And you have to wait 🕙 in the line for a long time or you lose your turn.
You probably wouldn't want to take your crush 😍 with you to run errands at the bank 🏦.
Burger Conclusion
In this scenario of "fast food burgers with your crush", as there is a lot of waiting 🕙, it makes a lot more sense to have a concurrent system ⏸🔀⏯.
This is the case for most of the web applications.
Many, many users, but your server is waiting 🕙 for their not-so-good connection to send their requests.
And then waiting 🕙 again for the responses to come back.
This "waiting" 🕙 is measured in microseconds, but still, summing it all, it's a lot of waiting in the end.
That's why it makes a lot of sense to use asynchronous ⏸🔀⏯ code for web APIs.
This kind of asynchronicity is what made NodeJS popular (even though NodeJS is not parallel) and that's the strength of Go as a programming language.
And that's the same level of performance you get with
FastAPI
.
And as you can have parallelism and asynchronicity at the same time, you get higher performance than most of the tested NodeJS frameworks and on par with Go, which is a compiled language closer to C
(all thanks to Starlette)
.
Is concurrency better than parallelism?
Nope! That's not the moral of the story.
Concurrency is different than parallelism. And it is better on
specific
scenarios that involve a lot of waiting. Because of that, it generally is a lot better than parallelism for web application development. But not for everything.
So, to balance that out, imagine the following short story:
You have to clean a big, dirty house.
Yep, that's the whole story
.
There's no waiting 🕙 anywhere, just a lot of work to be done, on multiple places of the house.
You could have turns as in the burgers example, first the living room, then the kitchen, but as you are not waiting 🕙 for anything, just cleaning and cleaning, the turns wouldn't affect anything.
It would take the same amount of time to finish with or without turns (concurrency) and you would have done the same amount of work.
But in this case, if you could bring the 8 ex-cashier/cooks/now-cleaners, and each one of them (plus you) could take a zone of the house to clean it, you could do all the work in
parallel
, with the extra help, and finish much sooner.
In this scenario, each one of the cleaners (including you) would be a processor, doing their part of the job.
And as most of the execution time is taken by actual work (instead of waiting), and the work in a computer is done by a
CPU
, they call these problems "CPU bound".
Common examples of CPU bound operations are things that require complex math processing.
For example:
Audio
or
image processing
.
Computer vision
: an image is composed of millions of pixels, each pixel has 3 values / colors, processing that normally requires computing something on those pixels, all at the same time.
Machine Learning
: it normally requires lots of "matrix" and "vector" multiplications. Think of a huge spreadsheet with numbers and multiplying all of them together at the same time.
Deep Learning
: this is a sub-field of Machine Learning, so, the same applies. It's just that there is not a single spreadsheet of numbers to multiply, but a huge set of them, and in many cases, you use a special processor to build and / or use those models.
Concurrency + Parallelism: Web + Machine Learning
With
FastAPI
you can take advantage of concurrency that is very common for web development (the same main attraction of NodeJS).
But you can also exploit the benefits of parallelism and multiprocessing (having multiple processes running in parallel) for
CPU bound
workloads like those in Machine Learning systems.
That, plus the simple fact that Python is the main language for
Data Science
, Machine Learning and especially Deep Learning, make FastAPI a very good match for Data Science / Machine Learning web APIs and applications (among many others).
To see how to achieve this parallelism in production see the section about
Deployment
.
async
and
await
Modern versions of Python have a very intuitive way to define asynchronous code. This makes it look just like normal "sequential" code and do the "awaiting" for you at the right moments.
When there is an operation that will require waiting before giving the results and has support for these new Python features, you can code it like:
burgers
=
await
get_burgers
(
2
)
The key here is the
await
. It tells Python that it has to wait ⏸ for
get_burgers(2)
to finish doing its thing 🕙 before storing the results in
burgers
. With that, Python will know that it can go and do something else 🔀 ⏯ in the meanwhile (like receiving another request).
For
await
to work, it has to be inside a function that supports this asynchronicity. To do that, you just declare it with
async def
:
async
def
get_burgers
(
number
:
int
):
## Do some asynchronous stuff to create the burgers
return
burgers
...instead of
def
:
## This is not asynchronous
def
get_sequential_burgers
(
number
:
int
):
## Do some sequential stuff to create the burgers
return
burgers
With
async def
, Python knows that, inside that function, it has to be aware of
await
expressions, and that it can "pause" ⏸ the execution of that function and go do something else 🔀 before coming back.
When you want to call an
async def
function, you have to "await" it. So, this won't work:
## This won't work, because get_burgers was defined with: async def
burgers
=
get_burgers
(
2
)
So, if you are using a library that tells you that you can call it with
await
, you need to create the
path operation functions
that uses it with
async def
, like in:
@app
.
get
(
'/burgers'
)
async
def
read_burgers
():
burgers
=
await
get_burgers
(
2
)
return
burgers
More technical details
You might have noticed that
await
can only be used inside of functions defined with
async def
.
But at the same time, functions defined with
async def
have to be "awaited". So, functions with
async def
can only be called inside of functions defined with
async def
too.
So, about the egg and the chicken, how do you call the first
async
function?
If you are working with
FastAPI
you don't have to worry about that, because that "first" function will be your
path operation function
, and FastAPI will know how to do the right thing.
But if you want to use
async
/
await
without FastAPI, you can do it as well.
Write your own async code
Starlette (and
FastAPI
) are based on
AnyIO
, which makes it compatible with both Python's standard library
asyncio
and
Trio
.
In particular, you can directly use
AnyIO
for your advanced concurrency use cases that require more advanced patterns in your own code.
And even if you were not using FastAPI, you could also write your own async applications with
AnyIO
to be highly compatible and get its benefits (e.g.
structured concurrency
).
I created another library on top of AnyIO, as a thin layer on top, to improve a bit the type annotations and get better
autocompletion
,
inline errors
, etc. It also has a friendly introduction and tutorial to help you
understand
and write
your own async code
:
Asyncer
. It would be particularly useful if you need to
combine async code with regular
(blocking/synchronous) code.
Other forms of asynchronous code
This style of using
async
and
await
is relatively new in the language.
But it makes working with asynchronous code a lot easier.
This same syntax (or almost identical) was also included recently in modern versions of JavaScript (in Browser and NodeJS).
But before that, handling asynchronous code was quite more complex and difficult.
In previous versions of Python, you could have used threads or
Gevent
. But the code is way more complex to understand, debug, and think about.
In previous versions of NodeJS / Browser JavaScript, you would have used "callbacks". Which leads to
callback hell
.
Coroutines
Coroutine
is just the very fancy term for the thing returned by an
async def
function. Python knows that it is something like a function, that it can start and that it will end at some point, but that it might be paused ⏸ internally too, whenever there is an
await
inside of it.
But all this functionality of using asynchronous code with
async
and
await
is many times summarized as using "coroutines". It is comparable to the main key feature of Go, the "Goroutines".
Conclusion
Let's see the same phrase from above:
Modern versions of Python have support for
"asynchronous code"
using something called
"coroutines"
, with
async
and
await
syntax.
That should make more sense now. ✨
All that is what powers FastAPI (through Starlette) and what makes it have such an impressive performance.
Very Technical Details
Warning
You can probably skip this.
These are very technical details of how
FastAPI
works underneath.
If you have quite some technical knowledge (coroutines, threads, blocking, etc.) and are curious about how FastAPI handles
async def
vs normal
def
, go ahead.
Path operation functions
When you declare a
path operation function
with normal
def
instead of
async def
, it is run in an external threadpool that is then awaited, instead of being called directly (as it would block the server).
If you are coming from another async framework that does not work in the way described above and you are used to defining trivial compute-only
path operation functions
with plain
def
for a tiny performance gain (about 100 nanoseconds), please note that in
FastAPI
the effect would be quite opposite. In these cases, it's better to use
async def
unless your
path operation functions
use code that performs blocking
I/O
.
Still, in both situations, chances are that
FastAPI
will
still be faster
than (or at least comparable to) your previous framework.
Dependencies
The same applies for
dependencies
. If a dependency is a standard
def
function instead of
async def
, it is run in the external threadpool.
Sub-dependencies
You can have multiple dependencies and
sub-dependencies
requiring each other (as parameters of the function definitions), some of them might be created with
async def
and some with normal
def
. It would still work, and the ones created with normal
def
would be called on an external thread (from the threadpool) instead of being "awaited".
Other utility functions
Any other utility function that you call directly can be created with normal
def
or
async def
and FastAPI won't affect the way you call it.
This is in contrast to the functions that FastAPI calls for you:
path operation functions
and dependencies.
If your utility function is a normal function with
def
, it will be called directly (as you write it in your code), not in a threadpool, if the function is created with
async def
then you should
await
for that function when you call it in your code.
Again, these are very technical details that would probably be useful if you came searching for them.
Otherwise, you should be good with the guidelines from the section above:
In a hurry?
.

## 034_AZ
FastAPI
FastAPI framework, yüksək məshuldarlı, öyrənməsi asan, çevik kodlama, istifadəyə hazırdır
Sənədlər
:
https://fastapi.tiangolo.com
Qaynaq Kodu
:
https://github.com/fastapi/fastapi
FastAPI Python ilə API yaratmaq üçün standart Python
tip məsləhətlərinə
əsaslanan, müasir, sürətli (yüksək performanslı) framework-dür.
Əsas xüsusiyyətləri bunlardır:
Sürətli
: Çox yüksək performans,
NodeJS
və
Go
səviyyəsində (Starlette və Pydantic-ə təşəkkürlər).
Ən sürətli Python frameworklərindən biridir
.
Çevik kodlama
: Funksiyanallıqları inkişaf etdirmək sürətini təxminən 200%-dən 300%-ə qədər artırın. *
Daha az xəta
: İnsan (developer) tərəfindən törədilən səhvlərin təxminən 40% -ni azaldın. *
İntuitiv
: Əla redaktor dəstəyi. Hər yerdə
otomatik tamamlama
. Xətaları müəyyənləşdirməyə daha az vaxt sərf edəcəksiniz.
Asan
: İstifadəsi və öyrənilməsi asan olması üçün nəzərdə tutulmuşdur. Sənədləri oxumaq üçün daha az vaxt ayıracaqsınız.
Qısa
: Kod təkrarlanmasını minimuma endirin. Hər bir parametr tərifində birdən çox xüsusiyyət ilə və daha az səhvlə qarşılaşacaqsınız.
Güclü
: Avtomatik və interaktiv sənədlərlə birlikdə istifadəyə hazır kod əldə edə bilərsiniz.
Standartlara əsaslanan
: API-lar üçün açıq standartlara əsaslanır (və tam uyğun gəlir):
OpenAPI
(əvvəlki adı ilə Swagger) və
JSON Schema
.
* Bu fikirlər daxili development komandasının hazırladıqları məhsulların sınaqlarına əsaslanır.
Sponsorlar
`
Digər sponsorlar
Rəylər
"
[...] Son günlərdə
FastAPI
-ı çox istifadə edirəm. [...] Əslində onu komandamın bütün
Microsoftda ML sevislərində
istifadə etməyi planlayıram. Onların bəziləri
windows
-un əsas məhsuluna və bəzi
Office
məhsullarına inteqrasiya olunurlar.
"
Kabir Khan -
Microsoft
(ref)
"
FastAPI
kitabxanasını
Proqnozlar
əldə etmək üçün sorğulana bilən
REST
serverini yaratmaqda istifadə etdik.
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
böhran idarəçiliyi
orkestrləşmə framework-nün açıq qaynaqlı buraxılışını elan etməkdən məmnundur:
Dispatch
! [
FastAPI
ilə quruldu]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
FastAPI
üçün həyəcanlıyam. Çox əyləncəlidir!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Düzünü desəm, sizin qurduğunuz şey həqiqətən möhkəm və peşəkar görünür. Bir çox cəhətdən
Hug
-un olmasını istədiyim kimdir - kiminsə belə bir şey qurduğunu görmək həqiqətən ruhlandırıcıdır.
"
Timothy Crosley -
Hug
creator
(ref)
"
Əgər REST API-lər yaratmaq üçün
müasir framework
öyrənmək istəyirsinizsə,
FastAPI
-a baxın [...] Sürətli, istifadəsi və öyrənməsi asandır. [...]
"
"
API
xidmətlərimizi
FastAPI
-a köçürdük [...] Sizin də bəyənəcəyinizi düşünürük.
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
Python ilə istifadəyə hazır API qurmaq istəyən hər kəsə
FastAPI
-ı tövsiyə edirəm.
Möhtəşəm şəkildə dizayn edilmiş
,
istifadəsi asan
və
yüksək dərəcədə genişlənə bilən
-dir, API əsaslı inkişaf strategiyamızın
əsas komponentinə
çevrilib və Virtual TAC Engineer kimi bir çox avtomatlaşdırma və servisləri idarə edir.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, CLI-ların FastAPI-ı
Əgər siz veb API əvəzinə terminalda istifadə ediləcək
CLI
proqramı qurursunuzsa,
Typer
-a baxa bilərsiniz.
Typer
FastAPI-ın kiçik qardaşıdır. Və o, CLI-lərin
FastAPI
-ı olmaq üçün nəzərdə tutulub. ⌨️ 🚀
Tələblər
FastAPI nəhənglərin çiyinlərində dayanır:
Web tərəfi üçün
Starlette
.
Data tərəfi üçün
Pydantic
.
Quraşdırma
fast →
pip install fastapi
restart ↻
Tətbiqimizi əlçatan etmək üçün bizə
Uvicorn
və ya
Hypercorn
kimi ASGI server lazımdır.
fast →
pip install "uvicorn[standard]"
restart ↻
Nümunə
Kodu yaradaq
main.py
adlı fayl yaradaq və ona aşağıdakı kodu yerləşdirək:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Və ya
async def
...
Əgər kodunuzda
async
və ya
await
vardırsa
async def
istifadə edə bilərik:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Qeyd
:
Əgər bu mövzu haqqında məlumatınız yoxdursa
async
və
await
sənədindəki
"Tələsirsən?"
bölməsinə baxa bilərsiniz.
Kodu işə salaq
Serveri aşağıdakı əmr ilə işə salaq:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
uvicorn main:app --reload
əmri haqqında...
uvicorn main:app
əmri aşağıdakılara instinad edir:
main
:
main.py
faylı (yəni Python "modulu").
app
:
main.py
faylında
app = FastAPI()
sətrində yaratdığımız
FastAPI
obyektidir.
--reload
: kod dəyişikliyindən sonra avtomatik olaraq serveri yenidən işə salır. Bu parametrdən yalnız development mərhələsində istifadə etməliyik.
İndi yoxlayaq
Bu linki brauzerimizdə açaq
http://127.0.0.1:8000/items/5?q=somequery
.
Aşağıdakı kimi bir JSON cavabı görəcəksiniz:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Siz artıq bir API yaratmısınız, hansı ki:
/
və
/items/{item_id}
yollarında
HTTP sorğularını qəbul edir.
Hər iki
yolda
GET
əməliyyatlarını
(həmçinin HTTP
metodları
kimi bilinir) aparır.
/items/{item_id}
yolu
item_id
adlı
int
qiyməti almalı olan
yol parametrinə
sahibdir.
/items/{item_id}
yolunun
q
adlı yol parametri var və bu parametr istəyə bağlı olsa da,
str
qiymətini almalıdır.
İnteraktiv API Sənədləri
İndi
http://127.0.0.1:8000/docs
ünvanına daxil olun.
Avtomatik interaktiv API sənədlərini görəcəksiniz (
Swagger UI
tərəfindən təmin edilir):
Alternativ API sənədləri
İndi isə
http://127.0.0.1:8000/redoc
ünvanına daxil olun.
ReDoc
tərəfindən təqdim edilən avtomatik sənədləri görəcəksiniz:
Nümunəni Yeniləyək
İndi gəlin
main.py
faylını
PUT
sorğusu ilə birlikdə
gövdə
qəbul edəcək şəkildə dəyişdirək.
Pydantic sayəsində standart Python tiplərindən istifadə edərək
gövdə
ni müəyyən edək.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Server avtomatik olaraq yenidən işə salınmalı idi (çünki biz yuxarıda
uvicorn
əmri ilə
--reload
parametrindən istifadə etmişik).
İnteraktiv API sənədlərindəki dəyişikliyə baxaq
Yenidən
http://127.0.0.1:8000/docs
ünvanına daxil olun.
İnteraktiv API sənədləri yeni gövdə də daxil olmaq ilə avtomatik olaraq yenilənəcək:
"Try it out" düyməsini klikləyin, bu, parametrləri doldurmağa və API ilə birbaşa əlaqə saxlamağa imkan verir:
Sonra "Execute" düyməsini klikləyin, istifadəçi interfeysi API ilə əlaqə quracaq, parametrləri göndərəcək, nəticələri əldə edəcək və onları ekranda göstərəcək:
Alternativ API Sənədlərindəki Dəyişikliyə Baxaq
İndi isə yenidən
http://127.0.0.1:8000/redoc
ünvanına daxil olun.
Alternativ sənədlər həm də yeni sorğu parametri və gövdəsini əks etdirəcək:
Xülasə
Ümumiləşdirsək, parametrlər, gövdə və s. Biz məlumat növlərini
bir dəfə
funksiya parametrləri kimi təyin edirik.
Bunu standart müasir Python tipləri ilə edirsiniz.
Yeni sintaksis, müəyyən bir kitabxananın metodlarını və ya siniflərini və s. öyrənmək məcburiyyətində deyilsiniz.
Sadəcə standart
Python
.
Məsələn,
int
üçün:
item_id
:
int
və ya daha mürəkkəb
Item
modeli üçün:
item
:
Item
...və yalnız parametr tipini təyin etməklə bunları əldə edirsiniz:
Redaktor dəstəyi ilə:
Avtomatik tamamlama.
Tip yoxlanması.
Məlumatların Təsdiqlənməsi:
Məlumat etibarsız olduqda avtomatik olaraq aydın xətalar göstərir.
Hətta çox dərin JSON obyektlərində belə doğrulama aparır.
Daxil olan məlumatları
çevirmək
üçün aşağıdakı məlumat növlərindən istifadə edilir:
JSON.
Yol
parametrləri.
Sorğu
parametrləri.
Çərəzlər
.
Başlıqlaq
.
Formalar
.
Fayllar.
Daxil olan məlumatları
çevirmək
üçün aşağıdakı məlumat növlərindən istifadə edilir (JSON olaraq):
Python tiplərinin (
str
,
int
,
float
,
bool
,
list
, və s) çevrilməsi.
datetime
obyektləri.
UUID
obyektləri.
Verilənlər bazası modelləri.
və daha çoxu...
2 alternativ istifadəçi interfeysi daxil olmaqla avtomatik interaktiv API sənədlərini təmin edir:
Swagger UI.
ReDoc.
Gəlin əvvəlki nümunəyə qayıdaq və
FastAPI
-nin nələr edəcəyinə nəzər salaq:
GET
və
PUT
sorğuları üçün
item_id
-nin
yolda
olub-olmadığını yoxlayacaq.
item_id
-nin
GET
və
PUT
sorğuları üçün növünün
int
olduğunu yoxlayacaq.
Əgər
int
deyilsə, səbəbini göstərən bir xəta mesajı göstərəcəkdir.
məcburi olmayan
q
parametrinin
GET
(
http://127.0.0.1:8000/items/foo?q=somequery
burdakı kimi) sorğusu içərisində olub olmadığını yoxlayacaq.
q
parametrini
= None
ilə yaratdığımız üçün,
məcburi olmayan
parametr olacaq.
Əgər
None
olmasaydı, bu məcburi parametr olardı (
PUT
metodunun gövdəsində olduğu kimi).
PUT
sorğusu üçün,
/items/{item_id}
gövdəsini JSON olaraq oxuyacaq:
name
adında məcburi bir parametr olub olmadığını və əgər varsa, tipinin
str
olub olmadığını yoxlayacaq.
price
adında məcburi bir parametr olub olmadığını və əgər varsa, tipinin
float
olub olmadığını yoxlayacaq.
is_offer
adında
məcburi olmayan
bir parametr olub olmadığını və əgər varsa, tipinin
float
olub olmadığını yoxlayacaq.
Bütün bunlar ən dərin JSON obyektlərində belə işləyəcək.
Məlumatların JSON-a və JSON-un Python obyektinə çevrilməsi avtomatik həyata keçiriləcək.
Hər şeyi OpenAPI ilə uyğun olacaq şəkildə avtomatik olaraq sənədləşdirəcək və onları aşağıdakı kimi istifadə edə biləcək:
İnteraktiv sənədləşmə sistemləri.
Bir çox proqramlaşdırma dilləri üçün avtomatlaşdırılmış
müştəri
kodu yaratma sistemləri.
2 interaktiv sənədləşmə veb interfeysini birbaşa təmin edəcək.
Yeni başlamışıq, amma siz artıq işin məntiqini başa düşmüsünüz.
İndi aşağıdakı sətri dəyişdirməyə çalışın:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...bundan:
...
"item_name"
:
item
.
name
...
...buna:
...
"item_price"
:
item
.
price
...
...və redaktorun məlumat tiplərini bildiyini və avtomatik tamaladığını görəcəksiniz:
Daha çox funksiyaya malik daha dolğun nümunə üçün
Öyrədici - İstifadəçi Təlimatı
səhifəsinə baxa bilərsiniz.
Spoiler xəbərdarlığı
: Öyrədici - istifadəçi təlimatına bunlar daxildir:
Parametrlərin
,
başlıqlar
,
çərəzlər
,
forma sahələri
və
fayllar
olaraq müəyyən edilməsi.
maximum_length
və ya
regex
kimi
doğrulama məhdudiyyətlərinin
necə təyin ediləcəyi.
Çox güclü və istifadəsi asan
Dependency Injection
sistemi.
Təhlükəsizlik və autentifikasiya,
JWT tokenləri
ilə
OAuth2
dəstəyi və
HTTP Basic
autentifikasiyası.
çox dərin JSON modellərini
müəyyən etmək üçün daha irəli səviyyə (lakin eyni dərəcədə asan) üsullar (Pydantic sayəsində).
Strawberry
və digər kitabxanalar ilə
GraphQL
inteqrasiyası.
Digər əlavə xüsusiyyətlər (Starlette sayəsində):
WebSockets
HTTPX və
pytest
sayəsində çox asan testlər
CORS
Cookie Sessions
...və daha çoxu.
Performans
Müstəqil TechEmpower meyarları göstərir ki, Uvicorn üzərində işləyən
FastAPI
proqramları
ən sürətli Python kitabxanalarından biridir
, yalnız Starlette və Uvicorn-un özündən yavaşdır, ki FastAPI bunların üzərinə qurulmuş bir framework-dür. (*)
Ətraflı məlumat üçün bu bölməyə nəzər salın
Müqayisələr
.
Məcburi Olmayan Tələblər
Pydantic tərəfindən istifadə olunanlar:
email-validator
- e-poçtun yoxlanılması üçün.
pydantic-settings
- parametrlərin idarə edilməsi üçün.
pydantic-extra-types
- Pydantic ilə istifadə edilə bilən əlavə tiplər üçün.
Starlette tərəfindən istifadə olunanlar:
httpx
- Əgər
TestClient
strukturundan istifadə edəcəksinizsə, tələb olunur.
jinja2
- Standart
şablon
konfiqurasiyasından istifadə etmək istəyirsinizsə, tələb olunur.
python-multipart
-
request.form()
ilə forma
"çevirmə"
dəstəyindən istifadə etmək istəyirsinizsə, tələb olunur.
itsdangerous
-
SessionMiddleware
dəstəyi üçün tələb olunur.
pyyaml
-
SchemaGenerator
dəstəyi üçün tələb olunur (Çox güman ki, FastAPI istifadə edərkən buna ehtiyacınız olmayacaq).
ujson
-
UJSONResponse
istifadə etmək istəyirsinizsə, tələb olunur.
Həm FastAPI, həm də Starlette tərəfindən istifadə olunur:
uvicorn
- Yaratdığımız proqramı servis edəcək veb server kimi fəaliyyət göstərir.
orjson
-
ORJSONResponse
istifadə edəcəksinizsə tələb olunur.
Bütün bunları
pip install fastapi[all]
ilə quraşdıra bilərsiniz.
Lisenziya
Bu layihə MIT lisenziyasının şərtlərinə əsasən lisenziyalaşdırılıb.

## 035_BENCHMARKS
Benchmarks¶
---

Benchmarks
Independent TechEmpower benchmarks show
FastAPI
applications running under Uvicorn as
one of the fastest Python frameworks available
, only below Starlette and Uvicorn themselves (used internally by FastAPI).
But when checking benchmarks and comparisons you should keep the following in mind.
Benchmarks and speed
When you check the benchmarks, it is common to see several tools of different types compared as equivalent.
Specifically, to see Uvicorn, Starlette and FastAPI compared together (among many other tools).
The simpler the problem solved by the tool, the better performance it will get. And most of the benchmarks don't test the additional features provided by the tool.
The hierarchy is like:
Uvicorn
: an ASGI server
Starlette
: (uses Uvicorn) a web microframework
FastAPI
: (uses Starlette) an API microframework with several additional features for building APIs, with data validation, etc.
Uvicorn
:
Will have the best performance, as it doesn't have much extra code apart from the server itself.
You wouldn't write an application in Uvicorn directly. That would mean that your code would have to include more or less, at least, all the code provided by Starlette (or
FastAPI
). And if you did that, your final application would have the same overhead as having used a framework and minimizing your app code and bugs.
If you are comparing Uvicorn, compare it against Daphne, Hypercorn, uWSGI, etc. Application servers.
Starlette
:
Will have the next best performance, after Uvicorn. In fact, Starlette uses Uvicorn to run. So, it probably can only get "slower" than Uvicorn by having to execute more code.
But it provides you the tools to build simple web applications, with routing based on paths, etc.
If you are comparing Starlette, compare it against Sanic, Flask, Django, etc. Web frameworks (or microframeworks).
FastAPI
:
The same way that Starlette uses Uvicorn and cannot be faster than it,
FastAPI
uses Starlette, so it cannot be faster than it.
FastAPI provides more features on top of Starlette. Features that you almost always need when building APIs, like data validation and serialization. And by using it, you get automatic documentation for free (the automatic documentation doesn't even add overhead to running applications, it is generated on startup).
If you didn't use FastAPI and used Starlette directly (or another tool, like Sanic, Flask, Responder, etc) you would have to implement all the data validation and serialization yourself. So, your final application would still have the same overhead as if it was built using FastAPI. And in many cases, this data validation and serialization is the biggest amount of code written in applications.
So, by using FastAPI you are saving development time, bugs, lines of code, and you would probably get the same performance (or better) you would if you didn't use it (as you would have to implement it all in your code).
If you are comparing FastAPI, compare it against a web application framework (or set of tools) that provides data validation, serialization and documentation, like Flask-apispec, NestJS, Molten, etc. Frameworks with integrated automatic data validation, serialization and documentation.

## 036_BN
FastAPI
FastAPI উচ্চক্ষমতা সম্পন্ন, সহজে শেখার এবং দ্রুত কোড করে প্রোডাকশনের জন্য ফ্রামওয়ার্ক।
নির্দেশিকা নথি
:
https://fastapi.tiangolo.com
সোর্স কোড
:
https://github.com/fastapi/fastapi
FastAPI একটি আধুনিক, দ্রুত ( বেশি ক্ষমতা ) সম্পন্ন, Python 3.6+ দিয়ে API তৈরির জন্য স্ট্যান্ডার্ড পাইথন টাইপ ইঙ্গিত ভিত্তিক ওয়েব ফ্রেমওয়ার্ক।
এর মূল বৈশিষ্ট্য গুলো হলঃ
গতি
: এটি
NodeJS
এবং
Go
এর মত কার্যক্ষমতা সম্পন্ন (Starlette এবং Pydantic এর সাহায্যে)।
পাইথন এর দ্রুততম ফ্রেমওয়ার্ক গুলোর মধ্যে এটি একটি
।
দ্রুত কোড করা
:বৈশিষ্ট্য তৈরির গতি ২০০% থেকে ৩০০% বৃদ্ধি করে৷ *
স্বল্প bugs
: মানুব (ডেভেলপার) সৃষ্ট ত্রুটির প্রায় ৪০% হ্রাস করে। *
স্বজ্ঞাত
: দুর্দান্ত এডিটর সাহায্য
Completion
নামেও পরিচিত। দ্রুত ডিবাগ করা যায়।
সহজ
: এটি এমন ভাবে সজানো হয়েছে যেন নির্দেশিকা নথি পড়ে সহজে শেখা এবং ব্যবহার করা যায়।
সংক্ষিপ্ত
: কোড পুনরাবৃত্তি কমানোর পাশাপাশি, bug কমায় এবং প্রতিটি প্যারামিটার ঘোষণা থেকে একাধিক ফিচার পাওয়া যায় ।
জোরালো
: স্বয়ংক্রিয় ভাবে তৈরি ক্রিয়াশীল নির্দেশনা নথি (documentation) সহ উৎপাদন উপযোগি (Production-ready) কোড পাওয়া যায়।
মান-ভিত্তিক
: এর ভিত্তি
OpenAPI
(যা পুর্বে Swagger নামে পরিচিত ছিল) এবং
JSON Schema
এর আদর্শের মানের ওপর
* উৎপাদনমুখি এপ্লিকেশন বানানোর এক দল ডেভেলপার এর মতামত ভিত্তিক ফলাফল।
স্পনসর গণ
অন্যান্য স্পনসর গণ
মতামত সমূহ
"
আমি আজকাল
FastAPI
ব্যবহার করছি। [...] আমরা ভাবছি মাইক্রোসফ্টে
ML সার্ভিস
এ সকল দলের জন্য এটি ব্যবহার করব। যার মধ্যে কিছু পণ্য
Windows
এ সংযোযন হয় এবং কিছু
Office
এর সাথে সংযোযন হচ্ছে।
"
কবির খান -
মাইক্রোসফ্টে
(ref)
"
আমরা
FastAPI
লাইব্রেরি গ্রহণ করেছি একটি
REST
সার্ভার তৈরি করতে, যা
ভবিষ্যদ্বাণী
পাওয়ার জন্য কুয়েরি করা যেতে পারে। [লুডউইগের জন্য]
"
পিয়েরো মোলিনো, ইয়ারোস্লাভ দুদিন, এবং সাই সুমন্থ মিরিয়ালা -
উবার
(ref)
"
Netflix
আমাদের
ক্রাইসিস ম্যানেজমেন্ট
অর্কেস্ট্রেশন ফ্রেমওয়ার্ক:
ডিসপ্যাচ
এর ওপেন সোর্স রিলিজ ঘোষণা করতে পেরে আনন্দিত! [যাকিনা
FastAPI
দিয়ে নির্মিত]
"
কেভিন গ্লিসন, মার্ক ভিলানোভা, ফরেস্ট মনসেন -
নেটফ্লিক্স
(ref)
"
আমি
FastAPI
নিয়ে চাঁদের সমান উৎসাহিত। এটি খুবই মজার!
"
ব্রায়ান ওকেন -
পাইথন বাইটস
পডকাস্ট হোস্ট
(ref)
"_সত্যিই, আপনি যা তৈরি করেছেন তা খুব মজবুত এবং পরিপূর্ন৷ অনেক উপায়ে, আমি যা
Hug
এ করতে চেয়েছিলাম - তা কাউকে তৈরি করতে দেখে আমি সত্যিই অনুপ্রানিত৷_"
টিমোথি ক্রসলে -
Hug
স্রষ্টা
(ref)
"আপনি যদি REST API তৈরির জন্য একটি
আধুনিক ফ্রেমওয়ার্ক
শিখতে চান, তাহলে
FastAPI
দেখুন [...] এটি দ্রুত, ব্যবহার করা সহজ এবং শিখতেও সহজ [...]_"
"
আমরা আমাদের
APIs
[...] এর জন্য
FastAPI
- তে এসেছি [...] আমি মনে করি আপনিও এটি পছন্দ করবেন [...]
"
ইনেস মন্টানি - ম্যাথিউ হোনিবাল -
Explosion AI
প্রতিষ্ঠাতা -
spaCy
স্রষ্টা
(ref)
-
(ref)
Typer
, CLI এর জন্য FastAPI
আপনি যদি
CLI
অ্যাপ বানাতে চান, যা কিনা ওয়েব API এর পরিবর্তে টার্মিনালে ব্যবহার হবে, তাহলে দেখুন
Typer
.
টাইপার
হল FastAPI এর ছোট ভাইয়ের মত। এবং এটির উদ্দেশ্য ছিল
CLIs এর FastAPI
হওয়া। ⌨️ 🚀
প্রয়োজনীয়তা গুলো
Python 3.7+
FastAPI কিছু দানবেদের কাঁধে দাঁড়িয়ে আছে:
Starlette
ওয়েব অংশের জন্য.
Pydantic
ডেটা অংশগুলির জন্য.
ইনস্টলেশন প্রক্রিয়া
fast →
pip install fastapi
restart ↻
আপনার একটি ASGI সার্ভারেরও প্রয়োজন হবে, প্রোডাকশনের জন্য
Uvicorn
অথবা
Hypercorn
.
fast →
pip install "uvicorn[standard]"
restart ↻
উদাহরণ
তৈরি
main.py
নামে একটি ফাইল তৈরি করুন:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
অথবা ব্যবহার করুন
async def
...
যদি আপনার কোড
async
/
await
, ব্যবহার করে তাহলে
async def
ব্যবহার করুন:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
টীকা
:
আপনি যদি না জানেন,
"তাড়াহুড়ো?"
বিভাগটি দেখুন
async
এবং
await
নথির মধ্যে দেখুন
.
এটি চালান
সার্ভার চালু করুন:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
নির্দেশনা সম্পর্কে
uvicorn main:app --reload
...
uvicorn main:app
নির্দেশনাটি দ্বারা বোঝায়:
main
: ফাইল
main.py
(পাইথন "মডিউল")।
app
:
app = FastAPI()
লাইন দিয়ে
main.py
এর ভিতরে তৈরি করা অবজেক্ট।
--reload
: কোড পরিবর্তনের পরে সার্ভার পুনরায় চালু করুন। এটি শুধুমাত্র ডেভেলপমেন্ট এর সময় ব্যবহার করুন।
এটা চেক করুন
আপনার ব্রাউজার খুলুন
http://127.0.0.1:8000/items/5?q=somequery
এ।
আপনি JSON রেসপন্স দেখতে পাবেন:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
আপনি ইতিমধ্যে একটি API তৈরি করেছেন যা:
/
এবং
/items/{item_id}
paths
এ HTTP অনুরোধ গ্রহণ করে।
উভয়
path
ই
GET
অপারেশন
নেয় ( যা HTTP
methods
নামেও পরিচিত)।
path
/items/{item_id}
-এ একটি
path প্যারামিটার
item_id
আছে যা কিনা
int
হতে হবে।
path
/items/{item_id}
-এর একটি ঐচ্ছিক
str
query প্যারামিটার
q
আছে।
ক্রিয়াশীল API নির্দেশিকা নথি
এখন যান
http://127.0.0.1:8000/docs
.
আপনি স্বয়ংক্রিয় ভাবে প্রস্তুত ক্রিয়াশীল API নির্দেশিকা নথি দেখতে পাবেন (
Swagger UI
প্রদত্ত):
বিকল্প API নির্দেশিকা নথি
এবং এখন
http://127.0.0.1:8000/redoc
এ যান.
আপনি স্বয়ংক্রিয় ভাবে প্রস্তুত বিকল্প নির্দেশিকা নথি দেখতে পাবেন (
ReDoc
প্রদত্ত):
উদাহরণস্বরূপ আপগ্রেড
এখন
main.py
ফাইলটি পরিবর্তন করুন যেন এটি
PUT
রিকুয়েস্ট থেকে বডি পেতে পারে।
Python স্ট্যান্ডার্ড লাইব্রেরি, Pydantic এর সাহায্যে বডি ঘোষণা করুন।
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
সার্ভারটি স্বয়ংক্রিয়ভাবে পুনরায় লোড হওয়া উচিত (কারণ আপনি উপরের
uvicorn
কমান্ডে
--reload
যোগ করেছেন)।
ক্রিয়াশীল API নির্দেশিকা নথি উন্নীতকরণ
এখন
http://127.0.0.1:8000/docs
এডড্রেসে যান.
ক্রিয়াশীল API নির্দেশিকা নথিটি স্বয়ংক্রিয়ভাবে উন্নীত হযে যাবে, নতুন বডি সহ:
"Try it out" বাটনে চাপুন, এটি আপনাকে পেরামিটারগুলো পূরণ করতে এবং API এর সাথে সরাসরি ক্রিয়া-কলাপ করতে দিবে:
তারপরে "Execute" বাটনে চাপুন, ব্যবহারকারীর ইন্টারফেস আপনার API এর সাথে যোগাযোগ করবে, পেরামিটার পাঠাবে, ফলাফলগুলি পাবে এবং সেগুলি পর্রদায় দেখাবে:
বিকল্প API নির্দেশিকা নথি আপগ্রেড
এবং এখন
http://127.0.0.1:8000/redoc
এ যান।
বিকল্প নির্দেশিকা নথিতেও নতুন কুয়েরি প্যারামিটার এবং বডি প্রতিফলিত হবে:
সংক্ষিপ্তকরণ
সংক্ষেপে, আপনি
শুধু একবার
প্যারামিটারের ধরন, বডি ইত্যাদি ফাংশন প্যারামিটার হিসেবে ঘোষণা করেন।
আপনি সেটি আধুনিক পাইথনের সাথে করেন।
আপনাকে নতুন করে নির্দিষ্ট কোন লাইব্রেরির বাক্য গঠন, ফাংশন বা ক্লাস কিছুই শিখতে হচ্ছে না।
শুধুই আধুনিক
Python 3.6+
উদাহরণস্বরূপ,
int
এর জন্য:
item_id
:
int
অথবা আরও জটিল
Item
মডেলের জন্য:
item
:
Item
...এবং সেই একই ঘোষণার সাথে আপনি পাবেন:
এডিটর সাহায্য, যেমন
সমাপ্তি।
ধরণ যাচাই
তথ্য যাচাইকরণ:
ডেটা অবৈধ হলে স্বয়ংক্রিয় এবং পরিষ্কার ত্রুটির নির্দেশনা।
এমনকি গভীরভাবে নেস্ট করা JSON অবজেক্টের জন্য বৈধতা।
প্রেরিত তথ্য
রূপান্তর
: যা নেটওয়ার্ক থেকে পাইথনের তথ্য এবং ধরনে আসে, এবং সেখান থেকে পড়া:
JSON।
পাথ প্যারামিটার।
কুয়েরি প্যারামিটার।
কুকিজ
হেডার
ফর্ম
ফাইল
আউটপুট ডেটার
রূপান্তর
: পাইথন ডেটা এবং টাইপ থেকে নেটওয়ার্ক ডেটাতে রূপান্তর করা (JSON হিসাবে):
-পাইথন টাইপে রূপান্তর করুন (
str
,
int
,
float
,
bool
,
list
, ইত্যাদি)।
datetime
অবজেক্ট।
UUID
objeঅবজেক্টcts।
ডাটাবেস মডেল।
...এবং আরো অনেক।
স্বয়ংক্রিয় ক্রিয়াশীল API নির্দেশিকা নথি, 2টি বিকল্প ব্যবহারকারীর ইন্টারফেস সহ:
সোয়াগার ইউ আই (Swagger UI)।
রিডক (ReDoc)।
পূর্ববর্তী কোড উদাহরণে ফিরে আসা যাক,
FastAPI
যা করবে:
GET
এবং
PUT
অনুরোধের জন্য পথে
item_id
আছে কিনা তা যাচাই করবে।
GET
এবং
PUT
অনুরোধের জন্য
item_id
টাইপ
int
এর হতে হবে তা যাচাই করবে।
যদি না হয় তবে ক্লায়েন্ট একটি উপযুক্ত, পরিষ্কার ত্রুটি দেখতে পাবেন।
GET
অনুরোধের জন্য একটি ঐচ্ছিক ক্যুয়েরি প্যারামিটার নামক
q
(যেমন
http://127.0.0.1:8000/items/foo?q=somequery
) আছে কি তা চেক করবে।
যেহেতু
q
প্যারামিটারটি
= None
দিয়ে ঘোষণা করা হয়েছে, তাই এটি ঐচ্ছিক।
None
ছাড়া এটি প্রয়োজনীয় হতো (যেমন
PUT
এর ক্ষেত্রে হয়েছে)।
/items/{item_id}
এর জন্য
PUT
অনুরোধের বডি JSON হিসাবে পড়ুন:
লক্ষ করুন,
name
একটি প্রয়োজনীয় অ্যাট্রিবিউট হিসাবে বিবেচনা করেছে এবং এটি
str
হতে হবে।
লক্ষ করুন এখানে,
price
অ্যাট্রিবিউটটি আবশ্যক এবং এটি
float
হতে হবে।
লক্ষ করুন
is_offer
একটি ঐচ্ছিক অ্যাট্রিবিউট এবং এটি
bool
হতে হবে যদি উপস্থিত থাকে।
এই সবটি গভীরভাবে অবস্থানরত JSON অবজেক্টগুলিতেও কাজ করবে।
স্বয়ংক্রিয়ভাবে JSON হতে এবং JSON থেকে কনভার্ট করুন।
OpenAPI দিয়ে সবকিছু ডকুমেন্ট করুন, যা ব্যবহার করা যেতে পারে:
ক্রিয়াশীল নির্দেশিকা নথি।
অনেক ভাষার জন্য স্বয়ংক্রিয় ক্লায়েন্ট কোড তৈরির ব্যবস্থা।
সরাসরি 2টি ক্রিয়াশীল নির্দেশিকা নথি ওয়েব পৃষ্ঠ প্রদান করা হয়েছে।
আমরা এতক্ষন শুধু এর পৃষ্ঠ তৈরি করেছি, কিন্তু আপনি ইতমধ্যেই এটি কিভাবে কাজ করে তার ধারণাও পেয়ে গিয়েছেন।
নিম্নোক্ত লাইন গুলো পরিবর্তন করার চেষ্টা করুন:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...পুর্বে:
...
"item_name"
:
item
.
name
...
...পরবর্তীতে:
...
"item_price"
:
item
.
price
...
...এবং দেখুন কিভাবে আপনার এডিটর উপাদানগুলোকে সয়ংক্রিয়ভাবে-সম্পন্ন করবে এবং তাদের ধরন জানতে পারবে:
আরও বৈশিষ্ট্য সম্পন্ন উদাহরণের জন্য, দেখুন
টিউটোরিয়াল - ব্যবহারকারীর গাইড
.
স্পয়লার সতর্কতা
: টিউটোরিয়াল - ব্যবহারকারীর গাইড নিম্নোক্ত বিষয়গুলি অন্তর্ভুক্ত করে:
হেডার
,
কুকিজ
,
ফর্ম ফিল্ড
এবং
ফাইলগুলি
এমন অন্যান্য জায়গা থেকে প্যারামিটার ঘোষণা করা।
maximum_length
বা
regex
এর মতো
যাচাইকরণ বাধামুক্তি
সেট করা হয় কিভাবে, তা নিয়ে আলোচনা করা হবে।
একটি খুব শক্তিশালী এবং ব্যবহার করা সহজ
ডিপেন্ডেন্সি ইনজেকশন
পদ্ধতি
OAuth2
এবং
JWT টোকেন
এবং
HTTP Basic
auth সহ নিরাপত্তা এবং অনুমোদনপ্রাপ্তি সম্পর্কিত বিষয়সমূহের উপর।
গভীরভাবে অবস্থানরত JSON মডেল
ঘোষণা করার জন্য আরও উন্নত (কিন্তু সমান সহজ) কৌশল (Pydantic কে ধন্যবাদ)।
আরো অতিরিক্ত বৈশিষ্ট্য (স্টারলেটকে ধন্যবাদ) হিসাবে:
WebSockets
GraphQL
HTTPX এবং
pytest
ভিত্তিক অত্যন্ত সহজ পরীক্ষা
CORS
Cookie Sessions
...এবং আরো।
কর্মক্ষমতা
স্বাধীন TechEmpower Benchmarks দেখায় যে
FastAPI
অ্যাপ্লিকেশনগুলি Uvicorn-এর অধীনে চলমান দ্রুততম
পাইথন ফ্রেমওয়ার্কগুলির মধ্যে একটি,
শুধুমাত্র Starlette এবং Uvicorn-এর পর (FastAPI দ্বারা অভ্যন্তরীণভাবে ব্যবহৃত)। (*)
এটি সম্পর্কে আরও বুঝতে, দেখুন
Benchmarks
.
ঐচ্ছিক নির্ভরশীলতা
Pydantic দ্বারা ব্যবহৃত:
email-validator
- ইমেল যাচাইকরণের জন্য।
স্টারলেট দ্বারা ব্যবহৃত:
httpx
- আপনি যদি
TestClient
ব্যবহার করতে চান তাহলে আবশ্যক।
jinja2
- আপনি যদি প্রদত্ত টেমপ্লেট রূপরেখা ব্যবহার করতে চান তাহলে প্রয়োজন।
python-multipart
- আপনি যদি ফর্ম সহায়তা করতে চান তাহলে প্রয়োজন
"parsing"
,
request.form()
সহ।
itsdangerous
-
SessionMiddleware
সহায়তার জন্য প্রয়োজন।
pyyaml
- স্টারলেটের SchemaGenerator সাপোর্ট এর জন্য প্রয়োজন (আপনার সম্ভাবত FastAPI প্রয়োজন নেই)।
graphene
-
GraphQLApp
সহায়তার জন্য প্রয়োজন।
FastAPI / Starlette দ্বারা ব্যবহৃত:
uvicorn
- সার্ভারের জন্য যা আপনার অ্যাপ্লিকেশন লোড করে এবং পরিবেশন করে।
orjson
- আপনি
ORJSONResponse
ব্যবহার করতে চাইলে প্রয়োজন।
ujson
- আপনি
UJSONResponse
ব্যবহার করতে চাইলে প্রয়োজন।
আপনি এই সব ইনস্টল করতে পারেন
pip install fastapi[all]
দিয়ে.
লাইসেন্স
এই প্রজেক্ট MIT লাইসেন্স নীতিমালার অধীনে শর্তায়িত।

## 037_CONTRIBUTING
Development - Contributing¶
---

Development - Contributing
First, you might want to see the basic ways to
help FastAPI and get help
.
Developing
If you already cloned the
fastapi repository
and you want to deep dive in the code, here are some guidelines to set up your environment.
Virtual environment
Follow the instructions to create and activate a
virtual environment
for the internal code of
fastapi
.
Install requirements using pip
After activating the environment, install the required packages:
fast →
pip install -r requirement
It will install all the dependencies and your local FastAPI in your local environment.
Using your local FastAPI
If you create a Python file that imports and uses FastAPI, and run it with the Python from your local environment, it will use your cloned local FastAPI source code.
And if you update that local FastAPI source code when you run that Python file again, it will use the fresh version of FastAPI you just edited.
That way, you don't have to "install" your local version to be able to test every change.
Technical Details
This only happens when you install using this included
requirements.txt
instead of running
pip install fastapi
directly.
That is because inside the
requirements.txt
file, the local version of FastAPI is marked to be installed in "editable" mode, with the
-e
option.
Format the code
There is a script that you can run that will format and clean all your code:
fast →
bash scripts/format.sh
restart ↻
It will also auto-sort all your imports.
Tests
There is a script that you can run locally to test all the code and generate coverage reports in HTML:
fast →
bash scripts/test-cov-html.sh
restart ↻
This command generates a directory
./htmlcov/
, if you open the file
./htmlcov/index.html
in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.
Docs
First, make sure you set up your environment as described above, that will install all the requirements.
Docs live
During local development, there is a script that builds the site and checks for any changes, live-reloading:
fast →
python ./scripts/docs.py live
[INFO]
Serving on http://127.0.0.1:8008
[INFO]
Start watching changes
[INFO]
Start detecting changes
restart ↻
It will serve the documentation on
http://127.0.0.1:8008
.
That way, you can edit the documentation/source files and see the changes live.
Tip
Alternatively, you can perform the same steps that scripts does manually.
Go into the language directory, for the main docs in English it's at
docs/en/
:
$
cd
docs/en/
Then run
mkdocs
in that directory:
$
mkdocs
serve
--dev-addr
127
.0.0.1:8008
Typer CLI (optional)
The instructions here show you how to use the script at
./scripts/docs.py
with the
python
program directly.
But you can also use
Typer CLI
, and you will get autocompletion in your terminal for the commands after installing completion.
If you install Typer CLI, you can install completion with:
fast →
typer --install-completion
zsh completion installed in /home/user/.bashrc.
Completion will take effect once you restart the terminal.
restart ↻
Docs Structure
The documentation uses
MkDocs
.
And there are extra tools/scripts in place to handle translations in
./scripts/docs.py
.
Tip
You don't need to see the code in
./scripts/docs.py
, you just use it in the command line.
All the documentation is in Markdown format in the directory
./docs/en/
.
Many of the tutorials have blocks of code.
In most of the cases, these blocks of code are actual complete applications that can be run as is.
In fact, those blocks of code are not written inside the Markdown, they are Python files in the
./docs_src/
directory.
And those Python files are included/injected in the documentation when generating the site.
Docs for tests
Most of the tests actually run against the example source files in the documentation.
This helps to make sure that:
The documentation is up-to-date.
The documentation examples can be run as is.
Most of the features are covered by the documentation, ensured by test coverage.
Apps and docs at the same time
If you run the examples with, e.g.:
fast →
fastapi dev tutorial001.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
as Uvicorn by default will use the port
8000
, the documentation on port
8008
won't clash.
Translations
Help with translations is VERY MUCH appreciated! And it can't be done without the help from the community. 🌎 🚀
Here are the steps to help with translations.
Tips and guidelines
Check the currently
existing pull requests
for your language. You can filter the pull requests by the ones with the label for your language. For example, for Spanish, the label is
lang-es
.
Review those pull requests, requesting changes or approving them. For the languages I don't speak, I'll wait for several others to review the translation before merging.
Tip
You can
add comments with change suggestions
to existing pull requests.
Check the docs about
adding a pull request review
to approve it or request changes.
Check if there's a
GitHub Discussion
to coordinate translations for your language. You can subscribe to it, and when there's a new pull request to review, an automatic comment will be added to the discussion.
If you translate pages, add a single pull request per page translated. That will make it much easier for others to review it.
To check the 2-letter code for the language you want to translate, you can use the table
List of ISO 639-1 codes
.
Existing language
Let's say you want to translate a page for a language that already has translations for some pages, like Spanish.
In the case of Spanish, the 2-letter code is
es
. So, the directory for Spanish translations is located at
docs/es/
.
Tip
The main ("official") language is English, located at
docs/en/
.
Now run the live server for the docs in Spanish:
fast →
💬 Use the command "live" and pass the language code as a CLI argument
python ./scripts/docs.py live es
[INFO]
Serving on http://127.0.0.1:8008
[INFO]
Start watching changes
[INFO]
Start detecting changes
restart ↻
Tip
Alternatively, you can perform the same steps that scripts does manually.
Go into the language directory, for the Spanish translations it's at
docs/es/
:
$
cd
docs/es/
Then run
mkdocs
in that directory:
$
mkdocs
serve
--dev-addr
127
.0.0.1:8008
Now you can go to
http://127.0.0.1:8008
and see your changes live.
You will see that every language has all the pages. But some pages are not translated and have an info box at the top, about the missing translation.
Now let's say that you want to add a translation for the section
Features
.
Copy the file at:
docs/en/docs/features.md
Paste it in exactly the same location but for the language you want to translate, e.g.:
docs/es/docs/features.md
Tip
Notice that the only change in the path and file name is the language code, from
en
to
es
.
If you go to your browser you will see that now the docs show your new section (the info box at the top is gone). 🎉
Now you can translate it all and see how it looks as you save the file.
Don't Translate these Pages
🚨 Don't translate:
Files under
reference/
release-notes.md
fastapi-people.md
external-links.md
newsletter.md
management-tasks.md
management.md
contributing.md
Some of these files are updated very frequently and a translation would always be behind, or they include the main content from English source files, etc.
New Language
Let's say that you want to add translations for a language that is not yet translated, not even some pages.
Let's say you want to add translations for Creole, and it's not yet there in the docs.
Checking the link from above, the code for "Creole" is
ht
.
The next step is to run the script to generate a new translation directory:
fast →
💬 Use the command new-lang, pass the language code as a CLI argument
python ./scripts/docs.py new-lang ht
Successfully initialized: docs/ht
restart ↻
Now you can check in your code editor the newly created directory
docs/ht/
.
That command created a file
docs/ht/mkdocs.yml
with a simple config that inherits everything from the
en
version:
INHERIT
:
../en/mkdocs.yml
Tip
You could also simply create that file with those contents manually.
That command also created a dummy file
docs/ht/index.md
for the main page, you can start by translating that one.
You can continue with the previous instructions for an "Existing Language" for that process.
You can make the first pull request with those two files,
docs/ht/mkdocs.yml
and
docs/ht/index.md
. 🎉
Preview the result
As already mentioned above, you can use the
./scripts/docs.py
with the
live
command to preview the results (or
mkdocs serve
).
Once you are done, you can also test it all as it would look online, including all the other languages.
To do that, first build all the docs:
fast →
💬 Use the command "build-all", this will take a bit
python ./scripts/docs.py build-all
Building docs for: en
Building docs for: es
Successfully built docs for: es
restart ↻
This builds all those independent MkDocs sites for each language, combines them, and generates the final output at
./site/
.
Then you can serve that with the command
serve
:
fast →
💬 Use the command "serve" after running "build-all"
python ./scripts/docs.py serve
Warning: this is a very simple server. For development, use mkdocs serve instead.
This is here only to preview a site with translations already built.
Make sure you run the build-all command first.
Serving at: http://127.0.0.1:8008
restart ↻
Translation specific tips and guidelines
Translate only the Markdown documents (
.md
). Do not translate the code examples at
./docs_src
.
In code blocks within the Markdown document, translate comments (
## a comment
), but leave the rest unchanged.
Do not change anything enclosed in "``" (inline code).
In lines starting with
///
translate only the text part after
|
. Leave the rest unchanged.
You can translate info boxes like
/// warning
with for example
/// warning | Achtung
. But do not change the word immediately after the
///
, it determines the color of the info box.
Do not change the paths in links to images, code files, Markdown documents.
However, when a Markdown document is translated, the
## hash-parts
in links to its headings may change. Update these links if possible.
Search for such links in the translated document using the regex
## [^# ]
.
Search in all documents already translated into your language for
your-translated-document.md
. For example VS Code has an option "Edit" -> "Find in Files".
When translating a document, do not "pre-translate"
## hash-parts
that link to headings in untranslated documents.

## 038_DE
FastAPI¶
---

FastAPI
FastAPI Framework, hochperformant, leicht zu erlernen, schnell zu programmieren, einsatzbereit
Dokumentation
:
https://fastapi.tiangolo.com
Quellcode
:
https://github.com/fastapi/fastapi
FastAPI ist ein modernes, schnelles (hoch performantes) Webframework zur Erstellung von APIs mit Python auf Basis von Standard-Python-Typhinweisen.
Seine Schlüssel-Merkmale sind:
Schnell
: Sehr hohe Leistung, auf Augenhöhe mit
NodeJS
und
Go
(Dank Starlette und Pydantic).
Eines der schnellsten verfügbaren Python-Frameworks
.
Schnell zu programmieren
: Erhöhen Sie die Geschwindigkeit bei der Entwicklung von Funktionen um etwa 200 % bis 300 %. *
Weniger Bugs
: Verringern Sie die von Menschen (Entwicklern) verursachten Fehler um etwa 40 %. *
Intuitiv
: Exzellente Editor-Unterstützung.
Code-Vervollständigung
überall. Weniger Debuggen.
Einfach
: So konzipiert, dass es einfach zu benutzen und zu erlernen ist. Weniger Zeit für das Lesen der Dokumentation.
Kurz
: Minimieren Sie die Verdoppelung von Code. Mehrere Funktionen aus jeder Parameterdeklaration. Weniger Bugs.
Robust
: Erhalten Sie produktionsreifen Code. Mit automatischer, interaktiver Dokumentation.
Standards-basiert
: Basierend auf (und vollständig kompatibel mit) den offenen Standards für APIs:
OpenAPI
(früher bekannt als Swagger) und
JSON Schema
.
* Schätzung auf Basis von Tests in einem internen Entwicklungsteam, das Produktionsanwendungen erstellt.
Sponsoren
Andere Sponsoren
Meinungen
„
[...] Ich verwende
FastAPI
heutzutage sehr oft. [...] Ich habe tatsächlich vor, es für alle
ML-Dienste meines Teams bei Microsoft
zu verwenden. Einige davon werden in das Kernprodukt
Windows
und einige
Office
-Produkte integriert.
“
Kabir Khan -
Microsoft
(Ref)
„
Wir haben die
FastAPI
-Bibliothek genommen, um einen
REST
-Server zu erstellen, der abgefragt werden kann, um
Vorhersagen
zu erhalten. [für Ludwig]
“
Piero Molino, Yaroslav Dudin, und Sai Sumanth Miryala -
Uber
(Ref)
„
Netflix
freut sich, die Open-Source-Veröffentlichung unseres
Krisenmanagement
-Orchestrierung-Frameworks bekannt zu geben:
Dispatch
! [erstellt mit
FastAPI
]
“
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(Ref)
„
Ich bin überglücklich mit
FastAPI
. Es macht so viel Spaß!
“
Brian Okken -
Host des
Python Bytes
Podcast
(Ref)
„
Ehrlich, was Du gebaut hast, sieht super solide und poliert aus. In vielerlei Hinsicht ist es so, wie ich
Hug
haben wollte – es ist wirklich inspirierend, jemanden so etwas bauen zu sehen.
“
Timothy Crosley -
Autor von
Hug
(Ref)
„
Wenn Sie ein
modernes Framework
zum Erstellen von REST-APIs erlernen möchten, schauen Sie sich
FastAPI
an. [...] Es ist schnell, einfach zu verwenden und leicht zu erlernen [...]
“
„
Wir haben zu
FastAPI
für unsere
APIs
gewechselt [...] Ich denke, es wird Ihnen gefallen [...]
“
Ines Montani - Matthew Honnibal -
Gründer von
Explosion AI
- Autoren von
spaCy
(Ref)
-
(Ref)
„
Falls irgendjemand eine Produktions-Python-API erstellen möchte, kann ich
FastAPI
wärmstens empfehlen. Es ist
wunderschön konzipiert
,
einfach zu verwenden
und
hoch skalierbar
; es ist zu einer
Schlüsselkomponente
in unserer API-First-Entwicklungsstrategie geworden und treibt viele Automatisierungen und Dienste an, wie etwa unseren virtuellen TAC-Ingenieur.
“
Deon Pillsbury -
Cisco
(Ref)
Typer
, das FastAPI der CLIs
Wenn Sie eine
CLI
-Anwendung für das Terminal erstellen, anstelle einer Web-API, schauen Sie sich
Typer
an.
Typer
ist die kleine Schwester von FastAPI. Und es soll das
FastAPI der CLIs
sein. ⌨️ 🚀
Anforderungen
FastAPI steht auf den Schultern von Giganten:
Starlette
für die Webanteile.
Pydantic
für die Datenanteile.
Installation
fast →
pip install fastapi
restart ↻
Sie benötigen außerdem einen
ASGI
-Server. Für die Produktumgebung beispielsweise
Uvicorn
oder
Hypercorn
.
fast →
pip install "uvicorn[standard]"
restart ↻
Beispiel
Erstellung
Erstellen Sie eine Datei
main.py
mit:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Oder verwenden Sie
async def
...
Wenn Ihr Code
async
/
await
verwendet, benutzen Sie
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Anmerkung
:
Wenn Sie das nicht kennen, schauen Sie sich den Abschnitt
„In Eile?“
über
async
und
await
in der Dokumentation
an.
Starten
Führen Sie den Server aus:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
Was macht der Befehl
uvicorn main:app --reload
...
Der Befehl
uvicorn main:app
bezieht sich auf:
main
: die Datei
main.py
(das Python-„Modul“).
app
: das Objekt, das innerhalb von
main.py
mit der Zeile
app = FastAPI()
erzeugt wurde.
--reload
: lässt den Server nach Codeänderungen neu starten. Tun Sie das nur während der Entwicklung.
Testen
Öffnen Sie Ihren Browser unter
http://127.0.0.1:8000/items/5?q=somequery
.
Sie erhalten die JSON-Response:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Damit haben Sie bereits eine API erstellt, welche:
HTTP-Anfragen auf den
Pfaden
/
und
/items/{item_id}
entgegennimmt.
Beide
Pfade
erhalten
GET
Operationen
(auch bekannt als HTTP
Methoden
).
Der
Pfad
/items/{item_id}
hat einen
Pfadparameter
item_id
, der ein
int
sein sollte.
Der
Pfad
/items/{item_id}
hat einen optionalen
str
Query Parameter
q
.
Interaktive API-Dokumentation
Gehen Sie nun auf
http://127.0.0.1:8000/docs
.
Sie sehen die automatische interaktive API-Dokumentation (bereitgestellt von
Swagger UI
):
Alternative API-Dokumentation
Gehen Sie jetzt auf
http://127.0.0.1:8000/redoc
.
Sie sehen die alternative automatische Dokumentation (bereitgestellt von
ReDoc
):
Beispiel Aktualisierung
Ändern Sie jetzt die Datei
main.py
, um den
Body
einer
PUT
-Anfrage zu empfangen.
Deklarieren Sie den Body mithilfe von Standard-Python-Typen, dank Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Der Server sollte automatisch neu geladen werden (weil Sie oben
--reload
zum Befehl
uvicorn
hinzugefügt haben).
Aktualisierung der interaktiven API-Dokumentation
Gehen Sie jetzt auf
http://127.0.0.1:8000/docs
.
Die interaktive API-Dokumentation wird automatisch aktualisiert, einschließlich des neuen Bodys:
Klicken Sie auf die Taste „Try it out“, damit können Sie die Parameter ausfüllen und direkt mit der API interagieren:
Klicken Sie dann auf die Taste „Execute“, die Benutzeroberfläche wird mit Ihrer API kommunizieren, sendet die Parameter, holt die Ergebnisse und zeigt sie auf dem Bildschirm an:
Aktualisierung der alternativen API-Dokumentation
Und nun gehen Sie auf
http://127.0.0.1:8000/redoc
.
Die alternative Dokumentation wird ebenfalls den neuen Abfrageparameter und -inhalt widerspiegeln:
Zusammenfassung
Zusammengefasst deklarieren Sie
einmal
die Typen von Parametern, Body, etc. als Funktionsparameter.
Das machen Sie mit modernen Standard-Python-Typen.
Sie müssen keine neue Syntax, Methoden oder Klassen einer bestimmten Bibliothek usw. lernen.
Nur Standard-
Python+
.
Zum Beispiel für ein
int
:
item_id
:
int
oder für ein komplexeres
Item
-Modell:
item
:
Item
... und mit dieser einen Deklaration erhalten Sie:
Editor-Unterstützung, einschließlich:
Code-Vervollständigung.
Typprüfungen.
Validierung von Daten:
Automatische und eindeutige Fehler, wenn die Daten ungültig sind.
Validierung auch für tief verschachtelte JSON-Objekte.
Konvertierung
von Eingabedaten: Aus dem Netzwerk kommend, zu Python-Daten und -Typen. Lesen von:
JSON.
Pfad-Parametern.
Abfrage-Parametern.
Cookies.
Header-Feldern.
Formularen.
Dateien.
Konvertierung
von Ausgabedaten: Konvertierung von Python-Daten und -Typen zu Netzwerkdaten (als JSON):
Konvertieren von Python-Typen (
str
,
int
,
float
,
bool
,
list
, usw.).
Datetime
-Objekte.
UUID
-Objekte.
Datenbankmodelle.
... und viele mehr.
Automatische interaktive API-Dokumentation, einschließlich 2 alternativer Benutzeroberflächen:
Swagger UI.
ReDoc.
Um auf das vorherige Codebeispiel zurückzukommen,
FastAPI
wird:
Überprüfen, dass es eine
item_id
im Pfad für
GET
- und
PUT
-Anfragen gibt.
Überprüfen, ob die
item_id
vom Typ
int
für
GET
- und
PUT
-Anfragen ist.
Falls nicht, wird dem Client ein nützlicher, eindeutiger Fehler angezeigt.
Prüfen, ob es einen optionalen Abfrageparameter namens
q
(wie in
http://127.0.0.1:8000/items/foo?q=somequery
) für
GET
-Anfragen gibt.
Da der
q
-Parameter mit
= None
deklariert ist, ist er optional.
Ohne das
None
wäre er erforderlich (wie der Body im Fall von
PUT
).
Bei
PUT
-Anfragen an
/items/{item_id}
den Body als JSON lesen:
Prüfen, ob er ein erforderliches Attribut
name
hat, das ein
str
sein muss.
Prüfen, ob er ein erforderliches Attribut
price
hat, das ein
float
sein muss.
Prüfen, ob er ein optionales Attribut
is_offer
hat, das ein
bool
sein muss, falls vorhanden.
All dies würde auch für tief verschachtelte JSON-Objekte funktionieren.
Automatisch von und nach JSON konvertieren.
Alles mit OpenAPI dokumentieren, welches verwendet werden kann von:
Interaktiven Dokumentationssystemen.
Automatisch Client-Code generierenden Systemen für viele Sprachen.
Zwei interaktive Dokumentation-Webschnittstellen direkt zur Verfügung stellen.
Wir haben nur an der Oberfläche gekratzt, aber Sie bekommen schon eine Vorstellung davon, wie das Ganze funktioniert.
Versuchen Sie, diese Zeile zu ändern:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
... von:
...
"item_name"
:
item
.
name
...
... zu:
...
"item_price"
:
item
.
price
...
... und sehen Sie, wie Ihr Editor die Attribute automatisch ausfüllt und ihre Typen kennt:
Für ein vollständigeres Beispiel, mit weiteren Funktionen, siehe das
Tutorial - Benutzerhandbuch
.
Spoiler-Alarm
: Das Tutorial - Benutzerhandbuch enthält:
Deklaration von
Parametern
von anderen verschiedenen Stellen wie:
Header-Felder
,
Cookies
,
Formularfelder
und
Dateien
.
Wie man
Validierungseinschränkungen
wie
maximum_length
oder
regex
setzt.
Ein sehr leistungsfähiges und einfach zu bedienendes System für
Dependency Injection
.
Sicherheit und Authentifizierung, einschließlich Unterstützung für
OAuth2
mit
JWT-Tokens
und
HTTP-Basic
-Authentifizierung.
Fortgeschrittenere (aber ebenso einfache) Techniken zur Deklaration
tief verschachtelter JSON-Modelle
(dank Pydantic).
GraphQL
Integration mit
Strawberry
und anderen Bibliotheken.
Viele zusätzliche Funktionen (dank Starlette) wie:
WebSockets
extrem einfache Tests auf Basis von
httpx
und
pytest
CORS
Cookie Sessions
... und mehr.
Performanz
Unabhängige TechEmpower-Benchmarks zeigen
FastAPI
-Anwendungen, die unter Uvicorn laufen, als
eines der schnellsten verfügbaren Python-Frameworks
, nur noch hinter Starlette und Uvicorn selbst (intern von FastAPI verwendet).
Um mehr darüber zu erfahren, siehe den Abschnitt
Benchmarks
.
Optionale Abhängigkeiten
Wird von Pydantic verwendet:
email-validator
- für E-Mail-Validierung.
pydantic-settings
- für die Verwaltung von Einstellungen.
pydantic-extra-types
- für zusätzliche Typen, mit Pydantic zu verwenden.
Wird von Starlette verwendet:
httpx
- erforderlich, wenn Sie den
TestClient
verwenden möchten.
jinja2
- erforderlich, wenn Sie die Standardkonfiguration für Templates verwenden möchten.
python-multipart
- erforderlich, wenn Sie Formulare mittels
request.form()
„parsen“
möchten.
itsdangerous
- erforderlich für
SessionMiddleware
Unterstützung.
pyyaml
- erforderlich für Starlette's
SchemaGenerator
Unterstützung (Sie brauchen das wahrscheinlich nicht mit FastAPI).
ujson
- erforderlich, wenn Sie
UJSONResponse
verwenden möchten.
Wird von FastAPI / Starlette verwendet:
uvicorn
- für den Server, der Ihre Anwendung lädt und serviert.
orjson
- erforderlich, wenn Sie
ORJSONResponse
verwenden möchten.
Sie können diese alle mit
pip install "fastapi[all]"
installieren.
Lizenz
Dieses Projekt ist unter den Bedingungen der MIT-Lizenz lizenziert.

## 039_DEPLOYMENT
Deployment¶
---

Deployment
Deploying a
FastAPI
application is relatively easy.
What Does Deployment Mean
To
deploy
an application means to perform the necessary steps to make it
available to the users
.
For a
web API
, it normally involves putting it in a
remote machine
, with a
server program
that provides good performance, stability, etc, so that your
users
can
access
the application efficiently and without interruptions or problems.
This is in contrast to the
development
stages, where you are constantly changing the code, breaking it and fixing it, stopping and restarting the development server, etc.
Deployment Strategies
There are several ways to do it depending on your specific use case and the tools that you use.
You could
deploy a server
yourself using a combination of tools, you could use a
cloud service
that does part of the work for you, or other possible options.
I will show you some of the main concepts you should probably keep in mind when deploying a
FastAPI
application (although most of it applies to any other type of web application).
You will see more details to keep in mind and some of the techniques to do it in the next sections. ✨

## 040_DEPLOYMENT_CLOUD
Deploy FastAPI on Cloud Providers¶
---

Deploy FastAPI on Cloud Providers
You can use virtually
any cloud provider
to deploy your FastAPI application.
In most of the cases, the main cloud providers have guides to deploy FastAPI with them.
Cloud Providers - Sponsors
Some cloud providers ✨
sponsor FastAPI
✨, this ensures the continued and healthy
development
of FastAPI and its
ecosystem
.
And it shows their true commitment to FastAPI and its
community
(you), as they not only want to provide you a
good service
but also want to make sure you have a
good and healthy framework
, FastAPI. 🙇
You might want to try their services and follow their guides:
Platform.sh
Porter
Render

## 041_DEPLOYMENT_CONCEPTS
Deployments Concepts¶
---

Deployments Concepts
When deploying a
FastAPI
application, or actually, any type of web API, there are several concepts that you probably care about, and using them you can find the
most appropriate
way to
deploy your application
.
Some of the important concepts are:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
We'll see how they would affect
deployments
.
In the end, the ultimate objective is to be able to
serve your API clients
in a way that is
secure
, to
avoid disruptions
, and to use the
compute resources
(for example remote servers/virtual machines) as efficiently as possible. 🚀
I'll tell you a bit more about these
concepts
here, and that would hopefully give you the
intuition
you would need to decide how to deploy your API in very different environments, possibly even in
future
ones that don't exist yet.
By considering these concepts, you will be able to
evaluate and design
the best way to deploy
your own APIs
.
In the next chapters, I'll give you more
concrete recipes
to deploy FastAPI applications.
But for now, let's check these important
conceptual ideas
. These concepts also apply to any other type of web API. 💡
Security - HTTPS
In the
previous chapter about HTTPS
we learned about how HTTPS provides encryption for your API.
We also saw that HTTPS is normally provided by a component
external
to your application server, a
TLS Termination Proxy
.
And there has to be something in charge of
renewing the HTTPS certificates
, it could be the same component or it could be something different.
Example Tools for HTTPS
Some of the tools you could use as a TLS Termination Proxy are:
Traefik
Automatically handles certificates renewals ✨
Caddy
Automatically handles certificates renewals ✨
Nginx
With an external component like Certbot for certificate renewals
HAProxy
With an external component like Certbot for certificate renewals
Kubernetes with an Ingress Controller like Nginx
With an external component like cert-manager for certificate renewals
Handled internally by a cloud provider as part of their services (read below 👇)
Another option is that you could use a
cloud service
that does more of the work including setting up HTTPS. It could have some restrictions or charge you more, etc. But in that case, you wouldn't have to set up a TLS Termination Proxy yourself.
I'll show you some concrete examples in the next chapters.
Then the next concepts to consider are all about the program running your actual API (e.g. Uvicorn).
Program and Process
We will talk a lot about the running "
process
", so it's useful to have clarity about what it means, and what's the difference with the word "
program
".
What is a Program
The word
program
is commonly used to describe many things:
The
code
that you write, the
Python files
.
The
file
that can be
executed
by the operating system, for example:
python
,
python.exe
or
uvicorn
.
A particular program while it is
running
on the operating system, using the CPU, and storing things in memory. This is also called a
process
.
What is a Process
The word
process
is normally used in a more specific way, only referring to the thing that is running in the operating system (like in the last point above):
A particular program while it is
running
on the operating system.
This doesn't refer to the file, nor to the code, it refers
specifically
to the thing that is being
executed
and managed by the operating system.
Any program, any code,
can only do things
when it is being
executed
. So, when there's a
process running
.
The process can be
terminated
(or "killed") by you, or by the operating system. At that point, it stops running/being executed, and it can
no longer do things
.
Each application that you have running on your computer has some process behind it, each running program, each window, etc. And there are normally many processes running
at the same time
while a computer is on.
There can be
multiple processes
of the
same program
running at the same time.
If you check out the "task manager" or "system monitor" (or similar tools) in your operating system, you will be able to see many of those processes running.
And, for example, you will probably see that there are multiple processes running the same browser program (Firefox, Chrome, Edge, etc). They normally run one process per tab, plus some other extra processes.
Now that we know the difference between the terms
process
and
program
, let's continue talking about deployments.
Running on Startup
In most cases, when you create a web API, you want it to be
always running
, uninterrupted, so that your clients can always access it. This is of course, unless you have a specific reason why you want it to run only in certain situations, but most of the time you want it constantly running and
available
.
In a Remote Server
When you set up a remote server (a cloud server, a virtual machine, etc.) the simplest thing you can do is use
fastapi run
(which uses Uvicorn) or something similar, manually, the same way you do when developing locally.
And it will work and will be useful
during development
.
But if your connection to the server is lost, the
running process
will probably die.
And if the server is restarted (for example after updates, or migrations from the cloud provider) you probably
won't notice it
. And because of that, you won't even know that you have to restart the process manually. So, your API will just stay dead. 😱
Run Automatically on Startup
In general, you will probably want the server program (e.g. Uvicorn) to be started automatically on server startup, and without needing any
human intervention
, to have a process always running with your API (e.g. Uvicorn running your FastAPI app).
Separate Program
To achieve this, you will normally have a
separate program
that would make sure your application is run on startup. And in many cases, it would also make sure other components or applications are also run, for example, a database.
Example Tools to Run at Startup
Some examples of the tools that can do this job are:
Docker
Kubernetes
Docker Compose
Docker in Swarm Mode
Systemd
Supervisor
Handled internally by a cloud provider as part of their services
Others...
I'll give you more concrete examples in the next chapters.
Restarts
Similar to making sure your application is run on startup, you probably also want to make sure it is
restarted
after failures.
We Make Mistakes
We, as humans, make
mistakes
, all the time. Software almost
always
has
bugs
hidden in different places. 🐛
And we as developers keep improving the code as we find those bugs and as we implement new features (possibly adding new bugs too 😅).
Small Errors Automatically Handled
When building web APIs with FastAPI, if there's an error in our code, FastAPI will normally contain it to the single request that triggered the error. 🛡
The client will get a
500 Internal Server Error
for that request, but the application will continue working for the next requests instead of just crashing completely.
Bigger Errors - Crashes
Nevertheless, there might be cases where we write some code that
crashes the entire application
making Uvicorn and Python crash. 💥
And still, you would probably not want the application to stay dead because there was an error in one place, you probably want it to
continue running
at least for the
path operations
that are not broken.
Restart After Crash
But in those cases with really bad errors that crash the running
process
, you would want an external component that is in charge of
restarting
the process, at least a couple of times...
Tip
...Although if the whole application is just
crashing immediately
it probably doesn't make sense to keep restarting it forever. But in those cases, you will probably notice it during development, or at least right after deployment.
So let's focus on the main cases, where it could crash entirely in some particular cases
in the future
, and it still makes sense to restart it.
You would probably want to have the thing in charge of restarting your application as an
external component
, because by that point, the same application with Uvicorn and Python already crashed, so there's nothing in the same code of the same app that could do anything about it.
Example Tools to Restart Automatically
In most cases, the same tool that is used to
run the program on startup
is also used to handle automatic
restarts
.
For example, this could be handled by:
Docker
Kubernetes
Docker Compose
Docker in Swarm Mode
Systemd
Supervisor
Handled internally by a cloud provider as part of their services
Others...
Replication - Processes and Memory
With a FastAPI application, using a server program like the
fastapi
command that runs Uvicorn, running it once in
one process
can serve multiple clients concurrently.
But in many cases, you will want to run several worker processes at the same time.
Multiple Processes - Workers
If you have more clients than what a single process can handle (for example if the virtual machine is not too big) and you have
multiple cores
in the server's CPU, then you could have
multiple processes
running with the same application at the same time, and distribute all the requests among them.
When you run
multiple processes
of the same API program, they are commonly called
workers
.
Worker Processes and Ports
Remember from the docs
About HTTPS
that only one process can be listening on one combination of port and IP address in a server?
This is still true.
So, to be able to have
multiple processes
at the same time, there has to be a
single process listening on a port
that then transmits the communication to each worker process in some way.
Memory per Process
Now, when the program loads things in memory, for example, a machine learning model in a variable, or the contents of a large file in a variable, all that
consumes a bit of the memory (RAM)
of the server.
And multiple processes normally
don't share any memory
. This means that each running process has its own things, variables, and memory. And if you are consuming a large amount of memory in your code,
each process
will consume an equivalent amount of memory.
Server Memory
For example, if your code loads a Machine Learning model with
1 GB in size
, when you run one process with your API, it will consume at least 1 GB of RAM. And if you start
4 processes
(4 workers), each will consume 1 GB of RAM. So in total, your API will consume
4 GB of RAM
.
And if your remote server or virtual machine only has 3 GB of RAM, trying to load more than 4 GB of RAM will cause problems. 🚨
Multiple Processes - An Example
In this example, there's a
Manager Process
that starts and controls two
Worker Processes
.
This Manager Process would probably be the one listening on the
port
in the IP. And it would transmit all the communication to the worker processes.
Those worker processes would be the ones running your application, they would perform the main computations to receive a
request
and return a
response
, and they would load anything you put in variables in RAM.
And of course, the same machine would probably have
other processes
running as well, apart from your application.
An interesting detail is that the percentage of the
CPU used
by each process can
vary
a lot over time, but the
memory (RAM)
normally stays more or less
stable
.
If you have an API that does a comparable amount of computations every time and you have a lot of clients, then the
CPU utilization
will probably
also be stable
(instead of constantly going up and down quickly).
Examples of Replication Tools and Strategies
There can be several approaches to achieve this, and I'll tell you more about specific strategies in the next chapters, for example when talking about Docker and containers.
The main constraint to consider is that there has to be a
single
component handling the
port
in the
public IP
. And then it has to have a way to
transmit
the communication to the replicated
processes/workers
.
Here are some possible combinations and strategies:
Uvicorn
with
--workers
One Uvicorn
process manager
would listen on the
IP
and
port
, and it would start
multiple Uvicorn worker processes
.
Kubernetes
and other distributed
container systems
Something in the
Kubernetes
layer would listen on the
IP
and
port
. The replication would be by having
multiple containers
, each with
one Uvicorn process
running.
Cloud services
that handle this for you
The cloud service will probably
handle replication for you
. It would possibly let you define
a process to run
, or a
container image
to use, in any case, it would most probably be
a single Uvicorn process
, and the cloud service would be in charge of replicating it.
Tip
Don't worry if some of these items about
containers
, Docker, or Kubernetes don't make a lot of sense yet.
I'll tell you more about container images, Docker, Kubernetes, etc. in a future chapter:
FastAPI in Containers - Docker
.
Previous Steps Before Starting
There are many cases where you want to perform some steps
before starting
your application.
For example, you might want to run
database migrations
.
But in most cases, you will want to perform these steps only
once
.
So, you will want to have a
single process
to perform those
previous steps
, before starting the application.
And you will have to make sure that it's a single process running those previous steps
even
if afterwards, you start
multiple processes
(multiple workers) for the application itself. If those steps were run by
multiple processes
, they would
duplicate
the work by running it in
parallel
, and if the steps were something delicate like a database migration, they could cause conflicts with each other.
Of course, there are some cases where there's no problem in running the previous steps multiple times, in that case, it's a lot easier to handle.
Tip
Also, keep in mind that depending on your setup, in some cases you
might not even need any previous steps
before starting your application.
In that case, you wouldn't have to worry about any of this. 🤷
Examples of Previous Steps Strategies
This will
depend heavily
on the way you
deploy your system
, and it would probably be connected to the way you start programs, handling restarts, etc.
Here are some possible ideas:
An "Init Container" in Kubernetes that runs before your app container
A bash script that runs the previous steps and then starts your application
You would still need a way to start/restart
that
bash script, detect errors, etc.
Tip
I'll give you more concrete examples for doing this with containers in a future chapter:
FastAPI in Containers - Docker
.
Resource Utilization
Your server(s) is (are) a
resource
, you can consume or
utilize
, with your programs, the computation time on the CPUs, and the RAM memory available.
How much of the system resources do you want to be consuming/utilizing? It might be easy to think "not much", but in reality, you will probably want to consume
as much as possible without crashing
.
If you are paying for 3 servers but you are using only a little bit of their RAM and CPU, you are probably
wasting money
💸, and probably
wasting server electric power
🌎, etc.
In that case, it could be better to have only 2 servers and use a higher percentage of their resources (CPU, memory, disk, network bandwidth, etc).
On the other hand, if you have 2 servers and you are using
100% of their CPU and RAM
, at some point one process will ask for more memory, and the server will have to use the disk as "memory" (which can be thousands of times slower), or even
crash
. Or one process might need to do some computation and would have to wait until the CPU is free again.
In this case, it would be better to get
one extra server
and run some processes on it so that they all have
enough RAM and CPU time
.
There's also the chance that for some reason you have a
spike
of usage of your API. Maybe it went viral, or maybe some other services or bots start using it. And you might want to have extra resources to be safe in those cases.
You could put an
arbitrary number
to target, for example, something
between 50% to 90%
of resource utilization. The point is that those are probably the main things you will want to measure and use to tweak your deployments.
You can use simple tools like
htop
to see the CPU and RAM used in your server or the amount used by each process. Or you can use more complex monitoring tools, which may be distributed across servers, etc.
Recap
You have been reading here some of the main concepts that you would probably need to keep in mind when deciding how to deploy your application:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
Understanding these ideas and how to apply them should give you the intuition necessary to take any decisions when configuring and tweaking your deployments. 🤓
In the next sections, I'll give you more concrete examples of possible strategies you can follow. 🚀

## 042_DEPLOYMENT_DOCKER
FastAPI in Containers - Docker¶
---

FastAPI in Containers - Docker
When deploying FastAPI applications a common approach is to build a
Linux container image
. It's normally done using
Docker
. You can then deploy that container image in one of a few possible ways.
Using Linux containers has several advantages including
security
,
replicability
,
simplicity
, and others.
Tip
In a hurry and already know this stuff? Jump to the
Dockerfile
below 👇
.
Dockerfile Preview 👀
FROM
python:3.9
WORKDIR
/code
COPY
./requirements.txt
/code/requirements.txt
RUN
pip
install
--no-cache-dir
--upgrade
-r
/code/requirements.txt
COPY
./app
/code/app
CMD
[
"fastapi"
,
"run"
,
"app/main.py"
,
"--port"
,
"80"
]
## If running behind a proxy like Nginx or Traefik add --proxy-headers
## CMD ["fastapi", "run", "app/main.py", "--port", "80", "--proxy-headers"]
What is a Container
Containers (mainly Linux containers) are a very
lightweight
way to package applications including all their dependencies and necessary files while keeping them isolated from other containers (other applications or components) in the same system.
Linux containers run using the same Linux kernel of the host (machine, virtual machine, cloud server, etc). This just means that they are very lightweight (compared to full virtual machines emulating an entire operating system).
This way, containers consume
little resources
, an amount comparable to running the processes directly (a virtual machine would consume much more).
Containers also have their own
isolated
running processes (commonly just one process), file system, and network, simplifying deployment, security, development, etc.
What is a Container Image
A
container
is run from a
container image
.
A container image is a
static
version of all the files, environment variables, and the default command/program that should be present in a container.
Static
here means that the container
image
is not running, it's not being executed, it's only the packaged files and metadata.
In contrast to a "
container image
" that is the stored static contents, a "
container
" normally refers to the running instance, the thing that is being
executed
.
When the
container
is started and running (started from a
container image
) it could create or change files, environment variables, etc. Those changes will exist only in that container, but would not persist in the underlying container image (would not be saved to disk).
A container image is comparable to the
program
file and contents, e.g.
python
and some file
main.py
.
And the
container
itself (in contrast to the
container image
) is the actual running instance of the image, comparable to a
process
. In fact, a container is running only when it has a
process running
(and normally it's only a single process). The container stops when there's no process running in it.
Container Images
Docker has been one of the main tools to create and manage
container images
and
containers
.
And there's a public
Docker Hub
with pre-made
official container images
for many tools, environments, databases, and applications.
For example, there's an official
Python Image
.
And there are many other images for different things like databases, for example for:
PostgreSQL
MySQL
MongoDB
Redis
, etc.
By using a pre-made container image it's very easy to
combine
and use different tools. For example, to try out a new database. In most cases, you can use the
official images
, and just configure them with environment variables.
That way, in many cases you can learn about containers and Docker and reuse that knowledge with many different tools and components.
So, you would run
multiple containers
with different things, like a database, a Python application, a web server with a React frontend application, and connect them together via their internal network.
All the container management systems (like Docker or Kubernetes) have these networking features integrated into them.
Containers and Processes
A
container image
normally includes in its metadata the default program or command that should be run when the
container
is started and the parameters to be passed to that program. Very similar to what would be if it was in the command line.
When a
container
is started, it will run that command/program (although you can override it and make it run a different command/program).
A container is running as long as the
main process
(command or program) is running.
A container normally has a
single process
, but it's also possible to start subprocesses from the main process, and that way you will have
multiple processes
in the same container.
But it's not possible to have a running container without
at least one running process
. If the main process stops, the container stops.
Build a Docker Image for FastAPI
Okay, let's build something now! 🚀
I'll show you how to build a
Docker image
for FastAPI
from scratch
, based on the
official Python
image.
This is what you would want to do in
most cases
, for example:
Using
Kubernetes
or similar tools
When running on a
Raspberry Pi
Using a cloud service that would run a container image for you, etc.
Package Requirements
You would normally have the
package requirements
for your application in some file.
It would depend mainly on the tool you use to
install
those requirements.
The most common way to do it is to have a file
requirements.txt
with the package names and their versions, one per line.
You would of course use the same ideas you read in
About FastAPI versions
to set the ranges of versions.
For example, your
requirements.txt
could look like:
fastapi[standard]>=0.113.0,<0.114.0
pydantic>=2.7.0,<3.0.0
And you would normally install those package dependencies with
pip
, for example:
fast →
pip install -r requirements.txt
Successfully installed fastapi pydantic
restart ↻
Info
There are other formats and tools to define and install package dependencies.
Create the
FastAPI
Code
Create an
app
directory and enter it.
Create an empty file
__init__.py
.
Create a
main.py
file with:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Dockerfile
Now in the same project directory create a file
Dockerfile
with:
FROM
python:3.9
WORKDIR
/code
COPY
./requirements.txt
/code/requirements.txt
RUN
pip
install
--no-cache-dir
--upgrade
-r
/code/requirements.txt
COPY
./app
/code/app
CMD
[
"fastapi"
,
"run"
,
"app/main.py"
,
"--port"
,
"80"
]
Tip
Review what each line does by clicking each number bubble in the code. 👆
Warning
Make sure to
always
use the
exec form
of the
CMD
instruction, as explained below.
Use
CMD
- Exec Form
The
CMD
Docker instruction can be written using two forms:
✅
Exec
form:
## ✅ Do this
CMD
[
"fastapi"
,
"run"
,
"app/main.py"
,
"--port"
,
"80"
]
⛔️
Shell
form:
## ⛔️ Don't do this
CMD
fastapi
run
app/main.py
--port
80
Make sure to always use the
exec
form to ensure that FastAPI can shutdown gracefully and
lifespan events
are triggered.
You can read more about it in the
Docker docs for shell and exec form
.
This can be quite noticeable when using
docker compose
. See this Docker Compose FAQ section for more technical details:
Why do my services take 10 seconds to recreate or stop?
.
Directory Structure
You should now have a directory structure like:
.
├── app
│   ├── __init__.py
│ └── main.py
├── Dockerfile
└── requirements.txt
Behind a TLS Termination Proxy
If you are running your container behind a TLS Termination Proxy (load balancer) like Nginx or Traefik, add the option
--proxy-headers
, this will tell Uvicorn (through the FastAPI CLI) to trust the headers sent by that proxy telling it that the application is running behind HTTPS, etc.
CMD
[
"fastapi"
,
"run"
,
"app/main.py"
,
"--proxy-headers"
,
"--port"
,
"80"
]
Docker Cache
There's an important trick in this
Dockerfile
, we first copy the
file with the dependencies alone
, not the rest of the code. Let me tell you why is that.
COPY
./requirements.txt
/code/requirements.txt
Docker and other tools
build
these container images
incrementally
, adding
one layer on top of the other
, starting from the top of the
Dockerfile
and adding any files created by each of the instructions of the
Dockerfile
.
Docker and similar tools also use an
internal cache
when building the image, if a file hasn't changed since the last time building the container image, then it will
reuse the same layer
created the last time, instead of copying the file again and creating a new layer from scratch.
Just avoiding the copy of files doesn't necessarily improve things too much, but because it used the cache for that step, it can
use the cache for the next step
. For example, it could use the cache for the instruction that installs dependencies with:
RUN
pip
install
--no-cache-dir
--upgrade
-r
/code/requirements.txt
The file with the package requirements
won't change frequently
. So, by copying only that file, Docker will be able to
use the cache
for that step.
And then, Docker will be able to
use the cache for the next step
that downloads and install those dependencies. And here's where we
save a lot of time
. ✨ ...and avoid boredom waiting. 😪😆
Downloading and installing the package dependencies
could take minutes
, but using the
cache
would
take seconds
at most.
And as you would be building the container image again and again during development to check that your code changes are working, there's a lot of accumulated time this would save.
Then, near the end of the
Dockerfile
, we copy all the code. As this is what
changes most frequently
, we put it near the end, because almost always, anything after this step will not be able to use the cache.
COPY
./app
/code/app
Build the Docker Image
Now that all the files are in place, let's build the container image.
Go to the project directory (in where your
Dockerfile
is, containing your
app
directory).
Build your FastAPI image:
fast →
docker build -t myimage .
restart ↻
Tip
Notice the
.
at the end, it's equivalent to
./
, it tells Docker the directory to use to build the container image.
In this case, it's the same current directory (
.
).
Start the Docker Container
Run a container based on your image:
fast →
docker run -d --name mycontainer -p 80:80 myimage
restart ↻
Check it
You should be able to check it in your Docker container's URL, for example:
http://192.168.99.100/items/5?q=somequery
or
http://127.0.0.1/items/5?q=somequery
(or equivalent, using your Docker host).
You will see something like:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Interactive API docs
Now you can go to
http://192.168.99.100/docs
or
http://127.0.0.1/docs
(or equivalent, using your Docker host).
You will see the automatic interactive API documentation (provided by
Swagger UI
):
Alternative API docs
And you can also go to
http://192.168.99.100/redoc
or
http://127.0.0.1/redoc
(or equivalent, using your Docker host).
You will see the alternative automatic documentation (provided by
ReDoc
):
Build a Docker Image with a Single-File FastAPI
If your FastAPI is a single file, for example,
main.py
without an
./app
directory, your file structure could look like this:
.
├── Dockerfile
├── main.py
└── requirements.txt
Then you would just have to change the corresponding paths to copy the file inside the
Dockerfile
:
FROM
python:3.9
WORKDIR
/code
COPY
./requirements.txt
/code/requirements.txt
RUN
pip
install
--no-cache-dir
--upgrade
-r
/code/requirements.txt
COPY
./main.py
/code/
CMD
[
"fastapi"
,
"run"
,
"main.py"
,
"--port"
,
"80"
]
When you pass the file to
fastapi run
it will detect automatically that it is a single file and not part of a package and will know how to import it and serve your FastAPI app. 😎
Deployment Concepts
Let's talk again about some of the same
Deployment Concepts
in terms of containers.
Containers are mainly a tool to simplify the process of
building and deploying
an application, but they don't enforce a particular approach to handle these
deployment concepts
, and there are several possible strategies.
The
good news
is that with each different strategy there's a way to cover all of the deployment concepts. 🎉
Let's review these
deployment concepts
in terms of containers:
HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
HTTPS
If we focus just on the
container image
for a FastAPI application (and later the running
container
), HTTPS normally would be handled
externally
by another tool.
It could be another container, for example with
Traefik
, handling
HTTPS
and
automatic
acquisition of
certificates
.
Tip
Traefik has integrations with Docker, Kubernetes, and others, so it's very easy to set up and configure HTTPS for your containers with it.
Alternatively, HTTPS could be handled by a cloud provider as one of their services (while still running the application in a container).
Running on Startup and Restarts
There is normally another tool in charge of
starting and running
your container.
It could be
Docker
directly,
Docker Compose
,
Kubernetes
, a
cloud service
, etc.
In most (or all) cases, there's a simple option to enable running the container on startup and enabling restarts on failures. For example, in Docker, it's the command line option
--restart
.
Without using containers, making applications run on startup and with restarts can be cumbersome and difficult. But when
working with containers
in most cases that functionality is included by default. ✨
Replication - Number of Processes
If you have a
cluster
of machines with
Kubernetes
, Docker Swarm Mode, Nomad, or another similar complex system to manage distributed containers on multiple machines, then you will probably want to
handle replication
at the
cluster level
instead of using a
process manager
(like Uvicorn with workers) in each container.
One of those distributed container management systems like Kubernetes normally has some integrated way of handling
replication of containers
while still supporting
load balancing
for the incoming requests. All at the
cluster level
.
In those cases, you would probably want to build a
Docker image from scratch
as
explained above
, installing your dependencies, and running
a single Uvicorn process
instead of using multiple Uvicorn workers.
Load Balancer
When using containers, you would normally have some component
listening on the main port
. It could possibly be another container that is also a
TLS Termination Proxy
to handle
HTTPS
or some similar tool.
As this component would take the
load
of requests and distribute that among the workers in a (hopefully)
balanced
way, it is also commonly called a
Load Balancer
.
Tip
The same
TLS Termination Proxy
component used for HTTPS would probably also be a
Load Balancer
.
And when working with containers, the same system you use to start and manage them would already have internal tools to transmit the
network communication
(e.g. HTTP requests) from that
load balancer
(that could also be a
TLS Termination Proxy
) to the container(s) with your app.
One Load Balancer - Multiple Worker Containers
When working with
Kubernetes
or similar distributed container management systems, using their internal networking mechanisms would allow the single
load balancer
that is listening on the main
port
to transmit communication (requests) to possibly
multiple containers
running your app.
Each of these containers running your app would normally have
just one process
(e.g. a Uvicorn process running your FastAPI application). They would all be
identical containers
, running the same thing, but each with its own process, memory, etc. That way you would take advantage of
parallelization
in
different cores
of the CPU, or even in
different machines
.
And the distributed container system with the
load balancer
would
distribute the requests
to each one of the containers with your app
in turns
. So, each request could be handled by one of the multiple
replicated containers
running your app.
And normally this
load balancer
would be able to handle requests that go to
other
apps in your cluster (e.g. to a different domain, or under a different URL path prefix), and would transmit that communication to the right containers for
that other
application running in your cluster.
One Process per Container
In this type of scenario, you probably would want to have
a single (Uvicorn) process per container
, as you would already be handling replication at the cluster level.
So, in this case, you
would not
want to have a multiple workers in the container, for example with the
--workers
command line option.You would want to have just a
single Uvicorn process
per container (but probably multiple containers).
Having another process manager inside the container (as would be with multiple workers) would only add
unnecessary complexity
that you are most probably already taking care of with your cluster system.
Containers with Multiple Processes and Special Cases
Of course, there are
special cases
where you could want to have
a container
with several
Uvicorn worker processes
inside.
In those cases, you can use the
--workers
command line option to set the number of workers that you want to run:
FROM
python:3.9
WORKDIR
/code
COPY
./requirements.txt
/code/requirements.txt
RUN
pip
install
--no-cache-dir
--upgrade
-r
/code/requirements.txt
COPY
./app
/code/app
CMD
[
"fastapi"
,
"run"
,
"app/main.py"
,
"--port"
,
"80"
,
"--workers"
,
"4"
]
Here are some examples of when that could make sense:
A Simple App
You could want a process manager in the container if your application is
simple enough
that can run it on a
single server
, not a cluster.
Docker Compose
You could be deploying to a
single server
(not a cluster) with
Docker Compose
, so you wouldn't have an easy way to manage replication of containers (with Docker Compose) while preserving the shared network and
load balancing
.
Then you could want to have
a single container
with a
process manager
starting
several worker processes
inside.
The main point is,
none
of these are
rules written in stone
that you have to blindly follow. You can use these ideas to
evaluate your own use case
and decide what is the best approach for your system, checking out how to manage the concepts of:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
Memory
If you run
a single process per container
you will have a more or less well-defined, stable, and limited amount of memory consumed by each of those containers (more than one if they are replicated).
And then you can set those same memory limits and requirements in your configurations for your container management system (for example in
Kubernetes
). That way it will be able to
replicate the containers
in the
available machines
taking into account the amount of memory needed by them, and the amount available in the machines in the cluster.
If your application is
simple
, this will probably
not be a problem
, and you might not need to specify hard memory limits. But if you are
using a lot of memory
(for example with
machine learning
models), you should check how much memory you are consuming and adjust the
number of containers
that runs in
each machine
(and maybe add more machines to your cluster).
If you run
multiple processes per container
you will have to make sure that the number of processes started doesn't
consume more memory
than what is available.
Previous Steps Before Starting and Containers
If you are using containers (e.g. Docker, Kubernetes), then there are two main approaches you can use.
Multiple Containers
If you have
multiple containers
, probably each one running a
single process
(for example, in a
Kubernetes
cluster), then you would probably want to have a
separate container
doing the work of the
previous steps
in a single container, running a single process,
before
running the replicated worker containers.
Info
If you are using Kubernetes, this would probably be an
Init Container
.
If in your use case there's no problem in running those previous steps
multiple times in parallel
(for example if you are not running database migrations, but just checking if the database is ready yet), then you could also just put them in each container right before starting the main process.
Single Container
If you have a simple setup, with a
single container
that then starts multiple
worker processes
(or also just one process), then you could run those previous steps in the same container, right before starting the process with the app.
Base Docker Image
There used to be an official FastAPI Docker image:
tiangolo/uvicorn-gunicorn-fastapi
. But it is now deprecated. ⛔️
You should probably
not
use this base Docker image (or any other similar one).
If you are using
Kubernetes
(or others) and you are already setting
replication
at the cluster level, with multiple
containers
. In those cases, you are better off
building an image from scratch
as described above:
Build a Docker Image for FastAPI
.
And if you need to have multiple workers, you can simply use the
--workers
command line option.
Technical Details
The Docker image was created when Uvicorn didn't support managing and restarting dead workers, so it was needed to use Gunicorn with Uvicorn, which added quite some complexity, just to have Gunicorn manage and restart the Uvicorn worker processes.
But now that Uvicorn (and the
fastapi
command) support using
--workers
, there's no reason to use a base Docker image instead of building your own (it's pretty much the same amount of code 😅).
Deploy the Container Image
After having a Container (Docker) Image there are several ways to deploy it.
For example:
With
Docker Compose
in a single server
With a
Kubernetes
cluster
With a Docker Swarm Mode cluster
With another tool like Nomad
With a cloud service that takes your container image and deploys it
Docker Image with
uv
If you are using
uv
to install and manage your project, you can follow their
uv Docker guide
.
Recap
Using container systems (e.g. with
Docker
and
Kubernetes
) it becomes fairly straightforward to handle all the
deployment concepts
:
HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
In most cases, you probably won't want to use any base image, and instead
build a container image from scratch
based on the official Python Docker image.
Taking care of the
order
of instructions in the
Dockerfile
and the
Docker cache
you can
minimize build times
, to maximize your productivity (and avoid boredom). 😎

## 043_DEPLOYMENT_HTTPS
About HTTPS¶
---

About HTTPS
It is easy to assume that HTTPS is something that is just "enabled" or not.
But it is way more complex than that.
Tip
If you are in a hurry or don't care, continue with the next sections for step by step instructions to set everything up with different techniques.
To
learn the basics of HTTPS
, from a consumer perspective, check
https://howhttps.works/
.
Now, from a
developer's perspective
, here are several things to keep in mind while thinking about HTTPS:
For HTTPS,
the server
needs to
have "certificates"
generated by a
third party
.
Those certificates are actually
acquired
from the third party, not "generated".
Certificates have a
lifetime
.
They
expire
.
And then they need to be
renewed
,
acquired again
from the third party.
The encryption of the connection happens at the
TCP level
.
That's one layer
below HTTP
.
So, the
certificate and encryption
handling is done
before HTTP
.
TCP doesn't know about "domains"
. Only about IP addresses.
The information about the
specific domain
requested goes in the
HTTP data
.
The
HTTPS certificates
"certify" a
certain domain
, but the protocol and encryption happen at the TCP level,
before knowing
which domain is being dealt with.
By default
, that would mean that you can only have
one HTTPS certificate per IP address
.
No matter how big your server is or how small each application you have on it might be.
There is a
solution
to this, however.
There's an
extension
to the
TLS
protocol (the one handling the encryption at the TCP level, before HTTP) called
SNI
.
This SNI extension allows one single server (with a
single IP address
) to have
several HTTPS certificates
and serve
multiple HTTPS domains/applications
.
For this to work, a
single
component (program) running on the server, listening on the
public IP address
, must have
all the HTTPS certificates
in the server.
After
obtaining a secure connection, the communication protocol is
still HTTP
.
The contents are
encrypted
, even though they are being sent with the
HTTP protocol
.
It is a common practice to have
one program/HTTP server
running on the server (the machine, host, etc.) and
managing all the HTTPS parts
: receiving the
encrypted HTTPS requests
, sending the
decrypted HTTP requests
to the actual HTTP application running in the same server (the
FastAPI
application, in this case), take the
HTTP response
from the application,
encrypt it
using the appropriate
HTTPS certificate
and sending it back to the client using
HTTPS
. This server is often called a
TLS Termination Proxy
.
Some of the options you could use as a TLS Termination Proxy are:
Traefik (that can also handle certificate renewals)
Caddy (that can also handle certificate renewals)
Nginx
HAProxy
Let's Encrypt
Before Let's Encrypt, these
HTTPS certificates
were sold by trusted third parties.
The process to acquire one of these certificates used to be cumbersome, require quite some paperwork and the certificates were quite expensive.
But then
Let's Encrypt
was created.
It is a project from the Linux Foundation. It provides
HTTPS certificates for free
, in an automated way. These certificates use all the standard cryptographic security, and are short-lived (about 3 months), so the
security is actually better
because of their reduced lifespan.
The domains are securely verified and the certificates are generated automatically. This also allows automating the renewal of these certificates.
The idea is to automate the acquisition and renewal of these certificates so that you can have
secure HTTPS, for free, forever
.
HTTPS for Developers
Here's an example of how an HTTPS API could look like, step by step, paying attention mainly to the ideas important for developers.
Domain Name
It would probably all start by you
acquiring
some
domain name
. Then, you would configure it in a DNS server (possibly your same cloud provider).
You would probably get a cloud server (a virtual machine) or something similar, and it would have a
fixed
public IP address
.
In the DNS server(s) you would configure a record (an "
A record
") to point
your domain
to the public
IP address of your server
.
You would probably do this just once, the first time, when setting everything up.
Tip
This Domain Name part is way before HTTPS, but as everything depends on the domain and the IP address, it's worth mentioning it here.
DNS
Now let's focus on all the actual HTTPS parts.
First, the browser would check with the
DNS servers
what is the
IP for the domain
, in this case,
someapp.example.com
.
The DNS servers would tell the browser to use some specific
IP address
. That would be the public IP address used by your server, that you configured in the DNS servers.
TLS Handshake Start
The browser would then communicate with that IP address on
port 443
(the HTTPS port).
The first part of the communication is just to establish the connection between the client and the server and to decide the cryptographic keys they will use, etc.
This interaction between the client and the server to establish the TLS connection is called the
TLS handshake
.
TLS with SNI Extension
Only one process
in the server can be listening on a specific
port
in a specific
IP address
. There could be other processes listening on other ports in the same IP address, but only one for each combination of IP address and port.
TLS (HTTPS) uses the specific port
443
by default. So that's the port we would need.
As only one process can be listening on this port, the process that would do it would be the
TLS Termination Proxy
.
The TLS Termination Proxy would have access to one or more
TLS certificates
(HTTPS certificates).
Using the
SNI extension
discussed above, the TLS Termination Proxy would check which of the TLS (HTTPS) certificates available it should use for this connection, using the one that matches the domain expected by the client.
In this case, it would use the certificate for
someapp.example.com
.
The client already
trusts
the entity that generated that TLS certificate (in this case Let's Encrypt, but we'll see about that later), so it can
verify
that the certificate is valid.
Then, using the certificate, the client and the TLS Termination Proxy
decide how to encrypt
the rest of the
TCP communication
. This completes the
TLS Handshake
part.
After this, the client and the server have an
encrypted TCP connection
, this is what TLS provides. And then they can use that connection to start the actual
HTTP communication
.
And that's what
HTTPS
is, it's just plain
HTTP
inside a
secure TLS connection
instead of a pure (unencrypted) TCP connection.
Tip
Notice that the encryption of the communication happens at the
TCP level
, not at the HTTP level.
HTTPS Request
Now that the client and server (specifically the browser and the TLS Termination Proxy) have an
encrypted TCP connection
, they can start the
HTTP communication
.
So, the client sends an
HTTPS request
. This is just an HTTP request through an encrypted TLS connection.
Decrypt the Request
The TLS Termination Proxy would use the encryption agreed to
decrypt the request
, and would transmit the
plain (decrypted) HTTP request
to the process running the application (for example a process with Uvicorn running the FastAPI application).
HTTP Response
The application would process the request and send a
plain (unencrypted) HTTP response
to the TLS Termination Proxy.
HTTPS Response
The TLS Termination Proxy would then
encrypt the response
using the cryptography agreed before (that started with the certificate for
someapp.example.com
), and send it back to the browser.
Next, the browser would verify that the response is valid and encrypted with the right cryptographic key, etc. It would then
decrypt the response
and process it.
The client (browser) will know that the response comes from the correct server because it is using the cryptography they agreed using the
HTTPS certificate
before.
Multiple Applications
In the same server (or servers), there could be
multiple applications
, for example, other API programs or a database.
Only one process can be handling the specific IP and port (the TLS Termination Proxy in our example) but the other applications/processes can be running on the server(s) too, as long as they don't try to use the same
combination of public IP and port
.
That way, the TLS Termination Proxy could handle HTTPS and certificates for
multiple domains
, for multiple applications, and then transmit the requests to the right application in each case.
Certificate Renewal
At some point in the future, each certificate would
expire
(about 3 months after acquiring it).
And then, there would be another program (in some cases it's another program, in some cases it could be the same TLS Termination Proxy) that would talk to Let's Encrypt, and renew the certificate(s).
The
TLS certificates
are
associated with a domain name
, not with an IP address.
So, to renew the certificates, the renewal program needs to
prove
to the authority (Let's Encrypt) that it indeed
"owns" and controls that domain
.
To do that, and to accommodate different application needs, there are several ways it can do it. Some popular ways are:
Modify some DNS records
.
For this, the renewal program needs to support the APIs of the DNS provider, so, depending on the DNS provider you are using, this might or might not be an option.
Run as a server
(at least during the certificate acquisition process) on the public IP address associated with the domain.
As we said above, only one process can be listening on a specific IP and port.
This is one of the reasons why it's very useful when the same TLS Termination Proxy also takes care of the certificate renewal process.
Otherwise, you might have to stop the TLS Termination Proxy momentarily, start the renewal program to acquire the certificates, then configure them with the TLS Termination Proxy, and then restart the TLS Termination Proxy. This is not ideal, as your app(s) will not be available during the time that the TLS Termination Proxy is off.
All this renewal process, while still serving the app, is one of the main reasons why you would want to have a
separate system to handle HTTPS
with a TLS Termination Proxy instead of just using the TLS certificates with the application server directly (e.g. Uvicorn).
Recap
Having
HTTPS
is very important, and quite
critical
in most cases. Most of the effort you as a developer have to put around HTTPS is just about
understanding these concepts
and how they work.
But once you know the basic information of
HTTPS for developers
you can easily combine and configure different tools to help you manage everything in a simple way.
In some of the next chapters, I'll show you several concrete examples of how to set up
HTTPS
for
FastAPI
applications. 🔒

## 044_DEPLOYMENT_MANUALLY
Run a Server Manually¶
---

Run a Server Manually
Use the
fastapi run
Command
In short, use
fastapi run
to serve your FastAPI application:
fast →
fastapi run main.py
FastAPI
Starting production server 🚀
Searching for package file structure from directories
with
__init__.py
files
Importing from
/home/user/code/
awesomeapp
module
🐍 main.py
code
Importing the FastAPI app object from the module with
the following code:
from
main
import
app
app
Using import string:
main:app
server
Server started at
http://0.0.0.0:8000
server
Documentation at
http://0.0.0.0:8000/docs
Logs:
INFO
Started server process
[
2306215
]
INFO
Waiting for application startup.
INFO
Application startup complete.
INFO
Uvicorn running on
http://0.0.0.0:8000
(
Press CTRL+C
to quit
)
That would work for most of the cases. 😎
You could use that command for example to start your
FastAPI
app in a container, in a server, etc.
ASGI Servers
Let's go a little deeper into the details.
FastAPI uses a standard for building Python web frameworks and servers called
ASGI
. FastAPI is an ASGI web framework.
The main thing you need to run a
FastAPI
application (or any other ASGI application) in a remote server machine is an ASGI server program like
Uvicorn
, this is the one that comes by default in the
fastapi
command.
There are several alternatives, including:
Uvicorn
: a high performance ASGI server.
Hypercorn
: an ASGI server compatible with HTTP/2 and Trio among other features.
Daphne
: the ASGI server built for Django Channels.
Granian
: A Rust HTTP server for Python applications.
NGINX Unit
: NGINX Unit is a lightweight and versatile web application runtime.
Server Machine and Server Program
There's a small detail about names to keep in mind. 💡
The word "
server
" is commonly used to refer to both the remote/cloud computer (the physical or virtual machine) and also the program that is running on that machine (e.g. Uvicorn).
Just keep in mind that when you read "server" in general, it could refer to one of those two things.
When referring to the remote machine, it's common to call it
server
, but also
machine
,
VM
(virtual machine),
node
. Those all refer to some type of remote machine, normally running Linux, where you run programs.
Install the Server Program
When you install FastAPI, it comes with a production server, Uvicorn, and you can start it with the
fastapi run
command.
But you can also install an ASGI server manually.
Make sure you create a
virtual environment
, activate it, and then you can install the server application.
For example, to install Uvicorn:
fast →
pip install "uvicorn[standard]"
restart ↻
A similar process would apply to any other ASGI server program.
Tip
By adding the
standard
, Uvicorn will install and use some recommended extra dependencies.
That including
uvloop
, the high-performance drop-in replacement for
asyncio
, that provides the big concurrency performance boost.
When you install FastAPI with something like
pip install "fastapi[standard]"
you already get
uvicorn[standard]
as well.
Run the Server Program
If you installed an ASGI server manually, you would normally need to pass an import string in a special format for it to import your FastAPI application:
fast →
uvicorn main:app --host 0.0.0.0 --port 80
INFO
: Uvicorn running on http://0.0.0.0:80 (Press CTRL+C to quit)
restart ↻
Note
The command
uvicorn main:app
refers to:
main
: the file
main.py
(the Python "module").
app
: the object created inside of
main.py
with the line
app = FastAPI()
.
It is equivalent to:
from
main
import
app
Each alternative ASGI server program would have a similar command, you can read more in their respective documentation.
Warning
Uvicorn and other servers support a
--reload
option that is useful during development.
The
--reload
option consumes much more resources, is more unstable, etc.
It helps a lot during
development
, but you
shouldn't
use it in
production
.
Deployment Concepts
These examples run the server program (e.g Uvicorn), starting
a single process
, listening on all the IPs (
0.0.0.0
) on a predefined port (e.g.
80
).
This is the basic idea. But you will probably want to take care of some additional things, like:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
I'll tell you more about each of these concepts, how to think about them, and some concrete examples with strategies to handle them in the next chapters. 🚀

## 045_DEPLOYMENT_SERVER_WORKERS
Server Workers - Uvicorn with Workers¶
---

Server Workers - Uvicorn with Workers
Let's check back those deployment concepts from before:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
Up to this point, with all the tutorials in the docs, you have probably been running a
server program
, for example, using the
fastapi
command, that runs Uvicorn, running a
single process
.
When deploying applications you will probably want to have some
replication of processes
to take advantage of
multiple cores
and to be able to handle more requests.
As you saw in the previous chapter about
Deployment Concepts
, there are multiple strategies you can use.
Here I'll show you how to use
Uvicorn
with
worker processes
using the
fastapi
command or the
uvicorn
command directly.
Info
If you are using containers, for example with Docker or Kubernetes, I'll tell you more about that in the next chapter:
FastAPI in Containers - Docker
.
In particular, when running on
Kubernetes
you will probably
not
want to use workers and instead run
a single Uvicorn process per container
, but I'll tell you about it later in that chapter.
Multiple Workers
You can start multiple workers with the
--workers
command line option:
fastapi
uvicorn
If you use the
fastapi
command:
fast →
fastapi
run --workers 4
main.py
FastAPI
Starting production server 🚀
Searching for package file structure from directories with
__init__.py
files
Importing from
/home/user/code/
awesomeapp
module
🐍 main.py
code
Importing the FastAPI app object from the module with the
following code:
from
main
import
app
app
Using import string:
main:app
server
Server started at
http://0.0.0.0:8000
server
Documentation at
http://0.0.0.0:8000/docs
Logs:
INFO
Uvicorn running on
http://0.0.0.0:8000
(
Press CTRL+C to
quit
)
INFO
Started parent process
[
27365
]
INFO
Started server process
[
27368
]
INFO
Started server process
[
27369
]
INFO
Started server process
[
27370
]
INFO
Started server process
[
27367
]
INFO
Waiting for application startup.
INFO
Waiting for application startup.
INFO
Waiting for application startup.
INFO
Waiting for application startup.
INFO
Application startup complete.
INFO
Application startup complete.
INFO
Application startup complete.
INFO
Application startup complete.
restart ↻
If you prefer to use the
uvicorn
command directly:
fast →
uvicorn main:app --host 0.
The only new option here is
--workers
telling Uvicorn to start 4 worker processes.
You can also see that it shows the
PID
of each process,
27365
for the parent process (this is the
process manager
) and one for each worker process:
27368
,
27369
,
27370
, and
27367
.
Deployment Concepts
Here you saw how to use multiple
workers
to
parallelize
the execution of the application, take advantage of
multiple cores
in the CPU, and be able to serve
more requests
.
From the list of deployment concepts from above, using workers would mainly help with the
replication
part, and a little bit with the
restarts
, but you still need to take care of the others:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
Containers and Docker
In the next chapter about
FastAPI in Containers - Docker
I'll explain some strategies you could use to handle the other
deployment concepts
.
I'll show you how to
build your own image from scratch
to run a single Uvicorn process. It is a simple process and is probably what you would want to do when using a distributed container management system like
Kubernetes
.
Recap
You can use multiple worker processes with the
--workers
CLI option with the
fastapi
or
uvicorn
commands to take advantage of
multi-core CPUs
, to run
multiple processes in parallel
.
You could use these tools and ideas if you are setting up
your own deployment system
while taking care of the other deployment concepts yourself.
Check out the next chapter to learn about
FastAPI
with containers (e.g. Docker and Kubernetes). You will see that those tools have simple ways to solve the other
deployment concepts
as well. ✨

## 046_DEPLOYMENT_VERSIONS
About FastAPI versions¶
---

About FastAPI versions
FastAPI
is already being used in production in many applications and systems. And the test coverage is kept at 100%. But its development is still moving quickly.
New features are added frequently, bugs are fixed regularly, and the code is still continuously improving.
That's why the current versions are still
0.x.x
, this reflects that each version could potentially have breaking changes. This follows the
Semantic Versioning
conventions.
You can create production applications with
FastAPI
right now (and you have probably been doing it for some time), you just have to make sure that you use a version that works correctly with the rest of your code.
Pin your
fastapi
version
The first thing you should do is to "pin" the version of
FastAPI
you are using to the specific latest version that you know works correctly for your application.
For example, let's say you are using version
0.112.0
in your app.
If you use a
requirements.txt
file you could specify the version with:
fastapi[standard]==0.112.0
that would mean that you would use exactly the version
0.112.0
.
Or you could also pin it with:
fastapi[standard]>=0.112.0,<0.113.0
that would mean that you would use the versions
0.112.0
or above, but less than
0.113.0
, for example, a version
0.112.2
would still be accepted.
If you use any other tool to manage your installations, like
uv
, Poetry, Pipenv, or others, they all have a way that you can use to define specific versions for your packages.
Available versions
You can see the available versions (e.g. to check what is the current latest) in the
Release Notes
.
About versions
Following the Semantic Versioning conventions, any version below
1.0.0
could potentially add breaking changes.
FastAPI also follows the convention that any "PATCH" version change is for bug fixes and non-breaking changes.
Tip
The "PATCH" is the last number, for example, in
0.2.3
, the PATCH version is
3
.
So, you should be able to pin to a version like:
fastapi>=0.45.0,<0.46.0
Breaking changes and new features are added in "MINOR" versions.
Tip
The "MINOR" is the number in the middle, for example, in
0.2.3
, the MINOR version is
2
.
Upgrading the FastAPI versions
You should add tests for your app.
With
FastAPI
it's very easy (thanks to Starlette), check the docs:
Testing
After you have tests, then you can upgrade the
FastAPI
version to a more recent one, and make sure that all your code is working correctly by running your tests.
If everything is working, or after you make the necessary changes, and all your tests are passing, then you can pin your
fastapi
to that new recent version.
About Starlette
You shouldn't pin the version of
starlette
.
Different versions of
FastAPI
will use a specific newer version of Starlette.
So, you can just let
FastAPI
use the correct Starlette version.
About Pydantic
Pydantic includes the tests for
FastAPI
with its own tests, so new versions of Pydantic (above
1.0.0
) are always compatible with FastAPI.
You can pin Pydantic to any version above
1.0.0
that works for you.
For example:
pydantic>=2.7.0,<3.0.0

## 047_EM
FastAPI¶
---

FastAPI
FastAPI 🛠️, ↕ 🎭, ⏩ 💡, ⏩ 📟, 🔜 🏭
🧾
:
https://fastapi.tiangolo.com
ℹ 📟
:
https://github.com/fastapi/fastapi
FastAPI 🏛, ⏩ (↕-🎭), 🕸 🛠️ 🏗 🛠️ ⏮️ 🐍 3️⃣.8️⃣ ➕ ⚓️ 🔛 🐩 🐍 🆎 🔑.
🔑 ⚒:
⏩
: 📶 ↕ 🎭, 🔛 🇷🇪 ⏮️
✳
&
🚶
(👏 💃 & Pydantic).
1️⃣ ⏩ 🐍 🛠️ 💪
.
⏩ 📟
: 📈 🚅 🛠️ ⚒ 🔃 2️⃣0️⃣0️⃣ 💯 3️⃣0️⃣0️⃣ 💯. *
👩‍❤‍👨 🐛
: 📉 🔃 4️⃣0️⃣ 💯 🗿 (👩‍💻) 📉 ❌. *
🏋️
: 👑 👨‍🎨 🐕‍🦺.
🛠️
🌐. 🌘 🕰 🛠️.
⏩
: 🔧 ⏩ ⚙️ & 💡. 🌘 🕰 👂 🩺.
📏
: 📉 📟 ❎. 💗 ⚒ ⚪️➡️ 🔠 🔢 📄. 👩‍❤‍👨 🐛.
🏋️
: 🤚 🏭-🔜 📟. ⏮️ 🏧 🎓 🧾.
🐩-⚓️
: ⚓️ 🔛 (& 🍕 🔗 ⏮️) 📂 🐩 🔗:
🗄
(⏪ 💭 🦁) &
🎻 🔗
.
* ⚖ ⚓️ 🔛 💯 🔛 🔗 🛠️ 🏉, 🏗 🏭 🈸.
💰
🎏 💰
🤔
"
[...] 👤 ⚙️
FastAPI
📚 👫 📆. [...] 👤 🤙 📆 ⚙️ ⚫️ 🌐 👇 🏉
⚗ 🐕‍🦺 🤸‍♂
. 👫 💆‍♂ 🛠️ 🔘 🐚
🖥
🏬 &
📠
🏬.
"
🧿 🇵🇰 -
🤸‍♂
(🇦🇪)
"
👥 🛠️
FastAPI
🗃 🤖
🎂
💽 👈 💪 🔢 🚚
🔮
. [👨📛]
"
🇮🇹 🇸🇻, 👨📛 👨📛, & 🇱🇰 🕉 🕉 -
🙃
(🇦🇪)
"
📺
🙏 📣 📂-ℹ 🚀 👆
⚔ 🧾
🎶 🛠️:
📨
❗ [🏗 ⏮️
FastAPI
]
"
✡ 🍏, 👖 🇪🇸, 🌲 🍏 -
📺
(🇦🇪)
"
👤 🤭 🌕 😄 🔃
FastAPI
. ⚫️ 🎊 ❗
"
✡ 🇭🇰 -
🐍 🔢
📻 🦠
(🇦🇪)
"
🤙, ⚫️❔ 👆 ✔️ 🏗 👀 💎 💠 & 🇵🇱. 📚 🌌, ⚫️ ⚫️❔ 👤 💚
🤗
- ⚫️ 🤙 😍 👀 👱 🏗 👈.
"
✡ 🗄 -
🤗
👼
(🇦🇪)
"
🚥 👆 👀 💡 1️⃣
🏛 🛠️
🏗 🎂 🔗, ✅ 👅
FastAPI
[...] ⚫️ ⏩, ⏩ ⚙️ & ⏩ 💡 [...]
"
"
👥 ✔️ 🎛 🤭
FastAPI
👆
🔗
[...] 👤 💭 👆 🔜 💖 ⚫️ [...]
"
🇱🇨 🇸🇲 - ✡ Honnibal -
💥 👲
🕴 -
🌈
👼
(🇦🇪)
-
(🇦🇪)
"
🚥 🙆 👀 🏗 🏭 🐍 🛠️, 👤 🔜 🏆 👍
FastAPI
. ⚫️
💎 🏗
,
🙅 ⚙️
&
🏆 🛠️
, ⚫️ ✔️ ▶️️
🔑 🦲
👆 🛠️ 🥇 🛠️ 🎛 & 🚘 📚 🏧 & 🐕‍🦺 ✅ 👆 🕹 🔫 👨‍💻.
"
🇹🇦 🍰 -
📻
(🇦🇪)
🏎
, FastAPI 🇳🇨
🚥 👆 🏗
✳
📱 ⚙️ 📶 ↩️ 🕸 🛠️, ✅ 👅
🏎
.
🏎
FastAPI 🐥 👪. & ⚫️ 🎯
FastAPI 🇳🇨
. 👶 👶 👶
📄
🐍 3️⃣.7️⃣ ➕
FastAPI 🧍 🔛 ⌚ 🐘:
💃
🕸 🍕.
Pydantic
📊 🍕.
👷‍♂
fast →
pip install "fastapi[standard]"
restart ↻
👆 🔜 💪 🔫 💽, 🏭 ✅
Uvicorn
⚖️
Hypercorn
.
fast →
pip install "uvicorn[standard]"
restart ↻
🖼
✍ ⚫️
✍ 📁
main.py
⏮️:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
⚖️ ⚙️
async def
...
🚥 👆 📟 ⚙️
async
/
await
, ⚙️
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
🗒
:
🚥 👆 🚫 💭, ✅ _"🏃 ❓" _ 📄 🔃
async
&
await
🩺
.
🏃 ⚫️
🏃 💽 ⏮️:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
🔃 📋
uvicorn main:app --reload
...
📋
uvicorn main:app
🔗:
main
: 📁
main.py
(🐍 "🕹").
app
: 🎚 ✍ 🔘
main.py
⏮️ ⏸
app = FastAPI()
.
--reload
: ⚒ 💽 ⏏ ⏮️ 📟 🔀. 🕴 👉 🛠️.
✅ ⚫️
📂 👆 🖥
http://127.0.0.1:8000/items/5?q=somequery
.
👆 🔜 👀 🎻 📨:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
👆 ⏪ ✍ 🛠️ 👈:
📨 🇺🇸🔍 📨
➡
/
&
/items/{item_id}
.
👯‍♂️
➡
✊
GET
🛠️
(💭 🇺🇸🔍
👩‍🔬
).
➡
/items/{item_id}
✔️
➡ 🔢
item_id
👈 🔜
int
.
➡
/items/{item_id}
✔️ 📦
str
_🔢 =
q
.
🎓 🛠️ 🩺
🔜 🚶
http://127.0.0.1:8000/docs
.
👆 🔜 👀 🏧 🎓 🛠️ 🧾 (🚚
🦁 🎚
):
🎛 🛠️ 🩺
& 🔜, 🚶
http://127.0.0.1:8000/redoc
.
👆 🔜 👀 🎛 🏧 🧾 (🚚
📄
):
🖼 ♻
🔜 🔀 📁
main.py
📨 💪 ⚪️➡️
PUT
📨.
📣 💪 ⚙️ 🐩 🐍 🆎, 👏 Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
💽 🔜 🔃 🔁 (↩️ 👆 🚮
--reload
uvicorn
📋 🔛).
🎓 🛠️ 🩺 ♻
🔜 🚶
http://127.0.0.1:8000/docs
.
🎓 🛠️ 🧾 🔜 🔁 ℹ, 🔌 🆕 💪:
🖊 🔛 🔼 "🔄 ⚫️ 👅", ⚫️ ✔ 👆 🥧 🔢 & 🔗 🔗 ⏮️ 🛠️:
⤴️ 🖊 🔛 "🛠️" 🔼, 👩‍💻 🔢 🔜 🔗 ⏮️ 👆 🛠️, 📨 🔢, 🤚 🏁 & 🎦 👫 🔛 🖥:
🎛 🛠️ 🩺 ♻
& 🔜, 🚶
http://127.0.0.1:8000/redoc
.
🎛 🧾 🔜 🎨 🆕 🔢 🔢 & 💪:
🌃
📄, 👆 📣
🕐
🆎 🔢, 💪, ♒️. 🔢 🔢.
👆 👈 ⏮️ 🐩 🏛 🐍 🆎.
👆 🚫 ✔️ 💡 🆕 ❕, 👩‍🔬 ⚖️ 🎓 🎯 🗃, ♒️.
🐩
🐍 3️⃣.7️⃣ ➕
.
🖼,
int
:
item_id
:
int
⚖️ 🌖 🏗
Item
🏷:
item
:
Item
...& ⏮️ 👈 👁 📄 👆 🤚:
👨‍🎨 🐕‍🦺, 🔌:
🛠️.
🆎 ✅.
🔬 💽:
🏧 & 🆑 ❌ 🕐❔ 📊 ❌.
🔬 🙇 🐦 🎻 🎚.
🛠️
🔢 💽: 👟 ⚪️➡️ 🕸 🐍 💽 & 🆎. 👂 ⚪️➡️:
🎻.
➡ 🔢.
🔢 🔢.
🍪.
🎚.
📨.
📁.
🛠️
🔢 📊: 🗜 ⚪️➡️ 🐍 💽 & 🆎 🕸 💽 (🎻):
🗜 🐍 🆎 (
str
,
int
,
float
,
bool
,
list
, ♒️).
datetime
🎚.
UUID
🎚.
💽 🏷.
...& 📚 🌖.
🏧 🎓 🛠️ 🧾, 🔌 2️⃣ 🎛 👩‍💻 🔢:
🦁 🎚.
📄.
👟 🔙 ⏮️ 📟 🖼,
FastAPI
🔜:
✔ 👈 📤
item_id
➡
GET
&
PUT
📨.
✔ 👈
item_id
🆎
int
GET
&
PUT
📨.
🚥 ⚫️ 🚫, 👩‍💻 🔜 👀 ⚠, 🆑 ❌.
✅ 🚥 📤 📦 🔢 🔢 📛
q
(
http://127.0.0.1:8000/items/foo?q=somequery
)
GET
📨.
q
🔢 📣 ⏮️
= None
, ⚫️ 📦.
🍵
None
⚫️ 🔜 🚚 (💪 💼 ⏮️
PUT
).
PUT
📨
/items/{item_id}
, ✍ 💪 🎻:
✅ 👈 ⚫️ ✔️ ✔ 🔢
name
👈 🔜
str
.
✅ 👈 ⚫️ ✔️ ✔ 🔢
price
👈 ✔️
float
.
✅ 👈 ⚫️ ✔️ 📦 🔢
is_offer
, 👈 🔜
bool
, 🚥 🎁.
🌐 👉 🔜 👷 🙇 🐦 🎻 🎚.
🗜 ⚪️➡️ & 🎻 🔁.
📄 🌐 ⏮️ 🗄, 👈 💪 ⚙️:
🎓 🧾 ⚙️.
🏧 👩‍💻 📟 ⚡ ⚙️, 📚 🇪🇸.
🚚 2️⃣ 🎓 🧾 🕸 🔢 🔗.
👥 🖌 🧽, ✋️ 👆 ⏪ 🤚 💭 ❔ ⚫️ 🌐 👷.
🔄 🔀 ⏸ ⏮️:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...⚪️➡️:
...
"item_name"
:
item
.
name
...
...:
...
"item_price"
:
item
.
price
...
...& 👀 ❔ 👆 👨‍🎨 🔜 🚘-🏁 🔢 & 💭 👫 🆎:
🌅 🏁 🖼 🔌 🌅 ⚒, 👀
🔰 - 👩‍💻 🦮
.
🚘 🚨
: 🔰 - 👩‍💻 🦮 🔌:
📄
🔢
⚪️➡️ 🎏 🎏 🥉:
🎚
,
🍪
,
📨 🏑
&
📁
.
❔ ⚒
🔬 ⚛
maximum_length
⚖️
regex
.
📶 🏋️ & ⏩ ⚙️
🔗 💉
⚙️.
💂‍♂ & 🤝, ✅ 🐕‍🦺
Oauth2️⃣
⏮️
🥙 🤝
&
🇺🇸🔍 🔰
🔐.
🌅 🏧 (✋️ 😨 ⏩) ⚒ 📣
🙇 🐦 🎻 🏷
(👏 Pydantic).
🕹
🛠️ ⏮️
🍓
& 🎏 🗃.
📚 ➕ ⚒ (👏 💃):
** *️⃣ **
📶 ⏩ 💯 ⚓️ 🔛 🇸🇲 &
pytest
⚜
🍪 🎉
...& 🌖.
🎭
🔬 🇸🇲 📇 🎦
FastAPI
🈸 🏃‍♂ 🔽 Uvicorn
1️⃣ ⏩ 🐍 🛠️ 💪
, 🕴 🔛 💃 & Uvicorn 👫 (⚙️ 🔘 FastAPI). (*)
🤔 🌖 🔃 ⚫️, 👀 📄
📇
.
📦 🔗
⚙️ Pydantic:
email-validator
- 📧 🔬.
⚙️ 💃:
httpx
- ✔ 🚥 👆 💚 ⚙️
TestClient
.
jinja2
- ✔ 🚥 👆 💚 ⚙️ 🔢 📄 📳.
python-multipart
- ✔ 🚥 👆 💚 🐕‍🦺 📨
"✍"
, ⏮️
request.form()
.
itsdangerous
- ✔
SessionMiddleware
🐕‍🦺.
pyyaml
- ✔ 💃
SchemaGenerator
🐕‍🦺 (👆 🎲 🚫 💪 ⚫️ ⏮️ FastAPI).
⚙️ FastAPI / 💃:
uvicorn
- 💽 👈 📐 & 🍦 👆 🈸.
orjson
- ✔ 🚥 👆 💚 ⚙️
ORJSONResponse
.
ujson
- ✔ 🚥 👆 💚 ⚙️
UJSONResponse
.
👆 💪 ❎ 🌐 👫 ⏮️
pip install "fastapi[all]"
.
🛂
👉 🏗 ® 🔽 ⚖ 🇩🇪 🛂.

## 048_ENVIRONMENT_VARIABLES
Environment Variables¶
---

Environment Variables
Tip
If you already know what "environment variables" are and how to use them, feel free to skip this.
An environment variable (also known as "
env var
") is a variable that lives
outside
of the Python code, in the
operating system
, and could be read by your Python code (or by other programs as well).
Environment variables could be useful for handling application
settings
, as part of the
installation
of Python, etc.
Create and Use Env Vars
You can
create
and use environment variables in the
shell (terminal)
, without needing Python:
Linux, macOS, Windows Bash
Windows PowerShell
fast →
💬 You could create an env var MY_NAME with
export MY_NAME="Wade Wilso
fast →
💬 Create an env var MY_NAME
$Env:MY_NAME = "Wade Wilso
Read env vars in Python
You could also create environment variables
outside
of Python, in the terminal (or with any other method), and then
read them in Python
.
For example you could have a file
main.py
with:
import
os
name
=
os
.
getenv
(
"MY_NAME"
,
"World"
)
print
(
f
"Hello
{
name
}
from Python"
)
Tip
The second argument to
os.getenv()
is the default value to return.
If not provided, it's
None
by default, here we provide
"World"
as the default value to use.
Then you could call that Python program:
Linux, macOS, Windows Bash
Windows PowerShell
fast →
💬 Here we don't set the env var yet
python main.py
💬 As we didn't set the env var, we get the default value
Hello World from Python
💬 But if we create an environment variable first
export MY_NAME="Wade Wilson"
💬 And then call the program again
python main.py
💬 Now it can read the environment variable
Hello Wade Wilson from Python
restart ↻
fast →
💬 Here we don't set the env var yet
python main.py
💬 As we didn't set the env var, we get the default value
Hello World from Python
💬 But if we create an environment variable first
$
As environment variables can be set outside of the code, but can be read by the code, and don't have to be stored (committed to
git
) with the rest of the files, it's common to use them for configurations or
settings
.
You can also create an environment variable only for a
specific program invocation
, that is only available to that program, and only for its duration.
To do that, create it right before the program itself, on the same line:
fast →
💬 Create an env var MY_NAME in line for this program call
MY_NAME="Wade Wilson" python main.py
💬 Now it can read the environment variable
Hello Wade Wilson from Python
💬 The env var no longer exists afterwards
python main.py
Hello World from Python
restart ↻
Tip
You can read more about it at
The Twelve-Factor App: Config
.
Types and Validation
These environment variables can only handle
text strings
, as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS).
That means that
any value
read in Python from an environment variable
will be a
str
, and any conversion to a different type or any validation has to be done in code.
You will learn more about using environment variables for handling
application settings
in the
Advanced User Guide - Settings and Environment Variables
.
PATH
Environment Variable
There is a
special
environment variable called
PATH
that is used by the operating systems (Linux, macOS, Windows) to find programs to run.
The value of the variable
PATH
is a long string that is made of directories separated by a colon
:
on Linux and macOS, and by a semicolon
;
on Windows.
For example, the
PATH
environment variable could look like this:
Linux, macOS
Windows
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
This means that the system should look for programs in the directories:
/usr/local/bin
/usr/bin
/bin
/usr/sbin
/sbin
C:\Program Files\Python312\Scripts;C:\Program Files\Python312;C:\Windows\System32
This means that the system should look for programs in the directories:
C:\Program Files\Python312\Scripts
C:\Program Files\Python312
C:\Windows\System32
When you type a
command
in the terminal, the operating system
looks for
the program in
each of those directories
listed in the
PATH
environment variable.
For example, when you type
python
in the terminal, the operating system looks for a program called
python
in the
first directory
in that list.
If it finds it, then it will
use it
. Otherwise it keeps looking in the
other directories
.
Installing Python and Updating the
PATH
When you install Python, you might be asked if you want to update the
PATH
environment variable.
Linux, macOS
Windows
Let's say you install Python and it ends up in a directory
/opt/custompython/bin
.
If you say yes to update the
PATH
environment variable, then the installer will add
/opt/custompython/bin
to the
PATH
environment variable.
It could look like this:
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/custompython/bin
This way, when you type
python
in the terminal, the system will find the Python program in
/opt/custompython/bin
(the last directory) and use that one.
Let's say you install Python and it ends up in a directory
C:\opt\custompython\bin
.
If you say yes to update the
PATH
environment variable, then the installer will add
C:\opt\custompython\bin
to the
PATH
environment variable.
C:\Program Files\Python312\Scripts;C:\Program Files\Python312;C:\Windows\System32;C:\opt\custompython\bin
This way, when you type
python
in the terminal, the system will find the Python program in
C:\opt\custompython\bin
(the last directory) and use that one.
So, if you type:
fast →
python
restart ↻
Linux, macOS
Windows
The system will
find
the
python
program in
/opt/custompython/bin
and run it.
It would be roughly equivalent to typing:
fast →
/opt/custompython/bin/python
restart ↻
The system will
find
the
python
program in
C:\opt\custompython\bin\python
and run it.
It would be roughly equivalent to typing:
fast →
C:\opt\custompython\bin\py
This information will be useful when learning about
Virtual Environments
.
Conclusion
With this you should have a basic understanding of what
environment variables
are and how to use them in Python.
You can also read more about them in the
Wikipedia for Environment Variable
.
In many cases it's not very obvious how environment variables would be useful and applicable right away. But they keep showing up in many different scenarios when you are developing, so it's good to know about them.
For example, you will need this information in the next section, about
Virtual Environments
.

## 049_ES
FastAPI¶
---

FastAPI
FastAPI framework, alto rendimiento, fácil de aprender, rápido de programar, listo para producción
Documentación
:
https://fastapi.tiangolo.com
Código Fuente
:
https://github.com/fastapi/fastapi
FastAPI es un framework web moderno, rápido (de alto rendimiento), para construir APIs con Python basado en las anotaciones de tipos estándar de Python.
Las características clave son:
Rápido
: Muy alto rendimiento, a la par con
NodeJS
y
Go
(gracias a Starlette y Pydantic).
Uno de los frameworks Python más rápidos disponibles
.
Rápido de programar
: Aumenta la velocidad para desarrollar funcionalidades en aproximadamente un 200% a 300%. *
Menos bugs
: Reduce en aproximadamente un 40% los errores inducidos por humanos (desarrolladores). *
Intuitivo
: Gran soporte para editores.
Autocompletado
en todas partes. Menos tiempo depurando.
Fácil
: Diseñado para ser fácil de usar y aprender. Menos tiempo leyendo documentación.
Corto
: Minimiza la duplicación de código. Múltiples funcionalidades desde cada declaración de parámetro. Menos bugs.
Robusto
: Obtén código listo para producción. Con documentación interactiva automática.
Basado en estándares
: Basado (y completamente compatible) con los estándares abiertos para APIs:
OpenAPI
(anteriormente conocido como Swagger) y
JSON Schema
.
* estimación basada en pruebas con un equipo de desarrollo interno, construyendo aplicaciones de producción.
Sponsors
Otros sponsors
Opiniones
"
[...] Estoy usando
FastAPI
un montón estos días. [...] De hecho, estoy planeando usarlo para todos los servicios de
ML de mi equipo en Microsoft
. Algunos de ellos se están integrando en el núcleo del producto
Windows
y algunos productos de
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
Adoptamos el paquete
FastAPI
para crear un servidor
REST
que pueda ser consultado para obtener
predicciones
. [para Ludwig]
"
Piero Molino, Yaroslav Dudin, y Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
se complace en anunciar el lanzamiento de código abierto de nuestro framework de orquestación de
gestión de crisis
:
Dispatch
! [construido con
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Estoy súper emocionado con
FastAPI
. ¡Es tan divertido!
"
Brian Okken -
host del podcast Python Bytes
(ref)
"
Honestamente, lo que has construido parece súper sólido y pulido. En muchos aspectos, es lo que quería que
Hug
fuera; es realmente inspirador ver a alguien construir eso.
"
Timothy Crosley -
creador de Hug
(ref)
"
Si estás buscando aprender un
framework moderno
para construir APIs REST, échale un vistazo a
FastAPI
[...] Es rápido, fácil de usar y fácil de aprender [...]
"
"
Nos hemos cambiado a
FastAPI
para nuestras
APIs
[...] Creo que te gustará [...]
"
Ines Montani - Matthew Honnibal -
fundadores de Explosion AI
-
creadores de spaCy
(ref)
-
(ref)
"
Si alguien está buscando construir una API de Python para producción, altamente recomendaría
FastAPI
. Está
hermosamente diseñado
, es
simple de usar
y
altamente escalable
, se ha convertido en un
componente clave
en nuestra estrategia de desarrollo API primero y está impulsando muchas automatizaciones y servicios como nuestro Ingeniero Virtual TAC.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, el FastAPI de las CLIs
Si estás construyendo una aplicación de
CLI
para ser usada en el terminal en lugar de una API web, revisa
Typer
.
Typer
es el hermano pequeño de FastAPI. Y está destinado a ser el
FastAPI de las CLIs
. ⌨️ 🚀
Requisitos
FastAPI se apoya en hombros de gigantes:
Starlette
para las partes web.
Pydantic
para las partes de datos.
Instalación
Crea y activa un
entorno virtual
y luego instala FastAPI:
fast →
pip install "fastapi[standard]"
restart ↻
Nota
: Asegúrate de poner
"fastapi[standard]"
entre comillas para asegurar que funcione en todas las terminales.
Ejemplo
Créalo
Crea un archivo
main.py
con:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
O usa
async def
...
Si tu código usa
async
/
await
, usa
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Nota
:
Si no lo sabes, revisa la sección
"¿Con prisa?"
sobre
async
y
await
en la documentación
.
Córrelo
Corre el servidor con:
fast →
fastapi dev main.py
╭────────── FastAPI CLI - Development mode ───────────╮
│ │
│ Serving at: http://127.0.0.1:8000 │
│ │
│ API docs: http://127.0.0.1:8000/docs │
│ │
│ Running in development mode, for production use: │
│ │
│ fastapi run │
│ │
╰─────────────────────────────────────────────────────╯
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
Acerca del comando
fastapi dev main.py
...
El comando
fastapi dev
lee tu archivo
main.py
, detecta la app
FastAPI
en él y arranca un servidor usando
Uvicorn
.
Por defecto,
fastapi dev
comenzará con auto-recarga habilitada para el desarrollo local.
Puedes leer más sobre esto en la
documentación del CLI de FastAPI
.
Revísalo
Abre tu navegador en
http://127.0.0.1:8000/items/5?q=somequery
.
Verás el response JSON como:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Ya creaste una API que:
Recibe requests HTTP en los
paths
/
y
/items/{item_id}
.
Ambos
paths
toman
operaciones
GET
(también conocidas como métodos HTTP).
El
path
/items/{item_id}
tiene un
parámetro de path
item_id
que debe ser un
int
.
El
path
/items/{item_id}
tiene un
parámetro de query
q
opcional que es un
str
.
Documentación interactiva de la API
Ahora ve a
http://127.0.0.1:8000/docs
.
Verás la documentación interactiva automática de la API (proporcionada por
Swagger UI
):
Documentación de API Alternativa
Y ahora, ve a
http://127.0.0.1:8000/redoc
.
Verás la documentación alternativa automática (proporcionada por
ReDoc
):
Actualización del Ejemplo
Ahora modifica el archivo
main.py
para recibir un body desde un request
PUT
.
Declara el body usando tipos estándar de Python, gracias a Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
El servidor
fastapi dev
debería recargarse automáticamente.
Actualización de la Documentación Interactiva de la API
Ahora ve a
http://127.0.0.1:8000/docs
.
La documentación interactiva de la API se actualizará automáticamente, incluyendo el nuevo body:
Haz clic en el botón "Try it out", te permite llenar los parámetros e interactuar directamente con la API:
Luego haz clic en el botón "Execute", la interfaz de usuario se comunicará con tu API, enviará los parámetros, obtendrá los resultados y los mostrará en la pantalla:
Actualización de la Documentación Alternativa de la API
Y ahora, ve a
http://127.0.0.1:8000/redoc
.
La documentación alternativa también reflejará el nuevo parámetro de query y body:
Resumen
En resumen, declaras
una vez
los tipos de parámetros, body, etc. como parámetros de función.
Lo haces con tipos estándar modernos de Python.
No tienes que aprender una nueva sintaxis, los métodos o clases de un paquete específico, etc.
Solo
Python
estándar.
Por ejemplo, para un
int
:
item_id
:
int
o para un modelo
Item
más complejo:
item
:
Item
...y con esa única declaración obtienes:
Soporte para editores, incluyendo:
Autocompletado.
Chequeo de tipos.
Validación de datos:
Errores automáticos y claros cuando los datos son inválidos.
Validación incluso para objetos JSON profundamente anidados.
Conversión
de datos de entrada: de la red a los datos y tipos de Python. Leyendo desde:
JSON.
Parámetros de path.
Parámetros de query.
Cookies.
Headers.
Forms.
Archivos.
Conversión
de datos de salida: convirtiendo de datos y tipos de Python a datos de red (como JSON):
Convertir tipos de Python (
str
,
int
,
float
,
bool
,
list
, etc).
Objetos
datetime
.
Objetos
UUID
.
Modelos de base de datos.
...y muchos más.
Documentación interactiva automática de la API, incluyendo 2 interfaces de usuario alternativas:
Swagger UI.
ReDoc.
Volviendo al ejemplo de código anterior,
FastAPI
:
Validará que haya un
item_id
en el path para requests
GET
y
PUT
.
Validará que el
item_id
sea del tipo
int
para requests
GET
y
PUT
.
Si no lo es, el cliente verá un error útil y claro.
Comprobará si hay un parámetro de query opcional llamado
q
(como en
http://127.0.0.1:8000/items/foo?q=somequery
) para requests
GET
.
Como el parámetro
q
está declarado con
= None
, es opcional.
Sin el
None
sería requerido (como lo es el body en el caso con
PUT
).
Para requests
PUT
a
/items/{item_id}
, leerá el body como JSON:
Comprobará que tiene un atributo requerido
name
que debe ser un
str
.
Comprobará que tiene un atributo requerido
price
que debe ser un
float
.
Comprobará que tiene un atributo opcional
is_offer
, que debe ser un
bool
, si está presente.
Todo esto también funcionaría para objetos JSON profundamente anidados.
Convertirá de y a JSON automáticamente.
Documentará todo con OpenAPI, que puede ser usado por:
Sistemas de documentación interactiva.
Sistemas de generación automática de código cliente, para muchos lenguajes.
Proporcionará 2 interfaces web de documentación interactiva directamente.
Solo tocamos los conceptos básicos, pero ya te haces una idea de cómo funciona todo.
Intenta cambiar la línea con:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...desde:
...
"item_name"
:
item
.
name
...
...a:
...
"item_price"
:
item
.
price
...
...y observa cómo tu editor autocompleta los atributos y conoce sus tipos:
Para un ejemplo más completo incluyendo más funcionalidades, ve al
Tutorial - Guía del Usuario
.
Alerta de spoilers
: el tutorial - guía del usuario incluye:
Declaración de
parámetros
desde otros lugares diferentes como:
headers
,
cookies
,
campos de formulario
y
archivos
.
Cómo establecer
restricciones de validación
como
maximum_length
o
regex
.
Un sistema de
Inyección de Dependencias
muy poderoso y fácil de usar.
Seguridad y autenticación, incluyendo soporte para
OAuth2
con
tokens JWT
y autenticación
HTTP Basic
.
Técnicas más avanzadas (pero igualmente fáciles) para declarar
modelos JSON profundamente anidados
(gracias a Pydantic).
Integración con
GraphQL
usando
Strawberry
y otros paquetes.
Muchas funcionalidades extra (gracias a Starlette) como:
WebSockets
pruebas extremadamente fáciles basadas en HTTPX y
pytest
CORS
Sesiones de Cookies
...y más.
Rendimiento
Benchmarks independientes de TechEmpower muestran aplicaciones
FastAPI
ejecutándose bajo Uvicorn como
uno de los frameworks Python más rápidos disponibles
, solo por debajo de Starlette y Uvicorn (usados internamente por FastAPI). (*)
Para entender más sobre esto, ve la sección
Benchmarks
.
Dependencias
FastAPI depende de Pydantic y Starlette.
Dependencias
standard
Cuando instalas FastAPI con
pip install "fastapi[standard]"
viene con el grupo
standard
de dependencias opcionales:
Usadas por Pydantic:
email-validator
- para validación de correos electrónicos.
Usadas por Starlette:
httpx
- Requerido si deseas usar el
TestClient
.
jinja2
- Requerido si deseas usar la configuración de plantilla predeterminada.
python-multipart
- Requerido si deseas soportar
"parsing"
de forms, con
request.form()
.
Usadas por FastAPI / Starlette:
uvicorn
- para el servidor que carga y sirve tu aplicación. Esto incluye
uvicorn[standard]
, que incluye algunas dependencias (por ejemplo,
uvloop
) necesarias para servir con alto rendimiento.
fastapi-cli
- para proporcionar el comando
fastapi
.
Sin Dependencias
standard
Si no deseas incluir las dependencias opcionales
standard
, puedes instalar con
pip install fastapi
en lugar de
pip install "fastapi[standard]"
.
Dependencias Opcionales Adicionales
Existen algunas dependencias adicionales que podrías querer instalar.
Dependencias opcionales adicionales de Pydantic:
pydantic-settings
- para la gestión de configuraciones.
pydantic-extra-types
- para tipos extra para ser usados con Pydantic.
Dependencias opcionales adicionales de FastAPI:
orjson
- Requerido si deseas usar
ORJSONResponse
.
ujson
- Requerido si deseas usar
UJSONResponse
.
Licencia
Este proyecto tiene licencia bajo los términos de la licencia MIT.

## 050_EXTERNAL_LINKS
External Links and Articles¶
---

External Links and Articles
FastAPI
has a great community constantly growing.
There are many posts, articles, tools, and projects, related to
FastAPI
.
Here's an incomplete list of some of them.
Tip
If you have an article, project, tool, or anything related to
FastAPI
that is not yet listed here, create a
Pull Request adding it
.
Articles
English
How to profile a FastAPI asynchronous request
by
Balthazar Rouberol
.
Deploy a Serverless FastAPI App with Neon Postgres and AWS App Runner at any scale
by
Stephen Siegert - Neon
.
Building a Machine Learning Microservice with FastAPI
by
Kurtis Pykes - NVIDIA
.
Booking Appointments with Twilio, Notion, and FastAPI
by
Ravgeet Dhillon - Twilio
.
Write a Python data layer with Azure Cosmos DB and FastAPI
by
Abhinav Tripathi - Microsoft Blogs
.
10 Tips for adding SQLAlchemy to FastAPI
by
Donny Peeters
.
Tips on migrating from Flask to FastAPI and vice-versa
by
Jessica Temporal
.
Explore How to Effectively Use JWT With FastAPI
by
Ankit Anchlia
.
Instrument FastAPI with OpenTelemetry tracing and visualize traces in Grafana Tempo.
by
Nicoló Lino
.
ML serving and monitoring with FastAPI and Evidently
by
Mikhail Rozhkov, Elena Samuylova
.
FastAPI Tutorial in Visual Studio Code
by
Visual Studio Code Team
.
FastAPI application monitoring made easy
by
Apitally
.
Building a RESTful API with FastAPI: Secure Signup and Login Functionality Included
by
John Philip
.
Building a CRUD API with FastAPI and Supabase
by
Keshav Malik
.
Build an SMS Spam Classifier Serverless Database with FaunaDB and FastAPI
by
Adejumo Ridwan Suleiman
.
FastAPI lambda container: serverless simplified
by
Raf Rasenberg
.
Authorization on FastAPI with Casbin
by
Teresa N. Fontanella De Santis
.
How to monitor FastAPI application performance using Python agent
by
New Relic
.
Building the Poll App From Django Tutorial With FastAPI And React
by
Jean-Baptiste Rocher
.
Seamless FastAPI Configuration with ConfZ
by
Silvan Melchior
.
5 Advanced Features of FastAPI You Should Try
by
Kaustubh Gupta
.
Deploying ML Models as API Using FastAPI and Heroku
by
Kaustubh Gupta
.
Using GitHub Actions to Deploy a FastAPI Project to Heroku
by
Somraj Saha
.
How to Create A Fake Certificate Authority And Generate TLS Certs for FastAPI
by
@pystar
.
Building a realtime ticket booking solution with Kafka, FastAPI, and Ably
by
Ben Gamble
.
Building simple E-Commerce with NuxtJS and FastAPI
by
Shahriyar(Shako) Rzayev
.
Serve a machine learning model using Sklearn, FastAPI and Docker
by
Rodrigo Arenas
.
Building an API with FastAPI and Supabase and Deploying on Deta
by
Yashasvi Singh
.
Deploy FastAPI on Ubuntu and Serve using Caddy 2 Web Server
by
Navule Pavan Kumar Rao
.
Python Facebook messenger webhook with FastAPI on Glitch
by
Patrick Ladon
.
Deploy a dockerized FastAPI application to AWS
by
Valon Januzaj
.
FastAPI for Flask Users
by
Amit Chaudhary
.
How to monitor your FastAPI service
by
Louis Guitton
.
Creating a CRUD App with FastAPI (Part one)
by
Precious Ndubueze
.
Build And Host Fast Data Science Applications Using FastAPI
by
Farhad Malik
.
Deploy FastAPI on Azure App Service
by
Navule Pavan Kumar Rao
.
Machine learning model serving in Python using FastAPI and streamlit
by
Davide Fiocco
.
Introducing Dispatch
by
Netflix
.
Using FastAPI with Django
by
Stavros Korokithakis
.
Build a Secure Twilio Webhook with Python and FastAPI
by
Twilio
.
Build a web API from scratch with FastAPI - the workshop
by
Sebastián Ramírez (tiangolo)
.
FastAPI + Zeit.co = 🚀
by
Paul Sec
.
Build simple API service with Python FastAPI — Part 1
by
cuongld2
.
Microservice in Python using FastAPI
by
Paurakh Sharma Humagain
.
Real-time Notifications with Python and Postgres
by
Guillermo Cruz
.
Create and Deploy FastAPI app to Heroku without using Docker
by
Navule Pavan Kumar Rao
.
Another Boilerplate to FastAPI: Azure Pipeline CI + Pytest
by
Arthur Henrique
.
Deploy Machine Learning Models with Keras, FastAPI, Redis and Docker
by
Shane Soh
.
Towards Data Science: Deploying Iris Classifications with FastAPI and Docker
by
Mandy Gu
.
TestDriven.io: Developing and Testing an Asynchronous API with FastAPI and Pytest
by
Michael Herman
.
How To Deploy Tensorflow 2.0 Models As An API Service With FastAPI & Docker
by
Bernard Brenyah
.
Why I'm Leaving Flask
by
Dylan Anthony
.
Using Docker Compose to deploy a lightweight Python REST API with a job queue
by
Mike Moritz
.
A FastAPI and Swagger UI visual cheatsheet
by
@euri10
.
Uber: Ludwig v0.2 Adds New Features and Other Improvements to its Deep Learning Toolbox [including a FastAPI server]
by
Uber Engineering
.
How to Deploy a Machine Learning Model
by
Maarten Grootendorst
.
JWT Authentication with FastAPI and AWS Cognito
by
Johannes Gontrum
.
Top 5 Asynchronous Web Frameworks for Python
by
Ankush Thakur
.
Deploying a scikit-learn model with ONNX and FastAPI
by
Nico Axtmann
.
FastAPI authentication revisited: Enabling API key authentication
by
Nils de Bruin
.
FastAPI and Scikit-Learn: Easily Deploy Models
by
Nick Cortale
.
Introduction to the fastapi python framework
by
Errieta Kostala
.
FastAPI — How to add basic and cookie authentication
by
Nils de Bruin
.
FastAPI — Google as an external authentication provider
by
Nils de Bruin
.
FastAPI/Starlette debug vs prod
by
William Hayes
.
Developing FastAPI Application using K8s & AWS
by
Mukul Mantosh
.
Fastapi, Docker(Docker compose) and Postgres
by
KrishNa
.
Deployment using Docker, Lambda, Aurora, CDK & GH Actions
by
Devon Ray
.
Mastering Soft Delete: Advanced SQLAlchemy Techniques
by
Shubhendra Kushwaha
.
Role based row filtering: Advanced SQLAlchemy Techniques
by
Shubhendra Kushwaha
.
German
Domain-driven Design mit Python und FastAPI
by
Marcel Sander (actidoo)
.
Inbetriebnahme eines scikit-learn-Modells mit ONNX und FastAPI
by
Nico Axtmann
.
REST-API Programmieren mittels Python und dem FastAPI Modul
by
Felix Schürmeyer
.
Japanese
[FastAPI] Python製のASGI Web フレームワーク FastAPIに入門する
by
@bee2
.
PythonのWeb frameworkのパフォーマンス比較 (Django, Flask, responder, FastAPI, japronto)
by
@bee2
.
【第4回】FastAPIチュートリアル: toDoアプリを作ってみよう【管理者ページ改良編】
by
ライトコードメディア編集部
.
【第3回】FastAPIチュートリアル: toDoアプリを作ってみよう【認証・ユーザ登録編】
by
ライトコードメディア編集部
.
【第2回】FastAPIチュートリアル: ToDoアプリを作ってみよう【モデル構築編】
by
ライトコードメディア編集部
.
【第1回】FastAPIチュートリアル: ToDoアプリを作ってみよう【環境構築編】
by
ライトコードメディア編集部
.
フロントエンド開発者向けのDockerによるPython開発環境構築
by
Hikaru Takahashi
.
FastAPIでPOSTされたJSONのレスポンスbodyを受け取る
by
@angel_katayoku
.
FastAPIをMySQLと接続してDockerで管理してみる
by
@angel_katayoku
.
FastAPIでCORSを回避
by
@angel_katayoku
.
python製の最新APIフレームワーク FastAPI を触ってみた
by
@ryoryomaru
.
FastAPI｜DB接続してCRUDするPython製APIサーバーを構築
by
@mtitg
.
Portuguese
FastAPI do ZERO
by
Eduardo Mendes
.
Dicas para migrar uma aplicação de Flask para FastAPI e vice-versa
by
Jessica Temporal
.
Russian
FastAPI: знакомимся с фреймворком
by
Troy Köhler
.
Почему Вы должны попробовать FastAPI?
by
prostomarkeloff
.
Мелкая питонячая радость #2: Starlette - Солидная примочка – FastAPI
by
Andrey Korchak
.
Vietnamese
FASTAPI: TRIỂN KHAI BẰNG DOCKER
by
Nguyễn Nhân
.
Taiwanese
Tortoise ORM / FastAPI 整合快速筆記
by
Leon
.
Spanish
Tutorial de FastAPI, ¿el mejor framework de Python?
by
Eduardo Zepeda
.
Podcasts
English
Starting With FastAPI and Examining Python's Import System - Episode 72
by
Real Python
.
Do you dare to press "."? - Episode 247 - Dan #6: SQLModel - use the same models for SQL and FastAPI
by
Python Bytes FM
.
Build The Next Generation Of Python Web Applications With FastAPI - Episode 259 - interview to Sebastían Ramírez (tiangolo)
by
Podcast.
__init__
.
FastAPI on PythonBytes
by
Python Bytes FM
.
Talks
English
PyCon AU 2023: Testing asynchronous applications with FastAPI and pytest
by
Jeny Sadadia
.
[VIRTUAL] Py.Amsterdam's flying Software Circus: Intro to FastAPI
by
Sebastián Ramírez (tiangolo)
.
PyConBY 2020: Serve ML models easily with FastAPI
by
Sebastián Ramírez (tiangolo)
.
PyCon UK 2019: FastAPI from the ground up
by
Chris Withers
.
Taiwanese
PyCon TW 2024: 全方位強化 Python 服務可觀測性：以 FastAPI 和 Grafana Stack 為例
by
Blueswen
.
GitHub Repositories
Most starred GitHub repositories with the topic
fastapi
:
★ 33079 - full-stack-fastapi-template
by
@fastapi
.
★ 30350 - Hello-Python
by
@mouredev
.
★ 21593 - serve
by
@jina-ai
.
★ 17229 - HivisionIDPhotos
by
@Zeyi-Lin
.
★ 16068 - sqlmodel
by
@fastapi
.
★ 12689 - Douyin_TikTok_Download_API
by
@Evil0ctal
.
★ 11965 - fastapi-best-practices
by
@zhanymkanov
.
★ 9773 - awesome-fastapi
by
@mjhea0
.
★ 8829 - FastUI
by
@pydantic
.
★ 6779 - nonebot2
by
@nonebot
.
★ 6652 - FileCodeBox
by
@vastsa
.
★ 5722 - serge
by
@serge-chat
.
★ 5607 - hatchet
by
@hatchet-dev
.
★ 5327 - polar
by
@polarsource
.
★ 5235 - fastapi-users
by
@fastapi-users
.
★ 5193 - fastapi_mcp
by
@tadata-org
.
★ 4833 - SurfSense
by
@MODSetter
.
★ 4307 - chatgpt-web-share
by
@chatpire
.
★ 4281 - strawberry
by
@strawberry-graphql
.
★ 4110 - atrilabs-engine
by
@Atri-Labs
.
★ 4008 - dynaconf
by
@dynaconf
.
★ 3977 - poem
by
@poem-web
.
★ 3317 - farfalle
by
@rashadphz
.
★ 3253 - fastapi-admin
by
@fastapi-admin
.
★ 3228 - datamodel-code-generator
by
@koxudaxi
.
★ 3175 - LitServe
by
@Lightning-AI
.
★ 3172 - logfire
by
@pydantic
.
★ 3122 - opyrator
by
@ml-tooling
.
★ 3110 - huma
by
@danielgtaylor
.
★ 3068 - docarray
by
@docarray
.
★ 2892 - fastapi-realworld-example-app
by
@nsidnev
.
★ 2883 - Kokoro-FastAPI
by
@remsky
.
★ 2770 - uvicorn-gunicorn-fastapi-docker
by
@tiangolo
.
★ 2740 - tracecat
by
@TracecatHQ
.
★ 2517 - best-of-web-python
by
@ml-tooling
.
★ 2423 - RasaGPT
by
@paulpierre
.
★ 2376 - fastapi-react
by
@Buuntu
.
★ 2301 - FastAPI-template
by
@s3rius
.
★ 2289 - nextpy
by
@dot-agent
.
★ 2196 - sqladmin
by
@aminalaee
.
★ 2179 - 30-Days-of-Python
by
@codingforentrepreneurs
.
★ 2098 - langserve
by
@langchain-ai
.
★ 2077 - fastapi-utils
by
@fastapiutils
.
★ 2047 - supabase-py
by
@supabase
.
★ 2044 - solara
by
@widgetti
.
★ 1905 - mangum
by
@Kludex
.
★ 1823 - python-week-2022
by
@rochacbruno
.
★ 1754 - manage-fastapi
by
@ycd
.
★ 1746 - agentkit
by
@BCG-X-Official
.
★ 1742 - ormar
by
@collerek
.
★ 1630 - langchain-serve
by
@jina-ai
.
★ 1611 - termpair
by
@cs01
.
★ 1609 - piccolo
by
@piccolo-orm
.
★ 1587 - coronavirus-tracker-api
by
@ExpDev07
.
★ 1575 - fastapi-cache
by
@long2ice
.
★ 1568 - openapi-python-client
by
@openapi-generators
.
★ 1508 - fastapi-crudrouter
by
@awtkns
.
★ 1501 - slowapi
by
@laurentS
.
★ 1453 - awesome-fastapi-projects
by
@Kludex
.
★ 1390 - awesome-python-resources
by
@DjangoEx
.
★ 1353 - fastapi-pagination
by
@uriyyo
.
★ 1342 - budgetml
by
@ebhy
.
★ 1325 - fastapi-boilerplate
by
@teamhide
.
★ 1306 - vue-fastapi-admin
by
@mizhexiaoxiao
.
★ 1256 - fastapi-amis-admin
by
@amisadmin
.
★ 1245 - fastapi-tutorial
by
@liaogx
.
★ 1201 - fastapi-code-generator
by
@koxudaxi
.
★ 1201 - bracket
by
@evroon
.
★ 1179 - bolt-python
by
@slackapi
.
★ 1147 - fastapi_production_template
by
@zhanymkanov
.
★ 1145 - prometheus-fastapi-instrumentator
by
@trallnag
.
★ 1143 - bedrock-chat
by
@aws-samples
.
★ 1134 - langchain-extract
by
@langchain-ai
.
★ 1118 - odmantic
by
@art049
.
★ 1110 - fastapi-alembic-sqlmodel-async
by
@jonra1993
.
★ 1080 - fastcrud
by
@benavlabs
.
★ 1056 - restish
by
@rest-sh
.
★ 1050 - fastapi_best_architecture
by
@fastapi-practices
.
★ 1034 - runhouse
by
@run-house
.
★ 992 - autollm
by
@viddexa
.
★ 990 - lanarky
by
@ajndkr
.
★ 985 - FastAPI-boilerplate
by
@benavlabs
.
★ 938 - authx
by
@yezz123
.
★ 935 - secure
by
@TypeError
.
★ 925 - langcorn
by
@msoedov
.
★ 913 - energy-forecasting
by
@iusztinpaul
.
★ 886 - titiler
by
@developmentseed
.
★ 866 - flock
by
@Onelevenvy
.
★ 863 - httpdbg
by
@cle-b
.
★ 859 - marker-api
by
@adithya-s-k
.
★ 845 - ludic
by
@getludic
.
★ 827 - fastapi-do-zero
by
@dunossauro
.
★ 823 - fastapi-observability
by
@blueswen
.
★ 803 - fastapi-langgraph-agent-production-ready-template
by
@wassim249
.
★ 798 - fastapi-mail
by
@sabuhish
.
★ 785 - starlette-admin
by
@jowilf
.
★ 767 - lccn_predictor
by
@baoliay2008
.
★ 759 - aktools
by
@akfamily
.
★ 748 - KonomiTV
by
@tsukumijima
.

## 051_FA
FastAPI¶
---

FastAPI
فریم‌ورک FastAPI، کارایی بالا، یادگیری آسان، کدنویسی سریع، آماده برای استفاده در محیط پروداکشن
مستندات
:
https://fastapi.tiangolo.com
کد منبع
:
https://github.com/fastapi/fastapi
FastAPI یک وب فریم‌ورک مدرن و سریع (با کارایی بالا) برای ایجاد APIهای متنوع (وب، وب‌سوکت و غبره) با زبان پایتون نسخه +۳.۶ است. این فریم‌ورک با رعایت کامل راهنمای نوع داده (Type Hint) ایجاد شده است.
ویژگی‌های کلیدی این فریم‌ورک عبارتند از:
سرعت
: کارایی بسیار بالا و قابل مقایسه با
NodeJS
و
Go
(با تشکر از Starlette و Pydantic).
یکی از سریع‌ترین فریم‌ورک‌های پایتونی موجود
.
کدنویسی سریع
: افزایش ۲۰۰ تا ۳۰۰ درصدی سرعت توسعه قابلیت‌های جدید. *
باگ کمتر
: کاهش ۴۰ درصدی خطاهای انسانی (برنامه‌نویسی). *
هوشمندانه
: پشتیبانی فوق‌العاده در محیط‌های توسعه یکپارچه (IDE).
تکمیل
در همه بخش‌های کد. کاهش زمان رفع باگ.
آسان
: طراحی شده برای یادگیری و استفاده آسان. کاهش زمان مورد نیاز برای مراجعه به مستندات.
کوچک
: کاهش تکرار در کد. چندین قابلیت برای هر پارامتر (منظور پارامترهای ورودی تابع هندلر می‌باشد، به بخش
خلاصه
در همین صفحه مراجعه شود). باگ کمتر.
استوار
: ایجاد کدی آماده برای استفاده در محیط پروداکشن و تولید خودکار
مستندات تعاملی
مبتنی بر استانداردها
: مبتنی بر (و منطبق با) استانداردهای متن باز مربوط به API:
OpenAPI
(سوگر سابق) و
JSON Schema
.
* تخمین‌ها بر اساس تست‌های انجام شده در یک تیم توسعه داخلی که مشغول ایجاد برنامه‌های کاربردی واقعی بودند صورت گرفته است.
اسپانسرهای طلایی
دیگر اسپانسرها
نظر دیگران در مورد FastAPI
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products."
Kabir Khan -
Microsoft
(ref)
"We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I’m over the moon excited about
FastAPI
. It’s so fun!"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that."
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, فریم‌ورکی معادل FastAPI برای کار با
واسط خط فرمان
اگر در حال ساختن برنامه‌ای برای استفاده در
CLI
(به جای استفاده در وب) هستید، می‌توانید از
Typer
. استفاده کنید.
Typer
دوقلوی کوچکتر FastAPI است و قرار است معادلی برای FastAPI در برنامه‌های CLI باشد.️ 🚀
نیازمندی‌ها
پایتون +۳.۶
FastAPI مبتنی بر ابزارهای قدرتمند زیر است:
فریم‌ورک
Starlette
برای بخش وب.
کتابخانه
Pydantic
برای بخش داده‌.
نصب
fast →
pip install fastapi
restart ↻
نصب یک سرور پروداکشن نظیر
Uvicorn
یا
Hypercorn
نیز جزء نیازمندی‌هاست.
fast →
pip install "uvicorn[standard]"
restart ↻
مثال
ایجاد کنید
فایلی به نام
main.py
با محتوای زیر ایجاد کنید:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
همچنین می‌توانید از
async def
... نیز استفاده کنید
اگر در کدتان از
async
/
await
استفاده می‌کنید، از
async def
برای تعریف تابع خود استفاده کنید:
from
typing
import
Optional
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Optional
[
str
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
توجه
:
اگر با
async / await
آشنا نیستید، به بخش
"عجله‌ دارید?"
در صفحه درباره
async
و
await
در مستندات
مراجعه کنید.
اجرا کنید
با استفاده از دستور زیر سرور را اجرا کنید:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
درباره دستور
uvicorn main:app --reload
...
دستور
uvicorn main:app
شامل موارد زیر است:
main
: فایل
main.py
(ماژول پایتون ایجاد شده).
app
: شیء ایجاد شده در فایل
main.py
در خط
app = FastAPI()
.
--reload
: ریستارت کردن سرور با تغییر کد. تنها در هنگام توسعه از این گزینه استفاده شود..
بررسی کنید
آدرس
http://127.0.0.1:8000/items/5?q=somequery
را در مرورگر خود باز کنید.
پاسخ JSON زیر را مشاهده خواهید کرد:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
تا اینجا شما APIای ساختید که:
درخواست‌های HTTP به
مسیرهای
/
و
/items/{item_id}
را دریافت می‌کند.
هردو
مسیر
عملیات
(یا HTTP
متد
)
GET
را پشتیبانی می‌کند.
مسیر
/items/{item_id}
شامل
پارامتر مسیر
item_id
از نوع
int
است.
مسیر
/items/{item_id}
شامل
پارامتر پرسمان
اختیاری
q
از نوع
str
است.
مستندات API تعاملی
حال به آدرس
http://127.0.0.1:8000/docs
بروید.
مستندات API تعاملی (ایجاد شده به کمک
Swagger UI
) را مشاهده خواهید کرد:
مستندات API جایگزین
حال به آدرس
http://127.0.0.1:8000/redoc
بروید.
مستندات خودکار دیگری را مشاهده خواهید کرد که به کمک
ReDoc
ایجاد می‌شود:
تغییر مثال
حال فایل
main.py
را مطابق زیر ویرایش کنید تا بتوانید
بدنه
یک درخواست
PUT
را دریافت کنید.
به کمک Pydantic بدنه درخواست را با
انواع
استاندارد پایتون تعریف کنید.
from
typing
import
Optional
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
سرور به صورت خودکار ری‌استارت می‌شود (زیرا پیشتر از گزینه
--reload
در دستور
uvicorn
استفاده کردیم).
تغییر مستندات API تعاملی
مجددا به آدرس
http://127.0.0.1:8000/docs
بروید.
مستندات API تعاملی به صورت خودکار به‌روز شده است و شامل بدنه تعریف شده در مرحله قبل است:
روی دکمه "Try it out" کلیک کنید، اکنون می‌توانید پارامترهای مورد نیاز هر API را مشخص کرده و به صورت مستقیم با آنها تعامل کنید:
سپس روی دکمه "Execute" کلیک کنید، خواهید دید که واسط کاربری با APIهای تعریف شده ارتباط برقرار کرده، پارامترهای مورد نیاز را به آن‌ها ارسال می‌کند، سپس نتایج را دریافت کرده و در صفحه نشان می‌دهد:
تغییر مستندات API جایگزین
حال به آدرس
http://127.0.0.1:8000/redoc
بروید.
خواهید دید که مستندات جایگزین نیز به‌روزرسانی شده و شامل پارامتر پرسمان و بدنه تعریف شده می‌باشد:
خلاصه
به طور خلاصه شما
یک بار
انواع پارامترها، بدنه و غیره را به عنوان پارامترهای ورودی تابع خود تعریف می‌کنید.
این کار را با استفاده از انواع استاندارد و مدرن موجود در پایتون انجام می‌دهید.
نیازی به یادگیری
نحو
جدید یا متدها و کلاس‌های یک کتابخانه بخصوص و غیره نیست.
تنها
پایتون +۳.۶
.
به عنوان مثال برای یک پارامتر از نوع
int
:
item_id
:
int
یا برای یک مدل پیچیده‌تر مثل
Item
:
item
:
Item
...و با همین اعلان تمامی قابلیت‌های زیر در دسترس قرار می‌گیرد:
پشتیبانی ویرایشگر متنی شامل:
تکمیل کد.
بررسی انواع داده.
اعتبارسنجی داده:
خطاهای خودکار و مشخص در هنگام نامعتبر بودن داده.
اعتبارسنجی، حتی برای اشیاء JSON تو در تو.
تبدیل
داده ورودی: که از شبکه رسیده به انواع و داد‌ه‌ پایتونی. این داده‌ شامل:
JSON.
پارامترهای مسیر
.
پارامترهای پرسمان
.
کوکی‌ها
.
سرآیند‌ها (هدرها)
.
فرم‌ها
.
فایل‌ها
.
تبدیل
داده خروجی: تبدیل از انواع و داده‌ پایتون به داده شبکه (مانند JSON):
تبدیل انواع داده پایتونی (
str
,
int
,
float
,
bool
,
list
و غیره).
اشیاء
datetime
.
اشیاء
UUID
.
qمدل‌های پایگاه‌داده.
و موارد بیشمار دیگر.
دو مدل مستند API تعاملی خودکار :
Swagger UI.
ReDoc.
به مثال قبلی باز می‌گردیم، در این مثال
FastAPI
موارد زیر را انجام می‌دهد:
اعتبارسنجی اینکه پارامتر
item_id
در مسیر درخواست‌های
GET
و
PUT
موجود است.
اعتبارسنجی اینکه پارامتر
item_id
در درخواست‌های
GET
و
PUT
از نوع
int
است.
اگر غیر از این موارد باشد، سرویس‌گیرنده خطای مفید و مشخصی دریافت خواهد کرد.
بررسی وجود پارامتر پرسمان اختیاری
q
(مانند
http://127.0.0.1:8000/items/foo?q=somequery
) در درخواست‌های
GET
.
از آنجا که پارامتر
q
با
= None
مقداردهی شده است، این پارامتر اختیاری است.
اگر از مقدار اولیه
None
استفاده نکنیم، این پارامتر الزامی خواهد بود (همانند بدنه درخواست در درخواست
PUT
).
برای درخواست‌های
PUT
به آدرس
/items/{item_id}
، بدنه درخواست باید از نوع JSON تعریف شده باشد:
بررسی اینکه بدنه شامل فیلدی با نام
name
و از نوع
str
است.
بررسی اینکه بدنه شامل فیلدی با نام
price
و از نوع
float
است.
بررسی اینکه بدنه شامل فیلدی اختیاری با نام
is_offer
است، که در صورت وجود باید از نوع
bool
باشد.
تمامی این موارد برای اشیاء JSON در هر عمقی قابل بررسی می‌باشد.
تبدیل از/به JSON به صورت خودکار.
مستندسازی همه چیز با استفاده از OpenAPI، که می‌توان از آن برای موارد زیر استفاده کرد:
سیستم مستندات تعاملی.
تولید خودکار کد سرویس‌گیرنده‌ در زبان‌های برنامه‌نویسی بیشمار.
فراهم سازی ۲ مستند تعاملی مبتنی بر وب به صورت پیش‌فرض.
موارد ذکر شده تنها پاره‌ای از ویژگی‌های بیشمار FastAPI است اما ایده‌ای کلی از طرز کار آن در اختیار قرار می‌دهد.
خط زیر را به این صورت تغییر دهید:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
از:
...
"item_name"
:
item
.
name
...
به:
...
"item_price"
:
item
.
price
...
در حین تایپ کردن توجه کنید که چگونه ویرایش‌گر، ویژگی‌های کلاس
Item
را تشخیص داده و به تکمیل خودکار آنها کمک می‌کند:
برای مشاهده مثال‌های کامل‌تر که شامل قابلیت‌های بیشتری از FastAPI باشد به بخش
آموزش - راهنمای کاربر
مراجعه کنید.
هشدار اسپویل
: بخش آموزش - راهنمای کاربر شامل موارد زیر است:
اعلان
پارامترهای
موجود در بخش‌های دیگر درخواست، شامل:
سرآیند‌ (هدر)ها
،
کوکی‌ها
،
فیلد‌های فرم
و
فایل‌ها
.
چگونگی تنظیم
محدودیت‌های اعتبارسنجی
به عنوان مثال
maximum_length
یا
regex
.
سیستم
Dependency Injection
قوی و کاربردی.
امنیت و تایید هویت, شامل پشتیبانی از
OAuth2
مبتنی بر
JWT tokens
و
HTTP Basic
.
تکنیک پیشرفته برای تعریف
مدل‌های چند سطحی JSON
(بر اساس Pydantic).
قابلیت‌های اضافی دیگر (بر اساس Starlette) شامل:
وب‌سوکت
GraphQL
تست‌های خودکار آسان مبتنی بر HTTPX و
pytest
CORS
Cookie Sessions
و موارد بیشمار دیگر.
کارایی
معیار (بنچمارک‌)های مستقل TechEmpower حاکی از آن است که برنامه‌های
FastAPI
که تحت Uvicorn اجرا می‌شود،
یکی از سریع‌ترین فریم‌ورک‌های مبتنی بر پایتون
، است که کمی ضعیف‌تر از Starlette و Uvicorn عمل می‌کند (فریم‌ورک و سروری که FastAPI بر اساس آنها ایجاد شده است) (*)
برای درک بهتری از این موضوع به بخش
بنچ‌مارک‌ها
مراجعه کنید.
نیازمندی‌های اختیاری
استفاده شده توسط Pydantic:
email-validator
- برای اعتبارسنجی آدرس‌های ایمیل.
استفاده شده توسط Starlette:
HTTPX
- در صورتی که می‌خواهید از
TestClient
استفاده کنید.
aiofiles
- در صورتی که می‌خواهید از
FileResponse
و
StaticFiles
استفاده کنید.
jinja2
- در صورتی که بخواهید از پیکربندی پیش‌فرض برای قالب‌ها استفاده کنید.
python-multipart
- در صورتی که بخواهید با استفاده از
request.form()
از قابلیت
"تجزیه (parse)"
فرم استفاده کنید.
itsdangerous
- در صورتی که بخواید از
SessionMiddleware
پشتیبانی کنید.
pyyaml
- برای پشتیبانی
SchemaGenerator
در Starlet (به احتمال زیاد برای کار کردن با FastAPI به آن نیازی پیدا نمی‌کنید).
graphene
- در صورتی که از
GraphQLApp
پشتیبانی می‌کنید.
استفاده شده توسط FastAPI / Starlette:
uvicorn
- برای سرور اجرا کننده برنامه وب.
orjson
- در صورتی که بخواهید از
ORJSONResponse
استفاده کنید.
ujson
- در صورتی که بخواهید از
UJSONResponse
استفاده کنید.
می‌توان همه این موارد را با استفاده از دستور
pip install fastapi[all]
. به صورت یکجا نصب کرد.
لایسنس
این پروژه مشمول قوانین و مقررات لایسنس MIT است.

## 052_FASTAPI_CLI
FastAPI CLI¶
---

FastAPI CLI
FastAPI CLI
is a command line program that you can use to serve your FastAPI app, manage your FastAPI project, and more.
When you install FastAPI (e.g. with
pip install "fastapi[standard]"
), it includes a package called
fastapi-cli
, this package provides the
fastapi
command in the terminal.
To run your FastAPI app for development, you can use the
fastapi dev
command:
fast →
fastapi dev main.py
FastAPI
Starting development server 🚀
Searching for package file structure from directories with
__init__.py
files
Importing from
/home/user/code/
awesomeapp
module
🐍 main.py
code
Importing the FastAPI app object from the module with the
following code:
from
main
import
app
app
Using import string:
main:app
server
Server started at
http://127.0.0.1:8000
server
Documentation at
http://127.0.0.1:8000/docs
tip
Running in development mode, for production use:
fastapi run
Logs:
INFO
Will watch for changes in these directories:
[
'/home/user/code/awesomeapp'
]
INFO
Uvicorn running on
http://127.0.0.1:8000
(
Press CTRL+C to
quit
)
INFO
Started reloader process
[
383138
]
using WatchFiles
INFO
Started server process
[
383153
]
INFO
Waiting for application startup.
INFO
Application startup complete.
The command line program called
fastapi
is
FastAPI CLI
.
FastAPI CLI takes the path to your Python program (e.g.
main.py
) and automatically detects the
FastAPI
instance (commonly named
app
), determines the correct import process, and then serves it.
For production you would use
fastapi run
instead. 🚀
Internally,
FastAPI CLI
uses
Uvicorn
, a high-performance, production-ready, ASGI server. 😎
fastapi dev
Running
fastapi dev
initiates development mode.
By default,
auto-reload
is enabled, automatically reloading the server when you make changes to your code. This is resource-intensive and could be less stable than when it's disabled. You should only use it for development. It also listens on the IP address
127.0.0.1
, which is the IP for your machine to communicate with itself alone (
localhost
).
fastapi run
Executing
fastapi run
starts FastAPI in production mode by default.
By default,
auto-reload
is disabled. It also listens on the IP address
0.0.0.0
, which means all the available IP addresses, this way it will be publicly accessible to anyone that can communicate with the machine. This is how you would normally run it in production, for example, in a container.
In most cases you would (and should) have a "termination proxy" handling HTTPS for you on top, this will depend on how you deploy your application, your provider might do this for you, or you might need to set it up yourself.
Tip
You can learn more about it in the
deployment documentation
.

## 053_FASTAPI_PEOPLE
FastAPI People¶
---

FastAPI People
FastAPI has an amazing community that welcomes people from all backgrounds.
Creator
Hey! 👋
This is me:
@tiangolo
Answers: 1898
Pull Requests: 747
I'm the creator of
FastAPI
. You can read more about that in
Help FastAPI - Get Help - Connect with the author
.
...But here I want to show you the community.
FastAPI
receives a lot of support from the community. And I want to highlight their contributions.
These are the people that:
Help others with questions in GitHub
.
Create Pull Requests
.
Review Pull Requests,
especially important for translations
.
Help
manage the repository
(team members).
All these tasks help maintain the repository.
A round of applause to them. 👏 🙇
Team
This is the current list of team members. 😎
They have different levels of involvement and permissions, they can perform
repository management tasks
and together we
manage the FastAPI repository
.
@tiangolo
@Kludex
@alejsdev
@svlandeg
@YuriiMotov
@patrick91
@luzzodev
Although the team members have the permissions to perform privileged tasks, all the
help from others maintaining FastAPI
is very much appreciated! 🙇‍♂️
FastAPI Experts
These are the users that have been
helping others the most with questions in GitHub
. 🙇
They have proven to be
FastAPI Experts
by helping many others. ✨
Tip
You could become an official FastAPI Expert too!
Just
help others with questions in GitHub
. 🤓
You can see the
FastAPI Experts
for:
Last Month
🤓
3 Months
😎
6 Months
🧐
1 Year
🧑‍🔬
All Time
🧙
FastAPI Experts - Last Month
These are the users that have been
helping others the most with questions in GitHub
during the last month. 🤓
@YuriiMotov
Questions replied: 9
@luzzodev
Questions replied: 8
@alv2017
Questions replied: 3
@sachinh35
Questions replied: 2
@KianAnbarestani
Questions replied: 2
FastAPI Experts - 3 Months
These are the users that have been
helping others the most with questions in GitHub
during the last 3 months. 😎
@luzzodev
Questions replied: 25
@YuriiMotov
Questions replied: 24
@alv2017
Questions replied: 22
@jgould22
Questions replied: 13
@Kludex
Questions replied: 10
@yauhen-sobaleu
Questions replied: 9
@JavierSanchezCastro
Questions replied: 7
@sachinh35
Questions replied: 3
@SobikXexe
Questions replied: 3
FastAPI Experts - 6 Months
These are the users that have been
helping others the most with questions in GitHub
during the last 6 months. 🧐
@luzzodev
Questions replied: 57
@YuriiMotov
Questions replied: 56
@Kludex
Questions replied: 34
@alv2017
Questions replied: 25
@jgould22
Questions replied: 17
@sehraramiz
Questions replied: 11
@JavierSanchezCastro
Questions replied: 9
@yauhen-sobaleu
Questions replied: 9
@estebanx64
Questions replied: 7
@yvallois
Questions replied: 7
FastAPI Experts - 1 Year
These are the users that have been
helping others the most with questions in GitHub
during the last year. 🧑‍🔬
@YuriiMotov
Questions replied: 172
@Kludex
Questions replied: 63
@luzzodev
Questions replied: 61
@sinisaos
Questions replied: 41
@JavierSanchezCastro
Questions replied: 33
@jgould22
Questions replied: 27
@alv2017
Questions replied: 25
@ceb10n
Questions replied: 15
@estebanx64
Questions replied: 13
@n8sty
Questions replied: 13
@Kfir-G
Questions replied: 13
@sehraramiz
Questions replied: 11
@PhysicallyActive
Questions replied: 11
@mattmess1221
Questions replied: 11
@yauhen-sobaleu
Questions replied: 9
@AIdjis
Questions replied: 8
@yvallois
Questions replied: 7
@hasansezertasan
Questions replied: 5
@gustavosett
Questions replied: 5
FastAPI Experts - All Time
Here are the all time
FastAPI Experts
. 🤓🤯
These are the users that have
helped others the most with questions in GitHub
through
all time
. 🧙
@Kludex
Questions replied: 655
@jgould22
Questions replied: 263
@YuriiMotov
Questions replied: 247
@dmontagu
Questions replied: 240
@Mause
Questions replied: 219
@ycd
Questions replied: 217
@JarroVGIT
Questions replied: 192
@euri10
Questions replied: 153
@iudeen
Questions replied: 128
@phy25
Questions replied: 126
@JavierSanchezCastro
Questions replied: 91
@raphaelauv
Questions replied: 83
@ghandic
Questions replied: 71
@ArcLightSlavik
Questions replied: 71
@n8sty
Questions replied: 67
@luzzodev
Questions replied: 61
@falkben
Questions replied: 59
@acidjunk
Questions replied: 50
@yinziyan1206
Questions replied: 49
@sm-Fifteen
Questions replied: 49
@adriangb
Questions replied: 46
@insomnes
Questions replied: 45
@Dustyposa
Questions replied: 45
@odiseo0
Questions replied: 43
@frankie567
Questions replied: 43
@sinisaos
Questions replied: 41
@includeamin
Questions replied: 40
@chbndrhnns
Questions replied: 37
@STeveShary
Questions replied: 37
@krishnardt
Questions replied: 35
@panla
Questions replied: 32
@prostomarkeloff
Questions replied: 28
@hasansezertasan
Questions replied: 27
@dbanty
Questions replied: 26
@alv2017
Questions replied: 25
@wshayes
Questions replied: 25
@SirTelemak
Questions replied: 23
@connebs
Questions replied: 22
@nymous
Questions replied: 22
@chrisK824
Questions replied: 22
@rafsaf
Questions replied: 21
@ebottos94
Questions replied: 20
@nsidnev
Questions replied: 20
@chris-allnutt
Questions replied: 20
@estebanx64
Questions replied: 19
@zoliknemet
Questions replied: 18
@sehraramiz
Questions replied: 18
@retnikt
Questions replied: 18
Top Contributors
Here are the
Top Contributors
. 👷
These users have
created the most Pull Requests
that have been
merged
.
They have contributed source code, documentation, etc. 📦
@alejsdev
Pull Requests: 47
@Kludex
Pull Requests: 23
@dmontagu
Pull Requests: 17
@euri10
Pull Requests: 13
@kantandane
Pull Requests: 13
@nilslindemann
Pull Requests: 11
@zhaohan-dong
Pull Requests: 11
@mariacamilagl
Pull Requests: 9
@handabaldeep
Pull Requests: 9
@vishnuvskvkl
Pull Requests: 8
@svlandeg
Pull Requests: 7
@alissadb
Pull Requests: 6
@wshayes
Pull Requests: 5
@samuelcolvin
Pull Requests: 5
@waynerv
Pull Requests: 5
@krishnamadhavan
Pull Requests: 5
@alv2017
Pull Requests: 5
@jekirl
Pull Requests: 4
@hitrust
Pull Requests: 4
@ShahriyarR
Pull Requests: 4
@adriangb
Pull Requests: 4
@iudeen
Pull Requests: 4
@philipokiokio
Pull Requests: 4
@AlexWendland
Pull Requests: 4
@divums
Pull Requests: 3
@prostomarkeloff
Pull Requests: 3
@nsidnev
Pull Requests: 3
@pawamoy
Pull Requests: 3
@patrickmckenna
Pull Requests: 3
@hukkin
Pull Requests: 3
@marcosmmb
Pull Requests: 3
@Serrones
Pull Requests: 3
@uriyyo
Pull Requests: 3
@andrew222651
Pull Requests: 3
@rkbeatss
Pull Requests: 3
@asheux
Pull Requests: 3
@n25a
Pull Requests: 3
@ghandic
Pull Requests: 3
@TeoZosa
Pull Requests: 3
@graingert
Pull Requests: 3
@jaystone776
Pull Requests: 3
@zanieb
Pull Requests: 3
@MicaelJarniac
Pull Requests: 3
@papb
Pull Requests: 3
@musicinmybrain
Pull Requests: 3
@gitworkflows
Pull Requests: 3
There are hundreds of other contributors, you can see them all in the
FastAPI GitHub Contributors page
. 👷
Top Translators
These are the
Top Translators
. 🌐
These users have created the most Pull Requests with
translations to other languages
that have been
merged
.
@nilslindemann
Translations: 120
@jaystone776
Translations: 46
@ceb10n
Translations: 27
@valentinDruzhinin
Translations: 24
@tokusumi
Translations: 23
@SwftAlpc
Translations: 23
@hasansezertasan
Translations: 22
@waynerv
Translations: 20
@AlertRED
Translations: 16
@hard-coders
Translations: 15
@Joao-Pedro-P-Holanda
Translations: 14
@codingjenny
Translations: 14
@Xewus
Translations: 13
@Zhongheng-Cheng
Translations: 13
@Smlep
Translations: 11
@marcelomarkus
Translations: 11
@KaniKim
Translations: 10
@Vincy1230
Translations: 9
@rjNemo
Translations: 8
@xzmeng
Translations: 8
@pablocm83
Translations: 8
@ptt3199
Translations: 7
@batlopes
Translations: 6
@lucasbalieiro
Translations: 6
@Alexandrhub
Translations: 6
@Serrones
Translations: 5
@RunningIkkyu
Translations: 5
@Attsun1031
Translations: 5
@NinaHwang
Translations: 5
@rostik1410
Translations: 5
@alv2017
Translations: 5
@komtaki
Translations: 4
@JulianMaurin
Translations: 4
@stlucasgarcia
Translations: 4
@ComicShrimp
Translations: 4
@BilalAlpaslan
Translations: 4
@axel584
Translations: 4
@tamtam-fitness
Translations: 4
@Limsunoh
Translations: 4
@kwang1215
Translations: 4
@k94-ishi
Translations: 4
@jfunez
Translations: 3
@ycd
Translations: 3
@mariacamilagl
Translations: 3
@maoyibo
Translations: 3
@blt232018
Translations: 3
@magiskboy
Translations: 3
@luccasmmg
Translations: 3
@lbmendes
Translations: 3
Top Translation Reviewers
These users are the
Top Translation Reviewers
. 🕵️
I only speak a few languages (and not very well 😅). So, the reviewers are the ones that have the
power to approve translations
of the documentation. Without them, there wouldn't be documentation in several other languages.
@s111d
Reviews: 147
@Xewus
Reviews: 140
@sodaMelon
Reviews: 125
@ceb10n
Reviews: 112
@tokusumi
Reviews: 104
@hasansezertasan
Reviews: 95
@hard-coders
Reviews: 92
@alv2017
Reviews: 88
@nazarepiedady
Reviews: 83
@AlertRED
Reviews: 81
@Alexandrhub
Reviews: 68
@waynerv
Reviews: 63
@cassiobotaro
Reviews: 62
@mattwang44
Reviews: 59
@Laineyzhang55
Reviews: 48
@Kludex
Reviews: 47
@komtaki
Reviews: 45
@rostik1410
Reviews: 42
@svlandeg
Reviews: 42
@alperiox
Reviews: 42
@Rishat-F
Reviews: 42
@Winand
Reviews: 40
@solomein-sv
Reviews: 38
@JavierSanchezCastro
Reviews: 38
@stlucasgarcia
Reviews: 36
@SwftAlpc
Reviews: 36
@alejsdev
Reviews: 36
@timothy-jeong
Reviews: 36
@nilslindemann
Reviews: 35
@rjNemo
Reviews: 34
@codingjenny
Reviews: 34
@mezgoodle
Reviews: 33
@akarev0
Reviews: 33
@romashevchenko
Reviews: 32
@LorhanSohaky
Reviews: 30
@Vincy1230
Reviews: 30
@black-redoc
Reviews: 29
@pedabraham
Reviews: 28
@Smlep
Reviews: 28
@dedkot01
Reviews: 28
@hsuanchi
Reviews: 28
@dpinezich
Reviews: 28
@maoyibo
Reviews: 27
@0417taehyun
Reviews: 27
@BilalAlpaslan
Reviews: 26
@junah201
Reviews: 26
@zy7y
Reviews: 25
@mycaule
Reviews: 25
@Aruelius
Reviews: 24
Sponsors
These are the
Sponsors
. 😎
They are supporting my work with
FastAPI
(and others), mainly through
GitHub Sponsors
.
Gold Sponsors
Silver Sponsors
Bronze Sponsors
Individual Sponsors
@Nixtla
@subtotal
@mercedes-benz
@marvin-robot
@Ponte-Energy-Partners
@BoostryJP
@acsone
@Trivie
@takashi-yoneya
@mainframeindustries
@yasyf
@alixlahuec
@primer-io
@upciti
@samuelcolvin
@otosky
@ramonalmeidam
@ashi-agrawal
@RaamEEIL
@ehaca
@raphaellaude
@timlrx
@Leay15
@ProteinQure
@kaoru0310
@DelfinaCare
@Karine-Bauch
@eruditis
@jugeeem
@logic-automation
@roboflow
@dudikbender
@patsatsia
@anthonycepeda
@patricioperezv
@chickenandstats
@dodo5522
@knallgelb
@dblackrun
@zsinx6
@kennywakeland
@aacayaco
@anomaly
@mj0331
@gorhack
@Ryandaydev
@vincentkoc
@jstanden
@paulcwatts
@andreaso
@robintw
@pamelafox
@ericof
@wshayes
@koxudaxi
@falkben
@mintuhouse
@TrevorBenson
@wdwinslow
@catherinenelson1
@jsoques
@joeds13
@dannywade
@khadrawy
@mjohnsey
@jaredtrog
@oliverxchen
@ternaus
@eseglem
@FernandoCelmer
@Rehket
@hiancdtrsnm
@jpizquierdo
@pawamoy
@bnkc
@petercool
@siavashyj
@mobyw
@ArtyomVancyan
@caviri
@hgalytoby
@browniebroke
@joshuatz
@SebTota
@nisutec
@hoenie-ams
@joerambo
@rlnchow
@engineerjoe440
@lukzmu
@conservative-dude
@CR1337
@PunRabbit
@PelicanQ
@miguelgr
@WillHogan
@my3
@leobiscassi
@Alisa-lisa
@ddanier
@bryanculbertson
@slafs
@ceb10n
@tochikuji
@moonape1226
@msehnout
@xncbf
@DMantis
@hard-coders
@supdann
@mntolia
@pheanex
@Zuzah
@artempronevskiy
@TheR1D
@danielunderwood
@rangulvers
@sdevkota
@brizzbuzz
@Baghdady92
@KentShikama
@katnoria
@harsh183
@hcristea
@andrecorumba
@rwxd
@morzan1001
@sadikkuzu
@Olegt0rr
@larsyngvelundin
@one-st-one
@federicsp
@Toothwitch
@andreagrandi
About the data - technical details
The main intention of this page is to highlight the effort of the community to help others.
Especially including efforts that are normally less visible, and in many cases more arduous, like helping others with questions and reviewing Pull Requests with translations.
The data is calculated each month, you can read the
source code here
.
Here I'm also highlighting contributions from sponsors.
I also reserve the right to update the algorithm, sections, thresholds, etc (just in case 🤷).

## 054_FEATURES
Features¶
---

Features
FastAPI features
FastAPI
gives you the following:
Based on open standards
OpenAPI
for API creation, including declarations of
path
operations
, parameters, request bodies, security, etc.
Automatic data model documentation with
JSON Schema
(as OpenAPI itself is based on JSON Schema).
Designed around these standards, after a meticulous study. Instead of an afterthought layer on top.
This also allows using automatic
client code generation
in many languages.
Automatic docs
Interactive API documentation and exploration web user interfaces. As the framework is based on OpenAPI, there are multiple options, 2 included by default.
Swagger UI
, with interactive exploration, call and test your API directly from the browser.
Alternative API documentation with
ReDoc
.
Just Modern Python
It's all based on standard
Python type
declarations (thanks to Pydantic). No new syntax to learn. Just standard modern Python.
If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI), check the short tutorial:
Python Types
.
You write standard Python with types:
from
datetime
import
date
from
pydantic
import
BaseModel
## Declare a variable as a str
## and get editor support inside the function
def
main
(
user_id
:
str
):
return
user_id
## A Pydantic model
class
User
(
BaseModel
):
id
:
int
name
:
str
joined
:
date
That can then be used like:
my_user
:
User
=
User
(
id
=
3
,
name
=
"John Doe"
,
joined
=
"2018-07-19"
)
second_user_data
=
{
"id"
:
4
,
"name"
:
"Mary"
,
"joined"
:
"2018-11-30"
,
}
my_second_user
:
User
=
User
(
**
second_user_data
)
Info
**second_user_data
means:
Pass the keys and values of the
second_user_data
dict directly as key-value arguments, equivalent to:
User(id=4, name="Mary", joined="2018-11-30")
Editor support
All the framework was designed to be easy and intuitive to use, all the decisions were tested on multiple editors even before starting development, to ensure the best development experience.
In the Python developer surveys, it's clear
that one of the most used features is "autocompletion"
.
The whole
FastAPI
framework is based to satisfy that. Autocompletion works everywhere.
You will rarely need to come back to the docs.
Here's how your editor might help you:
in
Visual Studio Code
:
in
PyCharm
:
You will get completion in code you might even consider impossible before. As for example, the
price
key inside a JSON body (that could have been nested) that comes from a request.
No more typing the wrong key names, coming back and forth between docs, or scrolling up and down to find if you finally used
username
or
user_name
.
Short
It has sensible
defaults
for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need and to define the API you need.
But by default, it all
"just works"
.
Validation
Validation for most (or all?) Python
data types
, including:
JSON objects (
dict
).
JSON array (
list
) defining item types.
String (
str
) fields, defining min and max lengths.
Numbers (
int
,
float
) with min and max values, etc.
Validation for more exotic types, like:
URL.
Email.
UUID.
...and others.
All the validation is handled by the well-established and robust
Pydantic
.
Security and authentication
Security and authentication integrated. Without any compromise with databases or data models.
All the security schemes defined in OpenAPI, including:
HTTP Basic.
OAuth2
(also with
JWT tokens
). Check the tutorial on
OAuth2 with JWT
.
API keys in:
Headers.
Query parameters.
Cookies, etc.
Plus all the security features from Starlette (including
session cookies
).
All built as reusable tools and components that are easy to integrate with your systems, data stores, relational and NoSQL databases, etc.
Dependency Injection
FastAPI includes an extremely easy to use, but extremely powerful
Dependency Injection
system.
Even dependencies can have dependencies, creating a hierarchy or
"graph" of dependencies
.
All
automatically handled
by the framework.
All the dependencies can require data from requests and
augment the path operation
constraints and automatic documentation.
Automatic validation
even for
path operation
parameters defined in dependencies.
Support for complex user authentication systems,
database connections
, etc.
No compromise
with databases, frontends, etc. But easy integration with all of them.
Unlimited "plug-ins"
Or in other way, no need for them, import and use the code you need.
Any integration is designed to be so simple to use (with dependencies) that you can create a "plug-in" for your application in 2 lines of code using the same structure and syntax used for your
path operations
.
Tested
100%
test coverage
.
100%
type annotated
code base.
Used in production applications.
Starlette features
FastAPI
is fully compatible with (and based on)
Starlette
. So, any additional Starlette code you have, will also work.
FastAPI
is actually a sub-class of
Starlette
. So, if you already know or use Starlette, most of the functionality will work the same way.
With
FastAPI
you get all of
Starlette
's features (as FastAPI is just Starlette on steroids):
Seriously impressive performance. It is
one of the fastest Python frameworks available, on par with
NodeJS
and
Go
.
WebSocket
support.
In-process background tasks.
Startup and shutdown events.
Test client built on HTTPX.
CORS
, GZip, Static Files, Streaming responses.
Session and Cookie
support.
100% test coverage.
100% type annotated codebase.
Pydantic features
FastAPI
is fully compatible with (and based on)
Pydantic
. So, any additional Pydantic code you have, will also work.
Including external libraries also based on Pydantic, as
ORM
s,
ODM
s for databases.
This also means that in many cases you can pass the same object you get from a request
directly to the database
, as everything is validated automatically.
The same applies the other way around, in many cases you can just pass the object you get from the database
directly to the client
.
With
FastAPI
you get all of
Pydantic
's features (as FastAPI is based on Pydantic for all the data handling):
No brainfuck
:
No new schema definition micro-language to learn.
If you know Python types you know how to use Pydantic.
Plays nicely with your
IDE
/
linter
/brain
:
Because pydantic data structures are just instances of classes you define; auto-completion, linting, mypy and your intuition should all work properly with your validated data.
Validate
complex structures
:
Use of hierarchical Pydantic models, Python
typing
’s
List
and
Dict
, etc.
And validators allow complex data schemas to be clearly and easily defined, checked and documented as JSON Schema.
You can have deeply
nested JSON
objects and have them all validated and annotated.
Extensible
:
Pydantic allows custom data types to be defined or you can extend validation with methods on a model decorated with the validator decorator.
100% test coverage.

## 055_FR
FastAPI¶
---

FastAPI
Framework FastAPI, haute performance, facile à apprendre, rapide à coder, prêt pour la production
Documentation
:
https://fastapi.tiangolo.com
Code Source
:
https://github.com/fastapi/fastapi
FastAPI est un framework web moderne et rapide (haute performance) pour la création d'API avec Python, basé sur les annotations de type standard de Python.
Les principales fonctionnalités sont :
Rapidité
: De très hautes performances, au niveau de
NodeJS
et
Go
(grâce à Starlette et Pydantic).
L'un des frameworks Python les plus rapides
.
Rapide à coder
: Augmente la vitesse de développement des fonctionnalités d'environ 200 % à 300 %. *
Moins de bugs
: Réduit d'environ 40 % les erreurs induites par le développeur. *
Intuitif
: Excellente compatibilité avec les IDE.
Complétion
complète. Moins de temps passé à déboguer.
Facile
: Conçu pour être facile à utiliser et à apprendre. Moins de temps passé à lire la documentation.
Concis
: Diminue la duplication de code. De nombreuses fonctionnalités liées à la déclaration de chaque paramètre. Moins de bugs.
Robuste
: Obtenez un code prêt pour la production. Avec une documentation interactive automatique.
Basé sur des normes
: Basé sur (et entièrement compatible avec) les standards ouverts pour les APIs :
OpenAPI
(précédemment connu sous le nom de Swagger) et
JSON Schema
.
* estimation basée sur des tests d'une équipe de développement interne, construisant des applications de production.
Sponsors
Other sponsors
Opinions
"
[...] J'utilise beaucoup
FastAPI
ces derniers temps. [...] Je prévois de l'utiliser dans mon équipe pour tous les
services de ML chez Microsoft
. Certains d'entre eux seront intégrés dans le coeur de
Windows
et dans certains produits
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
Nous avons adopté la bibliothèque
FastAPI
pour créer un serveur
REST
qui peut être interrogé pour obtenir des
prédictions
. [pour Ludwig]
"
Piero Molino, Yaroslav Dudin et Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
a le plaisir d'annoncer la sortie en open-source de notre framework d'orchestration de
gestion de crise
:
Dispatch
! [construit avec
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Je suis très enthousiaste à propos de
FastAPI
. C'est un bonheur !
"
Brian Okken -
Auteur du podcast
Python Bytes
(ref)
"
Honnêtement, ce que vous avez construit a l'air super solide et élégant. A bien des égards, c'est comme ça que je voulais que
Hug
soit - c'est vraiment inspirant de voir quelqu'un construire ça.
"
Timothy Crosley -
Créateur de
Hug
(ref)
"
Si vous cherchez à apprendre un
framework moderne
pour créer des APIs REST, regardez
FastAPI
[...] C'est rapide, facile à utiliser et à apprendre [...]
"
"
Nous sommes passés à
FastAPI
pour nos
APIs
[...] Je pense que vous l'aimerez [...]
"
Ines Montani - Matthew Honnibal -
Fondateurs de
Explosion AI
- Créateurs de
spaCy
(ref)
-
(ref)
"
Si quelqu'un cherche à construire une API Python de production, je recommande vivement
FastAPI
. Il est
bien conçu
,
simple à utiliser
et
très évolutif
. Il est devenu un
composant clé
dans notre stratégie de développement API first et il est à l'origine de nombreux automatismes et services tels que notre ingénieur virtuel TAC.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, le FastAPI des
CLI
Si vous souhaitez construire une application
CLI
utilisable dans un terminal au lieu d'une API web, regardez
Typer
.
Typer
est le petit frère de FastAPI. Et il est destiné à être le
FastAPI des
CLI
. ⌨️ 🚀
Prérequis
FastAPI repose sur les épaules de géants :
Starlette
pour les parties web.
Pydantic
pour les parties données.
Installation
fast →
pip install fastapi
restart ↻
Vous aurez également besoin d'un serveur ASGI pour la production tel que
Uvicorn
ou
Hypercorn
.
fast →
pip install "uvicorn[standard]"
restart ↻
Exemple
Créez
Créez un fichier
main.py
avec :
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Ou utilisez
async def
...
Si votre code utilise
async
/
await
, utilisez
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Note
Si vous n'êtes pas familier avec cette notion, consultez la section
"Vous êtes pressés ?"
à propos de
async
et
await
dans la documentation
.
Lancez
Lancez le serveur avec :
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
À propos de la commande
uvicorn main:app --reload
...
La commande
uvicorn main:app
fait référence à :
main
: le fichier
main.py
(le "module" Python).
app
: l'objet créé à l'intérieur de
main.py
avec la ligne
app = FastAPI()
.
--reload
: fait redémarrer le serveur après des changements de code. À n'utiliser que pour le développement.
Vérifiez
Ouvrez votre navigateur à l'adresse
http://127.0.0.1:8000/items/5?q=somequery
.
Vous obtenez alors cette réponse
JSON
:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Vous venez de créer une API qui :
Reçoit les requêtes HTTP pour les
chemins
/
et
/items/{item_id}
.
Les deux
chemins
acceptent des
opérations
GET
(également connu sous le nom de
méthodes
HTTP).
Le
chemin
/items/{item_id}
a un
paramètre
item_id
qui doit être un
int
.
Le
chemin
/items/{item_id}
a un
paramètre de requête
optionnel
q
de type
str
.
Documentation API interactive
Maintenant, rendez-vous sur
http://127.0.0.1:8000/docs
.
Vous verrez la documentation interactive automatique de l'API (fournie par
Swagger UI
) :
Documentation API alternative
Et maintenant, rendez-vous sur
http://127.0.0.1:8000/redoc
.
Vous verrez la documentation interactive automatique de l'API (fournie par
ReDoc
) :
Exemple plus poussé
Maintenant, modifiez le fichier
main.py
pour recevoir
le corps
d'une requête
PUT
.
Déclarez ce corps en utilisant les types Python standards, grâce à Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Le serveur se recharge normalement automatiquement (car vous avez pensé à
--reload
dans la commande
uvicorn
ci-dessus).
Plus loin avec la documentation API interactive
Maintenant, rendez-vous sur
http://127.0.0.1:8000/docs
.
La documentation interactive de l'API sera automatiquement mise à jour, y compris le nouveau corps de la requête :
Cliquez sur le bouton "Try it out", il vous permet de renseigner les paramètres et d'interagir directement avec l'API :
Cliquez ensuite sur le bouton "Execute", l'interface utilisateur communiquera avec votre API, enverra les paramètres, obtiendra les résultats et les affichera à l'écran :
Plus loin avec la documentation API alternative
Et maintenant, rendez-vous sur
http://127.0.0.1:8000/redoc
.
La documentation alternative reflétera également le nouveau paramètre de requête et le nouveau corps :
En résumé
En résumé, vous déclarez
une fois
les types de paramètres,
le corps
de la requête, etc. en tant que paramètres de fonction.
Vous faites cela avec les types Python standard modernes.
Vous n'avez pas à apprendre une nouvelle syntaxe, les méthodes ou les classes d'une bibliothèque spécifique, etc.
Juste du
Python
standard.
Par exemple, pour un
int
:
item_id
:
int
ou pour un modèle
Item
plus complexe :
item
:
Item
... et avec cette déclaration unique, vous obtenez :
Une assistance dans votre IDE, notamment :
la complétion.
la vérification des types.
La validation des données :
des erreurs automatiques et claires lorsque les données ne sont pas valides.
une validation même pour les objets
JSON
profondément imbriqués.
Une conversion
des données d'entrée : venant du réseau et allant vers les données et types de Python, permettant de lire :
le
JSON
.
les paramètres du chemin
.
les paramètres de la requête
.
les cookies.
les en-têtes
.
les formulaires
.
les fichiers
.
La conversion
des données de sortie : conversion des données et types Python en données réseau (au format
JSON
), permettant de convertir :
les types Python (
str
,
int
,
float
,
bool
,
list
, etc).
les objets
datetime
.
les objets
UUID
.
les modèles de base de données.
... et beaucoup plus.
La documentation API interactive automatique, avec 2 interfaces utilisateur au choix :
Swagger UI.
ReDoc.
Pour revenir à l'exemple de code précédent,
FastAPI
permet de :
Valider que
item_id
existe dans le chemin des requêtes
GET
et
PUT
.
Valider que
item_id
est de type
int
pour les requêtes
GET
et
PUT
.
Si ce n'est pas le cas, le client voit une erreur utile et claire.
Vérifier qu'il existe un paramètre de requête facultatif nommé
q
(comme dans
http://127.0.0.1:8000/items/foo?q=somequery
) pour les requêtes
GET
.
Puisque le paramètre
q
est déclaré avec
= None
, il est facultatif.
Sans le
None
, il serait nécessaire (comme l'est
le corps
de la requête dans le cas du
PUT
).
Pour les requêtes
PUT
vers
/items/{item_id}
, de lire
le corps
en
JSON
:
Vérifier qu'il a un attribut obligatoire
name
qui devrait être un
str
.
Vérifier qu'il a un attribut obligatoire
prix
qui doit être un
float
.
Vérifier qu'il a un attribut facultatif
is_offer
, qui devrait être un
bool
, s'il est présent.
Tout cela fonctionnerait également pour les objets
JSON
profondément imbriqués.
Convertir de et vers
JSON
automatiquement.
Documenter tout avec OpenAPI, qui peut être utilisé par :
Les systèmes de documentation interactifs.
Les systèmes de génération automatique de code client, pour de nombreuses langues.
Fournir directement 2 interfaces web de documentation interactive.
Nous n'avons fait qu'effleurer la surface, mais vous avez déjà une idée de la façon dont tout cela fonctionne.
Essayez de changer la ligne contenant :
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
... de :
...
"item_name"
:
item
.
name
...
... vers :
...
"item_price"
:
item
.
price
...
... et voyez comment votre éditeur complétera automatiquement les attributs et connaîtra leurs types :
Pour un exemple plus complet comprenant plus de fonctionnalités, voir le
Tutoriel - Guide utilisateur
.
Spoiler alert
: le tutoriel - guide utilisateur inclut :
Déclaration de
paramètres
provenant d'autres endroits différents comme :
en-têtes
.
,
cookies
,
champs de formulaire
et
fichiers
.
L'utilisation de
contraintes de validation
comme
maximum_length
ou
regex
.
Un
système d'injection de dépendance
très puissant et facile à utiliser .
Sécurité et authentification, y compris la prise en charge de
OAuth2
avec les
jetons
JWT
et l'authentification
HTTP Basic
.
Des techniques plus avancées (mais tout aussi faciles) pour déclarer les
modèles
JSON
profondément imbriqués
(grâce à Pydantic).
Intégration de
GraphQL
avec
Strawberry
et d'autres bibliothèques.
D'obtenir de nombreuses fonctionnalités supplémentaires (grâce à Starlette) comme :
WebSockets
de tester le code très facilement avec
requests
et
pytest
CORS
Cookie Sessions
... et plus encore.
Performance
Les benchmarks TechEmpower indépendants montrent que les applications
FastAPI
s'exécutant sous Uvicorn sont
parmi les frameworks existants en Python les plus rapides
, juste derrière Starlette et Uvicorn (utilisés en interne par FastAPI). (*)
Pour en savoir plus, consultez la section
Benchmarks
.
Dépendances facultatives
Utilisées par Pydantic:
email-validator
- pour la validation des adresses email.
Utilisées par Starlette :
requests
- Obligatoire si vous souhaitez utiliser
TestClient
.
jinja2
- Obligatoire si vous souhaitez utiliser la configuration de template par défaut.
python-multipart
- Obligatoire si vous souhaitez supporter le
"décodage"
de formulaire avec
request.form()
.
itsdangerous
- Obligatoire pour la prise en charge de
SessionMiddleware
.
pyyaml
- Obligatoire pour le support
SchemaGenerator
de Starlette (vous n'en avez probablement pas besoin avec FastAPI).
Utilisées par FastAPI / Starlette :
uvicorn
- Pour le serveur qui charge et sert votre application.
orjson
- Obligatoire si vous voulez utiliser
ORJSONResponse
.
ujson
- Obligatoire si vous souhaitez utiliser
UJSONResponse
.
Vous pouvez tout installer avec
pip install fastapi[all]
.
Licence
Ce projet est soumis aux termes de la licence MIT.

## 056_HE
FastAPI¶
---

FastAPI
תשתית FastAPI, ביצועים גבוהים, קלה ללמידה, מהירה לתכנות, מוכנה לסביבת ייצור
תיעוד
:
https://fastapi.tiangolo.com
קוד
:
https://github.com/fastapi/fastapi
FastAPI היא תשתית רשת מודרנית ומהירה (ביצועים גבוהים) לבניית ממשקי תכנות יישומים (API) עם פייתון 3.6+ בהתבסס על רמזי טיפוסים סטנדרטיים.
תכונות המפתח הן:
מהירה
: ביצועים גבוהים מאוד, בקנה אחד עם NodeJS ו - Go (תודות ל - Starlette ו - Pydantic).
אחת מתשתיות הפייתון המהירות ביותר
.
מהירה לתכנות
: הגבירו את מהירות פיתוח התכונות החדשות בכ - %200 עד %300. *
פחות שגיאות
: מנעו כ - %40 משגיאות אנוש (מפתחים). *
אינטואיטיבית
: תמיכת עורך מעולה.
השלמה
בכל מקום. פחות זמן ניפוי שגיאות.
קלה
: מתוכננת להיות קלה לשימוש וללמידה. פחות זמן קריאת תיעוד.
קצרה
: מזערו שכפול קוד. מספר תכונות מכל הכרזת פרמטר. פחות שגיאות.
חסונה
: קבלו קוד מוכן לסביבת ייצור. עם תיעוד אינטרקטיבי אוטומטי.
מבוססת סטנדרטים
: מבוססת על (ותואמת לחלוטין ל -) הסטדנרטים הפתוחים לממשקי תכנות יישומים:
OpenAPI
(ידועים לשעבר כ - Swagger) ו -
JSON Schema
.
* הערכה מבוססת על בדיקות של צוות פיתוח פנימי שבונה אפליקציות בסביבת ייצור.
נותני חסות
נותני חסות אחרים
דעות
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I’m over the moon excited about
FastAPI
. It’s so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, ה - FastAPI של ממשקי שורת פקודה (CLI).
אם אתם בונים אפליקציית
CLI
לשימוש במסוף במקום ממשק רשת, העיפו מבט על
Typer
.
Typer
היא אחותה הקטנה של FastAPI. ומטרתה היא להיות ה -
FastAPI של ממשקי שורת פקודה
. ⌨️ 🚀
תלויות
פייתון 3.6+
FastAPI עומדת על כתפי ענקיות:
Starlette
לחלקי הרשת.
Pydantic
לחלקי המידע.
התקנה
fast →
pip install fastapi
restart ↻
תצטרכו גם שרת ASGI כגון
Uvicorn
או
Hypercorn
.
fast →
pip install "uvicorn[standard]"
restart ↻
דוגמא
צרו אותה
צרו קובץ בשם
main.py
עם:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
או השתמשו ב -
async def
...
אם הקוד שלכם משתמש ב -
async
/
await
, השתמשו ב -
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
שימו לב
:
אם אינכם יודעים, בדקו את פרק "ממהרים?" על
async
ו -
await
בתיעוד
.
הריצו אותה
התחילו את השרת עם:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
על הפקודה
uvicorn main:app --reload
...
הפקודה
uvicorn main:app
מתייחסת ל:
main
: הקובץ
main.py
(מודול פייתון).
app
: האובייקט שנוצר בתוך
main.py
עם השורה
app = FastAPI()
.
--reload
: גרמו לשרת להתאתחל לאחר שינויים בקוד. עשו זאת רק בסביבת פיתוח.
בדקו אותה
פתחו את הדפדפן שלכם בכתובת
http://127.0.0.1:8000/items/5?q=somequery
.
אתם תראו תגובת JSON:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
כבר יצרתם API ש:
מקבל בקשות HTTP בנתיבים
/
ו -
/items/{item_id}
.
שני ה
נתיבים
מקבלים
בקשות
GET
(ידועות גם כ
מתודות
HTTP).
ה
נתיב
/items/{item_id}
כולל *פרמטר נתיב_
item_id
שאמור להיות
int
.
ה
נתיב
/items/{item_id}
*פרמטר שאילתא_ אופציונלי
q
.
תיעוד API אינטרקטיבי
כעת פנו לכתובת
http://127.0.0.1:8000/docs
.
אתם תראו את התיעוד האוטומטי (מסופק על ידי
Swagger UI
):
תיעוד אלטרנטיבי
כעת פנו לכתובת
http://127.0.0.1:8000/redoc
.
אתם תראו תיעוד אלטרנטיבי (מסופק על ידי
ReDoc
):
שדרוג לדוגמא
כעת ערכו את הקובץ
main.py
כך שיוכל לקבל גוף מבקשת
PUT
.
הגדירו את הגוף בעזרת רמזי טיפוסים סטנדרטיים, הודות ל -
Pydantic
.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
השרת אמול להתאתחל אוטומטית (מאחר והוספתם
--reload
לפקודת
uvicorn
שלמעלה).
שדרוג התיעוד האינטרקטיבי
כעת פנו לכתובת
http://127.0.0.1:8000/docs
.
התיעוד האוטומטי יתעדכן, כולל הגוף החדש:
לחצו על הכפתור "Try it out", הוא יאפשר לכם למלא את הפרמטרים ולעבוד ישירות מול ה - API.
אחר כך לחצו על הכפתור "Execute", האתר יתקשר עם ה - API שלכם, ישלח את הפרמטרים, ישיג את התוצאות ואז יראה אותן על המסך:
שדרוג התיעוד האלטרנטיבי
כעת פנו לכתובת
http://127.0.0.1:8000/redoc
.
התיעוד האלטרנטיבי גם יראה את פרמטר השאילתא והגוף החדשים.
סיכום
לסיכום, אתם מכריזים ** פעם אחת** על טיפוסי הפרמטרים, גוף וכו' כפרמטרים לפונקציה.
אתם עושים את זה עם טיפוסי פייתון מודרניים.
אתם לא צריכים ללמוד תחביר חדש, מתודות או מחלקות של ספרייה ספיציפית, וכו'
רק
פייתון 3.6+
סטנדרטי.
לדוגמא, ל -
int
:
item_id
:
int
או למודל
Item
מורכב יותר:
item
:
Item
...ועם הכרזת הטיפוס האחת הזו אתם מקבלים:
תמיכת עורך, כולל:
השלמות.
בדיקת טיפוסים.
אימות מידע:
שגיאות ברורות ואטומטיות כאשר מוכנס מידע לא חוקי .
אימות אפילו לאובייקטי JSON מקוננים.
המרה
של מידע קלט: המרה של מידע שמגיע מהרשת למידע וטיפוסים של פייתון. קורא מ:
JSON.
פרמטרי נתיב.
פרמטרי שאילתא.
עוגיות.
כותרות.
טפסים.
קבצים.
המרה
של מידע פלט: המרה של מידע וטיפוסים מפייתון למידע רשת (כ - JSON):
המירו טיפוסי פייתון (
str
,
int
,
float
,
bool
,
list
, etc).
עצמי
datetime
.
עצמי
UUID
.
מודלי בסיסי נתונים.
...ורבים אחרים.
תיעוד API אוטומטי ואינטרקטיבית כולל שתי אלטרנטיבות לממשק המשתמש:
Swagger UI.
ReDoc.
בחזרה לדוגמאת הקוד הקודמת,
FastAPI
ידאג:
לאמת שיש
item_id
בנתיב בבקשות
GET
ו -
PUT
.
לאמת שה -
item_id
הוא מטיפוס
int
בבקשות
GET
ו -
PUT
.
אם הוא לא, הלקוח יראה שגיאה ברורה ושימושית.
לבדוק האם קיים פרמטר שאילתא בשם
q
(קרי
http://127.0.0.1:8000/items/foo?q=somequery
) לבקשות
GET
.
מאחר והפרמטר
q
מוגדר עם
= None
, הוא אופציונלי.
לולא ה -
None
הוא היה חובה (כמו הגוף במקרה של
PUT
).
לבקשות
PUT
לנתיב
/items/{item_id}
, לקרוא את גוף הבקשה כ - JSON:
לאמת שהוא כולל את מאפיין החובה
name
שאמור להיות מטיפוס
str
.
לאמת שהוא כולל את מאפיין החובה
price
שחייב להיות מטיפוס
float
.
לבדוק האם הוא כולל את מאפיין הרשות
is_offer
שאמור להיות מטיפוס
bool
, אם הוא נמצא.
כל זה יעבוד גם לאובייקט JSON מקונן.
להמיר מ - JSON ול- JSON אוטומטית.
לתעד הכל באמצעות OpenAPI, תיעוד שבו יוכלו להשתמש:
מערכות תיעוד אינטרקטיביות.
מערכות ייצור קוד אוטומטיות, להרבה שפות.
לספק ישירות שתי מערכות תיעוד רשתיות.
רק גרדנו את קצה הקרחון, אבל כבר יש לכם רעיון של איך הכל עובד.
נסו לשנות את השורה:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...מ:
...
"item_name"
:
item
.
name
...
...ל:
...
"item_price"
:
item
.
price
...
...וראו איך העורך שלכם משלים את המאפיינים ויודע את הטיפוסים שלהם:
לדוגמא יותר שלמה שכוללת עוד תכונות, ראו את ה
מדריך - למשתמש
.
התראת ספוילרים
: המדריך - למשתמש כולל:
הכרזה על
פרמטרים
ממקורות אחרים ושונים כגון:
כותרות
,
עוגיות
,
טפסים
ו -
קבצים
.
איך לקבוע
מגבלות אימות
בעזרת
maximum_length
או
regex
.
דרך חזקה וקלה להשתמש ב
הזרקת תלויות
.
אבטחה והתאמתות, כולל תמיכה ב -
OAuth2
עם
JWT
והתאמתות
HTTP Basic
.
טכניקות מתקדמות (אבל קלות באותה מידה) להכרזת אובייקטי JSON מקוננים (תודות ל - Pydantic).
אינטרקציה עם
GraphQL
דרך
Strawberry
וספריות אחרות.
תכונות נוספות רבות (תודות ל - Starlette) כגון:
WebSockets
בדיקות קלות במיוחד מבוססות על
requests
ו -
pytest
CORS
Cookie Sessions
...ועוד.
ביצועים
בדיקות עצמאיות של TechEmpower הראו שאפליקציות
FastAPI
שרצות תחת Uvicorn הן
מתשתיות הפייתון המהירות ביותר
, רק מתחת ל - Starlette ו - Uvicorn עצמן (ש - FastAPI מבוססת עליהן). (*)
כדי להבין עוד על הנושא, ראו את הפרק
Benchmarks
.
תלויות אופציונליות
בשימוש Pydantic:
email-validator
- לאימות כתובות אימייל.
בשימוש Starlette:
httpx
- דרוש אם ברצונכם להשתמש ב -
TestClient
.
jinja2
- דרוש אם ברצונכם להשתמש בברירת המחדל של תצורת הטמפלייטים.
python-multipart
- דרוש אם ברצונכם לתמוך ב
"פרסור"
טפסים, באצמעות
request.form()
.
itsdangerous
- דרוש אם ברצונכם להשתמש ב -
SessionMiddleware
.
pyyaml
- דרוש אם ברצונכם להשתמש ב -
SchemaGenerator
של Starlette (כנראה שאתם לא צריכים את זה עם FastAPI).
בשימוש FastAPI / Starlette:
uvicorn
- לשרת שטוען ומגיש את האפליקציה שלכם.
orjson
- דרוש אם ברצונכם להשתמש ב -
ORJSONResponse
.
ujson
- דרוש אם ברצונכם להשתמש ב -
UJSONResponse
.
תוכלו להתקין את כל אלו באמצעות
pip install "fastapi[all]"
.
רשיון
הפרויקט הזה הוא תחת התנאים של רשיון MIT.

## 057_HELP_FASTAPI
Help FastAPI - Get Help¶
---

Help FastAPI - Get Help
Do you like
FastAPI
?
Would you like to help FastAPI, other users, and the author?
Or would you like to get help with
FastAPI
?
There are very simple ways to help (several involve just one or two clicks).
And there are several ways to get help too.
Subscribe to the newsletter
You can subscribe to the (infrequent)
FastAPI and friends
newsletter
to stay updated about:
News about FastAPI and friends 🚀
Guides 📝
Features ✨
Breaking changes 🚨
Tips and tricks ✅
Follow FastAPI on Twitter
Follow @fastapi on
Twitter
to get the latest news about
FastAPI
. 🐦
Star
FastAPI
in GitHub
You can "star" FastAPI in GitHub (clicking the star button at the top right):
https://github.com/fastapi/fastapi
. ⭐️
By adding a star, other users will be able to find it more easily and see that it has been already useful for others.
Watch the GitHub repository for releases
You can "watch" FastAPI in GitHub (clicking the "watch" button at the top right):
https://github.com/fastapi/fastapi
. 👀
There you can select "Releases only".
By doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of
FastAPI
with bug fixes and new features.
Connect with the author
You can connect with
me (Sebastián Ramírez /
tiangolo
)
, the author.
You can:
Follow me on
GitHub
.
See other Open Source projects I have created that could help you.
Follow me to see when I create a new Open Source project.
Follow me on
Twitter
or
Mastodon
.
Tell me how you use FastAPI (I love to hear that).
Hear when I make announcements or release new tools.
You can also
follow @fastapi on Twitter
(a separate account).
Follow me on
LinkedIn
.
Hear when I make announcements or release new tools (although I use Twitter more often 🤷‍♂).
Read what I write (or follow me) on
Dev.to
or
Medium
.
Read other ideas, articles, and read about tools I have created.
Follow me to read when I publish something new.
Tweet about
FastAPI
Tweet about
FastAPI
and let me and others know why you like it. 🎉
I love to hear about how
FastAPI
is being used, what you have liked in it, in which project/company are you using it, etc.
Vote for FastAPI
Vote for
FastAPI
in Slant
.
Vote for
FastAPI
in AlternativeTo
.
Say you use
FastAPI
on StackShare
.
Help others with questions in GitHub
You can try and help others with their questions in:
GitHub Discussions
GitHub Issues
In many cases you might already know the answer for those questions. 🤓
If you are helping a lot of people with their questions, you will become an official
FastAPI Expert
. 🎉
Just remember, the most important point is: try to be kind. People come with their frustrations and in many cases don't ask in the best way, but try as best as you can to be kind. 🤗
The idea is for the
FastAPI
community to be kind and welcoming. At the same time, don't accept bullying or disrespectful behavior towards others. We have to take care of each other.
Here's how to help others with questions (in discussions or issues):
Understand the question
Check if you can understand what is the
purpose
and use case of the person asking.
Then check if the question (the vast majority are questions) is
clear
.
In many cases the question asked is about an imaginary solution from the user, but there might be a
better
one. If you can understand the problem and use case better, you might be able to suggest a better
alternative solution
.
If you can't understand the question, ask for more
details
.
Reproduce the problem
For most of the cases and most of the questions there's something related to the person's
original code
.
In many cases they will only copy a fragment of the code, but that's not enough to
reproduce the problem
.
You can ask them to provide a
minimal, reproducible, example
, that you can
copy-paste
and run locally to see the same error or behavior they are seeing, or to understand their use case better.
If you are feeling too generous, you can try to
create an example
like that yourself, just based on the description of the problem. Just keep in mind that this might take a lot of time and it might be better to ask them to clarify the problem first.
Suggest solutions
After being able to understand the question, you can give them a possible
answer
.
In many cases, it's better to understand their
underlying problem or use case
, because there might be a better way to solve it than what they are trying to do.
Ask to close
If they reply, there's a high chance you would have solved their problem, congrats,
you're a hero
! 🦸
Now, if that solved their problem, you can ask them to:
In GitHub Discussions: mark the comment as the
answer
.
In GitHub Issues:
close
the issue.
Watch the GitHub repository
You can "watch" FastAPI in GitHub (clicking the "watch" button at the top right):
https://github.com/fastapi/fastapi
. 👀
If you select "Watching" instead of "Releases only" you will receive notifications when someone creates a new issue or question. You can also specify that you only want to be notified about new issues, or discussions, or PRs, etc.
Then you can try and help them solve those questions.
Ask Questions
You can
create a new question
in the GitHub repository, for example to:
Ask a
question
or ask about a
problem
.
Suggest a new
feature
.
Note
: if you do it, then I'm going to ask you to also help others. 😉
Review Pull Requests
You can help me review pull requests from others.
Again, please try your best to be kind. 🤗
Here's what to keep in mind and how to review a pull request:
Understand the problem
First, make sure you
understand the problem
that the pull request is trying to solve. It might have a longer discussion in a GitHub Discussion or issue.
There's also a good chance that the pull request is not actually needed because the problem can be solved in a
different way
. Then you can suggest or ask about that.
Don't worry about style
Don't worry too much about things like commit message styles, I will squash and merge customizing the commit manually.
Also don't worry about style rules, there are already automatized tools checking that.
And if there's any other style or consistency need, I'll ask directly for that, or I'll add commits on top with the needed changes.
Check the code
Check and read the code, see if it makes sense,
run it locally
and see if it actually solves the problem.
Then
comment
saying that you did that, that's how I will know you really checked it.
Info
Unfortunately, I can't simply trust PRs that just have several approvals.
Several times it has happened that there are PRs with 3, 5 or more approvals, probably because the description is appealing, but when I check the PRs, they are actually broken, have a bug, or don't solve the problem they claim to solve. 😅
So, it's really important that you actually read and run the code, and let me know in the comments that you did. 🤓
If the PR can be simplified in a way, you can ask for that, but there's no need to be too picky, there might be a lot of subjective points of view (and I will have my own as well 🙈), so it's better if you can focus on the fundamental things.
Tests
Help me check that the PR has
tests
.
Check that the tests
fail
before the PR. 🚨
Then check that the tests
pass
after the PR. ✅
Many PRs don't have tests, you can
remind
them to add tests, or you can even
suggest
some tests yourself. That's one of the things that consume most time and you can help a lot with that.
Then also comment what you tried, that way I'll know that you checked it. 🤓
Create a Pull Request
You can
contribute
to the source code with Pull Requests, for example:
To fix a typo you found on the documentation.
To share an article, video, or podcast you created or found about FastAPI by
editing this file
.
Make sure you add your link to the start of the corresponding section.
To help
translate the documentation
to your language.
You can also help to review the translations created by others.
To propose new documentation sections.
To fix an existing issue/bug.
Make sure to add tests.
To add a new feature.
Make sure to add tests.
Make sure to add documentation if it's relevant.
Help Maintain FastAPI
Help me maintain
FastAPI
! 🤓
There's a lot of work to do, and for most of it,
YOU
can do it.
The main tasks that you can do right now are:
Help others with questions in GitHub
(see the section above).
Review Pull Requests
(see the section above).
Those two tasks are what
consume time the most
. That's the main work of maintaining FastAPI.
If you can help me with that,
you are helping me maintain FastAPI
and making sure it keeps
advancing faster and better
. 🚀
Join the chat
Join the 👥
Discord chat server
👥 and hang out with others in the FastAPI community.
Tip
For questions, ask them in
GitHub Discussions
, there's a much better chance you will receive help by the
FastAPI Experts
.
Use the chat only for other general conversations.
Don't use the chat for questions
Keep in mind that as chats allow more "free conversation", it's easy to ask questions that are too general and more difficult to answer, so, you might not receive answers.
In GitHub, the template will guide you to write the right question so that you can more easily get a good answer, or even solve the problem yourself even before asking. And in GitHub I can make sure I always answer everything, even if it takes some time. I can't personally do that with the chat systems. 😅
Conversations in the chat systems are also not as easily searchable as in GitHub, so questions and answers might get lost in the conversation. And only the ones in GitHub count to become a
FastAPI Expert
, so you will most probably receive more attention in GitHub.
On the other side, there are thousands of users in the chat systems, so there's a high chance you'll find someone to talk to there, almost all the time. 😄
Sponsor the author
If your
product/company
depends on or is related to
FastAPI
and you want to reach its users, you can sponsor the author (me) through
GitHub sponsors
. Depending on the tier, you could get some extra benefits, like a badge in the docs. 🎁
Thanks! 🚀

## 058_HISTORY_DESIGN_FUTURE
History, Design and Future¶
---

History, Design and Future
Some time ago,
a
FastAPI
user asked
:
What’s the history of this project? It seems to have come from nowhere to awesome in a few weeks [...]
Here's a little bit of that history.
Alternatives
I have been creating APIs with complex requirements for several years (Machine Learning, distributed systems, asynchronous jobs, NoSQL databases, etc), leading several teams of developers.
As part of that, I needed to investigate, test and use many alternatives.
The history of
FastAPI
is in great part the history of its predecessors.
As said in the section
Alternatives
:
FastAPI
wouldn't exist if not for the previous work of others.
There have been many tools created before that have helped inspire its creation.
I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by
FastAPI
using many different frameworks, plug-ins, and tools.
But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints).
Investigation
By using all the previous alternatives I had the chance to learn from all of them, take ideas, and combine them in the best way I could find for myself and the teams of developers I have worked with.
For example, it was clear that ideally it should be based on standard Python type hints.
Also, the best approach was to use already existing standards.
So, before even starting to code
FastAPI
, I spent several months studying the specs for OpenAPI, JSON Schema, OAuth2, etc. Understanding their relationship, overlap, and differences.
Design
Then I spent some time designing the developer "API" I wanted to have as a user (as a developer using FastAPI).
I tested several ideas in the most popular Python editors: PyCharm, VS Code, Jedi based editors.
By the last
Python Developer Survey
, that covers about 80% of the users.
It means that
FastAPI
was specifically tested with the editors used by 80% of the Python developers. And as most of the other editors tend to work similarly, all its benefits should work for virtually all editors.
That way I could find the best ways to reduce code duplication as much as possible, to have completion everywhere, type and error checks, etc.
All in a way that provided the best development experience for all the developers.
Requirements
After testing several alternatives, I decided that I was going to use
Pydantic
for its advantages.
Then I contributed to it, to make it fully compliant with JSON Schema, to support different ways to define constraint declarations, and to improve editor support (type checks, autocompletion) based on the tests in several editors.
During the development, I also contributed to
Starlette
, the other key requirement.
Development
By the time I started creating
FastAPI
itself, most of the pieces were already in place, the design was defined, the requirements and tools were ready, and the knowledge about the standards and specifications was clear and fresh.
Future
By this point, it's already clear that
FastAPI
with its ideas is being useful for many people.
It is being chosen over previous alternatives for suiting many use cases better.
Many developers and teams already depend on
FastAPI
for their projects (including me and my team).
But still, there are many improvements and features to come.
FastAPI
has a great future ahead.
And
your help
is greatly appreciated.

## 059_HOW_TO
How To - Recipes¶
---

How To - Recipes
Here you will see different recipes or "how to" guides for
several topics
.
Most of these ideas would be more or less
independent
, and in most cases you should only need to study them if they apply directly to
your project
.
If something seems interesting and useful to your project, go ahead and check it, but otherwise, you might probably just skip them.
Tip
If you want to
learn FastAPI
in a structured way (recommended), go and read the
Tutorial - User Guide
chapter by chapter instead.

## 060_HOW_TO_CONDITIONAL_OPENAPI
Conditional OpenAPI¶
---

Conditional OpenAPI
If you needed to, you could use settings and environment variables to configure OpenAPI conditionally depending on the environment, and even disable it entirely.
About security, APIs, and docs
Hiding your documentation user interfaces in production
shouldn't
be the way to protect your API.
That doesn't add any extra security to your API, the
path operations
will still be available where they are.
If there's a security flaw in your code, it will still exist.
Hiding the documentation just makes it more difficult to understand how to interact with your API, and could make it more difficult for you to debug it in production. It could be considered simply a form of
Security through obscurity
.
If you want to secure your API, there are several better things you can do, for example:
Make sure you have well defined Pydantic models for your request bodies and responses.
Configure any required permissions and roles using dependencies.
Never store plaintext passwords, only password hashes.
Implement and use well-known cryptographic tools, like Passlib and JWT tokens, etc.
Add more granular permission controls with OAuth2 scopes where needed.
...etc.
Nevertheless, you might have a very specific use case where you really need to disable the API docs for some environment (e.g. for production) or depending on configurations from environment variables.
Conditional OpenAPI from settings and env vars
You can easily use the same Pydantic settings to configure your generated OpenAPI and the docs UIs.
For example:
Python 3.8+
from
fastapi
import
FastAPI
from
pydantic_settings
import
BaseSettings
class
Settings
(
BaseSettings
):
openapi_url
:
str
=
"/openapi.json"
settings
=
Settings
()
app
=
FastAPI
(
openapi_url
=
settings
.
openapi_url
)
@app
.
get
(
"/"
)
def
root
():
return
{
"message"
:
"Hello World"
}
Here we declare the setting
openapi_url
with the same default of
"/openapi.json"
.
And then we use it when creating the
FastAPI
app.
Then you could disable OpenAPI (including the UI docs) by setting the environment variable
OPENAPI_URL
to the empty string, like:
fast →
OPENAPI_URL= uvicorn main:app
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
Then if you go to the URLs at
/openapi.json
,
/docs
, or
/redoc
you will just get a
404 Not Found
error like:
{
"detail"
:
"Not Found"
}

## 061_HOW_TO_CONFIGURE_SWAGGER_UI
Configure Swagger UI¶
---

Configure Swagger UI
You can configure some extra
Swagger UI parameters
.
To configure them, pass the
swagger_ui_parameters
argument when creating the
FastAPI()
app object or to the
get_swagger_ui_html()
function.
swagger_ui_parameters
receives a dictionary with the configurations passed to Swagger UI directly.
FastAPI converts the configurations to
JSON
to make them compatible with JavaScript, as that's what Swagger UI needs.
Disable Syntax Highlighting
For example, you could disable syntax highlighting in Swagger UI.
Without changing the settings, syntax highlighting is enabled by default:
But you can disable it by setting
syntaxHighlight
to
False
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
(
swagger_ui_parameters
=
{
"syntaxHighlight"
:
False
})
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
...and then Swagger UI won't show the syntax highlighting anymore:
Change the Theme
The same way you could set the syntax highlighting theme with the key
"syntaxHighlight.theme"
(notice that it has a dot in the middle):
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
(
swagger_ui_parameters
=
{
"syntaxHighlight"
:
{
"theme"
:
"obsidian"
}})
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
That configuration would change the syntax highlighting color theme:
Change Default Swagger UI Parameters
FastAPI includes some default configuration parameters appropriate for most of the use cases.
It includes these default configurations:
Python 3.8+
## Code above omitted 👆
swagger_ui_default_parameters
:
Annotated
[
Dict
[
str
,
Any
],
Doc
(
"""
Default configurations for Swagger UI.
You can use it as a template to add any other configurations needed.
"""
),
]
=
{
"dom_id"
:
"#swagger-ui"
,
"layout"
:
"BaseLayout"
,
"deepLinking"
:
True
,
"showExtensions"
:
True
,
"showCommonExtensions"
:
True
,
}
## Code below omitted 👇
👀 Full file preview
Python 3.8+
import
json
from
typing
import
Any
,
Dict
,
Optional
from
fastapi.encoders
import
jsonable_encoder
from
starlette.responses
import
HTMLResponse
from
typing_extensions
import
Annotated
,
Doc
swagger_ui_default_parameters
:
Annotated
[
Dict
[
str
,
Any
],
Doc
(
"""
Default configurations for Swagger UI.
You can use it as a template to add any other configurations needed.
"""
),
]
=
{
"dom_id"
:
"#swagger-ui"
,
"layout"
:
"BaseLayout"
,
"deepLinking"
:
True
,
"showExtensions"
:
True
,
"showCommonExtensions"
:
True
,
}
def
get_swagger_ui_html
(
*
,
openapi_url
:
Annotated
[
str
,
Doc
(
"""
The OpenAPI URL that Swagger UI should load and use.
This is normally done automatically by FastAPI using the default URL
`/openapi.json`.
"""
),
],
title
:
Annotated
[
str
,
Doc
(
"""
The HTML `<title>` content, normally shown in the browser tab.
"""
),
],
swagger_js_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the Swagger UI JavaScript.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the Swagger UI CSS.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css"
,
swagger_favicon_url
:
Annotated
[
str
,
Doc
(
"""
The URL of the favicon to use. It is normally shown in the browser tab.
"""
),
]
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
oauth2_redirect_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The OAuth2 redirect URL, it is normally automatically handled by FastAPI.
"""
),
]
=
None
,
init_oauth
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
A dictionary with Swagger UI OAuth2 initialization configurations.
"""
),
]
=
None
,
swagger_ui_parameters
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Configuration parameters for Swagger UI.
It defaults to [swagger_ui_default_parameters][fastapi.openapi.docs.swagger_ui_default_parameters].
"""
),
]
=
None
,
)
->
HTMLResponse
:
"""
Generate and return the HTML that loads Swagger UI for the interactive
API docs (normally served at `/docs`).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load Swagger UI's JavaScript and CSS.
Read more about it in the
[FastAPI docs for Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/)
and the [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
"""
current_swagger_ui_parameters
=
swagger_ui_default_parameters
.
copy
()
if
swagger_ui_parameters
:
current_swagger_ui_parameters
.
update
(
swagger_ui_parameters
)
html
=
f
"""
<!DOCTYPE html>
<html>
<head>
<link type="text/css" rel="stylesheet" href="
{
swagger_css_url
}
">
<link rel="shortcut icon" href="
{
swagger_favicon_url
}
">
<title>
{
title
}
</title>
</head>
<body>
<div id="swagger-ui">
</div>
<script src="
{
swagger_js_url
}
"></script>
<!-- `SwaggerUIBundle` is now available on the page -->
<script>
const ui = SwaggerUIBundle(
{{
url: '
{
openapi_url
}
',
"""
for
key
,
value
in
current_swagger_ui_parameters
.
items
():
html
+=
f
"
{
json
.
dumps
(
key
)
}
:
{
json
.
dumps
(
jsonable_encoder
(
value
))
}
,
\n
"
if
oauth2_redirect_url
:
html
+=
f
"oauth2RedirectUrl: window.location.origin + '
{
oauth2_redirect_url
}
',"
html
+=
"""
presets: [
SwaggerUIBundle.presets.apis,
SwaggerUIBundle.SwaggerUIStandalonePreset
],
})"""
if
init_oauth
:
html
+=
f
"""
ui.initOAuth(
{
json
.
dumps
(
jsonable_encoder
(
init_oauth
))
}
)
"""
html
+=
"""
</script>
</body>
</html>
"""
return
HTMLResponse
(
html
)
def
get_redoc_html
(
*
,
openapi_url
:
Annotated
[
str
,
Doc
(
"""
The OpenAPI URL that ReDoc should load and use.
This is normally done automatically by FastAPI using the default URL
`/openapi.json`.
"""
),
],
title
:
Annotated
[
str
,
Doc
(
"""
The HTML `<title>` content, normally shown in the browser tab.
"""
),
],
redoc_js_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the ReDoc JavaScript.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js"
,
redoc_favicon_url
:
Annotated
[
str
,
Doc
(
"""
The URL of the favicon to use. It is normally shown in the browser tab.
"""
),
]
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
with_google_fonts
:
Annotated
[
bool
,
Doc
(
"""
Load and use Google Fonts.
"""
),
]
=
True
,
)
->
HTMLResponse
:
"""
Generate and return the HTML response that loads ReDoc for the alternative
API docs (normally served at `/redoc`).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load ReDoc's JavaScript and CSS.
Read more about it in the
[FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
"""
html
=
f
"""
<!DOCTYPE html>
<html>
<head>
<title>
{
title
}
</title>
<!-- needed for adaptive design -->
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
"""
if
with_google_fonts
:
html
+=
"""
<link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
"""
html
+=
f
"""
<link rel="shortcut icon" href="
{
redoc_favicon_url
}
">
<!--
ReDoc doesn't change outer page styles
-->
<style>
body
{{
margin: 0;
padding: 0;
}}
</style>
</head>
<body>
<noscript>
ReDoc requires Javascript to function. Please enable it to browse the documentation.
</noscript>
<redoc spec-url="
{
openapi_url
}
"></redoc>
<script src="
{
redoc_js_url
}
"> </script>
</body>
</html>
"""
return
HTMLResponse
(
html
)
def
get_swagger_ui_oauth2_redirect_html
()
->
HTMLResponse
:
"""
Generate the HTML response with the OAuth2 redirection for Swagger UI.
You normally don't need to use or change this.
"""
## copied from https://github.com/swagger-api/swagger-ui/blob/v4.14.0/dist/oauth2-redirect.html
html
=
"""
<!doctype html>
<html lang="en-US">
<head>
<title>Swagger UI: OAuth2 Redirect</title>
</head>
<body>
<script>
'use strict';
function run () {
var oauth2 = window.opener.swaggerUIRedirectOauth2;
var sentState = oauth2.state;
var redirectUrl = oauth2.redirectUrl;
var isValid, qp, arr;
if (/code|token|error/.test(window.location.hash)) {
qp = window.location.hash.substring(1).replace('?', '&');
} else {
qp = location.search.substring(1);
}
arr = qp.split("&");
arr.forEach(function (v,i,_arr) { _arr[i] = '"' + v.replace('=', '":"') + '"';});
qp = qp ? JSON.parse('{' + arr.join() + '}',
function (key, value) {
return key === "" ? value : decodeURIComponent(value);
}
) :
{}
;
isValid = qp.state === sentState;
if ((
oauth2.auth.schema.get("flow") === "accessCode" ||
oauth2.auth.schema.get("flow") === "authorizationCode" ||
oauth2.auth.schema.get("flow") === "authorization_code"
) && !oauth2.auth.code) {
if (!isValid) {
oauth2.errCb({
authId: oauth2.auth.name,
source: "auth",
level: "warning",
message: "Authorization may be unsafe, passed state was changed in server. The passed state wasn't returned from auth server."
});
}
if (qp.code) {
delete oauth2.state;
oauth2.auth.code = qp.code;
oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});
} else {
let oauthErrorMsg;
if (qp.error) {
oauthErrorMsg = "["+qp.error+"]: " +
(qp.error_description ? qp.error_description+ ". " : "no accessCode received from the server. ") +
(qp.error_uri ? "More info: "+qp.error_uri : "");
}
oauth2.errCb({
authId: oauth2.auth.name,
source: "auth",
level: "error",
message: oauthErrorMsg || "[Authorization failed]: no accessCode received from the server."
});
}
} else {
oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});
}
window.close();
}
if (document.readyState !== 'loading') {
run();
} else {
document.addEventListener('DOMContentLoaded', function () {
run();
});
}
</script>
</body>
</html>
"""
return
HTMLResponse
(
content
=
html
)
You can override any of them by setting a different value in the argument
swagger_ui_parameters
.
For example, to disable
deepLinking
you could pass these settings to
swagger_ui_parameters
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
(
swagger_ui_parameters
=
{
"deepLinking"
:
False
})
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Other Swagger UI Parameters
To see all the other possible configurations you can use, read the official
docs for Swagger UI parameters
.
JavaScript-only settings
Swagger UI also allows other configurations to be
JavaScript-only
objects (for example, JavaScript functions).
FastAPI also includes these JavaScript-only
presets
settings:
presets
:
[
SwaggerUIBundle
.
presets
.
apis
,
SwaggerUIBundle
.
SwaggerUIStandalonePreset
]
These are
JavaScript
objects, not strings, so you can't pass them from Python code directly.
If you need to use JavaScript-only configurations like those, you can use one of the methods above. Override all the Swagger UI
path operation
and manually write any JavaScript you need.

## 062_HOW_TO_CUSTOM_DOCS_UI_ASSETS
Custom Docs UI Static Assets (Self-Hosting)¶
---

Custom Docs UI Static Assets (Self-Hosting)
The API docs use
Swagger UI
and
ReDoc
, and each of those need some JavaScript and CSS files.
By default, those files are served from a
CDN
.
But it's possible to customize it, you can set a specific CDN, or serve the files yourself.
Custom CDN for JavaScript and CSS
Let's say that you want to use a different
CDN
, for example you want to use
https://unpkg.com/
.
This could be useful if for example you live in a country that restricts some URLs.
Disable the automatic docs
The first step is to disable the automatic docs, as by default, those use the default CDN.
To disable them, set their URLs to
None
when creating your
FastAPI
app:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"https://unpkg.com/redoc@2/bundles/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Include the custom docs
Now you can create the
path operations
for the custom docs.
You can reuse FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments:
openapi_url
: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute
app.openapi_url
.
title
: the title of your API.
oauth2_redirect_url
: you can use
app.swagger_ui_oauth2_redirect_url
here to use the default.
swagger_js_url
: the URL where the HTML for your Swagger UI docs can get the
JavaScript
file. This is the custom CDN URL.
swagger_css_url
: the URL where the HTML for your Swagger UI docs can get the
CSS
file. This is the custom CDN URL.
And similarly for ReDoc...
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"https://unpkg.com/redoc@2/bundles/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Tip
The
path operation
for
swagger_ui_redirect
is a helper for when you use OAuth2.
If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication.
Swagger UI will handle it behind the scenes for you, but it needs this "redirect" helper.
Create a
path operation
to test it
Now, to be able to test that everything works, create a
path operation
:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"https://unpkg.com/redoc@2/bundles/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Test it
Now, you should be able to go to your docs at
http://127.0.0.1:8000/docs
, and reload the page, it will load those assets from the new CDN.
Self-hosting JavaScript and CSS for docs
Self-hosting the JavaScript and CSS could be useful if, for example, you need your app to keep working even while offline, without open Internet access, or in a local network.
Here you'll see how to serve those files yourself, in the same FastAPI app, and configure the docs to use them.
Project file structure
Let's say your project file structure looks like this:
.
├── app
│ ├── __init__.py
│ ├── main.py
Now create a directory to store those static files.
Your new file structure could look like this:
.
├── app
│   ├── __init__.py
│   ├── main.py
└── static/
Download the files
Download the static files needed for the docs and put them on that
static/
directory.
You can probably right-click each link and select an option similar to
Save link as...
.
Swagger UI
uses the files:
swagger-ui-bundle.js
swagger-ui.css
And
ReDoc
uses the file:
redoc.standalone.js
After that, your file structure could look like:
.
├── app
│   ├── __init__.py
│   ├── main.py
└── static
├── redoc.standalone.js
├── swagger-ui-bundle.js
└── swagger-ui.css
Serve the static files
Import
StaticFiles
.
"Mount" a
StaticFiles()
instance in a specific path.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
from
fastapi.staticfiles
import
StaticFiles
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"/static/swagger-ui-bundle.js"
,
swagger_css_url
=
"/static/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"/static/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Test the static files
Start your application and go to
http://127.0.0.1:8000/static/redoc.standalone.js
.
You should see a very long JavaScript file for
ReDoc
.
It could start with something like:
/*! For license information please see redoc.standalone.js.LICENSE.txt */
!
function
(
e
,
t
){
"object"
==
typeof
exports
&&
"object"
==
typeof
module
?
module
.
exports
=
t
(
require
(
"null"
))
:
...
That confirms that you are being able to serve static files from your app, and that you placed the static files for the docs in the correct place.
Now we can configure the app to use those static files for the docs.
Disable the automatic docs for static files
The same as when using a custom CDN, the first step is to disable the automatic docs, as those use the CDN by default.
To disable them, set their URLs to
None
when creating your
FastAPI
app:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
from
fastapi.staticfiles
import
StaticFiles
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"/static/swagger-ui-bundle.js"
,
swagger_css_url
=
"/static/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"/static/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Include the custom docs for static files
And the same way as with a custom CDN, now you can create the
path operations
for the custom docs.
Again, you can reuse FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments:
openapi_url
: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute
app.openapi_url
.
title
: the title of your API.
oauth2_redirect_url
: you can use
app.swagger_ui_oauth2_redirect_url
here to use the default.
swagger_js_url
: the URL where the HTML for your Swagger UI docs can get the
JavaScript
file.
This is the one that your own app is now serving
.
swagger_css_url
: the URL where the HTML for your Swagger UI docs can get the
CSS
file.
This is the one that your own app is now serving
.
And similarly for ReDoc...
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
from
fastapi.staticfiles
import
StaticFiles
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"/static/swagger-ui-bundle.js"
,
swagger_css_url
=
"/static/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"/static/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Tip
The
path operation
for
swagger_ui_redirect
is a helper for when you use OAuth2.
If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication.
Swagger UI will handle it behind the scenes for you, but it needs this "redirect" helper.
Create a
path operation
to test static files
Now, to be able to test that everything works, create a
path operation
:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
from
fastapi.staticfiles
import
StaticFiles
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"/static/swagger-ui-bundle.js"
,
swagger_css_url
=
"/static/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"/static/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Test Static Files UI
Now, you should be able to disconnect your WiFi, go to your docs at
http://127.0.0.1:8000/docs
, and reload the page.
And even without Internet, you would be able to see the docs for your API and interact with it.

## 063_HOW_TO_CUSTOM_REQUEST_AND_ROUTE
Custom Request and APIRoute class¶
---

Custom Request and APIRoute class
In some cases, you may want to override the logic used by the
Request
and
APIRoute
classes.
In particular, this may be a good alternative to logic in a middleware.
For example, if you want to read or manipulate the request body before it is processed by your application.
Danger
This is an "advanced" feature.
If you are just starting with
FastAPI
you might want to skip this section.
Use cases
Some use cases include:
Converting non-JSON request bodies to JSON (e.g.
msgpack
).
Decompressing gzip-compressed request bodies.
Automatically logging all request bodies.
Handling custom request body encodings
Let's see how to make use of a custom
Request
subclass to decompress gzip requests.
And an
APIRoute
subclass to use that custom request class.
Create a custom
GzipRequest
class
Tip
This is a toy example to demonstrate how it works, if you need Gzip support, you can use the provided
GzipMiddleware
.
First, we create a
GzipRequest
class, which will overwrite the
Request.body()
method to decompress the body in the presence of an appropriate header.
If there's no
gzip
in the header, it will not try to decompress the body.
That way, the same route class can handle gzip compressed or uncompressed requests.
Python 3.8+
import
gzip
from
typing
import
Callable
,
List
from
fastapi
import
Body
,
FastAPI
,
Request
,
Response
from
fastapi.routing
import
APIRoute
class
GzipRequest
(
Request
):
async
def
body
(
self
)
->
bytes
:
if
not
hasattr
(
self
,
"_body"
):
body
=
await
super
()
.
body
()
if
"gzip"
in
self
.
headers
.
getlist
(
"Content-Encoding"
):
body
=
gzip
.
decompress
(
body
)
self
.
_body
=
body
return
self
.
_body
class
GzipRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
request
=
GzipRequest
(
request
.
scope
,
request
.
receive
)
return
await
original_route_handler
(
request
)
return
custom_route_handler
app
=
FastAPI
()
app
.
router
.
route_class
=
GzipRoute
@app
.
post
(
"/sum"
)
async
def
sum_numbers
(
numbers
:
List
[
int
]
=
Body
()):
return
{
"sum"
:
sum
(
numbers
)}
Create a custom
GzipRoute
class
Next, we create a custom subclass of
fastapi.routing.APIRoute
that will make use of the
GzipRequest
.
This time, it will overwrite the method
APIRoute.get_route_handler()
.
This method returns a function. And that function is what will receive a request and return a response.
Here we use it to create a
GzipRequest
from the original request.
Python 3.8+
import
gzip
from
typing
import
Callable
,
List
from
fastapi
import
Body
,
FastAPI
,
Request
,
Response
from
fastapi.routing
import
APIRoute
class
GzipRequest
(
Request
):
async
def
body
(
self
)
->
bytes
:
if
not
hasattr
(
self
,
"_body"
):
body
=
await
super
()
.
body
()
if
"gzip"
in
self
.
headers
.
getlist
(
"Content-Encoding"
):
body
=
gzip
.
decompress
(
body
)
self
.
_body
=
body
return
self
.
_body
class
GzipRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
request
=
GzipRequest
(
request
.
scope
,
request
.
receive
)
return
await
original_route_handler
(
request
)
return
custom_route_handler
app
=
FastAPI
()
app
.
router
.
route_class
=
GzipRoute
@app
.
post
(
"/sum"
)
async
def
sum_numbers
(
numbers
:
List
[
int
]
=
Body
()):
return
{
"sum"
:
sum
(
numbers
)}
Technical Details
A
Request
has a
request.scope
attribute, that's just a Python
dict
containing the metadata related to the request.
A
Request
also has a
request.receive
, that's a function to "receive" the body of the request.
The
scope
dict
and
receive
function are both part of the ASGI specification.
And those two things,
scope
and
receive
, are what is needed to create a new
Request
instance.
To learn more about the
Request
check
Starlette's docs about Requests
.
The only thing the function returned by
GzipRequest.get_route_handler
does differently is convert the
Request
to a
GzipRequest
.
Doing this, our
GzipRequest
will take care of decompressing the data (if necessary) before passing it to our
path operations
.
After that, all of the processing logic is the same.
But because of our changes in
GzipRequest.body
, the request body will be automatically decompressed when it is loaded by
FastAPI
when needed.
Accessing the request body in an exception handler
Tip
To solve this same problem, it's probably a lot easier to use the
body
in a custom handler for
RequestValidationError
(
Handling Errors
).
But this example is still valid and it shows how to interact with the internal components.
We can also use this same approach to access the request body in an exception handler.
All we need to do is handle the request inside a
try
/
except
block:
Python 3.8+
from
typing
import
Callable
,
List
from
fastapi
import
Body
,
FastAPI
,
HTTPException
,
Request
,
Response
from
fastapi.exceptions
import
RequestValidationError
from
fastapi.routing
import
APIRoute
class
ValidationErrorLoggingRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
try
:
return
await
original_route_handler
(
request
)
except
RequestValidationError
as
exc
:
body
=
await
request
.
body
()
detail
=
{
"errors"
:
exc
.
errors
(),
"body"
:
body
.
decode
()}
raise
HTTPException
(
status_code
=
422
,
detail
=
detail
)
return
custom_route_handler
app
=
FastAPI
()
app
.
router
.
route_class
=
ValidationErrorLoggingRoute
@app
.
post
(
"/"
)
async
def
sum_numbers
(
numbers
:
List
[
int
]
=
Body
()):
return
sum
(
numbers
)
If an exception occurs, the
Request
instance will still be in scope, so we can read and make use of the request body when handling the error:
Python 3.8+
from
typing
import
Callable
,
List
from
fastapi
import
Body
,
FastAPI
,
HTTPException
,
Request
,
Response
from
fastapi.exceptions
import
RequestValidationError
from
fastapi.routing
import
APIRoute
class
ValidationErrorLoggingRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
try
:
return
await
original_route_handler
(
request
)
except
RequestValidationError
as
exc
:
body
=
await
request
.
body
()
detail
=
{
"errors"
:
exc
.
errors
(),
"body"
:
body
.
decode
()}
raise
HTTPException
(
status_code
=
422
,
detail
=
detail
)
return
custom_route_handler
app
=
FastAPI
()
app
.
router
.
route_class
=
ValidationErrorLoggingRoute
@app
.
post
(
"/"
)
async
def
sum_numbers
(
numbers
:
List
[
int
]
=
Body
()):
return
sum
(
numbers
)
Custom
APIRoute
class in a router
You can also set the
route_class
parameter of an
APIRouter
:
Python 3.8+
import
time
from
typing
import
Callable
from
fastapi
import
APIRouter
,
FastAPI
,
Request
,
Response
from
fastapi.routing
import
APIRoute
class
TimedRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
before
=
time
.
time
()
response
:
Response
=
await
original_route_handler
(
request
)
duration
=
time
.
time
()
-
before
response
.
headers
[
"X-Response-Time"
]
=
str
(
duration
)
print
(
f
"route duration:
{
duration
}
"
)
print
(
f
"route response:
{
response
}
"
)
print
(
f
"route response headers:
{
response
.
headers
}
"
)
return
response
return
custom_route_handler
app
=
FastAPI
()
router
=
APIRouter
(
route_class
=
TimedRoute
)
@app
.
get
(
"/"
)
async
def
not_timed
():
return
{
"message"
:
"Not timed"
}
@router
.
get
(
"/timed"
)
async
def
timed
():
return
{
"message"
:
"It's the time of my life"
}
app
.
include_router
(
router
)
In this example, the
path operations
under the
router
will use the custom
TimedRoute
class, and will have an extra
X-Response-Time
header in the response with the time it took to generate the response:
Python 3.8+
import
time
from
typing
import
Callable
from
fastapi
import
APIRouter
,
FastAPI
,
Request
,
Response
from
fastapi.routing
import
APIRoute
class
TimedRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
before
=
time
.
time
()
response
:
Response
=
await
original_route_handler
(
request
)
duration
=
time
.
time
()
-
before
response
.
headers
[
"X-Response-Time"
]
=
str
(
duration
)
print
(
f
"route duration:
{
duration
}
"
)
print
(
f
"route response:
{
response
}
"
)
print
(
f
"route response headers:
{
response
.
headers
}
"
)
return
response
return
custom_route_handler
app
=
FastAPI
()
router
=
APIRouter
(
route_class
=
TimedRoute
)
@app
.
get
(
"/"
)
async
def
not_timed
():
return
{
"message"
:
"Not timed"
}
@router
.
get
(
"/timed"
)
async
def
timed
():
return
{
"message"
:
"It's the time of my life"
}
app
.
include_router
(
router
)

## 064_HOW_TO_EXTENDING_OPENAPI
Extending OpenAPI¶
---

Extending OpenAPI
There are some cases where you might need to modify the generated OpenAPI schema.
In this section you will see how.
The normal process
The normal (default) process, is as follows.
A
FastAPI
application (instance) has an
.openapi()
method that is expected to return the OpenAPI schema.
As part of the application object creation, a
path operation
for
/openapi.json
(or for whatever you set your
openapi_url
) is registered.
It just returns a JSON response with the result of the application's
.openapi()
method.
By default, what the method
.openapi()
does is check the property
.openapi_schema
to see if it has contents and return them.
If it doesn't, it generates them using the utility function at
fastapi.openapi.utils.get_openapi
.
And that function
get_openapi()
receives as parameters:
title
: The OpenAPI title, shown in the docs.
version
: The version of your API, e.g.
2.5.0
.
openapi_version
: The version of the OpenAPI specification used. By default, the latest:
3.1.0
.
summary
: A short summary of the API.
description
: The description of your API, this can include markdown and will be shown in the docs.
routes
: A list of routes, these are each of the registered
path operations
. They are taken from
app.routes
.
Info
The parameter
summary
is available in OpenAPI 3.1.0 and above, supported by FastAPI 0.99.0 and above.
Overriding the defaults
Using the information above, you can use the same utility function to generate the OpenAPI schema and override each part that you need.
For example, let's add
ReDoc's OpenAPI extension to include a custom logo
.
Normal
FastAPI
First, write all your
FastAPI
application as normally:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.utils
import
get_openapi
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
def
custom_openapi
():
if
app
.
openapi_schema
:
return
app
.
openapi_schema
openapi_schema
=
get_openapi
(
title
=
"Custom title"
,
version
=
"2.5.0"
,
summary
=
"This is a very custom OpenAPI schema"
,
description
=
"Here's a longer description of the custom **OpenAPI** schema"
,
routes
=
app
.
routes
,
)
openapi_schema
[
"info"
][
"x-logo"
]
=
{
"url"
:
"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
}
app
.
openapi_schema
=
openapi_schema
return
app
.
openapi_schema
app
.
openapi
=
custom_openapi
Generate the OpenAPI schema
Then, use the same utility function to generate the OpenAPI schema, inside a
custom_openapi()
function:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.utils
import
get_openapi
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
def
custom_openapi
():
if
app
.
openapi_schema
:
return
app
.
openapi_schema
openapi_schema
=
get_openapi
(
title
=
"Custom title"
,
version
=
"2.5.0"
,
summary
=
"This is a very custom OpenAPI schema"
,
description
=
"Here's a longer description of the custom **OpenAPI** schema"
,
routes
=
app
.
routes
,
)
openapi_schema
[
"info"
][
"x-logo"
]
=
{
"url"
:
"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
}
app
.
openapi_schema
=
openapi_schema
return
app
.
openapi_schema
app
.
openapi
=
custom_openapi
Modify the OpenAPI schema
Now you can add the ReDoc extension, adding a custom
x-logo
to the
info
"object" in the OpenAPI schema:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.utils
import
get_openapi
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
def
custom_openapi
():
if
app
.
openapi_schema
:
return
app
.
openapi_schema
openapi_schema
=
get_openapi
(
title
=
"Custom title"
,
version
=
"2.5.0"
,
summary
=
"This is a very custom OpenAPI schema"
,
description
=
"Here's a longer description of the custom **OpenAPI** schema"
,
routes
=
app
.
routes
,
)
openapi_schema
[
"info"
][
"x-logo"
]
=
{
"url"
:
"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
}
app
.
openapi_schema
=
openapi_schema
return
app
.
openapi_schema
app
.
openapi
=
custom_openapi
Cache the OpenAPI schema
You can use the property
.openapi_schema
as a "cache", to store your generated schema.
That way, your application won't have to generate the schema every time a user opens your API docs.
It will be generated only once, and then the same cached schema will be used for the next requests.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.utils
import
get_openapi
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
def
custom_openapi
():
if
app
.
openapi_schema
:
return
app
.
openapi_schema
openapi_schema
=
get_openapi
(
title
=
"Custom title"
,
version
=
"2.5.0"
,
summary
=
"This is a very custom OpenAPI schema"
,
description
=
"Here's a longer description of the custom **OpenAPI** schema"
,
routes
=
app
.
routes
,
)
openapi_schema
[
"info"
][
"x-logo"
]
=
{
"url"
:
"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
}
app
.
openapi_schema
=
openapi_schema
return
app
.
openapi_schema
app
.
openapi
=
custom_openapi
Override the method
Now you can replace the
.openapi()
method with your new function.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.utils
import
get_openapi
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
def
custom_openapi
():
if
app
.
openapi_schema
:
return
app
.
openapi_schema
openapi_schema
=
get_openapi
(
title
=
"Custom title"
,
version
=
"2.5.0"
,
summary
=
"This is a very custom OpenAPI schema"
,
description
=
"Here's a longer description of the custom **OpenAPI** schema"
,
routes
=
app
.
routes
,
)
openapi_schema
[
"info"
][
"x-logo"
]
=
{
"url"
:
"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
}
app
.
openapi_schema
=
openapi_schema
return
app
.
openapi_schema
app
.
openapi
=
custom_openapi
Check it
Once you go to
http://127.0.0.1:8000/redoc
you will see that you are using your custom logo (in this example,
FastAPI
's logo):

## 065_HOW_TO_GENERAL
General - How To - Recipes¶
---

General - How To - Recipes
Here are several pointers to other places in the docs, for general or frequent questions.
Filter Data - Security
To ensure that you don't return more data than you should, read the docs for
Tutorial - Response Model - Return Type
.
Documentation Tags - OpenAPI
To add tags to your
path operations
, and group them in the docs UI, read the docs for
Tutorial - Path Operation Configurations - Tags
.
Documentation Summary and Description - OpenAPI
To add a summary and description to your
path operations
, and show them in the docs UI, read the docs for
Tutorial - Path Operation Configurations - Summary and Description
.
Documentation Response description - OpenAPI
To define the description of the response, shown in the docs UI, read the docs for
Tutorial - Path Operation Configurations - Response description
.
Documentation Deprecate a
Path Operation
- OpenAPI
To deprecate a
path operation
, and show it in the docs UI, read the docs for
Tutorial - Path Operation Configurations - Deprecation
.
Convert any Data to JSON-compatible
To convert any data to JSON-compatible, read the docs for
Tutorial - JSON Compatible Encoder
.
OpenAPI Metadata - Docs
To add metadata to your OpenAPI schema, including a license, version, contact, etc, read the docs for
Tutorial - Metadata and Docs URLs
.
OpenAPI Custom URL
To customize the OpenAPI URL (or remove it), read the docs for
Tutorial - Metadata and Docs URLs
.
OpenAPI Docs URLs
To update the URLs used for the automatically generated docs user interfaces, read the docs for
Tutorial - Metadata and Docs URLs
.

## 066_HOW_TO_GRAPHQL
GraphQL¶
---

GraphQL
As
FastAPI
is based on the
ASGI
standard, it's very easy to integrate any
GraphQL
library also compatible with ASGI.
You can combine normal FastAPI
path operations
with GraphQL on the same application.
Tip
GraphQL
solves some very specific use cases.
It has
advantages
and
disadvantages
when compared to common
web APIs
.
Make sure you evaluate if the
benefits
for your use case compensate the
drawbacks
. 🤓
GraphQL Libraries
Here are some of the
GraphQL
libraries that have
ASGI
support. You could use them with
FastAPI
:
Strawberry
🍓
With
docs for FastAPI
Ariadne
With
docs for FastAPI
Tartiflette
With
Tartiflette ASGI
to provide ASGI integration
Graphene
With
starlette-graphene3
GraphQL with Strawberry
If you need or want to work with
GraphQL
,
Strawberry
is the
recommended
library as it has the design closest to
FastAPI's
design, it's all based on
type annotations
.
Depending on your use case, you might prefer to use a different library, but if you asked me, I would probably suggest you try
Strawberry
.
Here's a small preview of how you could integrate Strawberry with FastAPI:
Python 3.8+
import
strawberry
from
fastapi
import
FastAPI
from
strawberry.fastapi
import
GraphQLRouter
@strawberry
.
type
class
User
:
name
:
str
age
:
int
@strawberry
.
type
class
Query
:
@strawberry
.
field
def
user
(
self
)
->
User
:
return
User
(
name
=
"Patrick"
,
age
=
100
)
schema
=
strawberry
.
Schema
(
query
=
Query
)
graphql_app
=
GraphQLRouter
(
schema
)
app
=
FastAPI
()
app
.
include_router
(
graphql_app
,
prefix
=
"/graphql"
)
You can learn more about Strawberry in the
Strawberry documentation
.
And also the docs about
Strawberry with FastAPI
.
Older
GraphQLApp
from Starlette
Previous versions of Starlette included a
GraphQLApp
class to integrate with
Graphene
.
It was deprecated from Starlette, but if you have code that used it, you can easily
migrate
to
starlette-graphene3
, that covers the same use case and has an
almost identical interface
.
Tip
If you need GraphQL, I still would recommend you check out
Strawberry
, as it's based on type annotations instead of custom classes and types.
Learn More
You can learn more about
GraphQL
in the
official GraphQL documentation
.
You can also read more about each those libraries described above in their links.

## 067_HOW_TO_SEPARATE_OPENAPI_SCHEMAS
Separate OpenAPI Schemas for Input and Output or Not¶
---

Separate OpenAPI Schemas for Input and Output or Not
When using
Pydantic v2
, the generated OpenAPI is a bit more exact and
correct
than before. 😎
In fact, in some cases, it will even have
two JSON Schemas
in OpenAPI for the same Pydantic model, for input and output, depending on if they have
default values
.
Let's see how that works and how to change it if you need to do that.
Pydantic Models for Input and Output
Let's say you have a Pydantic model with default values, like this one:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Optional
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Optional
[
str
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
List
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
Model for Input
If you use this model as an input like here:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Optional
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Optional
[
str
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
List
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
...then the
description
field will
not be required
. Because it has a default value of
None
.
Input Model in Docs
You can confirm that in the docs, the
description
field doesn't have a
red asterisk
, it's not marked as required:
Model for Output
But if you use the same model as an output, like here:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Optional
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Optional
[
str
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
List
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
...then because
description
has a default value, if you
don't return anything
for that field, it will still have that
default value
.
Model for Output Response Data
If you interact with the docs and check the response, even though the code didn't add anything in one of the
description
fields, the JSON response contains the default value (
null
):
This means that it will
always have a value
, it's just that sometimes the value could be
None
(or
null
in JSON).
That means that, clients using your API don't have to check if the value exists or not, they can
assume the field will always be there
, but just that in some cases it will have the default value of
None
.
The way to describe this in OpenAPI, is to mark that field as
required
, because it will always be there.
Because of that, the JSON Schema for a model can be different depending on if it's used for
input or output
:
for
input
the
description
will
not be required
for
output
it will be
required
(and possibly
None
, or in JSON terms,
null
)
Model for Output in Docs
You can check the output model in the docs too,
both
name
and
description
are marked as
required
with a
red asterisk
:
Model for Input and Output in Docs
And if you check all the available Schemas (JSON Schemas) in OpenAPI, you will see that there are two, one
Item-Input
and one
Item-Output
.
For
Item-Input
,
description
is
not required
, it doesn't have a red asterisk.
But for
Item-Output
,
description
is
required
, it has a red asterisk.
With this feature from
Pydantic v2
, your API documentation is more
precise
, and if you have autogenerated clients and SDKs, they will be more precise too, with a better
developer experience
and consistency. 🎉
Do not Separate Schemas
Now, there are some cases where you might want to have the
same schema for input and output
.
Probably the main use case for this is if you already have some autogenerated client code/SDKs and you don't want to update all the autogenerated client code/SDKs yet, you probably will want to do it at some point, but maybe not right now.
In that case, you can disable this feature in
FastAPI
, with the parameter
separate_input_output_schemas=False
.
Info
Support for
separate_input_output_schemas
was added in FastAPI
0.102.0
. 🤓
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
(
separate_input_output_schemas
=
False
)
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Optional
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Optional
[
str
]
=
None
app
=
FastAPI
(
separate_input_output_schemas
=
False
)
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
(
separate_input_output_schemas
=
False
)
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
List
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
Same Schema for Input and Output Models in Docs
And now there will be one single schema for input and output for the model, only
Item
, and it will have
description
as
not required
:
This is the same behavior as in Pydantic v1. 🤓

## 068_HOW_TO_TESTING_DATABASE
Testing a Database¶
---

Testing a Database
You can study about databases, SQL, and SQLModel in the
SQLModel docs
. 🤓
There's a mini
tutorial on using SQLModel with FastAPI
. ✨
That tutorial includes a section about
testing SQL databases
. 😎

## 069_HU
FastAPI
FastAPI keretrendszer, nagy teljesítmény, könnyen tanulható, gyorsan kódolható, productionre kész
Dokumentáció
:
https://fastapi.tiangolo.com
Forrás kód
:
https://github.com/fastapi/fastapi
A FastAPI egy modern, gyors (nagy teljesítményű), webes keretrendszer API-ok építéséhez Python -al, a Python szabványos típusjelöléseire építve.
Kulcs funkciók:
Gyors
: Nagyon nagy teljesítmény, a
NodeJS
-el és a
Go
-val egyenrangú (a Starlettenek és a Pydantic-nek köszönhetően).
Az egyik leggyorsabb Python keretrendszer
.
Gyorsan kódolható
: A funkciók fejlesztési sebességét 200-300 százalékkal megnöveli. *
Kevesebb hiba
: Körülbelül 40%-al csökkenti az emberi (fejlesztői) hibák számát. *
Intuitív
: Kiváló szerkesztő támogatás.
Kiegészítés
mindenhol. Kevesebb hibakereséssel töltött idő.
Egyszerű
: Egyszerű tanulásra és használatra tervezve. Kevesebb dokumentáció olvasással töltött idő.
Rövid
: Kód duplikáció minimalizálása. Több funkció minden paraméter deklarálásával. Kevesebb hiba.
Robosztus
: Production ready kód. Automatikus interaktív dokumentáció val.
Szabvány alapú
: Az API-ok nyílt szabványaira alapuló (és azokkal teljesen kompatibilis):
OpenAPI
(korábban Swagger néven ismert) és a
JSON Schema
.
* Egy production alkalmazásokat építő belső fejlesztői csapat tesztjein alapuló becslés.
Szponzorok
További szponzorok
Vélemények
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I’m over the moon excited about
FastAPI
. It’s so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
If anyone is looking to build a production Python API, I would highly recommend
FastAPI
. It is
beautifully designed
,
simple to use
and
highly scalable
, it has become a
key component
in our API first development strategy and is driving many automations and services such as our Virtual TAC Engineer.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, a CLI-ok FastAPI-ja
Ha egy olyan CLI alkalmazást fejlesztesz amit a parancssorban kell használni webes API helyett, tekintsd meg:
Typer
.
Typer
a FastAPI kistestvére. A
CLI-k FastAPI-ja
. ⌨️ 🚀
Követelmények
A FastAPI óriások vállán áll:
Starlette
a webes részekhez.
Pydantic
az adat részekhez.
Telepítés
fast →
pip install fastapi
restart ↻
A production-höz egy ASGI szerverre is szükség lesz, mint például az
Uvicorn
vagy a
Hypercorn
.
fast →
pip install "uvicorn[standard]"
restart ↻
Példa
Hozd létre
Hozz létre a
main.py
fájlt a következő tartalommal:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Vagy használd az
async def
-et...
Ha a kódod
async
/
await
-et, használ
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Megjegyzés
:
Ha nem tudod, tekintsd meg a
"Sietsz?"
szekciót
async
és
await
-ről dokumentációba
.
Futtasd le
Indítsd el a szervert a következő paranccsal:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
A parancsról
uvicorn main:app --reload
...
A
uvicorn main:app
parancs a következőre utal:
main
: fájl
main.py
(a Python "modul").
app
: a
main.py
-ban a
app = FastAPI()
sorral létrehozott objektum.
--reload
: kód változtatás esetén újra indítja a szervert. Csak fejlesztés közben használandó.
Ellenőrizd
Nyisd meg a böngésződ a következő címen:
http://127.0.0.1:8000/items/5?q=somequery
.
A következő JSON választ fogod látni:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Máris létrehoztál egy API-t ami:
HTTP kéréseket fogad a
/
és
/items/{item_id}
útvonalakon
.
Mindkét
útvonal
a
GET
műveletet
használja (másik elnevezés: HTTP
metódus
).
A
/items/{item_id}
útvonalnak
van egy
path paramétere
, az
item_id
, aminek
int
típusúnak kell lennie.
A
/items/{item_id}
útvonalnak
még van egy opcionális,
str
típusú
query paramétere
is, a
q
.
Interaktív API dokumentáció
Most nyisd meg a
http://127.0.0.1:8000/docs
címet.
Az automatikus interaktív API dokumentációt fogod látni (amit a
Swagger UI
-al hozunk létre):
Alternatív API dokumentáció
És most menj el a
http://127.0.0.1:8000/redoc
címre.
Az alternatív automatikus dokumentációt fogod látni. (lásd
ReDoc
):
Példa frissítése
Módosítsuk a
main.py
fájlt, hogy
PUT
kérések esetén tudjon body-t fogadni.
Deklaráld a body-t standard Python típusokkal, a Pydantic-nak köszönhetően.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
A szerver automatikusan újraindul (mert hozzáadtuk a --reload paramétert a fenti
uvicorn
parancshoz).
Interaktív API dokumentáció frissítése
Most menj el a
http://127.0.0.1:8000/docs
címre.
Az interaktív API dokumentáció automatikusan frissült így már benne van az új body.
Kattints rá a "Try it out" gombra, ennek segítségével kitöltheted a paramétereket és közvetlen használhatod az API-t:
Ezután kattints az "Execute" gompra, a felhasználói felület kommunikálni fog az API-oddal. Elküldi a paramétereket és a visszakapott választ megmutatja a képernyődön.
Alternatív API dokumentáció frissítés
Most menj el a
http://127.0.0.1:8000/redoc
címre.
Az alternatív dokumentáció szintúgy tükrözni fogja az új kérési paraméter és body-t.
Összefoglalás
Összegzésül, deklarálod
egyszer
a paraméterek, body, stb típusát funkciós paraméterekként.
Ezt standard modern Python típusokkal csinálod.
Nem kell új szintaxist, vagy specifikus könyvtár mert metódósait, stb. megtanulnod.
Csak standard
Python
.
Például egy
int
-nek:
item_id
:
int
Egy komplexebb
Item
modellnek:
item
:
Item
... És csupán egy deklarációval megkapod a:
Szerkesztő támogatást, beleértve:
Szövegkiegészítés.
Típus ellenőrzés.
Adatok validációja:
Automatikus és érthető hibák amikor az adatok hibásak.
Validáció mélyen ágyazott objektumok esetén is.
Bemeneti adatok
átváltása
: a hálózatról érkező Python adatokká és típusokká. Adatok olvasása következő forrásokból:
JSON.
Cím paraméterek.
Query paraméterek.
Cookie-k.
Header-ök.
Formok.
Fájlok.
Kimeneti adatok
átváltása
: Python adatok is típusokról hálózati adatokká:
válts át Python típusokat (
str
,
int
,
float
,
bool
,
list
, etc).
datetime
csak objektumokat.
UUID
objektumokat.
Adatbázis modelleket.
...És sok mást.
Automatikus interaktív dokumentáció, beleértve két alternatív dokumentációt is:
Swagger UI.
ReDoc.
Visszatérve az előző kód példához. A
FastAPI
:
Validálja hogy van egy
item_id
mező a
GET
és
PUT
kérésekben.
Validálja hogy az
item_id
int
típusú a
GET
és
PUT
kérésekben.
Ha nem akkor látni fogunk egy tiszta hibát ezzel kapcsolatban.
ellenőrzi hogyha van egy opcionális query paraméter
q
névvel (azaz
http://127.0.0.1:8000/items/foo?q=somequery
)
GET
kérések esetén.
Mivel a
q
paraméter
= None
-al van deklarálva, ezért opcionális.
None
nélkül ez a mező kötelező lenne (mint például a body
PUT
kérések esetén).
a
/items/{item_id}
címre érkező
PUT
kérések esetén, a JSON-t a következőképpen olvassa be:
Ellenőrzi hogy létezik a kötelező
name
nevű attribútum és
string
.
Ellenőrzi hogy létezik a kötelező
price
nevű attribútum és
float
.
Ellenőrzi hogy létezik a
is_offer
nevű opcionális paraméter, ami ha létezik akkor
bool
Ez ágyazott JSON objektumokkal is működik
JSONről való automatikus konvertálás.
dokumentáljuk mindent OpenAPI-al amit használható:
Interaktív dokumentációs rendszerekkel.
Automatikus kliens kód generáló a rendszerekkel, több nyelven.
Hozzá tartozik kettő interaktív dokumentációs web felület.
Eddig csak a felszínt kapargattuk, de a lényeg hogy most már könnyebben érthető hogyan működik.
Próbáld kicserélni a következő sorban:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...ezt:
...
"item_name"
:
item
.
name
...
...erre:
...
"item_price"
:
item
.
price
...
... És figyeld meg hogy a szerkesztő automatikusan tudni fogja a típusokat és kiegészíti azokat:
Teljesebb példákért és funkciókért tekintsd meg a
Tutorial - User Guide
-t.
Spoiler veszély
: a Tutorial - User Guidehoz tartozik:
Paraméterek
deklarációja különböző helyekről:
header-ök
,
cookie-k
,
form mezők
és
fájlok
.
Hogyan állíts be
validációs feltételeket
mint a
maximum_length
vagy a
regex
.
Nagyon hatékony és erős
Függőség Injekció
rendszerek.
Biztonság és autentikáció beleértve,
OAuth2
,
JWT tokens
és
HTTP Basic
támogatást.
Több haladó (de ugyanannyira könnyű) technika
mélyen ágyazott JSON modellek deklarációjára
(Pydantic-nek köszönhetően).
GraphQL
integráció
Strawberry
-vel és más könyvtárakkal.
több extra funkció (Starlette-nek köszönhetően) pl.:
WebSockets
rendkívül könnyű tesztek HTTPX és
pytest
alapokra építve
CORS
Cookie Sessions
...és több.
Teljesítmény
A független TechEmpower benchmarkok szerint az Uvicorn alatt futó
FastAPI
alkalmazások az
egyik leggyorsabb Python keretrendszerek közé tartoznak
, éppen lemaradva a Starlette és az Uvicorn (melyeket a FastAPI belsőleg használ) mögött.(*)
Ezeknek a további megértéséhez:
Benchmarks
.
Opcionális követelmények
Pydantic által használt:
email-validator
- e-mail validációkra.
pydantic-settings
- Beállítások követésére.
pydantic-extra-types
- Extra típusok Pydantic-hoz.
Starlette által használt:
httpx
- Követelmény ha a
TestClient
-et akarod használni.
jinja2
- Követelmény ha az alap template konfigurációt akarod használni.
python-multipart
- Követelmény ha
"parsing"
-ot akarsz támogatni,
request.form()
-al.
itsdangerous
- Követelmény
SessionMiddleware
támogatáshoz.
pyyaml
- Követelmény a Starlette
SchemaGenerator
-ának támogatásához (valószínűleg erre nincs szükség FastAPI használása esetén).
FastAPI / Starlette által használt
uvicorn
- Szerverekhez amíg betöltik és szolgáltatják az applikációdat.
orjson
- Követelmény ha
ORJSONResponse
-t akarsz használni.
ujson
- Követelmény ha
UJSONResponse
-t akarsz használni.
Ezeket mind telepítheted a
pip install "fastapi[all]"
paranccsal.
Licensz
Ez a projekt az MIT license, licensz alatt fut

## 070_ID
FastAPI¶
---

FastAPI
FastAPI, framework performa tinggi, mudah dipelajari, cepat untuk coding, siap untuk pengembangan
Dokumentasi
:
https://fastapi.tiangolo.com
Kode Sumber
:
https://github.com/fastapi/fastapi
FastAPI adalah
framework
web
moderen, cepat (performa-tinggi) untuk membangun API dengan Python berdasarkan tipe petunjuk Python.
Fitur utama FastAPI:
Cepat
: Performa sangat tinggi, setara
NodeJS
dan
Go
(berkat Starlette dan Pydantic).
Salah satu
framework
Python tercepat yang ada
.
Cepat untuk coding
: Meningkatkan kecepatan pengembangan fitur dari 200% sampai 300%. *
Sedikit bug
: Mengurangi hingga 40% kesalahan dari manusia (pemrogram). *
Intuitif
: Dukungan editor hebat.
Penyelesaian
di mana pun. Lebih sedikit
debugging
.
Mudah
: Dibuat mudah digunakan dan dipelajari. Sedikit waktu membaca dokumentasi.
Ringkas
: Mengurasi duplikasi kode. Beragam fitur dari setiap deklarasi parameter. Lebih sedikit
bug
.
Handal
: Dapatkan kode siap-digunakan. Dengan dokumentasi otomatis interaktif.
Standar-resmi
: Berdasarkan (kompatibel dengan ) standar umum untuk API:
OpenAPI
(sebelumnya disebut Swagger) dan
JSON Schema
.
* estimasi berdasarkan pengujian tim internal pengembangan applikasi siap pakai.
Sponsor
Sponsor lainnya
Opini
"
[...] Saya banyak menggunakan
FastAPI
sekarang ini. [...] Saya berencana menggunakannya di semua tim servis ML Microsoft. Beberapa dari mereka sudah mengintegrasikan dengan produk inti
Windows
* dan sebagian produk
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
Kami adopsi library
FastAPI
untuk membuat server
REST
yang melakukan kueri untuk menghasilkan
prediksi
. [untuk Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
dengan bangga mengumumkan rilis open-source orkestrasi framework
manajemen krisis
:
Dispatch
! [dibuat dengan
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Saya sangat senang dengan
FastAPI
. Sangat menyenangkan!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Jujur, apa yang anda buat sangat solid dan berkualitas. Ini adalah yang saya inginkan di
Hug
- sangat menginspirasi melihat seseorang membuat ini.
"
Timothy Crosley -
Hug
creator
(ref)
"
Jika anda ingin mempelajari
framework moderen
untuk membangun REST API, coba
FastAPI
[...] cepat, mudah digunakan dan dipelajari [...]
"
"
Kami sudah pindah ke
FastAPI
untuk
API
kami [...] Saya pikir kamu juga akan suka [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
Jika anda ingin membuat API Python siap pakai, saya merekomendasikan
FastAPI
. FastAPI
didesain indah
,
mudah digunakan
dan
sangat scalable
, FastAPI adalah
komponen kunci
di strategi pengembangan API pertama kami dan mengatur banyak otomatisasi dan service seperti TAC Engineer kami.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, CLI FastAPI
Jika anda mengembangkan app
CLI
yang digunakan di terminal bukan sebagai API web, kunjungi
Typer
.
Typer
adalah saudara kecil FastAPI. Dan ditujukan sebagai
CLI FastAPI
. ⌨️ 🚀
Prayarat
FastAPI berdiri di pundak raksasa:
Starlette
untuk bagian web.
Pydantic
untuk bagian data.
Instalasi
Buat dan aktifkan
virtual environment
kemudian
install
FastAPI:
fast →
pip install "fastapi[standard]"
restart ↻
Catatan
: Pastikan anda menulis
"fastapi[standard]"
dengan tanda petik untuk memastikan bisa digunakan di semua
terminal
.
Contoh
Buat app
Buat file
main.py
dengan:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Atau gunakan
async def
...
Jika kode anda menggunakan
async
/
await
, gunakan
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Catatan
:
Jika anda tidak paham, kunjungi
"Panduan cepat"
bagian
async
dan
await
di dokumentasi
.
Jalankan
Jalankan
server
dengan:
fast →
fastapi dev main.py
╭────────── FastAPI CLI - Development mode ───────────╮
│ │
│ Serving at: http://127.0.0.1:8000 │
│ │
│ API docs: http://127.0.0.1:8000/docs │
│ │
│ Running in development mode, for production use: │
│ │
│ fastapi run │
│ │
╰─────────────────────────────────────────────────────╯
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
Mengenai perintah
fastapi dev main.py
...
Perintah
fastapi dev
membaca file
main.py
, memeriksa app
FastAPI
di dalamnya, dan menjalan server dengan
Uvicorn
.
Secara otomatis,
fastapi dev
akan mengaktifkan
auto-reload
untuk pengembangan lokal.
Informasi lebih lanjut kunjungi
Dokumen FastAPI CLI
.
Periksa
Buka
browser
di
http://127.0.0.1:8000/items/5?q=somequery
.
Anda akan melihat respon JSON berikut:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Anda telah membuat API:
Menerima permintaan HTTP di
path
/
dan
/items/{item_id}
.
Kedua
paths
menerima
operasi
GET
(juga disebut
metode
HTTP).
path
/items/{item_id}
memiliki
parameter path
item_id
yang harus berjenis
int
.
path
/items/{item_id}
memiliki
query parameter
q
berjenis
str
.
Dokumentasi API interaktif
Sekarang kunjungi
http://127.0.0.1:8000/docs
.
Anda akan melihat dokumentasi API interaktif otomatis (dibuat oleh
Swagger UI
):
Dokumentasi API alternatif
Kemudian kunjungi
http://127.0.0.1:8000/redoc
.
Anda akan melihat dokumentasi alternatif otomatis (dibuat oleh
ReDoc
):
Contoh upgrade
Sekarang ubah
main.py
untuk menerima struktur permintaan
PUT
.
Deklarasikan struktur menggunakan tipe standar Python, berkat Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Server
fastapi dev
akan otomatis memuat kembali.
Upgrade dokumentasi API interaktif
Kunjungi
http://127.0.0.1:8000/docs
.
Dokumentasi API interaktif akan otomatis diperbarui, termasuk kode yang baru:
Klik tombol "Try it out", anda dapat mengisi parameter dan langsung berinteraksi dengan API:
Kemudian klik tombol "Execute", tampilan pengguna akan berkomunikasi dengan API, mengirim parameter, mendapatkan dan menampilkan hasil ke layar:
Upgrade dokumentasi API alternatif
Kunjungi
http://127.0.0.1:8000/redoc
.
Dokumentasi alternatif akan menampilkan parameter
query
dan struktur
request
:
Ringkasan
Singkatnya, anda mendeklarasikan
sekali
jenis parameter, struktur, dll. sebagai parameter fungsi.
Anda melakukannya dengan tipe standar moderen Python.
Anda tidak perlu belajar sintaksis, metode,
classs
baru dari
library
tertentu, dll.
Cukup
Python
standar.
Sebagai contoh untuk
int
:
item_id
:
int
atau untuk model lebih rumit
Item
:
item
:
Item
...dengan sekali deklarasi anda mendapatkan:
Dukungan editor, termasuk:
Pelengkapan kode.
Pengecekan tipe.
Validasi data:
Kesalahan otomatis dan jelas ketika data tidak sesuai.
Validasi hingga untuk object JSON bercabang mendalam.
Konversi
input data: berasal dari jaringan ke data dan tipe Python. Membaca dari:
JSON.
Parameter path.
Parameter query.
Cookie.
Header.
Form.
File.
Konversi
output data: konversi data Python ke tipe jaringan data (seperti JSON):
Konversi tipe Python (
str
,
int
,
float
,
bool
,
list
, dll).
Objek
datetime
.
Objek
UUID
.
Model database.
...dan banyak lagi.
Dokumentasi interaktif otomatis, termasuk 2 alternatif tampilan pengguna:
Swagger UI.
ReDoc.
Kembali ke kode contoh sebelumnya,
FastAPI
akan:
Validasi apakah terdapat
item_id
di
path
untuk permintaan
GET
dan
PUT
requests.
Validasi apakah
item_id
berjenit
int
untuk permintaan
GET
dan
PUT
.
Jika tidak, klien akan melihat pesan kesalahan jelas.
Periksa jika ada parameter
query
opsional bernama
q
(seperti
http://127.0.0.1:8000/items/foo?q=somequery
) untuk permintaan
GET
.
Karena parameter
q
dideklarasikan dengan
= None
, maka bersifat opsional.
Tanpa
None
maka akan menjadi wajib ada (seperti struktur di kondisi dengan
PUT
).
Untuk permintaan
PUT
/items/{item_id}
, membaca struktur sebagai JSON:
Memeriksa terdapat atribut wajib
name
harus berjenis
str
.
Memeriksa terdapat atribut wajib
price
harus berjenis
float
.
Memeriksa atribut opsional
is_offer
, harus berjenis
bool
, jika ada.
Semua ini juga sama untuk objek json yang bersarang mendalam.
Konversi dari dan ke JSON secara otomatis.
Dokumentasi segalanya dengan OpenAPI, dengan menggunakan:
Sistem dokumentasi interaktif.
Sistem otomatis penghasil kode, untuk banyak bahasa.
Menyediakan 2 tampilan dokumentasi web interaktif dengan langsung.
Kita baru menyentuh permukaannya saja, tetapi anda sudah mulai paham gambaran besar cara kerjanya.
Coba ubah baris:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...dari:
...
"item_name"
:
item
.
name
...
...menjadi:
...
"item_price"
:
item
.
price
...
...anda akan melihat kode editor secara otomatis melengkapi atributnya dan tahu tipe nya:
Untuk contoh lengkap termasuk fitur lainnya, kunjungi
Tutorial - Panduan Pengguna
.
Peringatan spoiler
: tutorial - panduan pengguna termasuk:
Deklarasi
parameter
dari tempat berbeda seperti:
header
,
cookie
,
form field
and
file
.
Bagaimana mengatur
batasan validasi
seperti
maximum_length
atau
regex
.
Sistem
Dependency Injection
yang hebat dan mudah digunakan.
Keamanan dan autentikasi, termasuk dukungan ke
OAuth2
dengan
JWT token
dan autentikasi
HTTP Basic
.
Teknik lebih aju (tetapi mudah dipakai untuk deklarasi
model JSON bersarang ke dalam
(berkat Pydantic).
Integrasi
GraphQL
dengan
Strawberry
dan library lainnya.
Fitur lainnya (berkat Starlette) seperti:
WebSocket
Test yang sangat mudah berdasarkan HTTPX dan
pytest
CORS
Cookie Session
...dan lainnya.
Performa
Tolok ukur Independent TechEmpower mendapati aplikasi
FastAPI
berjalan menggunakan Uvicorn sebagai
salah satu framework Python tercepat yang ada
, hanya di bawah Starlette dan Uvicorn itu sendiri (digunakan di internal FastAPI). (*)
Penjelasan lebih lanjut, lihat bagian
Tolok ukur
.
Dependensi
FastAPI bergantung pada Pydantic dan Starlette.
Dependensi
standar
Ketika anda meng-
install
FastAPI dengan
pip install "fastapi[standard]"
, maka FastAPI akan menggunakan sekumpulan dependensi opsional
standar
:
Digunakan oleh Pydantic:
email-validator
- untuk validasi email.
Digunakan oleh Starlette:
httpx
- Dibutuhkan jika anda menggunakan
TestClient
.
jinja2
- Dibutuhkan jika anda menggunakan konfigurasi template bawaan.
python-multipart
- Dibutuhkan jika anda menggunakan form dukungan
"parsing"
, dengan
request.form()
.
Digunakan oleh FastAPI / Starlette:
uvicorn
- untuk server yang memuat dan melayani aplikasi anda. Termasuk
uvicorn[standard]
, yang memasukan sejumlah dependensi (misal
uvloop
) untuk needed melayani dengan performa tinggi.
fastapi-cli
- untuk menyediakan perintah
fastapi
.
Tanpda dependensi
standard
Jika anda tidak ingin menambahkan dependensi opsional
standard
, anda dapat menggunakan
pip install fastapi
daripada
pip install "fastapi[standard]"
.
Dependensi Opsional Tambahan
Ada beberapa dependensi opsional yang bisa anda install.
Dependensi opsional tambahan Pydantic:
pydantic-settings
- untuk manajemen setting.
pydantic-extra-types
- untuk tipe tambahan yang digunakan dengan Pydantic.
Dependensi tambahan opsional FastAPI:
orjson
- Diperlukan jika anda akan menggunakan
ORJSONResponse
.
ujson
- Diperlukan jika anda akan menggunakan
UJSONResponse
.
Lisensi
Project terlisensi dengan lisensi MIT.

## 071_IT
FastAPI
FastAPI framework, alte prestazioni, facile da imparare, rapido da implementare, pronto per il rilascio in produzione
Documentazione
:
https://fastapi.tiangolo.com
Codice Sorgente
:
https://github.com/fastapi/fastapi
FastAPI è un web framework moderno e veloce (a prestazioni elevate) che serve a creare API con Python 3.6+ basato sulle annotazioni di tipo di Python.
Le sue caratteristiche principali sono:
Velocità
: Prestazioni molto elevate, alla pari di
NodeJS
e
Go
(grazie a Starlette e Pydantic).
Uno dei framework Python più veloci in circolazione
.
Veloce da programmare
: Velocizza il lavoro consentendo il rilascio di nuove funzionalità tra il 200% e il 300% più rapidamente. *
Meno bug
: Riduce di circa il 40% gli errori che commettono gli sviluppatori durante la scrittura del codice. *
Intuitivo
: Grande supporto per gli editor di testo con
autocompletamento
in ogni dove. In questo modo si può dedicare meno tempo al debugging.
Facile
: Progettato per essere facile da usare e imparare. Si riduce il tempo da dedicare alla lettura della documentazione.
Sintentico
: Minimizza la duplicazione di codice. Molteplici funzionalità, ognuna con la propria dichiarazione dei parametri. Meno errori.
Robusto
: Crea codice pronto per la produzione con documentazione automatica interattiva.
Basato sugli standard
: Basato su (e completamente compatibile con) gli open standard per le API:
OpenAPI
(precedentemente Swagger) e
JSON Schema
.
* Stima basata sull'esito di test eseguiti su codice sorgente di applicazioni rilasciate in produzione da un team interno di sviluppatori.
Sponsor
Altri sponsor
Recensioni
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, e Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I’m over the moon excited about
FastAPI
. It’s so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, la FastAPI delle CLI
Se stai sviluppando un'app
CLI
da usare nel terminale invece che una web API, ti consigliamo
Typer
.
Typer
è il fratello minore di FastAPI. Ed è stato ideato per essere la
FastAPI delle CLI
. ⌨️ 🚀
Requisiti
Python 3.6+
FastAPI è basata su importanti librerie:
Starlette
per le parti web.
Pydantic
per le parti dei dati.
Installazione
fast →
pip install fastapi
restart ↻
Per il rilascio in produzione, sarà necessario un server ASGI come
Uvicorn
oppure
Hypercorn
.
fast →
pip install uvicorn[standard]
restart ↻
Esempio
Crea un file
Crea un file
main.py
con:
from
fastapi
import
FastAPI
from
typing
import
Optional
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
str
=
Optional
[
None
]):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Oppure usa
async def
...
Se il tuo codice usa
async
/
await
, allora usa
async def
:
from
fastapi
import
FastAPI
from
typing
import
Optional
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Optional
[
str
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Nota
:
e vuoi approfondire, consulta la sezione
"In a hurry?"
su
async
e
await
nella documentazione
.
Esegui il server
Puoi far partire il server così:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
Informazioni sul comando
uvicorn main:app --reload
...
Vediamo il comando
uvicorn main:app
in dettaglio:
main
: il file
main.py
(il "modulo" Python).
app
: l'oggetto creato dentro
main.py
con la riga di codice
app = FastAPI()
.
--reload
: ricarica il server se vengono rilevati cambiamenti del codice. Usalo solo durante la fase di sviluppo.
Testa l'API
Apri il browser all'indirizzo
http://127.0.0.1:8000/items/5?q=somequery
.
Vedrai la seguente risposta JSON:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Hai appena creato un'API che:
Riceve richieste HTTP sui
paths
/
and
/items/{item_id}
.
Entrambi i
paths
accettano
GET
operations
(conosciuti anche come
HTTP
methods
).
Il
path
/items/{item_id}
ha un
path parameter
item_id
che deve essere un
int
.
Il
path
/items/{item_id}
ha una
str
query parameter
q
.
Documentazione interattiva dell'API
Adesso vai all'indirizzo
http://127.0.0.1:8000/docs
.
Vedrai la documentazione interattiva dell'API (offerta da
Swagger UI
):
Documentazione interattiva alternativa
Adesso accedi all'url
http://127.0.0.1:8000/redoc
.
Vedrai la documentazione interattiva dell'API (offerta da
ReDoc
):
Esempio più avanzato
Adesso modifica il file
main.py
per ricevere un
body
da una richiesta
PUT
.
Dichiara il
body
usando le annotazioni di tipo standard di Python, grazie a Pydantic.
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
from
typing
import
Optional
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
bool
=
Optional
[
None
]
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Optional
[
str
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Il server dovrebbe ricaricarsi in automatico (perché hai specificato
--reload
al comando
uvicorn
lanciato precedentemente).
Aggiornamento della documentazione interattiva
Adesso vai su
http://127.0.0.1:8000/docs
.
La documentazione interattiva dell'API verrà automaticamente aggiornata, includendo il nuovo
body
:
Fai click sul pulsante "Try it out", che ti permette di inserire i parametri per interagire direttamente con l'API:
Successivamente, premi sul pulsante "Execute". L'interfaccia utente comunicherà con la tua API, invierà i parametri, riceverà i risultati della richiesta, e li mostrerà sullo schermo:
Aggiornamento della documentazione alternativa
Ora vai su
http://127.0.0.1:8000/redoc
.
Anche la documentazione alternativa dell'API mostrerà il nuovo parametro della query e il
body
:
Riepilogo
Ricapitolando, è sufficiente dichiarare
una sola volta
i tipi dei parametri, del body, ecc. come parametri di funzioni.
Questo con le annotazioni per i tipi standard di Python.
Non c'è bisogno di imparare una nuova sintassi, metodi o classi specifici a una libreria, ecc.
È normalissimo
Python 3.6+
.
Per esempio, per un
int
:
item_id
:
int
o per un modello
Item
più complesso:
item
:
Item
...e con quella singola dichiarazione hai in cambio:
Supporto per gli editor di testo, incluso:
Autocompletamento.
Controllo sulle annotazioni di tipo.
Validazione dei dati:
Errori chiari e automatici quando i dati sono invalidi.
Validazione anche per gli oggetti JSON più complessi.
Conversione
dei dati di input: da risorse esterne a dati e tipi di Python. È possibile leggere da:
JSON.
Path parameters.
Query parameters.
Cookies.
Headers.
Form.
File.
Conversione
dei dati di output: converte dati e tipi di Python a dati per la rete (come JSON):
Converte i tipi di Python (
str
,
int
,
float
,
bool
,
list
, ecc).
Oggetti
datetime
.
Oggetti
UUID
.
Modelli del database.
...e molto di più.
Generazione di una documentazione dell'API interattiva, con scelta dell'interfaccia grafica:
Swagger UI.
ReDoc.
Tornando al precedente esempio,
FastAPI
:
Validerà che esiste un
item_id
nel percorso delle richieste
GET
e
PUT
.
Validerà che
item_id
sia di tipo
int
per le richieste
GET
e
PUT
.
Se non lo è, il client vedrà un errore chiaro e utile.
Controllerà se ci sia un parametro opzionale chiamato
q
(per esempio
http://127.0.0.1:8000/items/foo?q=somequery
) per le richieste
GET
.
Siccome il parametro
q
è dichiarato con
= None
, è opzionale.
Senza il
None
sarebbe stato obbligatorio (come per il body della richiesta
PUT
).
Per le richieste
PUT
su
/items/{item_id}
, leggerà il body come JSON, questo comprende:
verifica che la richiesta abbia un attributo obbligatorio
name
e che sia di tipo
str
.
verifica che la richiesta abbia un attributo obbligatorio
price
e che sia di tipo
float
.
verifica che la richiesta abbia un attributo opzionale
is_offer
e che sia di tipo
bool
, se presente.
Tutto questo funzionerebbe anche con oggetti JSON più complessi.
Convertirà
da
e
a
JSON automaticamente.
Documenterà tutto con OpenAPI, che può essere usato per:
Sistemi di documentazione interattivi.
Sistemi di generazione di codice dal lato client, per molti linguaggi.
Fornirà 2 interfacce di documentazione dell'API interattive.
Questa è solo la punta dell'iceberg, ma dovresti avere già un'idea di come il tutto funzioni.
Prova a cambiare questa riga di codice:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...da:
...
"item_name"
:
item
.
name
...
...a:
...
"item_price"
:
item
.
price
...
...e osserva come il tuo editor di testo autocompleterà gli attributi e sarà in grado di riconoscere i loro tipi:
Per un esempio più completo che mostra più funzionalità del framework, consulta
Tutorial - Guida Utente
.
Spoiler alert
: il tutorial - Guida Utente include:
Dichiarazione di
parameters
da altri posti diversi come:
headers
,
cookies
,
form fields
e
files
.
Come stabilire
vincoli di validazione
come
maximum_length
o
regex
.
Un sistema di
Dependency Injection
facile da usare e molto potente.
e potente.
Sicurezza e autenticazione, incluso il supporto per
OAuth2
con
token JWT
e autenticazione
HTTP Basic
.
Tecniche più avanzate (ma ugualmente semplici) per dichiarare
modelli JSON altamente nidificati
(grazie a Pydantic).
E altre funzionalità (grazie a Starlette) come:
WebSockets
GraphQL
test molto facili basati su
requests
e
pytest
CORS
Cookie Sessions
...e altro ancora.
Prestazioni
Benchmark indipendenti di TechEmpower mostrano che
FastAPI
basato su Uvicorn è
uno dei framework Python più veloci in circolazione
, solamente dietro a Starlette e Uvicorn (usate internamente da FastAPI). (*)
Per approfondire, consulta la sezione
Benchmarks
.
Dipendenze opzionali
Usate da Pydantic:
email-validator
- per la validazione di email.
Usate da Starlette:
requests
- Richiesto se vuoi usare il
TestClient
.
aiofiles
- Richiesto se vuoi usare
FileResponse
o
StaticFiles
.
jinja2
- Richiesto se vuoi usare la configurazione template di default.
python-multipart
- Richiesto se vuoi supportare il
"parsing"
con
request.form()
.
itsdangerous
- Richiesto per usare
SessionMiddleware
.
pyyaml
- Richiesto per il supporto dello
SchemaGenerator
di Starlette (probabilmente non ti serve con FastAPI).
graphene
- Richiesto per il supporto di
GraphQLApp
.
Usate da FastAPI / Starlette:
uvicorn
- per il server che carica e serve la tua applicazione.
orjson
- ichiesto se vuoi usare
ORJSONResponse
.
ujson
- Richiesto se vuoi usare
UJSONResponse
.
Puoi installarle tutte con
pip install fastapi[all]
.
Licenza
Questo progetto è concesso in licenza in base ai termini della licenza MIT.

## 072_JA
FastAPI¶
---

FastAPI
FastAPI framework, high performance, easy to learn, fast to code, ready for production
ドキュメント
:
https://fastapi.tiangolo.com
ソースコード
:
https://github.com/fastapi/fastapi
FastAPI は、Pythonの標準である型ヒントに基づいてPython 以降でAPI を構築するための、モダンで、高速(高パフォーマンス)な、Web フレームワークです。
主な特徴:
高速
:
NodeJS
や
Go
並みのとても高いパフォーマンス (Starlette と Pydantic のおかげです)。
最も高速な Python フレームワークの一つです
.
高速なコーディング
: 開発速度を約 200%~300%向上させます。 *
少ないバグ
: 開発者起因のヒューマンエラーを約 40％削減します。 *
直感的
: 素晴らしいエディタのサポートや
オートコンプリート。
デバッグ時間を削減します。
簡単
: 簡単に利用、習得できるようにデザインされています。ドキュメントを読む時間を削減します。
短い
: コードの重複を最小限にしています。各パラメータからの複数の機能。少ないバグ。
堅牢性
: 自動対話ドキュメントを使用して、本番環境で使用できるコードを取得します。
Standards-based
: API のオープンスタンダードに基づいており、完全に互換性があります:
OpenAPI
(以前は Swagger として知られていました) や
JSON スキーマ
.
* 本番アプリケーションを構築している開発チームのテストによる見積もり。
Sponsors
Other sponsors
評価
"
[...] 最近
FastAPI
を使っています。 [...] 実際に私のチームの全ての
Microsoft の機械学習サービス
で使用する予定です。 そのうちのいくつかのコアな
Windows
製品と
Office
製品に統合されつつあります。
"
Kabir Khan -
Microsoft
(ref)
"
FastAPIライブラリを採用し、クエリで
予測値
を取得できる
REST
サーバを構築しました。 [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
は、
危機管理
オーケストレーションフレームワーク、
Dispatch
のオープンソースリリースを発表できることをうれしく思います。 [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
私は
FastAPI
にワクワクしています。 めちゃくちゃ楽しいです！
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
正直、超堅実で洗練されているように見えます。いろんな意味で、それは私がハグしたかったものです。
"
Timothy Crosley -
Hug
creator
(ref)
"
REST API を構築するための
モダンなフレームワーク
を学びたい方は、
FastAPI
[...] をチェックしてみてください。 [...] 高速で, 使用、習得が簡単です。[...]
"
"
私たちの
API
は
FastAPI
に切り替えました。[...] きっと気に入ると思います。 [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, the FastAPI of CLIs
もし Web API の代わりにターミナルで使用する
CLI
アプリを構築する場合は、
Typer
を確認してください。
Typer
は FastAPI の弟分です。そして、
CLI 版 の FastAPI
を意味しています。
必要条件
FastAPI は巨人の肩の上に立っています。
Web の部分は
Starlette
データの部分は
Pydantic
インストール
fast →
pip install fastapi
restart ↻
本番環境では、
Uvicorn
または、
Hypercorn
のような、 ASGI サーバーが必要になります。
fast →
pip install "uvicorn[standard]"
restart ↻
アプリケーション例
アプリケーションの作成
main.py
を作成し、以下のコードを入力します:
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
str
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
または
async def
を使います...
async
/
await
を使用するときは、
async def
を使います:
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
str
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
注
:
わからない場合は、
ドキュメントの
async
と
await
にある
"In a hurry?"セクションをチェックしてください。
実行
以下のコマンドでサーバーを起動します:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
uvicorn main:app --reload
コマンドについて
uvicorn main:app
コマンドは以下の項目を参照します:
main
:
main.py
ファイル (Python "モジュール")
app
:
main.py
の
app = FastAPI()
の行で生成されたオブジェクト
--reload
: コードを変更したらサーバーを再起動します。このオプションは開発環境でのみ使用します
動作確認
ブラウザから
http://127.0.0.1:8000/items/5?q=somequery
を開きます。
以下の JSON のレスポンスが確認できます:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
もうすでに以下の API が作成されています:
/
と
/items/{item_id}
のパスで HTTP リクエストを受けます。
どちらのパスも
GET
操作
を取ります。(HTTP メソッドとしても知られています。)
/items/{item_id}
パスのパスパラメータ
item_id
は
int
でなければなりません。
パス
/items/{item_id}
はオプションの
str
クエリパラメータ
q
を持ちます。
自動対話型の API ドキュメント
http://127.0.0.1:8000/docs
にアクセスしてみてください。
自動対話型の API ドキュメントが表示されます。 (
Swagger UI
が提供しています。):
代替の API ドキュメント
http://127.0.0.1:8000/redoc
にアクセスしてみてください。
代替の自動ドキュメントが表示されます。(
ReDoc
が提供しています。):
アップグレード例
PUT
リクエストからボディを受け取るために
main.py
を修正しましょう。
Pydantic によって、Python の標準的な型を使ってボディを宣言します。
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
bool
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
str
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
サーバーは自動でリロードされます。(上述の
uvicorn
コマンドで
--reload
オプションを追加しているからです。)
自動対話型の API ドキュメントのアップグレード
http://127.0.0.1:8000/docs
にアクセスしましょう。
自動対話型の API ドキュメントが新しいボディも含めて自動でアップデートされます:
"Try it out"ボタンをクリックしてください。パラメータを入力して API と直接やりとりすることができます:
それから、"Execute" ボタンをクリックしてください。 ユーザーインターフェースは API と通信し、パラメータを送信し、結果を取得して画面に表示します:
代替の API ドキュメントのアップグレード
http://127.0.0.1:8000/redoc
にアクセスしましょう。
代替の API ドキュメントにも新しいクエリパラメータやボディが反映されます。
まとめ
要約すると、関数のパラメータとして、パラメータやボディ などの型を
一度だけ
宣言します。
標準的な最新の Python の型を使っています。
新しい構文や特定のライブラリのメソッドやクラスなどを覚える必要はありません。
単なる標準的な
3.8 以降の Python
です。
例えば、
int
の場合:
item_id
:
int
または、より複雑な
Item
モデルの場合:
item
:
Item
...そして、この一度の宣言で、以下のようになります:
以下を含むエディタサポート:
補完
タイプチェック
データの検証:
データが無効な場合に自動でエラーをクリアします。
深い入れ子になった JSON オブジェクトでも検証が可能です。
入力データの
変換
: ネットワークから Python のデータや型に変換してから読み取ります:
JSON.
パスパラメータ
クエリパラメータ
クッキー
ヘッダー
フォーム
ファイル
出力データの
変換
: Python のデータや型からネットワークデータへ変換します (JSON として):
Convert Python types (
str
,
int
,
float
,
bool
,
list
, etc).
datetime
オブジェクト
UUID
オブジェクト
データベースモデル
...などなど
2 つの代替ユーザーインターフェースを含む自動インタラクティブ API ドキュメント:
Swagger UI.
ReDoc.
コード例に戻りましょう、
FastAPI
は次のようになります:
GET
および
PUT
リクエストのパスに
item_id
があることを検証します。
item_id
が
GET
および
PUT
リクエストに対して
int
型であることを検証します。
そうでない場合は、クライアントは有用で明確なエラーが表示されます。
GET
リクエストに対してオプションのクエリパラメータ
q
(
http://127.0.0.1:8000/items/foo?q=somequery
のように) が存在するかどうかを調べます。
パラメータ
q
は
= None
で宣言されているので、オプションです。
None
がなければ必須になります（
PUT
の場合のボディと同様です）。
PUT
リクエストを
/items/{item_id}
に送信する場合は、ボディを JSON として読み込みます:
必須の属性
name
を確認してください。 それは
str
であるべきです。
必須の属性
price
を確認してください。それは
float
でなければならないです。
オプションの属性
is_offer
を確認してください。値がある場合は、
bool
であるべきです。
これらはすべて、深くネストされた JSON オブジェクトに対しても動作します。
JSON から JSON に自動的に変換します。
OpenAPIですべてを文書化し、以下を使用することができます:
対話的なドキュメントシステム。
多くの言語に対応した自動クライアントコード生成システム。
2 つの対話的なドキュメントのWebインターフェイスを直接提供します。
まだ表面的な部分に触れただけですが、もう全ての仕組みは分かっているはずです。
以下の行を変更してみてください:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...以下を:
...
"item_name"
:
item
.
name
...
...以下のように:
...
"item_price"
:
item
.
price
...
...そして、エディタが属性を自動補完し、そのタイプを知る方法を確認してください。:
より多くの機能を含む、より完全な例については、
チュートリアル - ユーザーガイド
をご覧ください。
ネタバレ注意
: チュートリアル - ユーザーガイドは以下の情報が含まれています:
ヘッダー
、
クッキー
、
フォームフィールド
、
ファイル
などの他の場所からの
パラメータ
宣言。
maximum_length
や
regex
のような
検証や制約
を設定する方法。
非常に強力で使いやすい
依存性注入
システム。
JWT トークン
を用いた
OAuth2
や
HTTP Basic 認証
のサポートを含む、セキュリティと認証。
深くネストされた JSON モデル
を宣言するためのより高度な（しかし同様に簡単な）技術（Pydantic のおかげです）。
以下のようなたくさんのおまけ機能(Starlette のおかげです):
WebSockets
GraphQL
httpx
や
pytest
をもとにした極限に簡単なテスト
CORS
クッキーセッション
...などなど。
パフォーマンス
独立した TechEmpower のベンチマークでは、Uvicorn で動作する
FastAPI
アプリケーションが、
Python フレームワークの中で最も高速なものの 1 つ
であり、Starlette と Uvicorn（FastAPI で内部的に使用されています）にのみ下回っていると示されています。
詳細は
ベンチマーク
セクションをご覧ください。
オプションの依存関係
Pydantic によって使用されるもの:
email-validator
- E メールの検証
Starlette によって使用されるもの:
httpx
-
TestClient
を使用するために必要です。
jinja2
- デフォルトのテンプレート設定を使用する場合は必要です。
python-multipart
-
"parsing"
request.form()
からの変換をサポートしたい場合は必要です。
itsdangerous
-
SessionMiddleware
サポートのためには必要です。
pyyaml
- Starlette の
SchemaGenerator
サポートのために必要です。 (FastAPI では必要ないでしょう。)
graphene
-
GraphQLApp
サポートのためには必要です。
FastAPI / Starlette に使用されるもの:
uvicorn
- アプリケーションをロードしてサーブするサーバーのため。
orjson
-
ORJSONResponse
を使用したい場合は必要です。
ujson
-
UJSONResponse
を使用する場合は必須です。
これらは全て
pip install fastapi[all]
でインストールできます。
ライセンス
このプロジェクトは MIT ライセンスです。

## 073_KO
FastAPI¶
---

FastAPI
FastAPI 프레임워크, 고성능, 간편한 학습, 빠른 코드 작성, 준비된 프로덕션
문서
:
https://fastapi.tiangolo.com
소스 코드
:
https://github.com/fastapi/fastapi
FastAPI는 현대적이고, 빠르며(고성능), 파이썬 표준 타입 힌트에 기초한 Python의 API를 빌드하기 위한 웹 프레임워크입니다.
주요 특징으로:
빠름
: (Starlette과 Pydantic 덕분에)
NodeJS
및
Go
와 대등할 정도로 매우 높은 성능.
사용 가능한 가장 빠른 파이썬 프레임워크 중 하나
.
빠른 코드 작성
: 약 200%에서 300%까지 기능 개발 속도 증가. *
적은 버그
: 사람(개발자)에 의한 에러 약 40% 감소. *
직관적
: 훌륭한 편집기 지원. 모든 곳에서
자동완성
. 적은 디버깅 시간.
쉬움
: 쉽게 사용하고 배우도록 설계. 적은 문서 읽기 시간.
짧음
: 코드 중복 최소화. 각 매개변수 선언의 여러 기능. 적은 버그.
견고함
: 준비된 프로덕션 용 코드를 얻으십시오. 자동 대화형 문서와 함께.
표준 기반
: API에 대한 (완전히 호환되는) 개방형 표준 기반:
OpenAPI
(이전에 Swagger로 알려졌던) 및
JSON 스키마
.
* 내부 개발팀의 프로덕션 애플리케이션을 빌드한 테스트에 근거한 측정
골드 스폰서
다른 스폰서
의견들
"
[...] 저는 요즘
FastAPI
를 많이 사용하고 있습니다. [...] 사실 우리 팀의
마이크로소프트 ML 서비스
전부를 바꿀 계획입니다. 그중 일부는 핵심
Windows
와 몇몇의
Office
제품들이 통합되고 있습니다.
"
Kabir Khan -
마이크로소프트
(ref)
"
FastAPI
라이브러리를 채택하여
예측
을 얻기 위해 쿼리를 실행 할 수 있는
REST
서버를 생성했습니다. [Ludwig을 위해]
"
Piero Molino, Yaroslav Dudin 그리고 Sai Sumanth Miryala -
우버
(ref)
"
Netflix
는 우리의 오픈 소스 배포판인
위기 관리
오케스트레이션 프레임워크를 발표할 수 있어 기쁩니다: 바로
Dispatch
입니다! [
FastAPI
로 빌드]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
넷플릭스
(ref)
"
FastAPI
가 너무 좋아서 구름 위를 걷는듯 합니다. 정말 즐겁습니다!
"
Brian Okken -
Python Bytes
팟캐스트 호스트
(ref)
"
솔직히, 당신이 만든 것은 매우 견고하고 세련되어 보입니다. 여러 면에서
Hug
가 이렇게 되었으면 합니다 - 그걸 만든 누군가를 보는 것은 많은 영감을 줍니다.
"
Timothy Crosley -
Hug
제작자
(ref)
"
REST API를 만들기 위해
현대적인 프레임워크
를 찾고 있다면
FastAPI
를 확인해 보십시오. [...] 빠르고, 쓰기 쉽고, 배우기도 쉽습니다 [...]
"
"
우리
API
를
FastAPI
로 바꿨습니다 [...] 아마 여러분도 좋아하실 것입니다 [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
설립자 -
spaCy
제작자
(ref)
-
(ref)
Typer
, FastAPI의 CLI
웹 API 대신 터미널에서 사용할
CLI
앱을 만들고 있다면,
Typer
를 확인해 보십시오.
Typer
는 FastAPI의 동생입니다. 그리고
FastAPI의 CLI
가 되기 위해 생겼습니다. ⌨️ 🚀
요구사항
FastAPI는 거인들의 어깨 위에 서 있습니다:
웹 부분을 위한
Starlette
.
데이터 부분을 위한
Pydantic
.
설치
fast →
pip install fastapi
restart ↻
프로덕션을 위해
Uvicorn
또는
Hypercorn
과 같은 ASGI 서버도 필요할 겁니다.
fast →
pip install "uvicorn[standard]"
restart ↻
예제
만들기
main.py
파일을 만드십시오:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
또는
async def
사용하기...
여러분의 코드가
async
/
await
을 사용한다면,
async def
를 사용하십시오.
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Note
:
잘 모르겠다면,
문서에서
async
와
await
에 관한
"급하세요?"
섹션을 확인해 보십시오.
실행하기
서버를 실행하십시오:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
uvicorn main:app --reload
명령에 관하여...
명령
uvicorn main:app
은 다음을 나타냅니다:
main
:
main.py
파일 (파이썬 "모듈").
app
: the object created inside of
main.py
with the line
app = FastAPI()
.
--reload
: 코드가 변경된 후 서버 재시작하기. 개발환경에서만 사용하십시오.
확인하기
브라우저로
http://127.0.0.1:8000/items/5?q=somequery
를 열어보십시오.
아래의 JSON 응답을 볼 수 있습니다:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
여러분은 벌써 API를 만들었습니다:
경로
/
및
/items/{item_id}
에서 HTTP 요청 받기.
두
경로
모두
GET
연산
(HTTP
메소드
로 알려진)을 받습니다.
경로
/items/{item_id}
는
경로 매개변수
int
형 이어야 하는
item_id
를 가지고 있습니다.
경로
/items/{item_id}
는 선택적인
str
형 이어야 하는
경로 매개변수
q
를 가지고 있습니다.
대화형 API 문서
이제
http://127.0.0.1:8000/docs
로 가보십시오.
자동 대화형 API 문서를 볼 수 있습니다 (
Swagger UI
제공):
대안 API 문서
그리고 이제
http://127.0.0.1:8000/redoc
로 가봅시다.
다른 자동 문서를 볼 수 있습니다(
ReDoc
제공):
예제 심화
이제
PUT
요청에 있는 본문(Body)을 받기 위해
main.py
를 수정해봅시다.
Pydantic을 이용해 파이썬 표준 타입으로 본문을 선언합니다.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
서버가 자동으로 리로딩 할 수 있어야 합니다 (위에서
uvicorn
명령에
--reload
을 추가 했기 때문입니다).
대화형 API 문서 업그레이드
이제
http://127.0.0.1:8000/docs
로 이동합니다.
대화형 API 문서가 새 본문과 함께 자동으로 업데이트 합니다:
"Try it out" 버튼을 클릭하면, 매개변수를 채울 수 있게 해주고 직접 API와 상호작용 할 수 있습니다:
그러고 나서 "Execute" 버튼을 누르면, 사용자 인터페이스는 API와 통신하고 매개변수를 전송하며 그 결과를 가져와서 화면에 표시합니다:
대안 API 문서 업그레이드
그리고 이제,
http://127.0.0.1:8000/redoc
로 이동합니다.
대안 문서 역시 새 쿼리 매개변수와 본문을 반영합니다:
요약
요약하면, 여러분은 매개변수의 타입, 본문 등을 함수 매개변수로서
한번에
선언했습니다.
여러분은 현대 표준 파이썬 타입으로 이를 행했습니다.
새로운 문법, 특정 라이브러리의 메소드나 클래스 등을 배울 필요가 없습니다.
그저 표준
Python
입니다.
예를 들어,
int
에 대해선:
item_id
:
int
또는 좀 더 복잡한
Item
모델에 대해선:
item
:
Item
...그리고 단 하나의 선언으로 여러분이 얻는 것은:
다음을 포함한 편집기 지원:
자동완성.
타입 검사.
데이터 검증:
데이터가 유효하지 않을 때 자동으로 생성하는 명확한 에러.
중첩된 JSON 객체에 대한 유효성 검사.
입력 데이터
변환
: 네트워크에서 파이썬 데이터 및 타입으로 전송. 읽을 수 있는 것들:
JSON.
경로 매개변수.
쿼리 매개변수.
쿠키.
헤더.
폼(Forms).
파일.
출력 데이터
변환
: 파이썬 데이터 및 타입을 네트워크 데이터로 전환(JSON 형식으로):
파이썬 타입 변환 (
str
,
int
,
float
,
bool
,
list
, 등).
datetime
객체.
UUID
객체.
데이터베이스 모델.
...더 많은 것들.
대안가능한 사용자 인터페이스를 2개 포함한 자동 대화형 API 문서:
Swagger UI.
ReDoc.
이전 코드 예제로 돌아가서,
FastAPI
는 다음처럼 처리합니다:
GET
및
PUT
요청에
item_id
가 경로에 있는지 검증.
GET
및
PUT
요청에
item_id
가
int
타입인지 검증.
그렇지 않다면 클라이언트는 유용하고 명확한 에러를 볼 수 있습니다.
GET
요청에
q
라는 선택적인 쿼리 매개변수가 검사(
http://127.0.0.1:8000/items/foo?q=somequery
처럼).
q
매개변수는
= None
으로 선언되었기 때문에 선택사항입니다.
None
이 없다면 필수사항입니다(
PUT
의 경우와 마찬가지로).
/items/{item_id}
으로의
PUT
요청은 본문을 JSON으로 읽음:
name
을 필수 속성으로 갖고
str
형인지 검사.
price
을 필수 속성으로 갖고
float
형인지 검사.
만약 주어진다면,
is_offer
를 선택 속성으로 갖고
bool
형인지 검사.
이 모든 것은 깊이 중첩된 JSON 객체에도 적용됩니다.
JSON을 변환하거나 JSON으로 변환하는 것을 자동화.
다음에서 사용할 수 있는 모든 것을 OpenAPI로 문서화:
대화형 문서 시스템.
여러 언어들에 대한 자동 클라이언트 코드 생성 시스템.
2개의 대화형 문서 웹 인터페이스를 직접 제공.
우리는 그저 수박 겉 핥기만 했을 뿐인데 여러분은 벌써 어떻게 작동하는지 알고 있습니다.
다음 줄을 바꿔보십시오:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...에서:
...
"item_name"
:
item
.
name
...
...으로:
...
"item_price"
:
item
.
price
...
...그러고 나서 여러분의 편집기가 속성과 타입을 알고 자동 완성하는지 보십시오:
더 많은 기능을 포함한 보다 완전한 예제의 경우,
튜토리얼 - 사용자 가이드
를 보십시오.
스포일러 주의
: 튜토리얼 - 사용자 가이드는:
서로 다른 장소에서
매개변수
선언:
헤더
,
쿠키
,
폼 필드
그리고
파일
.
maximum_length
또는
regex
처럼
유효성 제약
하는 방법.
강력하고 사용하기 쉬운
의존성 주입
시스템.
OAuth2
지원을 포함한
JWT tokens
및
HTTP Basic
을 갖는 보안과 인증.
(Pydantic 덕분에)
깊은 중첩 JSON 모델
을 선언하는데 더 진보한 (하지만 마찬가지로 쉬운) 기술.
(Starlette 덕분에) 많은 추가 기능:
웹 소켓
GraphQL
HTTPX 및
pytest
에 기반한 극히 쉬운 테스트
CORS
쿠키 세션
...기타 등등.
성능
독립된 TechEmpower 벤치마크에서 Uvicorn에서 작동하는 FastAPI 어플리케이션이
사용 가능한 가장 빠른 프레임워크 중 하나
로 Starlette와 Uvicorn(FastAPI에서 내부적으로 사용)에만 밑돌고 있습니다. (*)
자세한 내용은
벤치마크
섹션을 보십시오.
선택가능한 의존성
Pydantic이 사용하는:
email-validator
- 이메일 유효성 검사.
Starlette이 사용하는:
HTTPX
-
TestClient
를 사용하려면 필요.
jinja2
- 기본 템플릿 설정을 사용하려면 필요.
python-multipart
-
request.form()
과 함께
"parsing"
의 지원을 원하면 필요.
itsdangerous
-
SessionMiddleware
지원을 위해 필요.
pyyaml
- Starlette의
SchemaGenerator
지원을 위해 필요 (FastAPI와 쓸때는 필요 없을 것입니다).
graphene
-
GraphQLApp
지원을 위해 필요.
FastAPI / Starlette이 사용하는:
uvicorn
- 애플리케이션을 로드하고 제공하는 서버.
orjson
-
ORJSONResponse
을 사용하려면 필요.
ujson
-
UJSONResponse
를 사용하려면 필요.
pip install fastapi[all]
를 통해 이 모두를 설치 할 수 있습니다.
라이센스
이 프로젝트는 MIT 라이센스 조약에 따라 라이센스가 부여됩니다.

## 074_LEARN
Learn¶
---

Learn
Here are the introductory sections and the tutorials to learn
FastAPI
.
You could consider this a
book
, a
course
, the
official
and recommended way to learn FastAPI. 😎

## 075_MANAGEMENT_TASKS
Repository Management Tasks¶
---

Repository Management Tasks
These are the tasks that can be performed to manage the FastAPI repository by
team members
.
Tip
This section is useful only to a handful of people, team members with permissions to manage the repository. You can probably skip it. 😉
...so, you are a
team member of FastAPI
? Wow, you are so cool! 😎
You can help with everything on
Help FastAPI - Get Help
the same ways as external contributors. But additionally, there are some tasks that only you (as part of the team) can perform.
Here are the general instructions for the tasks you can perform.
Thanks a lot for your help. 🙇
Be Nice
First of all, be nice. 😊
You probably are super nice if you were added to the team, but it's worth mentioning it. 🤓
When Things are Difficult
When things are great, everything is easier, so that doesn't need much instructions. But when things are difficult, here are some guidelines.
Try to find the good side. In general, if people are not being unfriendly, try to thank their effort and interest, even if you disagree with the main subject (discussion, PR), just thank them for being interested in the project, or for having dedicated some time to try to do something.
It's difficult to convey emotion in text, use emojis to help. 😅
In discussions and PRs, in many cases, people bring their frustration and show it without filter, in many cases exaggerating, complaining, being entitled, etc. That's really not nice, and when it happens, it lowers our priority to solve their problems. But still, try to breath, and be gentle with your answers.
Try to avoid using bitter sarcasm or potentially passive-aggressive comments. If something is wrong, it's better to be direct (try to be gentle) than sarcastic.
Try to be as specific and objective as possible, avoid generalizations.
For conversations that are more difficult, for example to reject a PR, you can ask me (@tiangolo) to handle it directly.
Edit PR Titles
Edit the PR title to start with an emoji from
gitmoji
.
Use the emoji character, not the GitHub code. So, use
🐛
instead of
:bug:
. This is so that it shows up correctly outside of GitHub, for example in the release notes.
For translations use the
🌐
emoji ("globe with meridians").
Start the title with a verb. For example
Add
,
Refactor
,
Fix
, etc. This way the title will say the action that the PR does. Like
Add support for teleporting
, instead of
Teleporting wasn't working, so this PR fixes it
.
Edit the text of the PR title to start in "imperative", like giving an order. So, instead of
Adding support for teleporting
use
Add support for teleporting
.
Try to make the title descriptive about what it achieves. If it's a feature, try to describe it, for example
Add support for teleporting
instead of
Create TeleportAdapter class
.
Do not finish the title with a period (
.
).
When the PR is for a translation, start with the
🌐
and then
Add {language} translation for
and then the translated file path. For example:
🌐 Add Spanish translation for
`docs/es/docs/teleporting.md`
Once the PR is merged, a GitHub Action (
latest-changes
) will use the PR title to update the latest changes automatically.
So, having a nice PR title will not only look nice in GitHub, but also in the release notes. 📝
Add Labels to PRs
The same GitHub Action
latest-changes
uses one label in the PR to decide the section in the release notes to put this PR in.
Make sure you use a supported label from the
latest-changes list of labels
:
breaking
: Breaking Changes
Existing code will break if they update the version without changing their code. This rarely happens, so this label is not frequently used.
security
: Security Fixes
This is for security fixes, like vulnerabilities. It would almost never be used.
feature
: Features
New features, adding support for things that didn't exist before.
bug
: Fixes
Something that was supported didn't work, and this fixes it. There are many PRs that claim to be bug fixes because the user is doing something in an unexpected way that is not supported, but they considered it what should be supported by default. Many of these are actually features or refactors. But in some cases there's an actual bug.
refactor
: Refactors
This is normally for changes to the internal code that don't change the behavior. Normally it improves maintainability, or enables future features, etc.
upgrade
: Upgrades
This is for upgrades to direct dependencies from the project, or extra optional dependencies, normally in
pyproject.toml
. So, things that would affect final users, they would end up receiving the upgrade in their code base once they update. But this is not for upgrades to internal dependencies used for development, testing, docs, etc. Those internal dependencies, normally in
requirements.txt
files or GitHub Action versions should be marked as
internal
, not
upgrade
.
docs
: Docs
Changes in docs. This includes updating the docs, fixing typos. But it doesn't include changes to translations.
You can normally quickly detect it by going to the "Files changed" tab in the PR and checking if the updated file(s) starts with
docs/en/docs
. The original version of the docs is always in English, so in
docs/en/docs
.
lang-all
: Translations
Use this for translations. You can normally quickly detect it by going to the "Files changed" tab in the PR and checking if the updated file(s) starts with
docs/{some lang}/docs
but not
docs/en/docs
. For example,
docs/es/docs
.
internal
: Internal
Use this for changes that only affect how the repo is managed. For example upgrades to internal dependencies, changes in GitHub Actions or scripts, etc.
Tip
Some tools like Dependabot, will add some labels, like
dependencies
, but have in mind that this label is not used by the
latest-changes
GitHub Action, so it won't be used in the release notes. Please make sure one of the labels above is added.
Add Labels to Translation PRs
When there's a PR for a translation, apart from adding the
lang-all
label, also add a label for the language.
There will be a label for each language using the language code, like
lang-{lang code}
, for example,
lang-es
for Spanish,
lang-fr
for French, etc.
Add the specific language label.
Add the label
awaiting-review
.
The label
awaiting-review
is special, only used for translations. A GitHub Action will detect it, then it will read the language label, and it will update the GitHub Discussions managing the translations for that language to notify people that there's a new translation to review.
Once a native speaker comes, reviews the PR, and approves it, the GitHub Action will come and remove the
awaiting-review
label, and add the
approved-1
label.
This way, we can notice when there are new translations ready, because they have the
approved-1
label.
Merge Translation PRs
For Spanish, as I'm a native speaker and it's a language close to me, I will give it a final review myself and in most cases tweak the PR a bit before merging it.
For the other languages, confirm that:
The title is correct following the instructions above.
It has the labels
lang-all
and
lang-{lang code}
.
The PR changes only one Markdown file adding a translation.
Or in some cases, at most two files, if they are small, for the same language, and people reviewed them.
If it's the first translation for that language, it will have additional
mkdocs.yml
files, for those cases follow the instructions below.
The PR doesn't add any additional or extraneous files.
The translation seems to have a similar structure as the original English file.
The translation doesn't seem to change the original content, for example with obvious additional documentation sections.
The translation doesn't use different Markdown structures, for example adding HTML tags when the original didn't have them.
The "admonition" sections, like
tip
,
info
, etc. are not changed or translated. For example:
/// tip
This is a tip.
///
looks like this:
Tip
This is a tip.
...it could be translated as:
/// tip
Esto es un consejo.
///
...but needs to keep the exact
tip
keyword. If it was translated to
consejo
, like:
/// consejo
Esto es un consejo.
///
it would change the style to the default one, it would look like:
/// consejo
Esto es un consejo.
///
Those don't have to be translated, but if they are, they need to be written as:
/// tip | consejo
Esto es un consejo.
///
Which looks like:
consejo
Esto es un consejo.
First Translation PR
When there's a first translation for a language, it will have a
docs/{lang code}/docs/index.md
translated file and a
docs/{lang code}/mkdocs.yml
.
For example, for Bosnian, it would be:
docs/bs/docs/index.md
docs/bs/mkdocs.yml
The
mkdocs.yml
file will have only the following content:
INHERIT
:
../en/mkdocs.yml
The language code would normally be in the
ISO 639-1 list of language codes
.
In any case, the language code should be in the file
docs/language_names.yml
.
There won't be yet a label for the language code, for example, if it was Bosnian, there wouldn't be a
lang-bs
. Before creating the label and adding it to the PR, create the GitHub Discussion:
Go to the
Translations GitHub Discussions
Create a new discussion with the title
Bosnian Translations
(or the language name in English)
A description of:
## Bosnian translations
This is the issue to track translations of the docs to Bosnian. 🚀
Here are the [
PRs to review with the label `lang-bs`
](
https://github.com/fastapi/fastapi/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc+label%3Alang-bs+label%3A%22awaiting-review%22
). 🤓
Update "Bosnian" with the new language.
And update the search link to point to the new language label that will be created, like
lang-bs
.
Create and add the label to that new Discussion just created, like
lang-bs
.
Then go back to the PR, and add the label, like
lang-bs
, and
lang-all
and
awaiting-review
.
Now the GitHub action will automatically detect the label
lang-bs
and will post in that Discussion that this PR is waiting to be reviewed.
Review PRs
If a PR doesn't explain what it does or why, ask for more information.
A PR should have a specific use case that it is solving.
If the PR is for a feature, it should have docs.
Unless it's a feature we want to discourage, like support for a corner case that we don't want users to use.
The docs should include a source example file, not write Python directly in Markdown.
If the source example(s) file can have different syntax for Python 3.8, 3.9, 3.10, there should be different versions of the file, and they should be shown in tabs in the docs.
There should be tests testing the source example.
Before the PR is applied, the new tests should fail.
After applying the PR, the new tests should pass.
Coverage should stay at 100%.
If you see the PR makes sense, or we discussed it and considered it should be accepted, you can add commits on top of the PR to tweak it, to add docs, tests, format, refactor, remove extra files, etc.
Feel free to comment in the PR to ask for more information, to suggest changes, etc.
Once you think the PR is ready, move it in the internal GitHub project for me to review it.
FastAPI People PRs
Every month, a GitHub Action updates the FastAPI People data. Those PRs look like this one:
👥 Update FastAPI People
.
If the tests are passing, you can merge it right away.
External Links PRs
When people add external links they edit this file
external_links.yml
.
Make sure the new link is in the correct category (e.g. "Podcasts") and language (e.g. "Japanese").
A new link should be at the top of its list.
The link URL should work (it should not return a 404).
The content of the link should be about FastAPI.
The new addition should have these fields:
author
: The name of the author.
link
: The URL with the content.
title
: The title of the link (the title of the article, podcast, etc).
After checking all these things and ensuring the PR has the right labels, you can merge it.
Dependabot PRs
Dependabot will create PRs to update dependencies for several things, and those PRs all look similar, but some are way more delicate than others.
If the PR is for a direct dependency, so, Dependabot is modifying
pyproject.toml
,
don't merge it
. 😱 Let me check it first. There's a good chance that some additional tweaks or updates are needed.
If the PR updates one of the internal dependencies, for example it's modifying
requirements.txt
files, or GitHub Action versions, if the tests are passing, the release notes (shown in a summary in the PR) don't show any obvious potential breaking change, you can merge it. 😎
Mark GitHub Discussions Answers
When a question in GitHub Discussions has been answered, mark the answer by clicking "Mark as answer".
You can filter discussions by
Questions
that are
Unanswered
.

## 076_MANAGEMENT
Repository Management¶
---

Repository Management
Here's a short description of how the FastAPI repository is managed and maintained.
Owner
I,
@tiangolo
, am the creator and owner of the FastAPI repository. 🤓
I normally give the final review to each PR before merging them. I make the final decisions on the project, I'm the
BDFL
. 😅
Team
There's a team of people that help manage and maintain the project. 😎
They have different levels of permissions and
specific instructions
.
Some of the tasks they can perform include:
Adding labels to PRs.
Editing PR titles.
Adding commits on top of PRs to tweak them.
Mark answers in GitHub Discussions questions, etc.
Merge some specific types of PRs.
You can see the current team members in
FastAPI People - Team
.
Joining the team is by invitation only, and I could update or remove permissions, instructions, or membership.
FastAPI Experts
The people that help others the most in GitHub Discussions can become
FastAPI Experts
.
This is normally the best way to contribute to the project.
External Contributions
External contributions are very welcome and appreciated, including answering questions, submitting PRs, etc. 🙇‍♂️
There are many ways to
help maintain FastAPI
.

## 077_NL
FastAPI¶
---

FastAPI
FastAPI framework, zeer goede prestaties, eenvoudig te leren, snel te programmeren, klaar voor productie
Documentatie
:
https://fastapi.tiangolo.com
Broncode
:
https://github.com/tiangolo/fastapi
FastAPI is een modern, snel (zeer goede prestaties), web framework voor het bouwen van API's in Python, gebruikmakend van standaard Python type-hints.
De belangrijkste kenmerken zijn:
Snel
: Zeer goede prestaties, vergelijkbaar met
NodeJS
en
Go
(dankzij Starlette en Pydantic).
Een van de snelste beschikbare Python frameworks
.
Snel te programmeren
: Verhoog de snelheid om functionaliteit te ontwikkelen met ongeveer 200% tot 300%. *
Minder bugs
: Verminder ongeveer 40% van de door mensen (ontwikkelaars) veroorzaakte fouten. *
Intuïtief
: Buitengewoon goede ondersteuning voor editors.
Overal automische code aanvulling
. Minder tijd kwijt aan debuggen.
Eenvoudig
: Ontworpen om gemakkelijk te gebruiken en te leren. Minder tijd nodig om documentatie te lezen.
Kort
: Minimaliseer codeduplicatie. Elke parameterdeclaratie ondersteunt meerdere functionaliteiten. Minder bugs.
Robust
: Code gereed voor productie. Met automatische interactieve documentatie.
Standards-based
: Gebaseerd op (en volledig verenigbaar met) open standaarden voor API's:
OpenAPI
(voorheen bekend als Swagger) en
JSON Schema
.
* schatting op basis van testen met een intern ontwikkelteam en bouwen van productieapplicaties.
Sponsors
Overige sponsoren
Meningen
"
[...] Ik gebruik
FastAPI
heel vaak tegenwoordig. [...] Ik ben van plan om het te gebruiken voor alle
ML-services van mijn team bij Microsoft
. Sommige van deze worden geïntegreerd in het kernproduct van
Windows
en sommige
Office
-producten.
"
Kabir Khan -
Microsoft
(ref)
"
We hebben de
FastAPI
library gebruikt om een
REST
server te maken die bevraagd kan worden om
voorspellingen
te maken. [voor Ludwig]
"
Piero Molino, Yaroslav Dudin en Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is verheugd om een open-source release aan te kondigen van ons
crisismanagement
-orkestratieframework:
Dispatch
! [gebouwd met
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Ik ben super enthousiast over
FastAPI
. Het is zo leuk!
"
Brian Okken -
Python Bytes
podcast presentator
(ref)
"
Wat je hebt gebouwd ziet er echt super solide en gepolijst uit. In veel opzichten is het wat ik wilde dat
Hug
kon zijn - het is echt inspirerend om iemand dit te zien bouwen.
"
Timothy Crosley -
Hug
creator
(ref)
"Wie geïnteresseerd is in een
modern framework
voor het bouwen van REST API's, bekijkt best eens
FastAPI
[...] Het is snel, gebruiksvriendelijk en gemakkelijk te leren [...]_"
"
We zijn overgestapt naar
FastAPI
voor onze
API's
[...] Het gaat jou vast ook bevallen [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
oprichters -
spaCy
ontwikkelaars
(ref)
-
(ref)
"
Wie een Python API wil bouwen voor productie, kan ik ten stelligste
FastAPI
aanraden. Het is
prachtig ontworpen
,
eenvoudig te gebruiken
en
gemakkelijk schaalbaar
, het is een
cruciale component
geworden in onze strategie om API's centraal te zetten, en het vereenvoudigt automatisering en diensten zoals onze Virtual TAC Engineer.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, de FastAPI van CLIs
Als je een
CLI
-app bouwt die in de terminal moet worden gebruikt in plaats van een web-API, gebruik dan
Typer
.
Typer
is het kleine broertje van FastAPI. En het is bedoeld als de
FastAPI van CLI's
. ️
Vereisten
FastAPI staat op de schouders van reuzen:
Starlette
voor de webonderdelen.
Pydantic
voor de datadelen.
Installatie
fast →
pip install "fastapi[standard]"
restart ↻
Opmerking
: Zet
"fastapi[standard]"
tussen aanhalingstekens om ervoor te zorgen dat het werkt in alle terminals.
Voorbeeld
Creëer het
Maak het bestand
main.py
aan met daarin:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Of maak gebruik van
async def
...
Als je code gebruik maakt van
async
/
await
, gebruik dan
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Opmerking
:
Als je het niet weet, kijk dan in het gedeelte
"Heb je haast?"
over
async
en
await
in de documentatie
.
Voer het uit
Run de server met:
fast →
fastapi dev main.py
╭────────── FastAPI CLI - Development mode ───────────╮
│ │
│ Serving at: http://127.0.0.1:8000 │
│ │
│ API docs: http://127.0.0.1:8000/docs │
│ │
│ Running in development mode, for production use: │
│ │
│ fastapi run │
│ │
╰─────────────────────────────────────────────────────╯
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
Over het commando
fastapi dev main.py
...
Het commando
fastapi dev
leest het
main.py
bestand, detecteert de
FastAPI
app, en start een server met
Uvicorn
.
Standaard zal dit commando
fastapi dev
starten met "auto-reload" geactiveerd voor ontwikkeling op het lokale systeem.
Je kan hier meer over lezen in de
FastAPI CLI documentatie
.
Controleer het
Open je browser op
http://127.0.0.1:8000/items/5?q=somequery
.
Je zult een JSON response zien:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Je hebt een API gemaakt die:
HTTP verzoeken kan ontvangen op de
paden
/
en
/items/{item_id}
.
Beide
paden
hebben
GET
operaties
(ook bekend als HTTP
methoden
).
Het
pad
/items/{item_id}
heeft een
pad parameter
item_id
dat een
int
moet zijn.
Het
pad
/items/{item_id}
heeft een optionele
str
query parameter
q
.
Interactieve API documentatie
Ga naar
http://127.0.0.1:8000/docs
.
Je ziet de automatische interactieve API documentatie (verstrekt door
Swagger UI
):
Alternatieve API documentatie
Ga vervolgens naar
http://127.0.0.1:8000/redoc
.
Je ziet de automatische interactieve API documentatie (verstrekt door
ReDoc
):
Voorbeeld upgrade
Pas nu het bestand
main.py
aan om de body van een
PUT
request te ontvangen.
Dankzij Pydantic kunnen we de body declareren met standaard Python types.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
De
fastapi dev
server zou automatisch moeten herladen.
Interactieve API documentatie upgrade
Ga nu naar
http://127.0.0.1:8000/docs
.
De interactieve API-documentatie wordt automatisch bijgewerkt, inclusief de nieuwe body:
Klik op de knop "Try it out", hiermee kan je de parameters invullen en direct met de API interacteren:
Klik vervolgens op de knop "Execute", de gebruikersinterface zal communiceren met jouw API, de parameters verzenden, de resultaten ophalen en deze op het scherm tonen:
Alternatieve API documentatie upgrade
Ga vervolgens naar
http://127.0.0.1:8000/redoc
.
De alternatieve documentatie zal ook de nieuwe queryparameter en body weergeven:
Samenvatting
Samengevat declareer je
eenmalig
de types van parameters, body, etc. als functieparameters.
Dat doe je met standaard moderne Python types.
Je hoeft geen nieuwe syntax te leren, de methods of klassen van een specifieke bibliotheek, etc.
Gewoon standaard
Python
.
Bijvoorbeeld, voor een
int
:
item_id
:
int
of voor een complexer
Item
model:
item
:
Item
...en met die ene verklaring krijg je:
Editor ondersteuning, inclusief:
Code aanvulling.
Type validatie.
Validatie van data:
Automatische en duidelijke foutboodschappen wanneer de data ongeldig is.
Validatie zelfs voor diep geneste JSON objecten.
Conversie
van invoergegevens: afkomstig van het netwerk naar Python-data en -types. Zoals:
JSON.
Pad parameters.
Query parameters.
Cookies.
Headers.
Formulieren.
Bestanden.
Conversie
van uitvoergegevens: converstie van Python-data en -types naar netwerkgegevens (zoals JSON):
Converteer Python types (
str
,
int
,
float
,
bool
,
list
, etc).
datetime
objecten.
UUID
objecten.
Database modellen.
...en nog veel meer.
Automatische interactieve API-documentatie, inclusief 2 alternatieve gebruikersinterfaces:
Swagger UI.
ReDoc.
Terugkomend op het vorige code voorbeeld,
FastAPI
zal:
Valideren dat er een
item_id
bestaat in het pad voor
GET
en
PUT
verzoeken.
Valideren dat het
item_id
van het type
int
is voor
GET
en
PUT
verzoeken.
Wanneer dat niet het geval is, krijgt de cliënt een nuttige, duidelijke foutmelding.
Controleren of er een optionele query parameter is met de naam
q
(zoals in
http://127.0.0.1:8000/items/foo?q=somequery
) voor
GET
verzoeken.
Aangezien de
q
parameter werd gedeclareerd met
= None
, is deze optioneel.
Zonder de
None
declaratie zou deze verplicht zijn (net als bij de body in het geval met
PUT
).
Voor
PUT
verzoeken naar
/items/{item_id}
, lees de body als JSON:
Controleer of het een verplicht attribuut
naam
heeft en dat dat een
str
is.
Controleer of het een verplicht attribuut
price
heeft en dat dat een
float
is.
Controleer of het een optioneel attribuut
is_offer
heeft, dat een
bool
is wanneer het aanwezig is.
Dit alles werkt ook voor diep geneste JSON objecten.
Converteer automatisch van en naar JSON.
Documenteer alles met OpenAPI, dat gebruikt kan worden door:
Interactieve documentatiesystemen.
Automatische client code generatie systemen, voor vele talen.
Biedt 2 interactieve documentatie-webinterfaces aan.
Dit was nog maar een snel overzicht, maar je zou nu toch al een idee moeten hebben over hoe het allemaal werkt.
Probeer deze regel te veranderen:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...van:
...
"item_name"
:
item
.
name
...
...naar:
...
"item_price"
:
item
.
price
...
...en zie hoe je editor de attributen automatisch invult en hun types herkent:
Voor een vollediger voorbeeld met meer mogelijkheden, zie de
Tutorial - Gebruikershandleiding
.
Spoiler alert
: de tutorial - gebruikershandleiding bevat:
Declaratie van
parameters
op andere plaatsen zoals:
headers
,
cookies
,
formuliervelden
en
bestanden
.
Hoe stel je
validatie restricties
in zoals
maximum_length
of een
regex
.
Een zeer krachtig en eenvoudig te gebruiken
Dependency Injection
systeem.
Beveiliging en authenticatie, inclusief ondersteuning voor
OAuth2
met
JWT-tokens
en
HTTP Basic
auth.
Meer geavanceerde (maar even eenvoudige) technieken voor het declareren van
diep geneste JSON modellen
(dankzij Pydantic).
GraphQL
integratie met
Strawberry
en andere packages.
Veel extra functies (dankzij Starlette) zoals:
WebSockets
uiterst gemakkelijke tests gebaseerd op HTTPX en
pytest
CORS
Cookie Sessions
...en meer.
Prestaties
Onafhankelijke TechEmpower benchmarks tonen
FastAPI
applicaties draaiend onder Uvicorn aan als
een van de snelste Python frameworks beschikbaar
, alleen onder Starlette en Uvicorn zelf (intern gebruikt door FastAPI). (*)
Zie de sectie
Benchmarks
om hier meer over te lezen.
Afhankelijkheden
FastAPI maakt gebruik van Pydantic en Starlette.
standard
Afhankelijkheden
Wanneer je FastAPI installeert met
pip install "fastapi[standard]"
, worden de volgende
standard
optionele afhankelijkheden geïnstalleerd:
Gebruikt door Pydantic:
email_validator
- voor email validatie.
Gebruikt door Starlette:
httpx
- Vereist indien je de
TestClient
wil gebruiken.
jinja2
- Vereist als je de standaard templateconfiguratie wil gebruiken.
python-multipart
- Vereist indien je
"parsen"
van formulieren wil ondersteunen met
requests.form()
.
Gebruikt door FastAPI / Starlette:
uvicorn
- voor de server die jouw applicatie laadt en bedient.
fastapi-cli
- om het
fastapi
commando te voorzien.
Zonder
standard
Afhankelijkheden
Indien je de optionele
standard
afhankelijkheden niet wenst te installeren, kan je installeren met
pip install fastapi
in plaats van
pip install "fastapi[standard]"
.
Bijkomende Optionele Afhankelijkheden
Er zijn nog een aantal bijkomende afhankelijkheden die je eventueel kan installeren.
Bijkomende optionele afhankelijkheden voor Pydantic:
pydantic-settings
- voor het beheren van settings.
pydantic-extra-types
- voor extra data types die gebruikt kunnen worden met Pydantic.
Bijkomende optionele afhankelijkheden voor FastAPI:
orjson
- Vereist indien je
ORJSONResponse
wil gebruiken.
ujson
- Vereist indien je
UJSONResponse
wil gebruiken.
Licentie
Dit project is gelicenseerd onder de voorwaarden van de MIT licentie.

## 078_PL
FastAPI¶
---

FastAPI
FastAPI to szybki, prosty w nauce i gotowy do użycia w produkcji framework
Dokumentacja
:
https://fastapi.tiangolo.com
Kod żródłowy
:
https://github.com/fastapi/fastapi
FastAPI to nowoczesny, wydajny framework webowy do budowania API z użyciem Pythona bazujący na standardowym typowaniu Pythona.
Kluczowe cechy:
Wydajność
: FastAPI jest bardzo wydajny, na równi z
NodeJS
oraz
Go
(dzięki Starlette i Pydantic).
Jeden z najszybszych dostępnych frameworków Pythonowych
.
Szybkość kodowania
: Przyśpiesza szybkość pisania nowych funkcjonalności o około 200% do 300%. *
Mniejsza ilość błędów
: Zmniejsza ilość ludzkich (dewelopera) błędy o około 40%. *
Intuicyjność
: Wspaniałe wsparcie dla edytorów kodu. Dostępne wszędzie
automatyczne uzupełnianie
kodu. Krótszy czas debugowania.
Łatwość
: Zaprojektowany by być prosty i łatwy do nauczenia. Mniej czasu spędzonego na czytanie dokumentacji.
Kompaktowość
: Minimalizacja powtarzającego się kodu. Wiele funkcjonalności dla każdej deklaracji parametru. Mniej błędów.
Solidność
: Kod gotowy dla środowiska produkcyjnego. Wraz z automatyczną interaktywną dokumentacją.
Bazujący na standardach
: Oparty na (i w pełni kompatybilny z) otwartych standardach API:
OpenAPI
(wcześniej znane jako Swagger) oraz
JSON Schema
.
* oszacowania bazowane na testach wykonanych przez wewnętrzny zespół deweloperów, budujących aplikacie używane na środowisku produkcyjnym.
Sponsorzy
Inni sponsorzy
Opinie
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I’m over the moon excited about
FastAPI
. It’s so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, FastAPI aplikacji konsolowych
Jeżeli tworzysz aplikacje
CLI
, która ma być używana w terminalu zamiast API, sprawdź
Typer
.
Typer
to młodsze rodzeństwo FastAPI. Jego celem jest pozostanie
FastAPI aplikacji konsolowych
. ⌨️ 🚀
Wymagania
FastAPI oparty jest na:
Starlette
dla części webowej.
Pydantic
dla części obsługujących dane.
Instalacja
fast →
pip install fastapi
restart ↻
Na serwerze produkcyjnym będziesz także potrzebował serwera ASGI, np.
Uvicorn
lub
Hypercorn
.
fast →
pip install "uvicorn[standard]"
restart ↻
Przykład
Stwórz
Utwórz plik o nazwie
main.py
z:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Albo użyj
async def
...
Jeżeli twój kod korzysta z
async
/
await
, użyj
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Przypis
:
Jeżeli nie znasz, sprawdź sekcję
"In a hurry?"
o
async
i
await
w dokumentacji
.
Uruchom
Uruchom serwer używając:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
O komendzie
uvicorn main:app --reload
...
Komenda
uvicorn main:app
odnosi się do:
main
: plik
main.py
("moduł" w Pythonie).
app
: obiekt stworzony w
main.py
w lini
app = FastAPI()
.
--reload
: spraw by serwer resetował się po każdej zmianie w kodzie. Używaj tego tylko w środowisku deweloperskim.
Wypróbuj
Otwórz link
http://127.0.0.1:8000/items/5?q=somequery
w przeglądarce.
Zobaczysz następującą odpowiedź JSON:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Właśnie stworzyłeś API które:
Otrzymuje żądania HTTP w
ścieżce
/
i
/items/{item_id}
.
Obie
ścieżki
używają
operacji
GET
(znane także jako
metody
HTTP).
Ścieżka
/items/{item_id}
ma
parametr ścieżki
item_id
który powinien być obiektem typu
int
.
Ścieżka
/items/{item_id}
ma opcjonalny
parametr zapytania
typu
str
o nazwie
q
.
Interaktywna dokumentacja API
Otwórz teraz stronę
http://127.0.0.1:8000/docs
.
Zobaczysz automatyczną interaktywną dokumentację API (dostarczoną z pomocą
Swagger UI
):
Alternatywna dokumentacja API
Otwórz teraz
http://127.0.0.1:8000/redoc
.
Zobaczysz alternatywną, lecz wciąż automatyczną dokumentację (wygenerowaną z pomocą
ReDoc
):
Aktualizacja przykładu
Zmodyfikuj teraz plik
main.py
, aby otrzmywał treść (body) żądania
PUT
.
Zadeklaruj treść żądania, używając standardowych typów w Pythonie dzięki Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Serwer powinien przeładować się automatycznie (ponieważ dodałeś
--reload
do komendy
uvicorn
powyżej).
Zaktualizowana interaktywna dokumentacja API
Wejdź teraz na
http://127.0.0.1:8000/docs
.
Interaktywna dokumentacja API zaktualizuje sie automatycznie, także z nową treścią żądania (body):
Kliknij przycisk "Try it out" (wypróbuj), pozwoli Ci to wypełnić parametry i bezpośrednio użyć API:
Kliknij potem przycisk "Execute" (wykonaj), interfejs użytkownika połączy się z API, wyśle parametry, otrzyma odpowiedź i wyświetli ją na ekranie:
Zaktualizowana alternatywna dokumentacja API
Otwórz teraz
http://127.0.0.1:8000/redoc
.
Alternatywna dokumentacja również pokaże zaktualizowane parametry i treść żądania (body):
Podsumowanie
Podsumowując, musiałeś zadeklarować typy parametrów, treści żądania (body) itp. tylko
raz
, i są one dostępne jako parametry funkcji.
Robisz to tak samo jak ze standardowymi typami w Pythonie.
Nie musisz sie uczyć żadnej nowej składni, metod lub klas ze specyficznych bibliotek itp.
Po prostu standardowy
Python
.
Na przykład, dla danych typu
int
:
item_id
:
int
albo dla bardziej złożonego obiektu
Item
:
item
:
Item
...i z pojedyńczą deklaracją otrzymujesz:
Wsparcie edytorów kodu, wliczając:
Auto-uzupełnianie.
Sprawdzanie typów.
Walidacja danych:
Automatyczne i przejrzyste błędy gdy dane są niepoprawne.
Walidacja nawet dla głęboko zagnieżdżonych obiektów JSON.
Konwersja
danych wejściowych: przychodzących z sieci na Pythonowe typy. Pozwala na przetwarzanie danych:
JSON.
Parametrów ścieżki.
Parametrów zapytania.
Dane cookies.
Dane nagłówków (headers).
Formularze.
Pliki.
Konwersja
danych wyjściowych: wychodzących z Pythona do sieci (jako JSON):
Przetwarzanie Pythonowych typów (
str
,
int
,
float
,
bool
,
list
, itp).
Obiekty
datetime
.
Obiekty
UUID
.
Modele baz danych.
...i wiele więcej.
Automatyczne interaktywne dokumentacje API, wliczając 2 alternatywne interfejsy użytkownika:
Swagger UI.
ReDoc.
Wracając do poprzedniego przykładu,
FastAPI
:
Potwierdzi, że w ścieżce jest
item_id
dla żądań
GET
i
PUT
.
Potwierdzi, że
item_id
jest typu
int
dla żądań
GET
i
PUT
.
Jeżeli nie jest, odbiorca zobaczy przydatną, przejrzystą wiadomość z błędem.
Sprawdzi czy w ścieżce jest opcjonalny parametr zapytania
q
(np.
http://127.0.0.1:8000/items/foo?q=somequery
) dla żądania
GET
.
Jako że parametr
q
jest zadeklarowany jako
= None
, jest on opcjonalny.
Gdyby tego
None
nie było, parametr ten byłby wymagany (tak jak treść żądania w żądaniu
PUT
).
Dla żądania
PUT
z ścieżką
/items/{item_id}
, odczyta treść żądania jako JSON:
Sprawdzi czy posiada wymagany atrybut
name
, który powinien być typu
str
.
Sprawdzi czy posiada wymagany atrybut
price
, który musi być typu
float
.
Sprawdzi czy posiada opcjonalny atrybut
is_offer
, który (jeżeli obecny) powinien być typu
bool
.
To wszystko będzie również działać dla głęboko zagnieżdżonych obiektów JSON.
Automatycznie konwertuje z i do JSON.
Dokumentuje wszystko w OpenAPI, które może być używane przez:
Interaktywne systemy dokumentacji.
Systemy automatycznego generowania kodu klienckiego, dla wielu języków.
Dostarczy bezpośrednio 2 interaktywne dokumentacje webowe.
To dopiero początek, ale już masz mniej-więcej pojęcie jak to wszystko działa.
Spróbuj zmienić linijkę:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...z:
...
"item_name"
:
item
.
name
...
...na:
...
"item_price"
:
item
.
price
...
...i zobacz jak edytor kodu automatycznie uzupełni atrybuty i będzie znał ich typy:
Dla bardziej kompletnych przykładów posiadających więcej funkcjonalności, zobacz
Tutorial - User Guide
.
Uwaga Spoiler
: tutorial - user guide zawiera:
Deklaracje
parametrów
z innych miejsc takich jak:
nagłówki
,
pliki cookies
,
formularze
i
pliki
.
Jak ustawić
ograniczenia walidacyjne
takie jak
maksymalna długość
lub
regex
.
Potężny i łatwy w użyciu system
Dependency Injection
.
Zabezpieczenia i autentykacja, wliczając wsparcie dla
OAuth2
z
tokenami JWT
oraz autoryzacją
HTTP Basic
.
Bardziej zaawansowane (ale równie proste) techniki deklarowania
głęboko zagnieżdżonych modeli JSON
(dzięki Pydantic).
Wiele dodatkowych funkcji (dzięki Starlette) takie jak:
WebSockety
GraphQL
bardzo proste testy bazujące na HTTPX oraz
pytest
CORS
Sesje cookie
...i więcej.
Wydajność
Niezależne benchmarki TechEmpower pokazują, że
FastAPI
(uruchomiony na serwerze Uvicorn)
jest jednym z najszybszych dostępnych Pythonowych frameworków
, zaraz po Starlette i Uvicorn (używanymi wewnątrznie przez FastAPI). (*)
Aby dowiedzieć się o tym więcej, zobacz sekcję
Benchmarks
.
Opcjonalne zależności
Używane przez Pydantic:
email-validator
- dla walidacji adresów email.
Używane przez Starlette:
httpx
- Wymagane jeżeli chcesz korzystać z
TestClient
.
aiofiles
- Wymagane jeżeli chcesz korzystać z
FileResponse
albo
StaticFiles
.
jinja2
- Wymagane jeżeli chcesz używać domyślnej konfiguracji szablonów.
python-multipart
- Wymagane jeżelich chcesz wsparcie
"parsowania"
formularzy, używając
request.form()
.
itsdangerous
- Wymagany dla wsparcia
SessionMiddleware
.
pyyaml
- Wymagane dla wsparcia
SchemaGenerator
z Starlette (z FastAPI prawdopodobnie tego nie potrzebujesz).
graphene
- Wymagane dla wsparcia
GraphQLApp
.
Używane przez FastAPI / Starlette:
uvicorn
- jako serwer, który ładuje i obsługuje Twoją aplikację.
orjson
- Wymagane jeżeli chcesz używać
ORJSONResponse
.
ujson
- Wymagane jeżeli chcesz korzystać z
UJSONResponse
.
Możesz zainstalować wszystkie te aplikacje przy pomocy
pip install fastapi[all]
.
Licencja
Ten projekt jest na licencji MIT.

## 079_PROJECT_GENERATION
Full Stack FastAPI Template¶
---

Full Stack FastAPI Template
Templates, while typically come with a specific setup, are designed to be flexible and customizable. This allows you to modify and adapt them to your project's requirements, making them an excellent starting point. 🏁
You can use this template to get started, as it includes a lot of the initial set up, security, database and some API endpoints already done for you.
GitHub Repository:
Full Stack FastAPI Template
Full Stack FastAPI Template - Technology Stack and Features
⚡
FastAPI
for the Python backend API.
🧰
SQLModel
for the Python SQL database interactions (ORM).
🔍
Pydantic
, used by FastAPI, for the data validation and settings management.
💾
PostgreSQL
as the SQL database.
🚀
React
for the frontend.
💃 Using TypeScript, hooks,
Vite
, and other parts of a modern frontend stack.
🎨
Chakra UI
for the frontend components.
🤖 An automatically generated frontend client.
🧪
Playwright
for End-to-End testing.
🦇 Dark mode support.
🐋
Docker Compose
for development and production.
🔒 Secure password hashing by default.
🔑 JWT token authentication.
📫 Email based password recovery.
✅ Tests with
Pytest
.
📞
Traefik
as a reverse proxy / load balancer.
🚢 Deployment instructions using Docker Compose, including how to set up a frontend Traefik proxy to handle automatic HTTPS certificates.
🏭 CI (continuous integration) and CD (continuous deployment) based on GitHub Actions.

## 080_PT
FastAPI¶
---

FastAPI
Framework FastAPI, alta performance, fácil de aprender, fácil de codar, pronto para produção
Documentação
:
https://fastapi.tiangolo.com
Código fonte
:
https://github.com/fastapi/fastapi
FastAPI é um moderno e rápido (alta performance)
framework web
para construção de APIs com Python, baseado nos
type hints
padrões do Python.
Os recursos chave são:
Rápido
: alta performance, equivalente a
NodeJS
e
Go
(graças ao Starlette e Pydantic).
Um dos frameworks mais rápidos disponíveis
.
Rápido para codar
: Aumenta a velocidade para desenvolver recursos entre 200% a 300%. *
Poucos bugs
: Reduz cerca de 40% de erros induzidos por humanos (desenvolvedores). *
Intuitivo
: Grande suporte a
IDEs
.
Auto-Complete
em todos os lugares. Menos tempo debugando.
Fácil
: Projetado para ser fácil de aprender e usar. Menos tempo lendo documentação.
Enxuto
: Minimize duplicação de código. Múltiplos recursos para cada declaração de parâmetro. Menos bugs.
Robusto
: Tenha código pronto para produção. E com documentação interativa automática.
Baseado em padrões
: Baseado em (e totalmente compatível com) os padrões abertos para APIs:
OpenAPI
(anteriormente conhecido como Swagger) e
JSON Schema
.
* estimativas baseadas em testes realizados com equipe interna de desenvolvimento, construindo aplicações em produção.
Patrocinadores Ouro
Outros patrocinadores
Opiniões
"
[...] Estou usando
FastAPI
muito esses dias. [...] Estou na verdade planejando utilizar ele em todos os times de
serviços
Machine Learning
na Microsoft
. Alguns deles estão sendo integrados no
core
do produto
Windows
e alguns produtos
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
Nós adotamos a biblioteca
FastAPI
para iniciar um servidor
REST
que pode ser consultado para obter
previsões
. [para o Ludwig]
"
Piero Molino, Yaroslav Dudin, e Sai Sumanth Miryala -
Uber
(ref)
"
A
Netflix
tem o prazer de anunciar o lançamento open-source do nosso framework de orquestração de
gerenciamento de crises
:
Dispatch
! [criado com
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Estou extremamente entusiasmado com o
FastAPI
. É tão divertido!
"
Brian Okken -
Python Bytes
podcaster
(ref)
"
Honestamente, o que você construiu parece super sólido e rebuscado. De muitas formas, eu queria que o
Hug
fosse assim - é realmente inspirador ver alguém que construiu ele.
"
Timothy Crosley -
criador do
Hug
(ref)
"
Se você está procurando aprender um
framework
moderno
para construir aplicações
REST
, dê uma olhada no
FastAPI
[...] É rápido, fácil de usar e fácil de aprender [...]
"
"
Nós trocamos nossas
APIs
por
FastAPI
[...] Acredito que vocês gostarão dele [...]
"
Ines Montani - Matthew Honnibal -
fundadores da
Explosion AI
- criadores da
spaCy
(ref)
-
(ref)
"
Se alguém estiver procurando construir uma API Python para produção, eu recomendaria fortemente o
FastAPI
. Ele é
lindamente projetado
,
simples de usar
e
altamente escalável
. Ele se tornou um
componente chave
para a nossa estratégia API first de desenvolvimento e está impulsionando diversas automações e serviços, como o nosso Virtual TAC Engineer.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, o FastAPI das interfaces de linhas de comando
Se você estiver construindo uma aplicação
CLI
para ser utilizada em um terminal ao invés de uma aplicação web, dê uma olhada no
Typer
.
Typer
é o irmão menor do FastAPI. E seu propósito é ser o
FastAPI das
CLIs
. ⌨️ 🚀
Requisitos
FastAPI está nos ombros de gigantes:
Starlette
para as partes web.
Pydantic
para a parte de dados.
Instalação
Crie e ative um
ambiente virtual
, e então instale o FastAPI:
fast →
pip install "fastapi[standard]"
restart ↻
Nota
: Certifique-se de que você colocou
"fastapi[standard]"
com aspas, para garantir que funcione em todos os terminais.
Exemplo
Crie
Crie um arquivo
main.py
com:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Ou use
async def
...
Se seu código utiliza
async
/
await
, use
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Nota
:
Se você não sabe, verifique a seção
"Com pressa?"
sobre
async
e
await
nas docs
.
Rode
Rode o servidor com:
fast →
fastapi dev main.py
╭────────── FastAPI CLI - Development mode ───────────╮
│ │
│ Serving at: http://127.0.0.1:8000 │
│ │
│ API docs: http://127.0.0.1:8000/docs │
│ │
│ Running in development mode, for production use: │
│ │
│ fastapi run │
│ │
╰─────────────────────────────────────────────────────╯
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
Sobre o comando
fastapi dev main.py
...
O comando
fastapi dev
lê o seu arquivo
main.py
, identifica o aplicativo
FastAPI
nele, e inicia um servidor usando o
Uvicorn
.
Por padrão, o
fastapi dev
iniciará com
auto-reload
habilitado para desenvolvimento local.
Você pode ler mais sobre isso na
documentação do FastAPI CLI
.
Verifique
Abra seu navegador em
http://127.0.0.1:8000/items/5?q=somequery
.
Você verá a resposta JSON como:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Você acabou de criar uma API que:
Recebe requisições HTTP nas
rotas
/
e
/items/{item_id}
.
Ambas
rotas
fazem
operações
GET
(também conhecido como
métodos
HTTP).
A
rota
/items/{item_id}
tem um
parâmetro de rota
item_id
que deve ser um
int
.
A
rota
/items/{item_id}
tem um
parâmetro query
q
str
opcional.
Documentação Interativa da API
Agora vá para
http://127.0.0.1:8000/docs
.
Você verá a documentação automática interativa da API (fornecida por
Swagger UI
):
Documentação Alternativa da API
E agora, vá para
http://127.0.0.1:8000/redoc
.
Você verá a documentação automática alternativa (fornecida por
ReDoc
):
Evoluindo o Exemplo
Agora modifique o arquivo
main.py
para receber um corpo para uma requisição
PUT
.
Declare o corpo utilizando tipos padrão Python, graças ao Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
O servidor
fastapi dev
deverá recarregar automaticamente.
Evoluindo a Documentação Interativa da API
Agora vá para
http://127.0.0.1:8000/docs
.
A documentação interativa da API será automaticamente atualizada, incluindo o novo corpo:
Clique no botão "Try it out", ele permitirá que você preencha os parâmetros e interaja diretamente com a API:
Então clique no botão "Execute", a interface do usuário irá se comunicar com a API, enviar os parâmetros, pegar os resultados e mostrá-los na tela:
Evoluindo a Documentação Alternativa da API
E agora, vá para
http://127.0.0.1:8000/redoc
.
A documentação alternativa também irá refletir o novo parâmetro da
query
e o corpo:
Recapitulando
Resumindo, você declara
uma vez
os tipos dos parâmetros, corpo etc. como parâmetros de função.
Você faz isso com os tipos padrão do Python moderno.
Você não terá que aprender uma nova sintaxe, métodos ou classes de uma biblioteca específica etc.
Apenas
Python
padrão.
Por exemplo, para um
int
:
item_id
:
int
ou para um modelo mais complexo,
Item
:
item
:
Item
...e com essa única declaração você tem:
Suporte ao Editor, incluindo:
Completação.
Verificação de tipos.
Validação de dados:
Erros automáticos e claros quando o dado é inválido.
Validação até para objetos JSON profundamente aninhados.
Conversão
de dados de entrada: vindo da rede para dados e tipos Python. Consegue ler:
JSON.
Parâmetros de rota.
Parâmetros de
query
.
Cookies
.
Cabeçalhos.
Formulários.
Arquivos.
Conversão
de dados de saída de tipos e dados Python para dados de rede (como JSON):
Converte tipos Python (
str
,
int
,
float
,
bool
,
list
etc).
Objetos
datetime
.
Objetos
UUID
.
Modelos de Banco de Dados.
...e muito mais.
Documentação interativa automática da API, incluindo 2 alternativas de interface de usuário:
Swagger UI.
ReDoc.
Voltando ao código do exemplo anterior,
FastAPI
irá:
Validar que existe um
item_id
na rota para requisições
GET
e
PUT
.
Validar que
item_id
é do tipo
int
para requisições
GET
e
PUT
.
Se não é validado, o cliente verá um útil, claro erro.
Verificar se existe um parâmetro de
query
opcional nomeado como
q
(como em
http://127.0.0.1:8000/items/foo?q=somequery
) para requisições
GET
.
Como o parâmetro
q
é declarado com
= None
, ele é opcional.
Sem o
None
ele poderia ser obrigatório (como o corpo no caso de
PUT
).
Para requisições
PUT
para
/items/{item_id}
, lerá o corpo como JSON e:
Verifica que tem um atributo obrigatório
name
que deve ser
str
.
Verifica que tem um atributo obrigatório
price
que deve ser
float
.
Verifica que tem an atributo opcional
is_offer
, que deve ser
bool
, se presente.
Tudo isso também funciona para objetos JSON profundamente aninhados.
Converter de e para JSON automaticamente.
Documentar tudo com OpenAPI, que poderá ser usado por:
Sistemas de documentação interativos.
Sistemas de clientes de geração de código automáticos, para muitas linguagens.
Fornecer diretamente 2 interfaces
web
de documentação interativa.
Nós apenas arranhamos a superfície, mas você já tem idéia de como tudo funciona.
Experimente mudar a seguinte linha:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...de:
...
"item_name"
:
item
.
name
...
...para:
...
"item_price"
:
item
.
price
...
...e veja como seu editor irá auto-completar os atributos e saberá os tipos:
Para um exemplo mais completo incluindo mais recursos, veja
Tutorial - Guia do Usuário
.
Alerta de Spoiler
: o tutorial - guia do usuário inclui:
Declaração de
parâmetetros
de diferentes lugares como:
cabeçalhos
,
cookies
,
campos de formulários
e
arquivos
.
Como configurar
Limitações de Validação
como
maximum_length
ou
regex
.
Um poderoso e fácil de usar sistema de
Injeção de Dependência
.
Segurança e autenticação, incluindo suporte para
OAuth2
com autenticação
JWT tokens
e
HTTP Basic
.
Técnicas mais avançadas (mas igualmente fáceis) para declaração de
modelos JSON profundamente aninhados
(graças ao Pydantic).
Integrações
GraphQL
com o
Strawberry
e outras bibliotecas.
Muitos recursos extras (graças ao Starlette) como:
WebSockets
testes extrememamente fáceis baseados em HTTPX e
pytest
CORS
Cookie Sessions
...e mais.
Performance
Testes de performance da
Independent TechEmpower
mostram aplicações
FastAPI
rodando sob Uvicorn como
um dos
frameworks
Python mais rápidos disponíveis
, somente atrás de Starlette e Uvicorn (utilizados internamente pelo FastAPI). (*)
Para entender mais sobre performance, veja a seção
Comparações
.
Dependências
O FastAPI depende do Pydantic e do Starlette.
Dependências
standard
Quando você instala o FastAPI com
pip install "fastapi[standard]"
, ele vêm com o grupo
standard
(padrão) de dependências opcionais:
Utilizado pelo Pydantic:
email-validator
- para validação de email.
Utilizado pelo Starlette:
httpx
- Obrigatório caso você queira utilizar o
TestClient
.
jinja2
- Obrigatório se você quer utilizar a configuração padrão de templates.
python-multipart
- Obrigatório se você deseja suporte a
"parsing"
de formulário, com
request.form()
.
Utilizado pelo FastAPI / Starlette:
uvicorn
- para o servidor que carrega e serve a sua aplicação. Isto inclui
uvicorn[standard]
, que inclui algumas dependências (e.g.
uvloop
) necessárias para servir em alta performance.
fastapi-cli
- que disponibiliza o comando
fastapi
.
Sem as dependências
standard
Se você não deseja incluir as dependências opcionais
standard
, você pode instalar utilizando
pip install fastapi
ao invés de
pip install "fastapi[standard]"
.
Dpendências opcionais adicionais
Existem algumas dependências adicionais que você pode querer instalar.
Dependências opcionais adicionais do Pydantic:
pydantic-settings
- para gerenciamento de configurações.
pydantic-extra-types
- tipos extras para serem utilizados com o Pydantic.
Dependências opcionais adicionais do FastAPI:
orjson
- Obrigatório se você deseja utilizar o
ORJSONResponse
.
ujson
- Obrigatório se você deseja utilizar o
UJSONResponse
.
Licença
Esse projeto é licenciado sob os termos da licença MIT.

## 081_PYTHON_TYPES
Python Types Intro¶
---

Python Types Intro
Python has support for optional "type hints" (also called "type annotations").
These
"type hints"
or annotations are a special syntax that allow declaring the
type
of a variable.
By declaring types for your variables, editors and tools can give you better support.
This is just a
quick tutorial / refresher
about Python type hints. It covers only the minimum necessary to use them with
FastAPI
... which is actually very little.
FastAPI
is all based on these type hints, they give it many advantages and benefits.
But even if you never use
FastAPI
, you would benefit from learning a bit about them.
Note
If you are a Python expert, and you already know everything about type hints, skip to the next chapter.
Motivation
Let's start with a simple example:
Python 3.8+
def
get_full_name
(
first_name
,
last_name
):
full_name
=
first_name
.
title
()
+
" "
+
last_name
.
title
()
return
full_name
print
(
get_full_name
(
"john"
,
"doe"
))
Calling this program outputs:
John Doe
The function does the following:
Takes a
first_name
and
last_name
.
Converts the first letter of each one to upper case with
title()
.
Concatenates
them with a space in the middle.
Python 3.8+
def
get_full_name
(
first_name
,
last_name
):
full_name
=
first_name
.
title
()
+
" "
+
last_name
.
title
()
return
full_name
print
(
get_full_name
(
"john"
,
"doe"
))
Edit it
It's a very simple program.
But now imagine that you were writing it from scratch.
At some point you would have started the definition of the function, you had the parameters ready...
But then you have to call "that method that converts the first letter to upper case".
Was it
upper
? Was it
uppercase
?
first_uppercase
?
capitalize
?
Then, you try with the old programmer's friend, editor autocompletion.
You type the first parameter of the function,
first_name
, then a dot (
.
) and then hit
Ctrl+Space
to trigger the completion.
But, sadly, you get nothing useful:
Add types
Let's modify a single line from the previous version.
We will change exactly this fragment, the parameters of the function, from:
first_name
,
last_name
to:
first_name
:
str
,
last_name
:
str
That's it.
Those are the "type hints":
Python 3.8+
def
get_full_name
(
first_name
:
str
,
last_name
:
str
):
full_name
=
first_name
.
title
()
+
" "
+
last_name
.
title
()
return
full_name
print
(
get_full_name
(
"john"
,
"doe"
))
That is not the same as declaring default values like would be with:
first_name
=
"john"
,
last_name
=
"doe"
It's a different thing.
We are using colons (
:
), not equals (
=
).
And adding type hints normally doesn't change what happens from what would happen without them.
But now, imagine you are again in the middle of creating that function, but with type hints.
At the same point, you try to trigger the autocomplete with
Ctrl+Space
and you see:
With that, you can scroll, seeing the options, until you find the one that "rings a bell":
More motivation
Check this function, it already has type hints:
Python 3.8+
def
get_name_with_age
(
name
:
str
,
age
:
int
):
name_with_age
=
name
+
" is this old: "
+
age
return
name_with_age
Because the editor knows the types of the variables, you don't only get completion, you also get error checks:
Now you know that you have to fix it, convert
age
to a string with
str(age)
:
Python 3.8+
def
get_name_with_age
(
name
:
str
,
age
:
int
):
name_with_age
=
name
+
" is this old: "
+
str
(
age
)
return
name_with_age
Declaring types
You just saw the main place to declare type hints. As function parameters.
This is also the main place you would use them with
FastAPI
.
Simple types
You can declare all the standard Python types, not only
str
.
You can use, for example:
int
float
bool
bytes
Python 3.8+
def
get_items
(
item_a
:
str
,
item_b
:
int
,
item_c
:
float
,
item_d
:
bool
,
item_e
:
bytes
):
return
item_a
,
item_b
,
item_c
,
item_d
,
item_d
,
item_e
Generic types with type parameters
There are some data structures that can contain other values, like
dict
,
list
,
set
and
tuple
. And the internal values can have their own type too.
These types that have internal types are called "
generic
" types. And it's possible to declare them, even with their internal types.
To declare those types and the internal types, you can use the standard Python module
typing
. It exists specifically to support these type hints.
Newer versions of Python
The syntax using
typing
is
compatible
with all versions, from Python 3.6 to the latest ones, including Python 3.9, Python 3.10, etc.
As Python advances,
newer versions
come with improved support for these type annotations and in many cases you won't even need to import and use the
typing
module to declare the type annotations.
If you can choose a more recent version of Python for your project, you will be able to take advantage of that extra simplicity.
In all the docs there are examples compatible with each version of Python (when there's a difference).
For example "
Python 3.6+
" means it's compatible with Python 3.6 or above (including 3.7, 3.8, 3.9, 3.10, etc). And "
Python 3.9+
" means it's compatible with Python 3.9 or above (including 3.10, etc).
If you can use the
latest versions of Python
, use the examples for the latest version, those will have the
best and simplest syntax
, for example, "
Python 3.10+
".
List
For example, let's define a variable to be a
list
of
str
.
Python 3.9+
Python 3.8+
Declare the variable, with the same colon (
:
) syntax.
As the type, put
list
.
As the list is a type that contains some internal types, you put them in square brackets:
def
process_items
(
items
:
list
[
str
]):
for
item
in
items
:
print
(
item
)
From
typing
, import
List
(with a capital
L
):
from
typing
import
List
def
process_items
(
items
:
List
[
str
]):
for
item
in
items
:
print
(
item
)
Declare the variable, with the same colon (
:
) syntax.
As the type, put the
List
that you imported from
typing
.
As the list is a type that contains some internal types, you put them in square brackets:
from
typing
import
List
def
process_items
(
items
:
List
[
str
]):
for
item
in
items
:
print
(
item
)
Info
Those internal types in the square brackets are called "type parameters".
In this case,
str
is the type parameter passed to
List
(or
list
in Python 3.9 and above).
That means: "the variable
items
is a
list
, and each of the items in this list is a
str
".
Tip
If you use Python 3.9 or above, you don't have to import
List
from
typing
, you can use the same regular
list
type instead.
By doing that, your editor can provide support even while processing items from the list:
Without types, that's almost impossible to achieve.
Notice that the variable
item
is one of the elements in the list
items
.
And still, the editor knows it is a
str
, and provides support for that.
Tuple and Set
You would do the same to declare
tuple
s and
set
s:
Python 3.9+
Python 3.8+
def
process_items
(
items_t
:
tuple
[
int
,
int
,
str
],
items_s
:
set
[
bytes
]):
return
items_t
,
items_s
from
typing
import
Set
,
Tuple
def
process_items
(
items_t
:
Tuple
[
int
,
int
,
str
],
items_s
:
Set
[
bytes
]):
return
items_t
,
items_s
This means:
The variable
items_t
is a
tuple
with 3 items, an
int
, another
int
, and a
str
.
The variable
items_s
is a
set
, and each of its items is of type
bytes
.
Dict
To define a
dict
, you pass 2 type parameters, separated by commas.
The first type parameter is for the keys of the
dict
.
The second type parameter is for the values of the
dict
:
Python 3.9+
Python 3.8+
def
process_items
(
prices
:
dict
[
str
,
float
]):
for
item_name
,
item_price
in
prices
.
items
():
print
(
item_name
)
print
(
item_price
)
from
typing
import
Dict
def
process_items
(
prices
:
Dict
[
str
,
float
]):
for
item_name
,
item_price
in
prices
.
items
():
print
(
item_name
)
print
(
item_price
)
This means:
The variable
prices
is a
dict
:
The keys of this
dict
are of type
str
(let's say, the name of each item).
The values of this
dict
are of type
float
(let's say, the price of each item).
Union
You can declare that a variable can be any of
several types
, for example, an
int
or a
str
.
In Python 3.6 and above (including Python 3.10) you can use the
Union
type from
typing
and put inside the square brackets the possible types to accept.
In Python 3.10 there's also a
new syntax
where you can put the possible types separated by a
vertical bar (
|
)
.
Python 3.10+
Python 3.8+
def
process_item
(
item
:
int
|
str
):
print
(
item
)
from
typing
import
Union
def
process_item
(
item
:
Union
[
int
,
str
]):
print
(
item
)
In both cases this means that
item
could be an
int
or a
str
.
Possibly
None
You can declare that a value could have a type, like
str
, but that it could also be
None
.
In Python 3.6 and above (including Python 3.10) you can declare it by importing and using
Optional
from the
typing
module.
from
typing
import
Optional
def
say_hi
(
name
:
Optional
[
str
]
=
None
):
if
name
is
not
None
:
print
(
f
"Hey
{
name
}
!"
)
else
:
print
(
"Hello World"
)
Using
Optional[str]
instead of just
str
will let the editor help you detect errors where you could be assuming that a value is always a
str
, when it could actually be
None
too.
Optional[Something]
is actually a shortcut for
Union[Something, None]
, they are equivalent.
This also means that in Python 3.10, you can use
Something | None
:
Python 3.10+
Python 3.8+
Python 3.8+ alternative
def
say_hi
(
name
:
str
|
None
=
None
):
if
name
is
not
None
:
print
(
f
"Hey
{
name
}
!"
)
else
:
print
(
"Hello World"
)
from
typing
import
Optional
def
say_hi
(
name
:
Optional
[
str
]
=
None
):
if
name
is
not
None
:
print
(
f
"Hey
{
name
}
!"
)
else
:
print
(
"Hello World"
)
from
typing
import
Union
def
say_hi
(
name
:
Union
[
str
,
None
]
=
None
):
if
name
is
not
None
:
print
(
f
"Hey
{
name
}
!"
)
else
:
print
(
"Hello World"
)
Using
Union
or
Optional
If you are using a Python version below 3.10, here's a tip from my very
subjective
point of view:
🚨 Avoid using
Optional[SomeType]
Instead ✨
use
Union[SomeType, None]
✨.
Both are equivalent and underneath they are the same, but I would recommend
Union
instead of
Optional
because the word "
optional
" would seem to imply that the value is optional, and it actually means "it can be
None
", even if it's not optional and is still required.
I think
Union[SomeType, None]
is more explicit about what it means.
It's just about the words and names. But those words can affect how you and your teammates think about the code.
As an example, let's take this function:
Python 3.8+
from
typing
import
Optional
def
say_hi
(
name
:
Optional
[
str
]):
print
(
f
"Hey
{
name
}
!"
)
🤓 Other versions and variants
Python 3.10+
def
say_hi
(
name
:
str
|
None
):
print
(
f
"Hey
{
name
}
!"
)
The parameter
name
is defined as
Optional[str]
, but it is
not optional
, you cannot call the function without the parameter:
say_hi
()
## Oh, no, this throws an error! 😱
The
name
parameter is
still required
(not
optional
) because it doesn't have a default value. Still,
name
accepts
None
as the value:
say_hi
(
name
=
None
)
## This works, None is valid 🎉
The good news is, once you are on Python 3.10 you won't have to worry about that, as you will be able to simply use
|
to define unions of types:
Python 3.10+
def
say_hi
(
name
:
str
|
None
):
print
(
f
"Hey
{
name
}
!"
)
🤓 Other versions and variants
Python 3.8+
from
typing
import
Optional
def
say_hi
(
name
:
Optional
[
str
]):
print
(
f
"Hey
{
name
}
!"
)
And then you won't have to worry about names like
Optional
and
Union
. 😎
Generic types
These types that take type parameters in square brackets are called
Generic types
or
Generics
, for example:
Python 3.10+
Python 3.9+
Python 3.8+
You can use the same builtin types as generics (with square brackets and types inside):
list
tuple
set
dict
And the same as with Python 3.8, from the
typing
module:
Union
Optional
(the same as with Python 3.8)
...and others.
In Python 3.10, as an alternative to using the generics
Union
and
Optional
, you can use the
vertical bar (
|
)
to declare unions of types, that's a lot better and simpler.
You can use the same builtin types as generics (with square brackets and types inside):
list
tuple
set
dict
And the same as with Python 3.8, from the
typing
module:
Union
Optional
...and others.
List
Tuple
Set
Dict
Union
Optional
...and others.
Classes as types
You can also declare a class as the type of a variable.
Let's say you have a class
Person
, with a name:
Python 3.8+
class
Person
:
def
__init__
(
self
,
name
:
str
):
self
.
name
=
name
def
get_person_name
(
one_person
:
Person
):
return
one_person
.
name
Then you can declare a variable to be of type
Person
:
Python 3.8+
class
Person
:
def
__init__
(
self
,
name
:
str
):
self
.
name
=
name
def
get_person_name
(
one_person
:
Person
):
return
one_person
.
name
And then, again, you get all the editor support:
Notice that this means "
one_person
is an
instance
of the class
Person
".
It doesn't mean "
one_person
is the
class
called
Person
".
Pydantic models
Pydantic
is a Python library to perform data validation.
You declare the "shape" of the data as classes with attributes.
And each attribute has a type.
Then you create an instance of that class with some values and it will validate the values, convert them to the appropriate type (if that's the case) and give you an object with all the data.
And you get all the editor support with that resulting object.
An example from the official Pydantic docs:
Python 3.10+
Python 3.9+
Python 3.8+
from
datetime
import
datetime
from
pydantic
import
BaseModel
class
User
(
BaseModel
):
id
:
int
name
:
str
=
"John Doe"
signup_ts
:
datetime
|
None
=
None
friends
:
list
[
int
]
=
[]
external_data
=
{
"id"
:
"123"
,
"signup_ts"
:
"2017-06-01 12:22"
,
"friends"
:
[
1
,
"2"
,
b
"3"
],
}
user
=
User
(
**
external_data
)
print
(
user
)
## > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print
(
user
.
id
)
## > 123
from
datetime
import
datetime
from
typing
import
Union
from
pydantic
import
BaseModel
class
User
(
BaseModel
):
id
:
int
name
:
str
=
"John Doe"
signup_ts
:
Union
[
datetime
,
None
]
=
None
friends
:
list
[
int
]
=
[]
external_data
=
{
"id"
:
"123"
,
"signup_ts"
:
"2017-06-01 12:22"
,
"friends"
:
[
1
,
"2"
,
b
"3"
],
}
user
=
User
(
**
external_data
)
print
(
user
)
## > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print
(
user
.
id
)
## > 123
from
datetime
import
datetime
from
typing
import
List
,
Union
from
pydantic
import
BaseModel
class
User
(
BaseModel
):
id
:
int
name
:
str
=
"John Doe"
signup_ts
:
Union
[
datetime
,
None
]
=
None
friends
:
List
[
int
]
=
[]
external_data
=
{
"id"
:
"123"
,
"signup_ts"
:
"2017-06-01 12:22"
,
"friends"
:
[
1
,
"2"
,
b
"3"
],
}
user
=
User
(
**
external_data
)
print
(
user
)
## > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print
(
user
.
id
)
## > 123
Info
To learn more about
Pydantic, check its docs
.
FastAPI
is all based on Pydantic.
You will see a lot more of all this in practice in the
Tutorial - User Guide
.
Tip
Pydantic has a special behavior when you use
Optional
or
Union[Something, None]
without a default value, you can read more about it in the Pydantic docs about
Required Optional fields
.
Type Hints with Metadata Annotations
Python also has a feature that allows putting
additional
metadata
in these type hints using
Annotated
.
Python 3.9+
Python 3.8+
In Python 3.9,
Annotated
is part of the standard library, so you can import it from
typing
.
from
typing
import
Annotated
def
say_hello
(
name
:
Annotated
[
str
,
"this is just metadata"
])
->
str
:
return
f
"Hello
{
name
}
"
In versions below Python 3.9, you import
Annotated
from
typing_extensions
.
It will already be installed with
FastAPI
.
from
typing_extensions
import
Annotated
def
say_hello
(
name
:
Annotated
[
str
,
"this is just metadata"
])
->
str
:
return
f
"Hello
{
name
}
"
Python itself doesn't do anything with this
Annotated
. And for editors and other tools, the type is still
str
.
But you can use this space in
Annotated
to provide
FastAPI
with additional metadata about how you want your application to behave.
The important thing to remember is that
the first
type parameter
you pass to
Annotated
is the
actual type
. The rest, is just metadata for other tools.
For now, you just need to know that
Annotated
exists, and that it's standard Python. 😎
Later you will see how
powerful
it can be.
Tip
The fact that this is
standard Python
means that you will still get the
best possible developer experience
in your editor, with the tools you use to analyze and refactor your code, etc. ✨
And also that your code will be very compatible with many other Python tools and libraries. 🚀
Type hints in
FastAPI
FastAPI
takes advantage of these type hints to do several things.
With
FastAPI
you declare parameters with type hints and you get:
Editor support
.
Type checks
.
...and
FastAPI
uses the same declarations to:
Define requirements
: from request path parameters, query parameters, headers, bodies, dependencies, etc.
Convert data
: from the request to the required type.
Validate data
: coming from each request:
Generating
automatic errors
returned to the client when the data is invalid.
Document
the API using OpenAPI:
which is then used by the automatic interactive documentation user interfaces.
This might all sound abstract. Don't worry. You'll see all this in action in the
Tutorial - User Guide
.
The important thing is that by using standard Python types, in a single place (instead of adding more classes, decorators, etc),
FastAPI
will do a lot of the work for you.
Info
If you already went through all the tutorial and came back to see more about types, a good resource is
the "cheat sheet" from
mypy
.

## 082_REFERENCE
Reference¶
---

Reference
Here's the reference or code API, the classes, functions, parameters, attributes, and
all the FastAPI parts you can use in your applications.
If you want to
learn FastAPI
you are much better off reading the
FastAPI Tutorial
.

## 083_REFERENCE_APIROUTER
APIRouterclass¶
---

APIRouter
class
Here's the reference information for the
APIRouter
class, with all its parameters, attributes and methods.
You can import the
APIRouter
class directly from
fastapi
:
from
fastapi
import
APIRouter
fastapi.APIRouter
APIRouter
(
*
,
prefix
=
""
,
tags
=
None
,
dependencies
=
None
,
default_response_class
=
Default
(
JSONResponse
),
responses
=
None
,
callbacks
=
None
,
routes
=
None
,
redirect_slashes
=
True
,
default
=
None
,
dependency_overrides_provider
=
None
,
route_class
=
APIRoute
,
on_startup
=
None
,
on_shutdown
=
None
,
lifespan
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Bases:
Router
APIRouter
class, used to group
path operations
, for example to structure
an app in multiple files. It would then be included in the
FastAPI
app, or
in another
APIRouter
(ultimately included in the app).
Read more about it in the
FastAPI docs for Bigger Applications - Multiple Files
.
Example
from
fastapi
import
APIRouter
,
FastAPI
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
prefix
An optional path prefix for the router.
TYPE:
str
DEFAULT:
''
tags
A list of tags to be applied to all the
path operations
in this
router.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to all the
path operations
in this router.
Read more about it in the
FastAPI docs for Bigger Applications - Multiple Files
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
default_response_class
The default response class to be used.
Read more in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
responses
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Additional Responses in OpenAPI
.
And in the
FastAPI docs for Bigger Applications
.
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
callbacks
OpenAPI callbacks that should apply to all
path operations
in this
router.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
routes
Note
: you probably shouldn't use this parameter, it is inherited
from Starlette and supported for compatibility.
A list of routes to serve incoming HTTP and WebSocket requests.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
redirect_slashes
Whether to detect and redirect slashes in URLs when the client doesn't
use the same format.
TYPE:
bool
DEFAULT:
True
default
Default function handler for this router. Used to handle
404 Not Found errors.
TYPE:
Optional
[
ASGIApp
]
DEFAULT:
None
dependency_overrides_provider
Only used internally by FastAPI to handle dependency overrides.
You shouldn't need to use it. It normally points to the
FastAPI
app
object.
TYPE:
Optional
[
Any
]
DEFAULT:
None
route_class
Custom route (
path operation
) class to be used by this router.
Read more about it in the
FastAPI docs for Custom Request and APIRoute class
.
TYPE:
Type
[
APIRoute
]
DEFAULT:
APIRoute
on_startup
A list of startup event handler functions.
You should instead use the
lifespan
handlers.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Sequence
[
Callable
[[],
Any
]]]
DEFAULT:
None
on_shutdown
A list of shutdown event handler functions.
You should instead use the
lifespan
handlers.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Sequence
[
Callable
[[],
Any
]]]
DEFAULT:
None
lifespan
A
Lifespan
context manager handler. This replaces
startup
and
shutdown
functions with a single context manager.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Lifespan
[
Any
]]
DEFAULT:
None
deprecated
Mark all
path operations
in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
bool
]
DEFAULT:
None
include_in_schema
To include (or not) all the
path operations
in this router in the
generated OpenAPI.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812
813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
def
__init__
(
self
,
*
,
prefix
:
Annotated
[
str
,
Doc
(
"An optional path prefix for the router."
)]
=
""
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to all the *path operations* in this
router.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to all the
*path operations* in this router.
Read more about it in the
[FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
default_response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
The default response class to be used.
Read more in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
"""
),
]
=
Default
(
JSONResponse
),
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
And in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
OpenAPI callbacks that should apply to all *path operations* in this
router.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
routes
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
**Note**: you probably shouldn't use this parameter, it is inherited
from Starlette and supported for compatibility.
---
A list of routes to serve incoming HTTP and WebSocket requests.
"""
),
deprecated
(
"""
You normally wouldn't use this parameter with FastAPI, it is inherited
from Starlette and supported for compatibility.
In FastAPI, you normally would use the *path operation methods*,
like `router.get()`, `router.post()`, etc.
"""
),
]
=
None
,
redirect_slashes
:
Annotated
[
bool
,
Doc
(
"""
Whether to detect and redirect slashes in URLs when the client doesn't
use the same format.
"""
),
]
=
True
,
default
:
Annotated
[
Optional
[
ASGIApp
],
Doc
(
"""
Default function handler for this router. Used to handle
404 Not Found errors.
"""
),
]
=
None
,
dependency_overrides_provider
:
Annotated
[
Optional
[
Any
],
Doc
(
"""
Only used internally by FastAPI to handle dependency overrides.
You shouldn't need to use it. It normally points to the `FastAPI` app
object.
"""
),
]
=
None
,
route_class
:
Annotated
[
Type
[
APIRoute
],
Doc
(
"""
Custom route (*path operation*) class to be used by this router.
Read more about it in the
[FastAPI docs for Custom Request and APIRoute class](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#custom-apiroute-class-in-a-router).
"""
),
]
=
APIRoute
,
on_startup
:
Annotated
[
Optional
[
Sequence
[
Callable
[[],
Any
]]],
Doc
(
"""
A list of startup event handler functions.
You should instead use the `lifespan` handlers.
Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
on_shutdown
:
Annotated
[
Optional
[
Sequence
[
Callable
[[],
Any
]]],
Doc
(
"""
A list of shutdown event handler functions.
You should instead use the `lifespan` handlers.
Read more in the
[FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
## the generic to Lifespan[AppType] is the type of the top level application
## which the router cannot know statically, so we use typing.Any
lifespan
:
Annotated
[
Optional
[
Lifespan
[
Any
]],
Doc
(
"""
A `Lifespan` context manager handler. This replaces `startup` and
`shutdown` functions with a single context manager.
Read more in the
[FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark all *path operations* in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) all the *path operations* in this router in the
generated OpenAPI.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
None
:
super
()
.
__init__
(
routes
=
routes
,
redirect_slashes
=
redirect_slashes
,
default
=
default
,
on_startup
=
on_startup
,
on_shutdown
=
on_shutdown
,
lifespan
=
lifespan
,
)
if
prefix
:
assert
prefix
.
startswith
(
"/"
),
"A path prefix must start with '/'"
assert
not
prefix
.
endswith
(
"/"
),
(
"A path prefix must not end with '/', as the routes will start with '/'"
)
self
.
prefix
=
prefix
self
.
tags
:
List
[
Union
[
str
,
Enum
]]
=
tags
or
[]
self
.
dependencies
=
list
(
dependencies
or
[])
self
.
deprecated
=
deprecated
self
.
include_in_schema
=
include_in_schema
self
.
responses
=
responses
or
{}
self
.
callbacks
=
callbacks
or
[]
self
.
dependency_overrides_provider
=
dependency_overrides_provider
self
.
route_class
=
route_class
self
.
default_response_class
=
default_response_class
self
.
generate_unique_id_function
=
generate_unique_id_function
websocket
websocket
(
path
,
name
=
None
,
*
,
dependencies
=
None
)
Decorate a WebSocket function.
Read more about it in the
FastAPI docs for WebSockets
.
Example
Example
from
fastapi
import
APIRouter
,
FastAPI
,
WebSocket
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
websocket
(
"/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
"
)
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
WebSocket path.
TYPE:
str
name
A name for the WebSocket. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be used for this
WebSocket.
Read more about it in the
FastAPI docs for WebSockets
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
Source code in
fastapi/routing.py
1046
1047
1048
1049
1050
1051
1052
1053
1054
1055
1056
1057
1058
1059
1060
1061
1062
1063
1064
1065
1066
1067
1068
1069
1070
1071
1072
1073
1074
1075
1076
1077
1078
1079
1080
1081
1082
1083
1084
1085
1086
1087
1088
1089
1090
1091
1092
1093
1094
1095
1096
1097
1098
1099
1100
1101
1102
1103
1104
1105
1106
1107
1108
1109
1110
1111
def
websocket
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
WebSocket path.
"""
),
],
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A name for the WebSocket. Only used internally.
"""
),
]
=
None
,
*
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be used for this
WebSocket.
Read more about it in the
[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
"""
),
]
=
None
,
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Decorate a WebSocket function.
Read more about it in the
[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
**Example**
## Example
```python
from fastapi import APIRouter, FastAPI, WebSocket
app = FastAPI()
router = APIRouter()
@router.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
await websocket.accept()
while True:
data = await websocket.receive_text()
await websocket.send_text(f"Message text was: {data}")
app.include_router(router)
```
"""
def
decorator
(
func
:
DecoratedCallable
)
->
DecoratedCallable
:
self
.
add_api_websocket_route
(
path
,
func
,
name
=
name
,
dependencies
=
dependencies
)
return
func
return
decorator
include_router
include_router
(
router
,
*
,
prefix
=
""
,
tags
=
None
,
dependencies
=
None
,
default_response_class
=
Default
(
JSONResponse
),
responses
=
None
,
callbacks
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Include another
APIRouter
in the same current
APIRouter
.
Read more about it in the
FastAPI docs for Bigger Applications
.
Example
from
fastapi
import
APIRouter
,
FastAPI
app
=
FastAPI
()
internal_router
=
APIRouter
()
users_router
=
APIRouter
()
@users_router
.
get
(
"/users/"
)
def
read_users
():
return
[{
"name"
:
"Rick"
},
{
"name"
:
"Morty"
}]
internal_router
.
include_router
(
users_router
)
app
.
include_router
(
internal_router
)
PARAMETER
DESCRIPTION
router
The
APIRouter
to include.
TYPE:
APIRouter
prefix
An optional path prefix for the router.
TYPE:
str
DEFAULT:
''
tags
A list of tags to be applied to all the
path operations
in this
router.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to all the
path operations
in this router.
Read more about it in the
FastAPI docs for Bigger Applications - Multiple Files
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
default_response_class
The default response class to be used.
Read more in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
responses
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Additional Responses in OpenAPI
.
And in the
FastAPI docs for Bigger Applications
.
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
callbacks
OpenAPI callbacks that should apply to all
path operations
in this
router.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
deprecated
Mark all
path operations
in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
bool
]
DEFAULT:
None
include_in_schema
Include (or not) all the
path operations
in this router in the
generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
1122
1123
1124
1125
1126
1127
1128
1129
1130
1131
1132
1133
1134
1135
1136
1137
1138
1139
1140
1141
1142
1143
1144
1145
1146
1147
1148
1149
1150
1151
1152
1153
1154
1155
1156
1157
1158
1159
1160
1161
1162
1163
1164
1165
1166
1167
1168
1169
1170
1171
1172
1173
1174
1175
1176
1177
1178
1179
1180
1181
1182
1183
1184
1185
1186
1187
1188
1189
1190
1191
1192
1193
1194
1195
1196
1197
1198
1199
1200
1201
1202
1203
1204
1205
1206
1207
1208
1209
1210
1211
1212
1213
1214
1215
1216
1217
1218
1219
1220
1221
1222
1223
1224
1225
1226
1227
1228
1229
1230
1231
1232
1233
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243
1244
1245
1246
1247
1248
1249
1250
1251
1252
1253
1254
1255
1256
1257
1258
1259
1260
1261
1262
1263
1264
1265
1266
1267
1268
1269
1270
1271
1272
1273
1274
1275
1276
1277
1278
1279
1280
1281
1282
1283
1284
1285
1286
1287
1288
1289
1290
1291
1292
1293
1294
1295
1296
1297
1298
1299
1300
1301
1302
1303
1304
1305
1306
1307
1308
1309
1310
1311
1312
1313
1314
1315
1316
1317
1318
1319
1320
1321
1322
1323
1324
1325
1326
1327
1328
1329
1330
1331
1332
1333
1334
1335
1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352
1353
1354
1355
1356
1357
1358
1359
1360
1361
1362
1363
1364
def
include_router
(
self
,
router
:
Annotated
[
"APIRouter"
,
Doc
(
"The `APIRouter` to include."
)],
*
,
prefix
:
Annotated
[
str
,
Doc
(
"An optional path prefix for the router."
)]
=
""
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to all the *path operations* in this
router.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to all the
*path operations* in this router.
Read more about it in the
[FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
default_response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
The default response class to be used.
Read more in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
"""
),
]
=
Default
(
JSONResponse
),
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
And in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
OpenAPI callbacks that should apply to all *path operations* in this
router.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark all *path operations* in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include (or not) all the *path operations* in this router in the
generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
None
:
"""
Include another `APIRouter` in the same current `APIRouter`.
Read more about it in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).
## Example
```python
from fastapi import APIRouter, FastAPI
app = FastAPI()
internal_router = APIRouter()
users_router = APIRouter()
@users_router.get("/users/")
def read_users():
return [{"name": "Rick"}, {"name": "Morty"}]
internal_router.include_router(users_router)
app.include_router(internal_router)
```
"""
if
prefix
:
assert
prefix
.
startswith
(
"/"
),
"A path prefix must start with '/'"
assert
not
prefix
.
endswith
(
"/"
),
(
"A path prefix must not end with '/', as the routes will start with '/'"
)
else
:
for
r
in
router
.
routes
:
path
=
getattr
(
r
,
"path"
)
## noqa: B009
name
=
getattr
(
r
,
"name"
,
"unknown"
)
if
path
is
not
None
and
not
path
:
raise
FastAPIError
(
f
"Prefix and path cannot be both empty (path operation:
{
name
}
)"
)
if
responses
is
None
:
responses
=
{}
for
route
in
router
.
routes
:
if
isinstance
(
route
,
APIRoute
):
combined_responses
=
{
**
responses
,
**
route
.
responses
}
use_response_class
=
get_value_or_default
(
route
.
response_class
,
router
.
default_response_class
,
default_response_class
,
self
.
default_response_class
,
)
current_tags
=
[]
if
tags
:
current_tags
.
extend
(
tags
)
if
route
.
tags
:
current_tags
.
extend
(
route
.
tags
)
current_dependencies
:
List
[
params
.
Depends
]
=
[]
if
dependencies
:
current_dependencies
.
extend
(
dependencies
)
if
route
.
dependencies
:
current_dependencies
.
extend
(
route
.
dependencies
)
current_callbacks
=
[]
if
callbacks
:
current_callbacks
.
extend
(
callbacks
)
if
route
.
callbacks
:
current_callbacks
.
extend
(
route
.
callbacks
)
current_generate_unique_id
=
get_value_or_default
(
route
.
generate_unique_id_function
,
router
.
generate_unique_id_function
,
generate_unique_id_function
,
self
.
generate_unique_id_function
,
)
self
.
add_api_route
(
prefix
+
route
.
path
,
route
.
endpoint
,
response_model
=
route
.
response_model
,
status_code
=
route
.
status_code
,
tags
=
current_tags
,
dependencies
=
current_dependencies
,
summary
=
route
.
summary
,
description
=
route
.
description
,
response_description
=
route
.
response_description
,
responses
=
combined_responses
,
deprecated
=
route
.
deprecated
or
deprecated
or
self
.
deprecated
,
methods
=
route
.
methods
,
operation_id
=
route
.
operation_id
,
response_model_include
=
route
.
response_model_include
,
response_model_exclude
=
route
.
response_model_exclude
,
response_model_by_alias
=
route
.
response_model_by_alias
,
response_model_exclude_unset
=
route
.
response_model_exclude_unset
,
response_model_exclude_defaults
=
route
.
response_model_exclude_defaults
,
response_model_exclude_none
=
route
.
response_model_exclude_none
,
include_in_schema
=
route
.
include_in_schema
and
self
.
include_in_schema
and
include_in_schema
,
response_class
=
use_response_class
,
name
=
route
.
name
,
route_class_override
=
type
(
route
),
callbacks
=
current_callbacks
,
openapi_extra
=
route
.
openapi_extra
,
generate_unique_id_function
=
current_generate_unique_id
,
)
elif
isinstance
(
route
,
routing
.
Route
):
methods
=
list
(
route
.
methods
or
[])
self
.
add_route
(
prefix
+
route
.
path
,
route
.
endpoint
,
methods
=
methods
,
include_in_schema
=
route
.
include_in_schema
,
name
=
route
.
name
,
)
elif
isinstance
(
route
,
APIWebSocketRoute
):
current_dependencies
=
[]
if
dependencies
:
current_dependencies
.
extend
(
dependencies
)
if
route
.
dependencies
:
current_dependencies
.
extend
(
route
.
dependencies
)
self
.
add_api_websocket_route
(
prefix
+
route
.
path
,
route
.
endpoint
,
dependencies
=
current_dependencies
,
name
=
route
.
name
,
)
elif
isinstance
(
route
,
routing
.
WebSocketRoute
):
self
.
add_websocket_route
(
prefix
+
route
.
path
,
route
.
endpoint
,
name
=
route
.
name
)
for
handler
in
router
.
on_startup
:
self
.
add_event_handler
(
"startup"
,
handler
)
for
handler
in
router
.
on_shutdown
:
self
.
add_event_handler
(
"shutdown"
,
handler
)
self
.
lifespan_context
=
_merge_lifespan_context
(
self
.
lifespan_context
,
router
.
lifespan_context
,
)
get
get
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP GET operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
get
(
"/items/"
)
def
read_items
():
return
[{
"name"
:
"Empanada"
},
{
"name"
:
"Arepa"
}]
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
1366
1367
1368
1369
1370
1371
1372
1373
1374
1375
1376
1377
1378
1379
1380
1381
1382
1383
1384
1385
1386
1387
1388
1389
1390
1391
1392
1393
1394
1395
1396
1397
1398
1399
1400
1401
1402
1403
1404
1405
1406
1407
1408
1409
1410
1411
1412
1413
1414
1415
1416
1417
1418
1419
1420
1421
1422
1423
1424
1425
1426
1427
1428
1429
1430
1431
1432
1433
1434
1435
1436
1437
1438
1439
1440
1441
1442
1443
1444
1445
1446
1447
1448
1449
1450
1451
1452
1453
1454
1455
1456
1457
1458
1459
1460
1461
1462
1463
1464
1465
1466
1467
1468
1469
1470
1471
1472
1473
1474
1475
1476
1477
1478
1479
1480
1481
1482
1483
1484
1485
1486
1487
1488
1489
1490
1491
1492
1493
1494
1495
1496
1497
1498
1499
1500
1501
1502
1503
1504
1505
1506
1507
1508
1509
1510
1511
1512
1513
1514
1515
1516
1517
1518
1519
1520
1521
1522
1523
1524
1525
1526
1527
1528
1529
1530
1531
1532
1533
1534
1535
1536
1537
1538
1539
1540
1541
1542
1543
1544
1545
1546
1547
1548
1549
1550
1551
1552
1553
1554
1555
1556
1557
1558
1559
1560
1561
1562
1563
1564
1565
1566
1567
1568
1569
1570
1571
1572
1573
1574
1575
1576
1577
1578
1579
1580
1581
1582
1583
1584
1585
1586
1587
1588
1589
1590
1591
1592
1593
1594
1595
1596
1597
1598
1599
1600
1601
1602
1603
1604
1605
1606
1607
1608
1609
1610
1611
1612
1613
1614
1615
1616
1617
1618
1619
1620
1621
1622
1623
1624
1625
1626
1627
1628
1629
1630
1631
1632
1633
1634
1635
1636
1637
1638
1639
1640
1641
1642
1643
1644
1645
1646
1647
1648
1649
1650
1651
1652
1653
1654
1655
1656
1657
1658
1659
1660
1661
1662
1663
1664
1665
1666
1667
1668
1669
1670
1671
1672
1673
1674
1675
1676
1677
1678
1679
1680
1681
1682
1683
1684
1685
1686
1687
1688
1689
1690
1691
1692
1693
1694
1695
1696
1697
1698
1699
1700
1701
1702
1703
1704
1705
1706
1707
1708
1709
1710
1711
1712
1713
1714
1715
1716
1717
1718
1719
1720
1721
1722
1723
1724
1725
1726
1727
1728
1729
1730
1731
1732
1733
1734
1735
1736
1737
1738
1739
1740
1741
def
get
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP GET operation.
## Example
```python
from fastapi import APIRouter, FastAPI
app = FastAPI()
router = APIRouter()
@router.get("/items/")
def read_items():
return [{"name": "Empanada"}, {"name": "Arepa"}]
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"GET"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
put
put
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP PUT operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
put
(
"/items/
{item_id}
"
)
def
replace_item
(
item_id
:
str
,
item
:
Item
):
return
{
"message"
:
"Item replaced"
,
"id"
:
item_id
}
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
1743
1744
1745
1746
1747
1748
1749
1750
1751
1752
1753
1754
1755
1756
1757
1758
1759
1760
1761
1762
1763
1764
1765
1766
1767
1768
1769
1770
1771
1772
1773
1774
1775
1776
1777
1778
1779
1780
1781
1782
1783
1784
1785
1786
1787
1788
1789
1790
1791
1792
1793
1794
1795
1796
1797
1798
1799
1800
1801
1802
1803
1804
1805
1806
1807
1808
1809
1810
1811
1812
1813
1814
1815
1816
1817
1818
1819
1820
1821
1822
1823
1824
1825
1826
1827
1828
1829
1830
1831
1832
1833
1834
1835
1836
1837
1838
1839
1840
1841
1842
1843
1844
1845
1846
1847
1848
1849
1850
1851
1852
1853
1854
1855
1856
1857
1858
1859
1860
1861
1862
1863
1864
1865
1866
1867
1868
1869
1870
1871
1872
1873
1874
1875
1876
1877
1878
1879
1880
1881
1882
1883
1884
1885
1886
1887
1888
1889
1890
1891
1892
1893
1894
1895
1896
1897
1898
1899
1900
1901
1902
1903
1904
1905
1906
1907
1908
1909
1910
1911
1912
1913
1914
1915
1916
1917
1918
1919
1920
1921
1922
1923
1924
1925
1926
1927
1928
1929
1930
1931
1932
1933
1934
1935
1936
1937
1938
1939
1940
1941
1942
1943
1944
1945
1946
1947
1948
1949
1950
1951
1952
1953
1954
1955
1956
1957
1958
1959
1960
1961
1962
1963
1964
1965
1966
1967
1968
1969
1970
1971
1972
1973
1974
1975
1976
1977
1978
1979
1980
1981
1982
1983
1984
1985
1986
1987
1988
1989
1990
1991
1992
1993
1994
1995
1996
1997
1998
1999
2000
2001
2002
2003
2004
2005
2006
2007
2008
2009
2010
2011
2012
2013
2014
2015
2016
2017
2018
2019
2020
2021
2022
2023
2024
2025
2026
2027
2028
2029
2030
2031
2032
2033
2034
2035
2036
2037
2038
2039
2040
2041
2042
2043
2044
2045
2046
2047
2048
2049
2050
2051
2052
2053
2054
2055
2056
2057
2058
2059
2060
2061
2062
2063
2064
2065
2066
2067
2068
2069
2070
2071
2072
2073
2074
2075
2076
2077
2078
2079
2080
2081
2082
2083
2084
2085
2086
2087
2088
2089
2090
2091
2092
2093
2094
2095
2096
2097
2098
2099
2100
2101
2102
2103
2104
2105
2106
2107
2108
2109
2110
2111
2112
2113
2114
2115
2116
2117
2118
2119
2120
2121
2122
2123
def
put
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP PUT operation.
## Example
```python
from fastapi import APIRouter, FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
router = APIRouter()
@router.put("/items/{item_id}")
def replace_item(item_id: str, item: Item):
return {"message": "Item replaced", "id": item_id}
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"PUT"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
post
post
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP POST operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item created"
}
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
2125
2126
2127
2128
2129
2130
2131
2132
2133
2134
2135
2136
2137
2138
2139
2140
2141
2142
2143
2144
2145
2146
2147
2148
2149
2150
2151
2152
2153
2154
2155
2156
2157
2158
2159
2160
2161
2162
2163
2164
2165
2166
2167
2168
2169
2170
2171
2172
2173
2174
2175
2176
2177
2178
2179
2180
2181
2182
2183
2184
2185
2186
2187
2188
2189
2190
2191
2192
2193
2194
2195
2196
2197
2198
2199
2200
2201
2202
2203
2204
2205
2206
2207
2208
2209
2210
2211
2212
2213
2214
2215
2216
2217
2218
2219
2220
2221
2222
2223
2224
2225
2226
2227
2228
2229
2230
2231
2232
2233
2234
2235
2236
2237
2238
2239
2240
2241
2242
2243
2244
2245
2246
2247
2248
2249
2250
2251
2252
2253
2254
2255
2256
2257
2258
2259
2260
2261
2262
2263
2264
2265
2266
2267
2268
2269
2270
2271
2272
2273
2274
2275
2276
2277
2278
2279
2280
2281
2282
2283
2284
2285
2286
2287
2288
2289
2290
2291
2292
2293
2294
2295
2296
2297
2298
2299
2300
2301
2302
2303
2304
2305
2306
2307
2308
2309
2310
2311
2312
2313
2314
2315
2316
2317
2318
2319
2320
2321
2322
2323
2324
2325
2326
2327
2328
2329
2330
2331
2332
2333
2334
2335
2336
2337
2338
2339
2340
2341
2342
2343
2344
2345
2346
2347
2348
2349
2350
2351
2352
2353
2354
2355
2356
2357
2358
2359
2360
2361
2362
2363
2364
2365
2366
2367
2368
2369
2370
2371
2372
2373
2374
2375
2376
2377
2378
2379
2380
2381
2382
2383
2384
2385
2386
2387
2388
2389
2390
2391
2392
2393
2394
2395
2396
2397
2398
2399
2400
2401
2402
2403
2404
2405
2406
2407
2408
2409
2410
2411
2412
2413
2414
2415
2416
2417
2418
2419
2420
2421
2422
2423
2424
2425
2426
2427
2428
2429
2430
2431
2432
2433
2434
2435
2436
2437
2438
2439
2440
2441
2442
2443
2444
2445
2446
2447
2448
2449
2450
2451
2452
2453
2454
2455
2456
2457
2458
2459
2460
2461
2462
2463
2464
2465
2466
2467
2468
2469
2470
2471
2472
2473
2474
2475
2476
2477
2478
2479
2480
2481
2482
2483
2484
2485
2486
2487
2488
2489
2490
2491
2492
2493
2494
2495
2496
2497
2498
2499
2500
2501
2502
2503
2504
2505
def
post
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP POST operation.
## Example
```python
from fastapi import APIRouter, FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
router = APIRouter()
@router.post("/items/")
def create_item(item: Item):
return {"message": "Item created"}
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"POST"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
delete
delete
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP DELETE operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
delete
(
"/items/
{item_id}
"
)
def
delete_item
(
item_id
:
str
):
return
{
"message"
:
"Item deleted"
}
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
2507
2508
2509
2510
2511
2512
2513
2514
2515
2516
2517
2518
2519
2520
2521
2522
2523
2524
2525
2526
2527
2528
2529
2530
2531
2532
2533
2534
2535
2536
2537
2538
2539
2540
2541
2542
2543
2544
2545
2546
2547
2548
2549
2550
2551
2552
2553
2554
2555
2556
2557
2558
2559
2560
2561
2562
2563
2564
2565
2566
2567
2568
2569
2570
2571
2572
2573
2574
2575
2576
2577
2578
2579
2580
2581
2582
2583
2584
2585
2586
2587
2588
2589
2590
2591
2592
2593
2594
2595
2596
2597
2598
2599
2600
2601
2602
2603
2604
2605
2606
2607
2608
2609
2610
2611
2612
2613
2614
2615
2616
2617
2618
2619
2620
2621
2622
2623
2624
2625
2626
2627
2628
2629
2630
2631
2632
2633
2634
2635
2636
2637
2638
2639
2640
2641
2642
2643
2644
2645
2646
2647
2648
2649
2650
2651
2652
2653
2654
2655
2656
2657
2658
2659
2660
2661
2662
2663
2664
2665
2666
2667
2668
2669
2670
2671
2672
2673
2674
2675
2676
2677
2678
2679
2680
2681
2682
2683
2684
2685
2686
2687
2688
2689
2690
2691
2692
2693
2694
2695
2696
2697
2698
2699
2700
2701
2702
2703
2704
2705
2706
2707
2708
2709
2710
2711
2712
2713
2714
2715
2716
2717
2718
2719
2720
2721
2722
2723
2724
2725
2726
2727
2728
2729
2730
2731
2732
2733
2734
2735
2736
2737
2738
2739
2740
2741
2742
2743
2744
2745
2746
2747
2748
2749
2750
2751
2752
2753
2754
2755
2756
2757
2758
2759
2760
2761
2762
2763
2764
2765
2766
2767
2768
2769
2770
2771
2772
2773
2774
2775
2776
2777
2778
2779
2780
2781
2782
2783
2784
2785
2786
2787
2788
2789
2790
2791
2792
2793
2794
2795
2796
2797
2798
2799
2800
2801
2802
2803
2804
2805
2806
2807
2808
2809
2810
2811
2812
2813
2814
2815
2816
2817
2818
2819
2820
2821
2822
2823
2824
2825
2826
2827
2828
2829
2830
2831
2832
2833
2834
2835
2836
2837
2838
2839
2840
2841
2842
2843
2844
2845
2846
2847
2848
2849
2850
2851
2852
2853
2854
2855
2856
2857
2858
2859
2860
2861
2862
2863
2864
2865
2866
2867
2868
2869
2870
2871
2872
2873
2874
2875
2876
2877
2878
2879
2880
2881
2882
def
delete
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP DELETE operation.
## Example
```python
from fastapi import APIRouter, FastAPI
app = FastAPI()
router = APIRouter()
@router.delete("/items/{item_id}")
def delete_item(item_id: str):
return {"message": "Item deleted"}
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"DELETE"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
options
options
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP OPTIONS operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
options
(
"/items/"
)
def
get_item_options
():
return
{
"additions"
:
[
"Aji"
,
"Guacamole"
]}
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
2884
2885
2886
2887
2888
2889
2890
2891
2892
2893
2894
2895
2896
2897
2898
2899
2900
2901
2902
2903
2904
2905
2906
2907
2908
2909
2910
2911
2912
2913
2914
2915
2916
2917
2918
2919
2920
2921
2922
2923
2924
2925
2926
2927
2928
2929
2930
2931
2932
2933
2934
2935
2936
2937
2938
2939
2940
2941
2942
2943
2944
2945
2946
2947
2948
2949
2950
2951
2952
2953
2954
2955
2956
2957
2958
2959
2960
2961
2962
2963
2964
2965
2966
2967
2968
2969
2970
2971
2972
2973
2974
2975
2976
2977
2978
2979
2980
2981
2982
2983
2984
2985
2986
2987
2988
2989
2990
2991
2992
2993
2994
2995
2996
2997
2998
2999
3000
3001
3002
3003
3004
3005
3006
3007
3008
3009
3010
3011
3012
3013
3014
3015
3016
3017
3018
3019
3020
3021
3022
3023
3024
3025
3026
3027
3028
3029
3030
3031
3032
3033
3034
3035
3036
3037
3038
3039
3040
3041
3042
3043
3044
3045
3046
3047
3048
3049
3050
3051
3052
3053
3054
3055
3056
3057
3058
3059
3060
3061
3062
3063
3064
3065
3066
3067
3068
3069
3070
3071
3072
3073
3074
3075
3076
3077
3078
3079
3080
3081
3082
3083
3084
3085
3086
3087
3088
3089
3090
3091
3092
3093
3094
3095
3096
3097
3098
3099
3100
3101
3102
3103
3104
3105
3106
3107
3108
3109
3110
3111
3112
3113
3114
3115
3116
3117
3118
3119
3120
3121
3122
3123
3124
3125
3126
3127
3128
3129
3130
3131
3132
3133
3134
3135
3136
3137
3138
3139
3140
3141
3142
3143
3144
3145
3146
3147
3148
3149
3150
3151
3152
3153
3154
3155
3156
3157
3158
3159
3160
3161
3162
3163
3164
3165
3166
3167
3168
3169
3170
3171
3172
3173
3174
3175
3176
3177
3178
3179
3180
3181
3182
3183
3184
3185
3186
3187
3188
3189
3190
3191
3192
3193
3194
3195
3196
3197
3198
3199
3200
3201
3202
3203
3204
3205
3206
3207
3208
3209
3210
3211
3212
3213
3214
3215
3216
3217
3218
3219
3220
3221
3222
3223
3224
3225
3226
3227
3228
3229
3230
3231
3232
3233
3234
3235
3236
3237
3238
3239
3240
3241
3242
3243
3244
3245
3246
3247
3248
3249
3250
3251
3252
3253
3254
3255
3256
3257
3258
3259
def
options
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP OPTIONS operation.
## Example
```python
from fastapi import APIRouter, FastAPI
app = FastAPI()
router = APIRouter()
@router.options("/items/")
def get_item_options():
return {"additions": ["Aji", "Guacamole"]}
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"OPTIONS"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
head
head
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP HEAD operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
head
(
"/items/"
,
status_code
=
204
)
def
get_items_headers
(
response
:
Response
):
response
.
headers
[
"X-Cat-Dog"
]
=
"Alone in the world"
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
3261
3262
3263
3264
3265
3266
3267
3268
3269
3270
3271
3272
3273
3274
3275
3276
3277
3278
3279
3280
3281
3282
3283
3284
3285
3286
3287
3288
3289
3290
3291
3292
3293
3294
3295
3296
3297
3298
3299
3300
3301
3302
3303
3304
3305
3306
3307
3308
3309
3310
3311
3312
3313
3314
3315
3316
3317
3318
3319
3320
3321
3322
3323
3324
3325
3326
3327
3328
3329
3330
3331
3332
3333
3334
3335
3336
3337
3338
3339
3340
3341
3342
3343
3344
3345
3346
3347
3348
3349
3350
3351
3352
3353
3354
3355
3356
3357
3358
3359
3360
3361
3362
3363
3364
3365
3366
3367
3368
3369
3370
3371
3372
3373
3374
3375
3376
3377
3378
3379
3380
3381
3382
3383
3384
3385
3386
3387
3388
3389
3390
3391
3392
3393
3394
3395
3396
3397
3398
3399
3400
3401
3402
3403
3404
3405
3406
3407
3408
3409
3410
3411
3412
3413
3414
3415
3416
3417
3418
3419
3420
3421
3422
3423
3424
3425
3426
3427
3428
3429
3430
3431
3432
3433
3434
3435
3436
3437
3438
3439
3440
3441
3442
3443
3444
3445
3446
3447
3448
3449
3450
3451
3452
3453
3454
3455
3456
3457
3458
3459
3460
3461
3462
3463
3464
3465
3466
3467
3468
3469
3470
3471
3472
3473
3474
3475
3476
3477
3478
3479
3480
3481
3482
3483
3484
3485
3486
3487
3488
3489
3490
3491
3492
3493
3494
3495
3496
3497
3498
3499
3500
3501
3502
3503
3504
3505
3506
3507
3508
3509
3510
3511
3512
3513
3514
3515
3516
3517
3518
3519
3520
3521
3522
3523
3524
3525
3526
3527
3528
3529
3530
3531
3532
3533
3534
3535
3536
3537
3538
3539
3540
3541
3542
3543
3544
3545
3546
3547
3548
3549
3550
3551
3552
3553
3554
3555
3556
3557
3558
3559
3560
3561
3562
3563
3564
3565
3566
3567
3568
3569
3570
3571
3572
3573
3574
3575
3576
3577
3578
3579
3580
3581
3582
3583
3584
3585
3586
3587
3588
3589
3590
3591
3592
3593
3594
3595
3596
3597
3598
3599
3600
3601
3602
3603
3604
3605
3606
3607
3608
3609
3610
3611
3612
3613
3614
3615
3616
3617
3618
3619
3620
3621
3622
3623
3624
3625
3626
3627
3628
3629
3630
3631
3632
3633
3634
3635
3636
3637
3638
3639
3640
3641
def
head
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP HEAD operation.
## Example
```python
from fastapi import APIRouter, FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
router = APIRouter()
@router.head("/items/", status_code=204)
def get_items_headers(response: Response):
response.headers["X-Cat-Dog"] = "Alone in the world"
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"HEAD"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
patch
patch
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP PATCH operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
patch
(
"/items/"
)
def
update_item
(
item
:
Item
):
return
{
"message"
:
"Item updated in place"
}
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
3643
3644
3645
3646
3647
3648
3649
3650
3651
3652
3653
3654
3655
3656
3657
3658
3659
3660
3661
3662
3663
3664
3665
3666
3667
3668
3669
3670
3671
3672
3673
3674
3675
3676
3677
3678
3679
3680
3681
3682
3683
3684
3685
3686
3687
3688
3689
3690
3691
3692
3693
3694
3695
3696
3697
3698
3699
3700
3701
3702
3703
3704
3705
3706
3707
3708
3709
3710
3711
3712
3713
3714
3715
3716
3717
3718
3719
3720
3721
3722
3723
3724
3725
3726
3727
3728
3729
3730
3731
3732
3733
3734
3735
3736
3737
3738
3739
3740
3741
3742
3743
3744
3745
3746
3747
3748
3749
3750
3751
3752
3753
3754
3755
3756
3757
3758
3759
3760
3761
3762
3763
3764
3765
3766
3767
3768
3769
3770
3771
3772
3773
3774
3775
3776
3777
3778
3779
3780
3781
3782
3783
3784
3785
3786
3787
3788
3789
3790
3791
3792
3793
3794
3795
3796
3797
3798
3799
3800
3801
3802
3803
3804
3805
3806
3807
3808
3809
3810
3811
3812
3813
3814
3815
3816
3817
3818
3819
3820
3821
3822
3823
3824
3825
3826
3827
3828
3829
3830
3831
3832
3833
3834
3835
3836
3837
3838
3839
3840
3841
3842
3843
3844
3845
3846
3847
3848
3849
3850
3851
3852
3853
3854
3855
3856
3857
3858
3859
3860
3861
3862
3863
3864
3865
3866
3867
3868
3869
3870
3871
3872
3873
3874
3875
3876
3877
3878
3879
3880
3881
3882
3883
3884
3885
3886
3887
3888
3889
3890
3891
3892
3893
3894
3895
3896
3897
3898
3899
3900
3901
3902
3903
3904
3905
3906
3907
3908
3909
3910
3911
3912
3913
3914
3915
3916
3917
3918
3919
3920
3921
3922
3923
3924
3925
3926
3927
3928
3929
3930
3931
3932
3933
3934
3935
3936
3937
3938
3939
3940
3941
3942
3943
3944
3945
3946
3947
3948
3949
3950
3951
3952
3953
3954
3955
3956
3957
3958
3959
3960
3961
3962
3963
3964
3965
3966
3967
3968
3969
3970
3971
3972
3973
3974
3975
3976
3977
3978
3979
3980
3981
3982
3983
3984
3985
3986
3987
3988
3989
3990
3991
3992
3993
3994
3995
3996
3997
3998
3999
4000
4001
4002
4003
4004
4005
4006
4007
4008
4009
4010
4011
4012
4013
4014
4015
4016
4017
4018
4019
4020
4021
4022
4023
def
patch
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP PATCH operation.
## Example
```python
from fastapi import APIRouter, FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
router = APIRouter()
@router.patch("/items/")
def update_item(item: Item):
return {"message": "Item updated in place"}
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"PATCH"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
trace
trace
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP TRACE operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
trace
(
"/items/
{item_id}
"
)
def
trace_item
(
item_id
:
str
):
return
None
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
4025
4026
4027
4028
4029
4030
4031
4032
4033
4034
4035
4036
4037
4038
4039
4040
4041
4042
4043
4044
4045
4046
4047
4048
4049
4050
4051
4052
4053
4054
4055
4056
4057
4058
4059
4060
4061
4062
4063
4064
4065
4066
4067
4068
4069
4070
4071
4072
4073
4074
4075
4076
4077
4078
4079
4080
4081
4082
4083
4084
4085
4086
4087
4088
4089
4090
4091
4092
4093
4094
4095
4096
4097
4098
4099
4100
4101
4102
4103
4104
4105
4106
4107
4108
4109
4110
4111
4112
4113
4114
4115
4116
4117
4118
4119
4120
4121
4122
4123
4124
4125
4126
4127
4128
4129
4130
4131
4132
4133
4134
4135
4136
4137
4138
4139
4140
4141
4142
4143
4144
4145
4146
4147
4148
4149
4150
4151
4152
4153
4154
4155
4156
4157
4158
4159
4160
4161
4162
4163
4164
4165
4166
4167
4168
4169
4170
4171
4172
4173
4174
4175
4176
4177
4178
4179
4180
4181
4182
4183
4184
4185
4186
4187
4188
4189
4190
4191
4192
4193
4194
4195
4196
4197
4198
4199
4200
4201
4202
4203
4204
4205
4206
4207
4208
4209
4210
4211
4212
4213
4214
4215
4216
4217
4218
4219
4220
4221
4222
4223
4224
4225
4226
4227
4228
4229
4230
4231
4232
4233
4234
4235
4236
4237
4238
4239
4240
4241
4242
4243
4244
4245
4246
4247
4248
4249
4250
4251
4252
4253
4254
4255
4256
4257
4258
4259
4260
4261
4262
4263
4264
4265
4266
4267
4268
4269
4270
4271
4272
4273
4274
4275
4276
4277
4278
4279
4280
4281
4282
4283
4284
4285
4286
4287
4288
4289
4290
4291
4292
4293
4294
4295
4296
4297
4298
4299
4300
4301
4302
4303
4304
4305
4306
4307
4308
4309
4310
4311
4312
4313
4314
4315
4316
4317
4318
4319
4320
4321
4322
4323
4324
4325
4326
4327
4328
4329
4330
4331
4332
4333
4334
4335
4336
4337
4338
4339
4340
4341
4342
4343
4344
4345
4346
4347
4348
4349
4350
4351
4352
4353
4354
4355
4356
4357
4358
4359
4360
4361
4362
4363
4364
4365
4366
4367
4368
4369
4370
4371
4372
4373
4374
4375
4376
4377
4378
4379
4380
4381
4382
4383
4384
4385
4386
4387
4388
4389
4390
4391
4392
4393
4394
4395
4396
4397
4398
4399
4400
4401
4402
4403
4404
4405
def
trace
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP TRACE operation.
## Example
```python
from fastapi import APIRouter, FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
router = APIRouter()
@router.trace("/items/{item_id}")
def trace_item(item_id: str):
return None
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"TRACE"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
on_event
on_event
(
event_type
)
Add an event handler for the router.
on_event
is deprecated, use
lifespan
event handlers instead.
Read more about it in the
FastAPI docs for Lifespan Events
.
PARAMETER
DESCRIPTION
event_type
The type of event.
startup
or
shutdown
.
TYPE:
str
Source code in
fastapi/routing.py
4407
4408
4409
4410
4411
4412
4413
4414
4415
4416
4417
4418
4419
4420
4421
4422
4423
4424
4425
4426
4427
4428
4429
4430
4431
4432
4433
4434
4435
4436
4437
4438
4439
@deprecated
(
"""
on_event is deprecated, use lifespan event handlers instead.
Read more about it in the
[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
"""
)
def
on_event
(
self
,
event_type
:
Annotated
[
str
,
Doc
(
"""
The type of event. `startup` or `shutdown`.
"""
),
],
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add an event handler for the router.
`on_event` is deprecated, use `lifespan` event handlers instead.
Read more about it in the
[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).
"""
def
decorator
(
func
:
DecoratedCallable
)
->
DecoratedCallable
:
self
.
add_event_handler
(
event_type
,
func
)
return
func
return
decorator

## 084_REFERENCE_BACKGROUND
Background Tasks -BackgroundTasks¶
---

Background Tasks -
BackgroundTasks
You can declare a parameter in a
path operation function
or dependency function with the type
BackgroundTasks
, and then you can use it to schedule the execution of background tasks after the response is sent.
You can import it directly from
fastapi
:
from
fastapi
import
BackgroundTasks
fastapi.BackgroundTasks
BackgroundTasks
(
tasks
=
None
)
Bases:
BackgroundTasks
A collection of background tasks that will be called after a response has been
sent to the client.
Read more about it in the
FastAPI docs for Background Tasks
.
Example
from
fastapi
import
BackgroundTasks
,
FastAPI
app
=
FastAPI
()
def
write_notification
(
email
:
str
,
message
=
""
):
with
open
(
"log.txt"
,
mode
=
"w"
)
as
email_file
:
content
=
f
"notification for
{
email
}
:
{
message
}
"
email_file
.
write
(
content
)
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
):
background_tasks
.
add_task
(
write_notification
,
email
,
message
=
"some notification"
)
return
{
"message"
:
"Notification sent in the background"
}
Source code in
starlette/background.py
32
33
def
__init__
(
self
,
tasks
:
typing
.
Sequence
[
BackgroundTask
]
|
None
=
None
):
self
.
tasks
=
list
(
tasks
)
if
tasks
else
[]
func
instance-attribute
func
=
func
args
instance-attribute
args
=
args
kwargs
instance-attribute
kwargs
=
kwargs
is_async
instance-attribute
is_async
=
is_async_callable
(
func
)
tasks
instance-attribute
tasks
=
list
(
tasks
)
if
tasks
else
[]
add_task
add_task
(
func
,
*
args
,
**
kwargs
)
Add a function to be called in the background after the response is sent.
Read more about it in the
FastAPI docs for Background Tasks
.
PARAMETER
DESCRIPTION
func
The function to call after the response is sent.
It can be a regular
def
function or an
async def
function.
TYPE:
Callable
[
P
,
Any
]
Source code in
fastapi/background.py
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
def
add_task
(
self
,
func
:
Annotated
[
Callable
[
P
,
Any
],
Doc
(
"""
The function to call after the response is sent.
It can be a regular `def` function or an `async def` function.
"""
),
],
*
args
:
P
.
args
,
**
kwargs
:
P
.
kwargs
,
)
->
None
:
"""
Add a function to be called in the background after the response is sent.
Read more about it in the
[FastAPI docs for Background Tasks](https://fastapi.tiangolo.com/tutorial/background-tasks/).
"""
return
super
()
.
add_task
(
func
,
*
args
,
**
kwargs
)

## 085_REFERENCE_DEPENDENCIES
Dependencies -Depends()andSecurity()¶
---

Dependencies -
Depends()
and
Security()
Depends()
Dependencies are handled mainly with the special function
Depends()
that takes a callable.
Here is the reference for it and its parameters.
You can import it directly from
fastapi
:
from
fastapi
import
Depends
fastapi.Depends
Depends
(
dependency
=
None
,
*
,
use_cache
=
True
)
Declare a FastAPI dependency.
It takes a single "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you.
Read more about it in the
FastAPI docs for Dependencies
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
PARAMETER
DESCRIPTION
dependency
A "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you, just pass the object
directly.
TYPE:
Optional
[
Callable
[...,
Any
]]
DEFAULT:
None
use_cache
By default, after a dependency is called the first time in a request, if
the dependency is declared again for the rest of the request (for example
if the dependency is needed by several dependencies), the value will be
re-used for the rest of the request.
Set
use_cache
to
False
to disable this behavior and ensure the
dependency is called again (if declared more than once) in the same request.
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/param_functions.py
2220
2221
2222
2223
2224
2225
2226
2227
2228
2229
2230
2231
2232
2233
2234
2235
2236
2237
2238
2239
2240
2241
2242
2243
2244
2245
2246
2247
2248
2249
2250
2251
2252
2253
2254
2255
2256
2257
2258
2259
2260
2261
2262
2263
2264
2265
2266
2267
2268
2269
2270
2271
2272
2273
2274
2275
2276
2277
def
Depends
(
## noqa: N802
dependency
:
Annotated
[
Optional
[
Callable
[
...
,
Any
]],
Doc
(
"""
A "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you, just pass the object
directly.
"""
),
]
=
None
,
*
,
use_cache
:
Annotated
[
bool
,
Doc
(
"""
By default, after a dependency is called the first time in a request, if
the dependency is declared again for the rest of the request (for example
if the dependency is needed by several dependencies), the value will be
re-used for the rest of the request.
Set `use_cache` to `False` to disable this behavior and ensure the
dependency is called again (if declared more than once) in the same request.
"""
),
]
=
True
,
)
->
Any
:
"""
Declare a FastAPI dependency.
It takes a single "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you.
Read more about it in the
[FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/).
**Example**
```python
from typing import Annotated
from fastapi import Depends, FastAPI
app = FastAPI()
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
return {"q": q, "skip": skip, "limit": limit}
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
return commons
```
"""
return
params
.
Depends
(
dependency
=
dependency
,
use_cache
=
use_cache
)
Security()
For many scenarios, you can handle security (authorization, authentication, etc.) with dependencies, using
Depends()
.
But when you want to also declare OAuth2 scopes, you can use
Security()
instead of
Depends()
.
You can import
Security()
directly from
fastapi
:
from
fastapi
import
Security
fastapi.Security
Security
(
dependency
=
None
,
*
,
scopes
=
None
,
use_cache
=
True
)
Declare a FastAPI Security dependency.
The only difference with a regular dependency is that it can declare OAuth2
scopes that will be integrated with OpenAPI and the automatic UI docs (by default
at
/docs
).
It takes a single "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you.
Read more about it in the
FastAPI docs for Security
and
in the
FastAPI docs for OAuth2 scopes
.
Example
from
typing
import
Annotated
from
fastapi
import
Security
,
FastAPI
from
.db
import
User
from
.security
import
get_current_active_user
app
=
FastAPI
()
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])]
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
PARAMETER
DESCRIPTION
dependency
A "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you, just pass the object
directly.
TYPE:
Optional
[
Callable
[...,
Any
]]
DEFAULT:
None
scopes
OAuth2 scopes required for the
path operation
that uses this Security
dependency.
The term "scope" comes from the OAuth2 specification, it seems to be
intentionally vague and interpretable. It normally refers to permissions,
in cases to roles.
These scopes are integrated with OpenAPI (and the API docs at
/docs
).
So they are visible in the OpenAPI specification.
)
TYPE:
Optional
[
Sequence
[
str
]]
DEFAULT:
None
use_cache
By default, after a dependency is called the first time in a request, if
the dependency is declared again for the rest of the request (for example
if the dependency is needed by several dependencies), the value will be
re-used for the rest of the request.
Set
use_cache
to
False
to disable this behavior and ensure the
dependency is called again (if declared more than once) in the same request.
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/param_functions.py
2280
2281
2282
2283
2284
2285
2286
2287
2288
2289
2290
2291
2292
2293
2294
2295
2296
2297
2298
2299
2300
2301
2302
2303
2304
2305
2306
2307
2308
2309
2310
2311
2312
2313
2314
2315
2316
2317
2318
2319
2320
2321
2322
2323
2324
2325
2326
2327
2328
2329
2330
2331
2332
2333
2334
2335
2336
2337
2338
2339
2340
2341
2342
2343
2344
2345
2346
2347
2348
2349
2350
2351
2352
2353
2354
2355
2356
2357
2358
2359
2360
def
Security
(
## noqa: N802
dependency
:
Annotated
[
Optional
[
Callable
[
...
,
Any
]],
Doc
(
"""
A "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you, just pass the object
directly.
"""
),
]
=
None
,
*
,
scopes
:
Annotated
[
Optional
[
Sequence
[
str
]],
Doc
(
"""
OAuth2 scopes required for the *path operation* that uses this Security
dependency.
The term "scope" comes from the OAuth2 specification, it seems to be
intentionally vague and interpretable. It normally refers to permissions,
in cases to roles.
These scopes are integrated with OpenAPI (and the API docs at `/docs`).
So they are visible in the OpenAPI specification.
)
"""
),
]
=
None
,
use_cache
:
Annotated
[
bool
,
Doc
(
"""
By default, after a dependency is called the first time in a request, if
the dependency is declared again for the rest of the request (for example
if the dependency is needed by several dependencies), the value will be
re-used for the rest of the request.
Set `use_cache` to `False` to disable this behavior and ensure the
dependency is called again (if declared more than once) in the same request.
"""
),
]
=
True
,
)
->
Any
:
"""
Declare a FastAPI Security dependency.
The only difference with a regular dependency is that it can declare OAuth2
scopes that will be integrated with OpenAPI and the automatic UI docs (by default
at `/docs`).
It takes a single "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you.
Read more about it in the
[FastAPI docs for Security](https://fastapi.tiangolo.com/tutorial/security/) and
in the
[FastAPI docs for OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).
**Example**
```python
from typing import Annotated
from fastapi import Security, FastAPI
from .db import User
from .security import get_current_active_user
app = FastAPI()
@app.get("/users/me/items/")
async def read_own_items(
current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])]
):
return [{"item_id": "Foo", "owner": current_user.username}]
```
"""
return
params
.
Security
(
dependency
=
dependency
,
scopes
=
scopes
,
use_cache
=
use_cache
)

## 086_REFERENCE_ENCODERS
Encoders -jsonable_encoder¶
---

Encoders -
jsonable_encoder
fastapi.encoders.jsonable_encoder
jsonable_encoder
(
obj
,
include
=
None
,
exclude
=
None
,
by_alias
=
True
,
exclude_unset
=
False
,
exclude_defaults
=
False
,
exclude_none
=
False
,
custom_encoder
=
None
,
sqlalchemy_safe
=
True
,
)
Convert any object to something that can be encoded in JSON.
This is used internally by FastAPI to make sure anything you return can be
encoded as JSON before it is sent to the client.
You can also use it yourself, for example to convert objects before saving them
in a database that supports only JSON.
Read more about it in the
FastAPI docs for JSON Compatible Encoder
.
PARAMETER
DESCRIPTION
obj
The input object to convert to JSON.
TYPE:
Any
include
Pydantic's
include
parameter, passed to Pydantic models to set the
fields to include.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
exclude
Pydantic's
exclude
parameter, passed to Pydantic models to set the
fields to exclude.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
by_alias
Pydantic's
by_alias
parameter, passed to Pydantic models to define if
the output should use the alias names (when provided) or the Python
attribute names. In an API, if you set an alias, it's probably because you
want to use it in the result, so you probably want to leave this set to
True
.
TYPE:
bool
DEFAULT:
True
exclude_unset
Pydantic's
exclude_unset
parameter, passed to Pydantic models to define
if it should exclude from the output the fields that were not explicitly
set (and that only had their default values).
TYPE:
bool
DEFAULT:
False
exclude_defaults
Pydantic's
exclude_defaults
parameter, passed to Pydantic models to define
if it should exclude from the output the fields that had the same default
value, even when they were explicitly set.
TYPE:
bool
DEFAULT:
False
exclude_none
Pydantic's
exclude_none
parameter, passed to Pydantic models to define
if it should exclude from the output any fields that have a
None
value.
TYPE:
bool
DEFAULT:
False
custom_encoder
Pydantic's
custom_encoder
parameter, passed to Pydantic models to define
a custom encoder.
TYPE:
Optional
[
Dict
[
Any
,
Callable
[[
Any
],
Any
]]]
DEFAULT:
None
sqlalchemy_safe
Exclude from the output any fields that start with the name
_sa
.
This is mainly a hack for compatibility with SQLAlchemy objects, they
store internal SQLAlchemy-specific state in attributes named with
_sa
,
and those objects can't (and shouldn't be) serialized to JSON.
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/encoders.py
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
def
jsonable_encoder
(
obj
:
Annotated
[
Any
,
Doc
(
"""
The input object to convert to JSON.
"""
),
],
include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Pydantic's `include` parameter, passed to Pydantic models to set the
fields to include.
"""
),
]
=
None
,
exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Pydantic's `exclude` parameter, passed to Pydantic models to set the
fields to exclude.
"""
),
]
=
None
,
by_alias
:
Annotated
[
bool
,
Doc
(
"""
Pydantic's `by_alias` parameter, passed to Pydantic models to define if
the output should use the alias names (when provided) or the Python
attribute names. In an API, if you set an alias, it's probably because you
want to use it in the result, so you probably want to leave this set to
`True`.
"""
),
]
=
True
,
exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Pydantic's `exclude_unset` parameter, passed to Pydantic models to define
if it should exclude from the output the fields that were not explicitly
set (and that only had their default values).
"""
),
]
=
False
,
exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define
if it should exclude from the output the fields that had the same default
value, even when they were explicitly set.
"""
),
]
=
False
,
exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Pydantic's `exclude_none` parameter, passed to Pydantic models to define
if it should exclude from the output any fields that have a `None` value.
"""
),
]
=
False
,
custom_encoder
:
Annotated
[
Optional
[
Dict
[
Any
,
Callable
[[
Any
],
Any
]]],
Doc
(
"""
Pydantic's `custom_encoder` parameter, passed to Pydantic models to define
a custom encoder.
"""
),
]
=
None
,
sqlalchemy_safe
:
Annotated
[
bool
,
Doc
(
"""
Exclude from the output any fields that start with the name `_sa`.
This is mainly a hack for compatibility with SQLAlchemy objects, they
store internal SQLAlchemy-specific state in attributes named with `_sa`,
and those objects can't (and shouldn't be) serialized to JSON.
"""
),
]
=
True
,
)
->
Any
:
"""
Convert any object to something that can be encoded in JSON.
This is used internally by FastAPI to make sure anything you return can be
encoded as JSON before it is sent to the client.
You can also use it yourself, for example to convert objects before saving them
in a database that supports only JSON.
Read more about it in the
[FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).
"""
custom_encoder
=
custom_encoder
or
{}
if
custom_encoder
:
if
type
(
obj
)
in
custom_encoder
:
return
custom_encoder
[
type
(
obj
)](
obj
)
else
:
for
encoder_type
,
encoder_instance
in
custom_encoder
.
items
():
if
isinstance
(
obj
,
encoder_type
):
return
encoder_instance
(
obj
)
if
include
is
not
None
and
not
isinstance
(
include
,
(
set
,
dict
)):
include
=
set
(
include
)
if
exclude
is
not
None
and
not
isinstance
(
exclude
,
(
set
,
dict
)):
exclude
=
set
(
exclude
)
if
isinstance
(
obj
,
BaseModel
):
## TODO: remove when deprecating Pydantic v1
encoders
:
Dict
[
Any
,
Any
]
=
{}
if
not
PYDANTIC_V2
:
encoders
=
getattr
(
obj
.
__config__
,
"json_encoders"
,
{})
## type: ignore[attr-defined]
if
custom_encoder
:
encoders
.
update
(
custom_encoder
)
obj_dict
=
_model_dump
(
obj
,
mode
=
"json"
,
include
=
include
,
exclude
=
exclude
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_none
=
exclude_none
,
exclude_defaults
=
exclude_defaults
,
)
if
"__root__"
in
obj_dict
:
obj_dict
=
obj_dict
[
"__root__"
]
return
jsonable_encoder
(
obj_dict
,
exclude_none
=
exclude_none
,
exclude_defaults
=
exclude_defaults
,
## TODO: remove when deprecating Pydantic v1
custom_encoder
=
encoders
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)
if
dataclasses
.
is_dataclass
(
obj
):
obj_dict
=
dataclasses
.
asdict
(
obj
)
return
jsonable_encoder
(
obj_dict
,
include
=
include
,
exclude
=
exclude
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
custom_encoder
=
custom_encoder
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)
if
isinstance
(
obj
,
Enum
):
return
obj
.
value
if
isinstance
(
obj
,
PurePath
):
return
str
(
obj
)
if
isinstance
(
obj
,
(
str
,
int
,
float
,
type
(
None
))):
return
obj
if
isinstance
(
obj
,
UndefinedType
):
return
None
if
isinstance
(
obj
,
dict
):
encoded_dict
=
{}
allowed_keys
=
set
(
obj
.
keys
())
if
include
is
not
None
:
allowed_keys
&=
set
(
include
)
if
exclude
is
not
None
:
allowed_keys
-=
set
(
exclude
)
for
key
,
value
in
obj
.
items
():
if
(
(
not
sqlalchemy_safe
or
(
not
isinstance
(
key
,
str
))
or
(
not
key
.
startswith
(
"_sa"
))
)
and
(
value
is
not
None
or
not
exclude_none
)
and
key
in
allowed_keys
):
encoded_key
=
jsonable_encoder
(
key
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_none
=
exclude_none
,
custom_encoder
=
custom_encoder
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)
encoded_value
=
jsonable_encoder
(
value
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_none
=
exclude_none
,
custom_encoder
=
custom_encoder
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)
encoded_dict
[
encoded_key
]
=
encoded_value
return
encoded_dict
if
isinstance
(
obj
,
(
list
,
set
,
frozenset
,
GeneratorType
,
tuple
,
deque
)):
encoded_list
=
[]
for
item
in
obj
:
encoded_list
.
append
(
jsonable_encoder
(
item
,
include
=
include
,
exclude
=
exclude
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
custom_encoder
=
custom_encoder
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)
)
return
encoded_list
if
type
(
obj
)
in
ENCODERS_BY_TYPE
:
return
ENCODERS_BY_TYPE
[
type
(
obj
)](
obj
)
for
encoder
,
classes_tuple
in
encoders_by_class_tuples
.
items
():
if
isinstance
(
obj
,
classes_tuple
):
return
encoder
(
obj
)
try
:
data
=
dict
(
obj
)
except
Exception
as
e
:
errors
:
List
[
Exception
]
=
[]
errors
.
append
(
e
)
try
:
data
=
vars
(
obj
)
except
Exception
as
e
:
errors
.
append
(
e
)
raise
ValueError
(
errors
)
from
e
return
jsonable_encoder
(
data
,
include
=
include
,
exclude
=
exclude
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
custom_encoder
=
custom_encoder
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)

## 087_REFERENCE_EXCEPTIONS
Exceptions -HTTPExceptionandWebSocketException¶
---

Exceptions -
HTTPException
and
WebSocketException
These are the exceptions that you can raise to show errors to the client.
When you raise an exception, as would happen with normal Python, the rest of the execution is aborted. This way you can raise these exceptions from anywhere in the code to abort a request and show the error to the client.
You can use:
HTTPException
WebSocketException
These exceptions can be imported directly from
fastapi
:
from
fastapi
import
HTTPException
,
WebSocketException
fastapi.HTTPException
HTTPException
(
status_code
,
detail
=
None
,
headers
=
None
)
Bases:
HTTPException
An HTTP exception you can raise in your own code to show errors to the client.
This is for client errors, invalid authentication, invalid data, etc. Not for server
errors in your code.
Read more about it in the
FastAPI docs for Handling Errors
.
Example
from
fastapi
import
FastAPI
,
HTTPException
app
=
FastAPI
()
items
=
{
"foo"
:
"The Foo Wrestlers"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
items
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"item"
:
items
[
item_id
]}
PARAMETER
DESCRIPTION
status_code
HTTP status code to send to the client.
TYPE:
int
detail
Any data to be sent to the client in the
detail
key of the JSON
response.
TYPE:
Any
DEFAULT:
None
headers
Any headers to send to the client in the response.
TYPE:
Optional
[
Dict
[
str
,
str
]]
DEFAULT:
None
Source code in
fastapi/exceptions.py
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
def
__init__
(
self
,
status_code
:
Annotated
[
int
,
Doc
(
"""
HTTP status code to send to the client.
"""
),
],
detail
:
Annotated
[
Any
,
Doc
(
"""
Any data to be sent to the client in the `detail` key of the JSON
response.
"""
),
]
=
None
,
headers
:
Annotated
[
Optional
[
Dict
[
str
,
str
]],
Doc
(
"""
Any headers to send to the client in the response.
"""
),
]
=
None
,
)
->
None
:
super
()
.
__init__
(
status_code
=
status_code
,
detail
=
detail
,
headers
=
headers
)
status_code
instance-attribute
status_code
=
status_code
detail
instance-attribute
detail
=
detail
headers
instance-attribute
headers
=
headers
fastapi.WebSocketException
WebSocketException
(
code
,
reason
=
None
)
Bases:
WebSocketException
A WebSocket exception you can raise in your own code to show errors to the client.
This is for client errors, invalid authentication, invalid data, etc. Not for server
errors in your code.
Read more about it in the
FastAPI docs for WebSockets
.
Example
from
typing
import
Annotated
from
fastapi
import
(
Cookie
,
FastAPI
,
WebSocket
,
WebSocketException
,
status
,
)
app
=
FastAPI
()
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
*
,
websocket
:
WebSocket
,
session
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
,
item_id
:
str
,
):
if
session
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie is:
{
session
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
PARAMETER
DESCRIPTION
code
A closing code from the
valid codes defined in the specification
.
TYPE:
int
reason
The reason to close the WebSocket connection.
It is UTF-8-encoded data. The interpretation of the reason is up to the
application, it is not specified by the WebSocket specification.
It could contain text that could be human-readable or interpretable
by the client code, etc.
TYPE:
Union
[
str
, None]
DEFAULT:
None
Source code in
fastapi/exceptions.py
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
def
__init__
(
self
,
code
:
Annotated
[
int
,
Doc
(
"""
A closing code from the
[valid codes defined in the specification](https://datatracker.ietf.org/doc/html/rfc6455#section-7.4.1).
"""
),
],
reason
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
The reason to close the WebSocket connection.
It is UTF-8-encoded data. The interpretation of the reason is up to the
application, it is not specified by the WebSocket specification.
It could contain text that could be human-readable or interpretable
by the client code, etc.
"""
),
]
=
None
,
)
->
None
:
super
()
.
__init__
(
code
=
code
,
reason
=
reason
)
code
instance-attribute
code
=
code
reason
instance-attribute
reason
=
reason
or
''

## 088_REFERENCE_FASTAPI
FastAPIclass¶
---

FastAPI
class
Here's the reference information for the
FastAPI
class, with all its parameters, attributes and methods.
You can import the
FastAPI
class directly from
fastapi
:
from
fastapi
import
FastAPI
fastapi.FastAPI
FastAPI
(
*
,
debug
=
False
,
routes
=
None
,
title
=
"FastAPI"
,
summary
=
None
,
description
=
""
,
version
=
"0.1.0"
,
openapi_url
=
"/openapi.json"
,
openapi_tags
=
None
,
servers
=
None
,
dependencies
=
None
,
default_response_class
=
Default
(
JSONResponse
),
redirect_slashes
=
True
,
docs_url
=
"/docs"
,
redoc_url
=
"/redoc"
,
swagger_ui_oauth2_redirect_url
=
"/docs/oauth2-redirect"
,
swagger_ui_init_oauth
=
None
,
middleware
=
None
,
exception_handlers
=
None
,
on_startup
=
None
,
on_shutdown
=
None
,
lifespan
=
None
,
terms_of_service
=
None
,
contact
=
None
,
license_info
=
None
,
openapi_prefix
=
""
,
root_path
=
""
,
root_path_in_servers
=
True
,
responses
=
None
,
callbacks
=
None
,
webhooks
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
swagger_ui_parameters
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
),
separate_input_output_schemas
=
True
,
**
extra
)
Bases:
Starlette
FastAPI
app class, the main entrypoint to use FastAPI.
Read more in the
FastAPI docs for First Steps
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
PARAMETER
DESCRIPTION
debug
Boolean indicating if debug tracebacks should be returned on server
errors.
Read more in the
Starlette docs for Applications
.
TYPE:
bool
DEFAULT:
False
routes
You normally wouldn't use this parameter with FastAPI, it is inherited
from Starlette and supported for compatibility.
In FastAPI, you normally would use the
path operation methods
,
like
app.get()
,
app.post()
, etc.
Note
: you probably shouldn't use this parameter, it is inherited
from Starlette and supported for compatibility.
A list of routes to serve incoming HTTP and WebSocket requests.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
title
The title of the API.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
title
=
"ChimichangApp"
)
TYPE:
str
DEFAULT:
'FastAPI'
summary
A short summary of the API.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
summary
=
"Deadpond's favorite app. Nuff said."
)
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description of the API. Supports Markdown (using
CommonMark syntax
).
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
description
=
"""
ChimichangApp API helps you do awesome stuff. 🚀
## Items
You can **read items**.
## Users
You will be able to:
* **Create users** (_not implemented_).
* **Read users** (_not implemented_).
"""
)
TYPE:
str
DEFAULT:
''
version
The version of the API.
Note
This is the version of your application, not the version of
the OpenAPI specification nor the version of FastAPI being used.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
version
=
"0.0.1"
)
TYPE:
str
DEFAULT:
'0.1.0'
openapi_url
The URL where the OpenAPI schema will be served from.
If you set it to
None
, no OpenAPI schema will be served publicly, and
the default automatic endpoints
/docs
and
/redoc
will also be
disabled.
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
openapi_url
=
"/api/v1/openapi.json"
)
TYPE:
Optional
[
str
]
DEFAULT:
'/openapi.json'
openapi_tags
A list of tags used by OpenAPI, these are the same
tags
you can set
in the
path operations
, like:
@app.get("/users/", tags=["users"])
@app.get("/items/", tags=["items"])
The order of the tags can be used to specify the order shown in
tools like Swagger UI, used in the automatic path
/docs
.
It's not required to specify all the tags used.
The tags that are not declared MAY be organized randomly or based
on the tools' logic. Each tag name in the list MUST be unique.
The value of each item is a
dict
containing:
name
: The name of the tag.
description
: A short description of the tag.
CommonMark syntax
MAY be used for rich
text representation.
externalDocs
: Additional external documentation for this tag. If
provided, it would contain a
dict
with:
description
: A short description of the target documentation.
CommonMark syntax
MAY be used for
rich text representation.
url
: The URL for the target documentation. Value MUST be in
the form of a URL.
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
tags_metadata
=
[
{
"name"
:
"users"
,
"description"
:
"Operations with users. The **login** logic is also here."
,
},
{
"name"
:
"items"
,
"description"
:
"Manage items. So _fancy_ they have their own docs."
,
"externalDocs"
:
{
"description"
:
"Items external docs"
,
"url"
:
"https://fastapi.tiangolo.com/"
,
},
},
]
app
=
FastAPI
(
openapi_tags
=
tags_metadata
)
TYPE:
Optional
[
List
[
Dict
[
str
,
Any
]]]
DEFAULT:
None
servers
A
list
of
dict
s with connectivity information to a target server.
You would use it, for example, if your application is served from
different domains and you want to use the same Swagger UI in the
browser to interact with each of them (instead of having multiple
browser tabs open). Or if you want to leave fixed the possible URLs.
If the servers
list
is not provided, or is an empty
list
, the
default value would be a
dict
with a
url
value of
/
.
Each item in the
list
is a
dict
containing:
url
: A URL to the target host. This URL supports Server Variables
and MAY be relative, to indicate that the host location is relative
to the location where the OpenAPI document is being served. Variable
substitutions will be made when a variable is named in
{
brackets
}
.
description
: An optional string describing the host designated by
the URL.
CommonMark syntax
MAY be used for
rich text representation.
variables
: A
dict
between a variable name and its value. The value
is used for substitution in the server's URL template.
Read more in the
FastAPI docs for Behind a Proxy
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
servers
=
[
{
"url"
:
"https://stag.example.com"
,
"description"
:
"Staging environment"
},
{
"url"
:
"https://prod.example.com"
,
"description"
:
"Production environment"
},
]
)
TYPE:
Optional
[
List
[
Dict
[
str
,
Union
[
str
,
Any
]]]]
DEFAULT:
None
dependencies
A list of global dependencies, they will be applied to each
path operation
, including in sub-routers.
Read more about it in the
FastAPI docs for Global Dependencies
.
Example
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
func_dep_1
,
func_dep_2
app
=
FastAPI
(
dependencies
=
[
Depends
(
func_dep_1
),
Depends
(
func_dep_2
)])
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
default_response_class
The default response class to be used.
Read more in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
Example
from
fastapi
import
FastAPI
from
fastapi.responses
import
ORJSONResponse
app
=
FastAPI
(
default_response_class
=
ORJSONResponse
)
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
redirect_slashes
Whether to detect and redirect slashes in URLs when the client doesn't
use the same format.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
redirect_slashes
=
True
)
## the default
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
With this app, if a client goes to
/items
(without a trailing slash),
they will be automatically redirected with an HTTP status code of 307
to
/items/
.
TYPE:
bool
DEFAULT:
True
docs_url
The path to the automatic interactive API documentation.
It is handled in the browser by Swagger UI.
The default URL is
/docs
. You can disable it by setting it to
None
.
If
openapi_url
is set to
None
, this will be automatically disabled.
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
docs_url
=
"/documentation"
,
redoc_url
=
None
)
TYPE:
Optional
[
str
]
DEFAULT:
'/docs'
redoc_url
The path to the alternative automatic interactive API documentation
provided by ReDoc.
The default URL is
/redoc
. You can disable it by setting it to
None
.
If
openapi_url
is set to
None
, this will be automatically disabled.
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
docs_url
=
"/documentation"
,
redoc_url
=
"redocumentation"
)
TYPE:
Optional
[
str
]
DEFAULT:
'/redoc'
swagger_ui_oauth2_redirect_url
The OAuth2 redirect endpoint for the Swagger UI.
By default it is
/docs/oauth2-redirect
.
This is only used if you use OAuth2 (with the "Authorize" button)
with Swagger UI.
TYPE:
Optional
[
str
]
DEFAULT:
'/docs/oauth2-redirect'
swagger_ui_init_oauth
OAuth2 configuration for the Swagger UI, by default shown at
/docs
.
Read more about the available configuration options in the
Swagger UI docs
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
middleware
List of middleware to be added when creating the application.
In FastAPI you would normally do this with
app.add_middleware()
instead.
Read more in the
FastAPI docs for Middleware
.
TYPE:
Optional
[
Sequence
[
Middleware
]]
DEFAULT:
None
exception_handlers
A dictionary with handlers for exceptions.
In FastAPI, you would normally use the decorator
@app.exception_handler()
.
Read more in the
FastAPI docs for Handling Errors
.
TYPE:
Optional
[
Dict
[
Union
[
int
,
Type
[
Exception
]],
Callable
[[
Request
,
Any
],
Coroutine
[
Any
,
Any
,
Response
]]]]
DEFAULT:
None
on_startup
A list of startup event handler functions.
You should instead use the
lifespan
handlers.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Sequence
[
Callable
[[],
Any
]]]
DEFAULT:
None
on_shutdown
A list of shutdown event handler functions.
You should instead use the
lifespan
handlers.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Sequence
[
Callable
[[],
Any
]]]
DEFAULT:
None
lifespan
A
Lifespan
context manager handler. This replaces
startup
and
shutdown
functions with a single context manager.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Lifespan
[
AppType
]]
DEFAULT:
None
terms_of_service
A URL to the Terms of Service for your API.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more at the
FastAPI docs for Metadata and Docs URLs
.
Example
app
=
FastAPI
(
terms_of_service
=
"http://example.com/terms/"
)
TYPE:
Optional
[
str
]
DEFAULT:
None
contact
A dictionary with the contact information for the exposed API.
It can contain several fields.
name
: (
str
) The name of the contact person/organization.
url
: (
str
) A URL pointing to the contact information. MUST be in
the format of a URL.
email
: (
str
) The email address of the contact person/organization.
MUST be in the format of an email address.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more at the
FastAPI docs for Metadata and Docs URLs
.
Example
app
=
FastAPI
(
contact
=
{
"name"
:
"Deadpoolio the Amazing"
,
"url"
:
"http://x-force.example.com/contact/"
,
"email"
:
"dp@x-force.example.com"
,
}
)
TYPE:
Optional
[
Dict
[
str
,
Union
[
str
,
Any
]]]
DEFAULT:
None
license_info
A dictionary with the license information for the exposed API.
It can contain several fields.
name
: (
str
)
REQUIRED
(if a
license_info
is set). The
license name used for the API.
identifier
: (
str
) An
SPDX
license expression
for the API. The
identifier
field is mutually exclusive of the
url
field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.
url
: (
str
) A URL to the license used for the API. This MUST be
the format of a URL.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more at the
FastAPI docs for Metadata and Docs URLs
.
Example
app
=
FastAPI
(
license_info
=
{
"name"
:
"Apache 2.0"
,
"url"
:
"https://www.apache.org/licenses/LICENSE-2.0.html"
,
}
)
TYPE:
Optional
[
Dict
[
str
,
Union
[
str
,
Any
]]]
DEFAULT:
None
openapi_prefix
"openapi_prefix" has been deprecated in favor of "root_path", which
follows more closely the ASGI standard, is simpler, and more
automatic. A URL prefix for the OpenAPI URL.
TYPE:
str
DEFAULT:
''
root_path
A path prefix handled by a proxy that is not seen by the application
but is seen by external clients, which affects things like Swagger UI.
Read more about it at the
FastAPI docs for Behind a Proxy
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
root_path
=
"/api/v1"
)
TYPE:
str
DEFAULT:
''
root_path_in_servers
To disable automatically generating the URLs in the
servers
field
in the autogenerated OpenAPI using the
root_path
.
Read more about it in the
FastAPI docs for Behind a Proxy
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
root_path_in_servers
=
False
)
TYPE:
bool
DEFAULT:
True
responses
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Additional Responses in OpenAPI
.
And in the
FastAPI docs for Bigger Applications
.
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
callbacks
OpenAPI callbacks that should apply to all
path operations
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
webhooks
Add OpenAPI webhooks. This is similar to
callbacks
but it doesn't
depend on specific
path operations
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Note
: This is available since OpenAPI 3.1.0, FastAPI 0.99.0.
Read more about it in the
FastAPI docs for OpenAPI Webhooks
.
TYPE:
Optional
[
APIRouter
]
DEFAULT:
None
deprecated
Mark all
path operations
as deprecated. You probably don't need it,
but it's available.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
bool
]
DEFAULT:
None
include_in_schema
To include (or not) all the
path operations
in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
swagger_ui_parameters
Parameters to configure Swagger UI, the autogenerated interactive API
documentation (by default at
/docs
).
Read more about it in the
FastAPI docs about how to Configure Swagger UI
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
separate_input_output_schemas
Whether to generate separate OpenAPI schemas for request body and
response body when the results would be more precise.
This is particularly useful when automatically generating clients.
For example, if you have a model like:
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
tags
:
list
[
str
]
=
[]
When
Item
is used for input, a request body,
tags
is not required,
the client doesn't have to provide it.
But when using
Item
for output, for a response body,
tags
is always
available because it has a default value, even if it's just an empty
list. So, the client should be able to always expect it.
In this case, there would be two different schemas, one for input and
another one for output.
TYPE:
bool
DEFAULT:
True
**extra
Extra keyword arguments to be stored in the app, not used by FastAPI
anywhere.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/applications.py
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812
813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
890
891
892
893
894
895
896
897
898
899
900
901
902
903
904
905
906
907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924
925
926
927
928
929
930
931
932
933
934
935
936
937
938
939
940
941
942
943
944
945
946
947
948
949
950
951
952
953
954
955
956
957
958
959
960
961
962
963
964
def
__init__
(
self
:
AppType
,
*
,
debug
:
Annotated
[
bool
,
Doc
(
"""
Boolean indicating if debug tracebacks should be returned on server
errors.
Read more in the
[Starlette docs for Applications](https://www.starlette.io/applications/#instantiating-the-application).
"""
),
]
=
False
,
routes
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
**Note**: you probably shouldn't use this parameter, it is inherited
from Starlette and supported for compatibility.
---
A list of routes to serve incoming HTTP and WebSocket requests.
"""
),
deprecated
(
"""
You normally wouldn't use this parameter with FastAPI, it is inherited
from Starlette and supported for compatibility.
In FastAPI, you normally would use the *path operation methods*,
like `app.get()`, `app.post()`, etc.
"""
),
]
=
None
,
title
:
Annotated
[
str
,
Doc
(
"""
The title of the API.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(title="ChimichangApp")
```
"""
),
]
=
"FastAPI"
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A short summary of the API.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(summary="Deadpond's favorite app. Nuff said.")
```
"""
),
]
=
None
,
description
:
Annotated
[
str
,
Doc
(
'''
A description of the API. Supports Markdown (using
[CommonMark syntax](https://commonmark.org/)).
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(
description="""
ChimichangApp API helps you do awesome stuff. 🚀
## Items
You can **read items**.
## Users
You will be able to:
* **Create users** (_not implemented_).
* **Read users** (_not implemented_).
"""
)
```
'''
),
]
=
""
,
version
:
Annotated
[
str
,
Doc
(
"""
The version of the API.
**Note** This is the version of your application, not the version of
the OpenAPI specification nor the version of FastAPI being used.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(version="0.0.1")
```
"""
),
]
=
"0.1.0"
,
openapi_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The URL where the OpenAPI schema will be served from.
If you set it to `None`, no OpenAPI schema will be served publicly, and
the default automatic endpoints `/docs` and `/redoc` will also be
disabled.
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#openapi-url).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(openapi_url="/api/v1/openapi.json")
```
"""
),
]
=
"/openapi.json"
,
openapi_tags
:
Annotated
[
Optional
[
List
[
Dict
[
str
,
Any
]]],
Doc
(
"""
A list of tags used by OpenAPI, these are the same `tags` you can set
in the *path operations*, like:
* `@app.get("/users/", tags=["users"])`
* `@app.get("/items/", tags=["items"])`
The order of the tags can be used to specify the order shown in
tools like Swagger UI, used in the automatic path `/docs`.
It's not required to specify all the tags used.
The tags that are not declared MAY be organized randomly or based
on the tools' logic. Each tag name in the list MUST be unique.
The value of each item is a `dict` containing:
* `name`: The name of the tag.
* `description`: A short description of the tag.
[CommonMark syntax](https://commonmark.org/) MAY be used for rich
text representation.
* `externalDocs`: Additional external documentation for this tag. If
provided, it would contain a `dict` with:
* `description`: A short description of the target documentation.
[CommonMark syntax](https://commonmark.org/) MAY be used for
rich text representation.
* `url`: The URL for the target documentation. Value MUST be in
the form of a URL.
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-tags).
**Example**
```python
from fastapi import FastAPI
tags_metadata = [
{
"name": "users",
"description": "Operations with users. The **login** logic is also here.",
},
{
"name": "items",
"description": "Manage items. So _fancy_ they have their own docs.",
"externalDocs": {
"description": "Items external docs",
"url": "https://fastapi.tiangolo.com/",
},
},
]
app = FastAPI(openapi_tags=tags_metadata)
```
"""
),
]
=
None
,
servers
:
Annotated
[
Optional
[
List
[
Dict
[
str
,
Union
[
str
,
Any
]]]],
Doc
(
"""
A `list` of `dict`s with connectivity information to a target server.
You would use it, for example, if your application is served from
different domains and you want to use the same Swagger UI in the
browser to interact with each of them (instead of having multiple
browser tabs open). Or if you want to leave fixed the possible URLs.
If the servers `list` is not provided, or is an empty `list`, the
default value would be a `dict` with a `url` value of `/`.
Each item in the `list` is a `dict` containing:
* `url`: A URL to the target host. This URL supports Server Variables
and MAY be relative, to indicate that the host location is relative
to the location where the OpenAPI document is being served. Variable
substitutions will be made when a variable is named in `{`brackets`}`.
* `description`: An optional string describing the host designated by
the URL. [CommonMark syntax](https://commonmark.org/) MAY be used for
rich text representation.
* `variables`: A `dict` between a variable name and its value. The value
is used for substitution in the server's URL template.
Read more in the
[FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#additional-servers).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(
servers=[
{"url": "https://stag.example.com", "description": "Staging environment"},
{"url": "https://prod.example.com", "description": "Production environment"},
]
)
```
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of global dependencies, they will be applied to each
*path operation*, including in sub-routers.
Read more about it in the
[FastAPI docs for Global Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/global-dependencies/).
**Example**
```python
from fastapi import Depends, FastAPI
from .dependencies import func_dep_1, func_dep_2
app = FastAPI(dependencies=[Depends(func_dep_1), Depends(func_dep_2)])
```
"""
),
]
=
None
,
default_response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
The default response class to be used.
Read more in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
**Example**
```python
from fastapi import FastAPI
from fastapi.responses import ORJSONResponse
app = FastAPI(default_response_class=ORJSONResponse)
```
"""
),
]
=
Default
(
JSONResponse
),
redirect_slashes
:
Annotated
[
bool
,
Doc
(
"""
Whether to detect and redirect slashes in URLs when the client doesn't
use the same format.
**Example**
```python
from fastapi import FastAPI
app = FastAPI(redirect_slashes=True) # the default
@app.get("/items/")
async def read_items():
return [{"item_id": "Foo"}]
```
With this app, if a client goes to `/items` (without a trailing slash),
they will be automatically redirected with an HTTP status code of 307
to `/items/`.
"""
),
]
=
True
,
docs_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The path to the automatic interactive API documentation.
It is handled in the browser by Swagger UI.
The default URL is `/docs`. You can disable it by setting it to `None`.
If `openapi_url` is set to `None`, this will be automatically disabled.
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(docs_url="/documentation", redoc_url=None)
```
"""
),
]
=
"/docs"
,
redoc_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The path to the alternative automatic interactive API documentation
provided by ReDoc.
The default URL is `/redoc`. You can disable it by setting it to `None`.
If `openapi_url` is set to `None`, this will be automatically disabled.
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(docs_url="/documentation", redoc_url="redocumentation")
```
"""
),
]
=
"/redoc"
,
swagger_ui_oauth2_redirect_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The OAuth2 redirect endpoint for the Swagger UI.
By default it is `/docs/oauth2-redirect`.
This is only used if you use OAuth2 (with the "Authorize" button)
with Swagger UI.
"""
),
]
=
"/docs/oauth2-redirect"
,
swagger_ui_init_oauth
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
OAuth2 configuration for the Swagger UI, by default shown at `/docs`.
Read more about the available configuration options in the
[Swagger UI docs](https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/).
"""
),
]
=
None
,
middleware
:
Annotated
[
Optional
[
Sequence
[
Middleware
]],
Doc
(
"""
List of middleware to be added when creating the application.
In FastAPI you would normally do this with `app.add_middleware()`
instead.
Read more in the
[FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).
"""
),
]
=
None
,
exception_handlers
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
Type
[
Exception
]],
Callable
[[
Request
,
Any
],
Coroutine
[
Any
,
Any
,
Response
]],
]
],
Doc
(
"""
A dictionary with handlers for exceptions.
In FastAPI, you would normally use the decorator
`@app.exception_handler()`.
Read more in the
[FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).
"""
),
]
=
None
,
on_startup
:
Annotated
[
Optional
[
Sequence
[
Callable
[[],
Any
]]],
Doc
(
"""
A list of startup event handler functions.
You should instead use the `lifespan` handlers.
Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
on_shutdown
:
Annotated
[
Optional
[
Sequence
[
Callable
[[],
Any
]]],
Doc
(
"""
A list of shutdown event handler functions.
You should instead use the `lifespan` handlers.
Read more in the
[FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
lifespan
:
Annotated
[
Optional
[
Lifespan
[
AppType
]],
Doc
(
"""
A `Lifespan` context manager handler. This replaces `startup` and
`shutdown` functions with a single context manager.
Read more in the
[FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
terms_of_service
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A URL to the Terms of Service for your API.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more at the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
app = FastAPI(terms_of_service="http://example.com/terms/")
```
"""
),
]
=
None
,
contact
:
Annotated
[
Optional
[
Dict
[
str
,
Union
[
str
,
Any
]]],
Doc
(
"""
A dictionary with the contact information for the exposed API.
It can contain several fields.
* `name`: (`str`) The name of the contact person/organization.
* `url`: (`str`) A URL pointing to the contact information. MUST be in
the format of a URL.
* `email`: (`str`) The email address of the contact person/organization.
MUST be in the format of an email address.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more at the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
app = FastAPI(
contact={
"name": "Deadpoolio the Amazing",
"url": "http://x-force.example.com/contact/",
"email": "dp@x-force.example.com",
}
)
```
"""
),
]
=
None
,
license_info
:
Annotated
[
Optional
[
Dict
[
str
,
Union
[
str
,
Any
]]],
Doc
(
"""
A dictionary with the license information for the exposed API.
It can contain several fields.
* `name`: (`str`) **REQUIRED** (if a `license_info` is set). The
license name used for the API.
* `identifier`: (`str`) An [SPDX](https://spdx.dev/) license expression
for the API. The `identifier` field is mutually exclusive of the `url`
field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.
* `url`: (`str`) A URL to the license used for the API. This MUST be
the format of a URL.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more at the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
app = FastAPI(
license_info={
"name": "Apache 2.0",
"url": "https://www.apache.org/licenses/LICENSE-2.0.html",
}
)
```
"""
),
]
=
None
,
openapi_prefix
:
Annotated
[
str
,
Doc
(
"""
A URL prefix for the OpenAPI URL.
"""
),
deprecated
(
"""
"openapi_prefix" has been deprecated in favor of "root_path", which
follows more closely the ASGI standard, is simpler, and more
automatic.
"""
),
]
=
""
,
root_path
:
Annotated
[
str
,
Doc
(
"""
A path prefix handled by a proxy that is not seen by the application
but is seen by external clients, which affects things like Swagger UI.
Read more about it at the
[FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(root_path="/api/v1")
```
"""
),
]
=
""
,
root_path_in_servers
:
Annotated
[
bool
,
Doc
(
"""
To disable automatically generating the URLs in the `servers` field
in the autogenerated OpenAPI using the `root_path`.
Read more about it in the
[FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#disable-automatic-server-from-root_path).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(root_path_in_servers=False)
```
"""
),
]
=
True
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
And in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
OpenAPI callbacks that should apply to all *path operations*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
webhooks
:
Annotated
[
Optional
[
routing
.
APIRouter
],
Doc
(
"""
Add OpenAPI webhooks. This is similar to `callbacks` but it doesn't
depend on specific *path operations*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
**Note**: This is available since OpenAPI 3.1.0, FastAPI 0.99.0.
Read more about it in the
[FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark all *path operations* as deprecated. You probably don't need it,
but it's available.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) all the *path operations* in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
swagger_ui_parameters
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Parameters to configure Swagger UI, the autogenerated interactive API
documentation (by default at `/docs`).
Read more about it in the
[FastAPI docs about how to Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
separate_input_output_schemas
:
Annotated
[
bool
,
Doc
(
"""
Whether to generate separate OpenAPI schemas for request body and
response body when the results would be more precise.
This is particularly useful when automatically generating clients.
For example, if you have a model like:
```python
from pydantic import BaseModel
class Item(BaseModel):
name: str
tags: list[str] = []
```
When `Item` is used for input, a request body, `tags` is not required,
the client doesn't have to provide it.
But when using `Item` for output, for a response body, `tags` is always
available because it has a default value, even if it's just an empty
list. So, the client should be able to always expect it.
In this case, there would be two different schemas, one for input and
another one for output.
"""
),
]
=
True
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Extra keyword arguments to be stored in the app, not used by FastAPI
anywhere.
"""
),
],
)
->
None
:
self
.
debug
=
debug
self
.
title
=
title
self
.
summary
=
summary
self
.
description
=
description
self
.
version
=
version
self
.
terms_of_service
=
terms_of_service
self
.
contact
=
contact
self
.
license_info
=
license_info
self
.
openapi_url
=
openapi_url
self
.
openapi_tags
=
openapi_tags
self
.
root_path_in_servers
=
root_path_in_servers
self
.
docs_url
=
docs_url
self
.
redoc_url
=
redoc_url
self
.
swagger_ui_oauth2_redirect_url
=
swagger_ui_oauth2_redirect_url
self
.
swagger_ui_init_oauth
=
swagger_ui_init_oauth
self
.
swagger_ui_parameters
=
swagger_ui_parameters
self
.
servers
=
servers
or
[]
self
.
separate_input_output_schemas
=
separate_input_output_schemas
self
.
extra
=
extra
self
.
openapi_version
:
Annotated
[
str
,
Doc
(
"""
The version string of OpenAPI.
FastAPI will generate OpenAPI version 3.1.0, and will output that as
the OpenAPI version. But some tools, even though they might be
compatible with OpenAPI 3.1.0, might not recognize it as a valid.
So you could override this value to trick those tools into using
the generated OpenAPI. Have in mind that this is a hack. But if you
avoid using features added in OpenAPI 3.1.0, it might work for your
use case.
This is not passed as a parameter to the `FastAPI` class to avoid
giving the false idea that FastAPI would generate a different OpenAPI
schema. It is only available as an attribute.
**Example**
```python
from fastapi import FastAPI
app = FastAPI()
app.openapi_version = "3.0.2"
```
"""
),
]
=
"3.1.0"
self
.
openapi_schema
:
Optional
[
Dict
[
str
,
Any
]]
=
None
if
self
.
openapi_url
:
assert
self
.
title
,
"A title must be provided for OpenAPI, e.g.: 'My API'"
assert
self
.
version
,
"A version must be provided for OpenAPI, e.g.: '2.1.0'"
## TODO: remove when discarding the openapi_prefix parameter
if
openapi_prefix
:
logger
.
warning
(
'"openapi_prefix" has been deprecated in favor of "root_path", which '
"follows more closely the ASGI standard, is simpler, and more "
"automatic. Check the docs at "
"https://fastapi.tiangolo.com/advanced/sub-applications/"
)
self
.
webhooks
:
Annotated
[
routing
.
APIRouter
,
Doc
(
"""
The `app.webhooks` attribute is an `APIRouter` with the *path
operations* that will be used just for documentation of webhooks.
Read more about it in the
[FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).
"""
),
]
=
webhooks
or
routing
.
APIRouter
()
self
.
root_path
=
root_path
or
openapi_prefix
self
.
state
:
Annotated
[
State
,
Doc
(
"""
A state object for the application. This is the same object for the
entire application, it doesn't change from request to request.
You normally wouldn't use this in FastAPI, for most of the cases you
would instead use FastAPI dependencies.
This is simply inherited from Starlette.
Read more about it in the
[Starlette docs for Applications](https://www.starlette.io/applications/#storing-state-on-the-app-instance).
"""
),
]
=
State
()
self
.
dependency_overrides
:
Annotated
[
Dict
[
Callable
[
...
,
Any
],
Callable
[
...
,
Any
]],
Doc
(
"""
A dictionary with overrides for the dependencies.
Each key is the original dependency callable, and the value is the
actual dependency that should be called.
This is for testing, to replace expensive dependencies with testing
versions.
Read more about it in the
[FastAPI docs for Testing Dependencies with Overrides](https://fastapi.tiangolo.com/advanced/testing-dependencies/).
"""
),
]
=
{}
self
.
router
:
routing
.
APIRouter
=
routing
.
APIRouter
(
routes
=
routes
,
redirect_slashes
=
redirect_slashes
,
dependency_overrides_provider
=
self
,
on_startup
=
on_startup
,
on_shutdown
=
on_shutdown
,
lifespan
=
lifespan
,
default_response_class
=
default_response_class
,
dependencies
=
dependencies
,
callbacks
=
callbacks
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
responses
=
responses
,
generate_unique_id_function
=
generate_unique_id_function
,
)
self
.
exception_handlers
:
Dict
[
Any
,
Callable
[[
Request
,
Any
],
Union
[
Response
,
Awaitable
[
Response
]]]
]
=
{}
if
exception_handlers
is
None
else
dict
(
exception_handlers
)
self
.
exception_handlers
.
setdefault
(
HTTPException
,
http_exception_handler
)
self
.
exception_handlers
.
setdefault
(
RequestValidationError
,
request_validation_exception_handler
)
self
.
exception_handlers
.
setdefault
(
WebSocketRequestValidationError
,
## Starlette still has incorrect type specification for the handlers
websocket_request_validation_exception_handler
,
## type: ignore
)
self
.
user_middleware
:
List
[
Middleware
]
=
(
[]
if
middleware
is
None
else
list
(
middleware
)
)
self
.
middleware_stack
:
Union
[
ASGIApp
,
None
]
=
None
self
.
setup
()
openapi_version
instance-attribute
openapi_version
=
'3.1.0'
The version string of OpenAPI.
FastAPI will generate OpenAPI version 3.1.0, and will output that as
the OpenAPI version. But some tools, even though they might be
compatible with OpenAPI 3.1.0, might not recognize it as a valid.
So you could override this value to trick those tools into using
the generated OpenAPI. Have in mind that this is a hack. But if you
avoid using features added in OpenAPI 3.1.0, it might work for your
use case.
This is not passed as a parameter to the
FastAPI
class to avoid
giving the false idea that FastAPI would generate a different OpenAPI
schema. It is only available as an attribute.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
app
.
openapi_version
=
"3.0.2"
webhooks
instance-attribute
webhooks
=
webhooks
or
APIRouter
()
The
app.webhooks
attribute is an
APIRouter
with the
path
operations
that will be used just for documentation of webhooks.
Read more about it in the
FastAPI docs for OpenAPI Webhooks
.
state
instance-attribute
state
=
State
()
A state object for the application. This is the same object for the
entire application, it doesn't change from request to request.
You normally wouldn't use this in FastAPI, for most of the cases you
would instead use FastAPI dependencies.
This is simply inherited from Starlette.
Read more about it in the
Starlette docs for Applications
.
dependency_overrides
instance-attribute
dependency_overrides
=
{}
A dictionary with overrides for the dependencies.
Each key is the original dependency callable, and the value is the
actual dependency that should be called.
This is for testing, to replace expensive dependencies with testing
versions.
Read more about it in the
FastAPI docs for Testing Dependencies with Overrides
.
openapi
openapi
()
Generate the OpenAPI schema of the application. This is called by FastAPI
internally.
The first time it is called it stores the result in the attribute
app.openapi_schema
, and next times it is called, it just returns that same
result. To avoid the cost of generating the schema every time.
If you need to modify the generated OpenAPI schema, you could modify it.
Read more in the
FastAPI docs for OpenAPI
.
Source code in
fastapi/applications.py
966
967
968
969
970
971
972
973
974
975
976
977
978
979
980
981
982
983
984
985
986
987
988
989
990
991
992
993
994
995
996
def
openapi
(
self
)
->
Dict
[
str
,
Any
]:
"""
Generate the OpenAPI schema of the application. This is called by FastAPI
internally.
The first time it is called it stores the result in the attribute
`app.openapi_schema`, and next times it is called, it just returns that same
result. To avoid the cost of generating the schema every time.
If you need to modify the generated OpenAPI schema, you could modify it.
Read more in the
[FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).
"""
if
not
self
.
openapi_schema
:
self
.
openapi_schema
=
get_openapi
(
title
=
self
.
title
,
version
=
self
.
version
,
openapi_version
=
self
.
openapi_version
,
summary
=
self
.
summary
,
description
=
self
.
description
,
terms_of_service
=
self
.
terms_of_service
,
contact
=
self
.
contact
,
license_info
=
self
.
license_info
,
routes
=
self
.
routes
,
webhooks
=
self
.
webhooks
.
routes
,
tags
=
self
.
openapi_tags
,
servers
=
self
.
servers
,
separate_input_output_schemas
=
self
.
separate_input_output_schemas
,
)
return
self
.
openapi_schema
websocket
websocket
(
path
,
name
=
None
,
*
,
dependencies
=
None
)
Decorate a WebSocket function.
Read more about it in the
FastAPI docs for WebSockets
.
Example
from
fastapi
import
FastAPI
,
WebSocket
app
=
FastAPI
()
@app
.
websocket
(
"/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
"
)
PARAMETER
DESCRIPTION
path
WebSocket path.
TYPE:
str
name
A name for the WebSocket. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be used for this
WebSocket.
Read more about it in the
FastAPI docs for WebSockets
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
Source code in
fastapi/applications.py
1190
1191
1192
1193
1194
1195
1196
1197
1198
1199
1200
1201
1202
1203
1204
1205
1206
1207
1208
1209
1210
1211
1212
1213
1214
1215
1216
1217
1218
1219
1220
1221
1222
1223
1224
1225
1226
1227
1228
1229
1230
1231
1232
1233
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243
1244
1245
1246
1247
1248
1249
1250
1251
1252
1253
def
websocket
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
WebSocket path.
"""
),
],
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A name for the WebSocket. Only used internally.
"""
),
]
=
None
,
*
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be used for this
WebSocket.
Read more about it in the
[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
"""
),
]
=
None
,
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Decorate a WebSocket function.
Read more about it in the
[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
**Example**
```python
from fastapi import FastAPI, WebSocket
app = FastAPI()
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
await websocket.accept()
while True:
data = await websocket.receive_text()
await websocket.send_text(f"Message text was: {data}")
```
"""
def
decorator
(
func
:
DecoratedCallable
)
->
DecoratedCallable
:
self
.
add_api_websocket_route
(
path
,
func
,
name
=
name
,
dependencies
=
dependencies
,
)
return
func
return
decorator
include_router
include_router
(
router
,
*
,
prefix
=
""
,
tags
=
None
,
dependencies
=
None
,
responses
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
default_response_class
=
Default
(
JSONResponse
),
callbacks
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Include an
APIRouter
in the same app.
Read more about it in the
FastAPI docs for Bigger Applications
.
Example
from
fastapi
import
FastAPI
from
.users
import
users_router
app
=
FastAPI
()
app
.
include_router
(
users_router
)
PARAMETER
DESCRIPTION
router
The
APIRouter
to include.
TYPE:
APIRouter
prefix
An optional path prefix for the router.
TYPE:
str
DEFAULT:
''
tags
A list of tags to be applied to all the
path operations
in this
router.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to all the
path operations
in this router.
Read more about it in the
FastAPI docs for Bigger Applications - Multiple Files
.
Example
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_token_header
from
.internal
import
admin
app
=
FastAPI
()
app
.
include_router
(
admin
.
router
,
dependencies
=
[
Depends
(
get_token_header
)],
)
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
responses
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Additional Responses in OpenAPI
.
And in the
FastAPI docs for Bigger Applications
.
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark all the
path operations
in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Example
from
fastapi
import
FastAPI
from
.internal
import
old_api
app
=
FastAPI
()
app
.
include_router
(
old_api
.
router
,
deprecated
=
True
,
)
TYPE:
Optional
[
bool
]
DEFAULT:
None
include_in_schema
Include (or not) all the
path operations
in this router in the
generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Example
from
fastapi
import
FastAPI
from
.internal
import
old_api
app
=
FastAPI
()
app
.
include_router
(
old_api
.
router
,
include_in_schema
=
False
,
)
TYPE:
bool
DEFAULT:
True
default_response_class
Default response class to be used for the
path operations
in this
router.
Read more in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
Example
from
fastapi
import
FastAPI
from
fastapi.responses
import
ORJSONResponse
from
.internal
import
old_api
app
=
FastAPI
()
app
.
include_router
(
old_api
.
router
,
default_response_class
=
ORJSONResponse
,
)
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
1255
1256
1257
1258
1259
1260
1261
1262
1263
1264
1265
1266
1267
1268
1269
1270
1271
1272
1273
1274
1275
1276
1277
1278
1279
1280
1281
1282
1283
1284
1285
1286
1287
1288
1289
1290
1291
1292
1293
1294
1295
1296
1297
1298
1299
1300
1301
1302
1303
1304
1305
1306
1307
1308
1309
1310
1311
1312
1313
1314
1315
1316
1317
1318
1319
1320
1321
1322
1323
1324
1325
1326
1327
1328
1329
1330
1331
1332
1333
1334
1335
1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352
1353
1354
1355
1356
1357
1358
1359
1360
1361
1362
1363
1364
1365
1366
1367
1368
1369
1370
1371
1372
1373
1374
1375
1376
1377
1378
1379
1380
1381
1382
1383
1384
1385
1386
1387
1388
1389
1390
1391
1392
1393
1394
1395
1396
1397
1398
1399
1400
1401
1402
1403
1404
1405
1406
1407
1408
1409
1410
1411
1412
1413
1414
1415
1416
1417
1418
1419
1420
1421
1422
1423
1424
1425
1426
1427
1428
1429
1430
1431
1432
1433
1434
1435
1436
1437
1438
1439
1440
1441
1442
1443
1444
1445
1446
1447
1448
1449
1450
1451
1452
1453
1454
1455
1456
1457
1458
def
include_router
(
self
,
router
:
Annotated
[
routing
.
APIRouter
,
Doc
(
"The `APIRouter` to include."
)],
*
,
prefix
:
Annotated
[
str
,
Doc
(
"An optional path prefix for the router."
)]
=
""
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to all the *path operations* in this
router.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to all the
*path operations* in this router.
Read more about it in the
[FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
**Example**
```python
from fastapi import Depends, FastAPI
from .dependencies import get_token_header
from .internal import admin
app = FastAPI()
app.include_router(
admin.router,
dependencies=[Depends(get_token_header)],
)
```
"""
),
]
=
None
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
And in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark all the *path operations* in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
**Example**
```python
from fastapi import FastAPI
from .internal import old_api
app = FastAPI()
app.include_router(
old_api.router,
deprecated=True,
)
```
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include (or not) all the *path operations* in this router in the
generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
**Example**
```python
from fastapi import FastAPI
from .internal import old_api
app = FastAPI()
app.include_router(
old_api.router,
include_in_schema=False,
)
```
"""
),
]
=
True
,
default_response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Default response class to be used for the *path operations* in this
router.
Read more in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
**Example**
```python
from fastapi import FastAPI
from fastapi.responses import ORJSONResponse
from .internal import old_api
app = FastAPI()
app.include_router(
old_api.router,
default_response_class=ORJSONResponse,
)
```
"""
),
]
=
Default
(
JSONResponse
),
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
None
:
"""
Include an `APIRouter` in the same app.
Read more about it in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).
## Example
```python
from fastapi import FastAPI
from .users import users_router
app = FastAPI()
app.include_router(users_router)
```
"""
self
.
router
.
include_router
(
router
,
prefix
=
prefix
,
tags
=
tags
,
dependencies
=
dependencies
,
responses
=
responses
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
default_response_class
=
default_response_class
,
callbacks
=
callbacks
,
generate_unique_id_function
=
generate_unique_id_function
,
)
get
get
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP GET operation.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
def
read_items
():
return
[{
"name"
:
"Empanada"
},
{
"name"
:
"Arepa"
}]
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
1460
1461
1462
1463
1464
1465
1466
1467
1468
1469
1470
1471
1472
1473
1474
1475
1476
1477
1478
1479
1480
1481
1482
1483
1484
1485
1486
1487
1488
1489
1490
1491
1492
1493
1494
1495
1496
1497
1498
1499
1500
1501
1502
1503
1504
1505
1506
1507
1508
1509
1510
1511
1512
1513
1514
1515
1516
1517
1518
1519
1520
1521
1522
1523
1524
1525
1526
1527
1528
1529
1530
1531
1532
1533
1534
1535
1536
1537
1538
1539
1540
1541
1542
1543
1544
1545
1546
1547
1548
1549
1550
1551
1552
1553
1554
1555
1556
1557
1558
1559
1560
1561
1562
1563
1564
1565
1566
1567
1568
1569
1570
1571
1572
1573
1574
1575
1576
1577
1578
1579
1580
1581
1582
1583
1584
1585
1586
1587
1588
1589
1590
1591
1592
1593
1594
1595
1596
1597
1598
1599
1600
1601
1602
1603
1604
1605
1606
1607
1608
1609
1610
1611
1612
1613
1614
1615
1616
1617
1618
1619
1620
1621
1622
1623
1624
1625
1626
1627
1628
1629
1630
1631
1632
1633
1634
1635
1636
1637
1638
1639
1640
1641
1642
1643
1644
1645
1646
1647
1648
1649
1650
1651
1652
1653
1654
1655
1656
1657
1658
1659
1660
1661
1662
1663
1664
1665
1666
1667
1668
1669
1670
1671
1672
1673
1674
1675
1676
1677
1678
1679
1680
1681
1682
1683
1684
1685
1686
1687
1688
1689
1690
1691
1692
1693
1694
1695
1696
1697
1698
1699
1700
1701
1702
1703
1704
1705
1706
1707
1708
1709
1710
1711
1712
1713
1714
1715
1716
1717
1718
1719
1720
1721
1722
1723
1724
1725
1726
1727
1728
1729
1730
1731
1732
1733
1734
1735
1736
1737
1738
1739
1740
1741
1742
1743
1744
1745
1746
1747
1748
1749
1750
1751
1752
1753
1754
1755
1756
1757
1758
1759
1760
1761
1762
1763
1764
1765
1766
1767
1768
1769
1770
1771
1772
1773
1774
1775
1776
1777
1778
1779
1780
1781
1782
1783
1784
1785
1786
1787
1788
1789
1790
1791
1792
1793
1794
1795
1796
1797
1798
1799
1800
1801
1802
1803
1804
1805
1806
1807
1808
1809
1810
1811
1812
1813
1814
1815
1816
1817
1818
1819
1820
1821
1822
1823
1824
1825
1826
1827
1828
1829
1830
1831
def
get
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP GET operation.
## Example
```python
from fastapi import FastAPI
app = FastAPI()
@app.get("/items/")
def read_items():
return [{"name": "Empanada"}, {"name": "Arepa"}]
```
"""
return
self
.
router
.
get
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
put
put
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP PUT operation.
Example
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
def
replace_item
(
item_id
:
str
,
item
:
Item
):
return
{
"message"
:
"Item replaced"
,
"id"
:
item_id
}
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
1833
1834
1835
1836
1837
1838
1839
1840
1841
1842
1843
1844
1845
1846
1847
1848
1849
1850
1851
1852
1853
1854
1855
1856
1857
1858
1859
1860
1861
1862
1863
1864
1865
1866
1867
1868
1869
1870
1871
1872
1873
1874
1875
1876
1877
1878
1879
1880
1881
1882
1883
1884
1885
1886
1887
1888
1889
1890
1891
1892
1893
1894
1895
1896
1897
1898
1899
1900
1901
1902
1903
1904
1905
1906
1907
1908
1909
1910
1911
1912
1913
1914
1915
1916
1917
1918
1919
1920
1921
1922
1923
1924
1925
1926
1927
1928
1929
1930
1931
1932
1933
1934
1935
1936
1937
1938
1939
1940
1941
1942
1943
1944
1945
1946
1947
1948
1949
1950
1951
1952
1953
1954
1955
1956
1957
1958
1959
1960
1961
1962
1963
1964
1965
1966
1967
1968
1969
1970
1971
1972
1973
1974
1975
1976
1977
1978
1979
1980
1981
1982
1983
1984
1985
1986
1987
1988
1989
1990
1991
1992
1993
1994
1995
1996
1997
1998
1999
2000
2001
2002
2003
2004
2005
2006
2007
2008
2009
2010
2011
2012
2013
2014
2015
2016
2017
2018
2019
2020
2021
2022
2023
2024
2025
2026
2027
2028
2029
2030
2031
2032
2033
2034
2035
2036
2037
2038
2039
2040
2041
2042
2043
2044
2045
2046
2047
2048
2049
2050
2051
2052
2053
2054
2055
2056
2057
2058
2059
2060
2061
2062
2063
2064
2065
2066
2067
2068
2069
2070
2071
2072
2073
2074
2075
2076
2077
2078
2079
2080
2081
2082
2083
2084
2085
2086
2087
2088
2089
2090
2091
2092
2093
2094
2095
2096
2097
2098
2099
2100
2101
2102
2103
2104
2105
2106
2107
2108
2109
2110
2111
2112
2113
2114
2115
2116
2117
2118
2119
2120
2121
2122
2123
2124
2125
2126
2127
2128
2129
2130
2131
2132
2133
2134
2135
2136
2137
2138
2139
2140
2141
2142
2143
2144
2145
2146
2147
2148
2149
2150
2151
2152
2153
2154
2155
2156
2157
2158
2159
2160
2161
2162
2163
2164
2165
2166
2167
2168
2169
2170
2171
2172
2173
2174
2175
2176
2177
2178
2179
2180
2181
2182
2183
2184
2185
2186
2187
2188
2189
2190
2191
2192
2193
2194
2195
2196
2197
2198
2199
2200
2201
2202
2203
2204
2205
2206
2207
2208
2209
def
put
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP PUT operation.
## Example
```python
from fastapi import FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
@app.put("/items/{item_id}")
def replace_item(item_id: str, item: Item):
return {"message": "Item replaced", "id": item_id}
```
"""
return
self
.
router
.
put
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
post
post
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP POST operation.
Example
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item created"
}
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
2211
2212
2213
2214
2215
2216
2217
2218
2219
2220
2221
2222
2223
2224
2225
2226
2227
2228
2229
2230
2231
2232
2233
2234
2235
2236
2237
2238
2239
2240
2241
2242
2243
2244
2245
2246
2247
2248
2249
2250
2251
2252
2253
2254
2255
2256
2257
2258
2259
2260
2261
2262
2263
2264
2265
2266
2267
2268
2269
2270
2271
2272
2273
2274
2275
2276
2277
2278
2279
2280
2281
2282
2283
2284
2285
2286
2287
2288
2289
2290
2291
2292
2293
2294
2295
2296
2297
2298
2299
2300
2301
2302
2303
2304
2305
2306
2307
2308
2309
2310
2311
2312
2313
2314
2315
2316
2317
2318
2319
2320
2321
2322
2323
2324
2325
2326
2327
2328
2329
2330
2331
2332
2333
2334
2335
2336
2337
2338
2339
2340
2341
2342
2343
2344
2345
2346
2347
2348
2349
2350
2351
2352
2353
2354
2355
2356
2357
2358
2359
2360
2361
2362
2363
2364
2365
2366
2367
2368
2369
2370
2371
2372
2373
2374
2375
2376
2377
2378
2379
2380
2381
2382
2383
2384
2385
2386
2387
2388
2389
2390
2391
2392
2393
2394
2395
2396
2397
2398
2399
2400
2401
2402
2403
2404
2405
2406
2407
2408
2409
2410
2411
2412
2413
2414
2415
2416
2417
2418
2419
2420
2421
2422
2423
2424
2425
2426
2427
2428
2429
2430
2431
2432
2433
2434
2435
2436
2437
2438
2439
2440
2441
2442
2443
2444
2445
2446
2447
2448
2449
2450
2451
2452
2453
2454
2455
2456
2457
2458
2459
2460
2461
2462
2463
2464
2465
2466
2467
2468
2469
2470
2471
2472
2473
2474
2475
2476
2477
2478
2479
2480
2481
2482
2483
2484
2485
2486
2487
2488
2489
2490
2491
2492
2493
2494
2495
2496
2497
2498
2499
2500
2501
2502
2503
2504
2505
2506
2507
2508
2509
2510
2511
2512
2513
2514
2515
2516
2517
2518
2519
2520
2521
2522
2523
2524
2525
2526
2527
2528
2529
2530
2531
2532
2533
2534
2535
2536
2537
2538
2539
2540
2541
2542
2543
2544
2545
2546
2547
2548
2549
2550
2551
2552
2553
2554
2555
2556
2557
2558
2559
2560
2561
2562
2563
2564
2565
2566
2567
2568
2569
2570
2571
2572
2573
2574
2575
2576
2577
2578
2579
2580
2581
2582
2583
2584
2585
2586
2587
def
post
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP POST operation.
## Example
```python
from fastapi import FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
@app.post("/items/")
def create_item(item: Item):
return {"message": "Item created"}
```
"""
return
self
.
router
.
post
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
delete
delete
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP DELETE operation.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
delete
(
"/items/
{item_id}
"
)
def
delete_item
(
item_id
:
str
):
return
{
"message"
:
"Item deleted"
}
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
2589
2590
2591
2592
2593
2594
2595
2596
2597
2598
2599
2600
2601
2602
2603
2604
2605
2606
2607
2608
2609
2610
2611
2612
2613
2614
2615
2616
2617
2618
2619
2620
2621
2622
2623
2624
2625
2626
2627
2628
2629
2630
2631
2632
2633
2634
2635
2636
2637
2638
2639
2640
2641
2642
2643
2644
2645
2646
2647
2648
2649
2650
2651
2652
2653
2654
2655
2656
2657
2658
2659
2660
2661
2662
2663
2664
2665
2666
2667
2668
2669
2670
2671
2672
2673
2674
2675
2676
2677
2678
2679
2680
2681
2682
2683
2684
2685
2686
2687
2688
2689
2690
2691
2692
2693
2694
2695
2696
2697
2698
2699
2700
2701
2702
2703
2704
2705
2706
2707
2708
2709
2710
2711
2712
2713
2714
2715
2716
2717
2718
2719
2720
2721
2722
2723
2724
2725
2726
2727
2728
2729
2730
2731
2732
2733
2734
2735
2736
2737
2738
2739
2740
2741
2742
2743
2744
2745
2746
2747
2748
2749
2750
2751
2752
2753
2754
2755
2756
2757
2758
2759
2760
2761
2762
2763
2764
2765
2766
2767
2768
2769
2770
2771
2772
2773
2774
2775
2776
2777
2778
2779
2780
2781
2782
2783
2784
2785
2786
2787
2788
2789
2790
2791
2792
2793
2794
2795
2796
2797
2798
2799
2800
2801
2802
2803
2804
2805
2806
2807
2808
2809
2810
2811
2812
2813
2814
2815
2816
2817
2818
2819
2820
2821
2822
2823
2824
2825
2826
2827
2828
2829
2830
2831
2832
2833
2834
2835
2836
2837
2838
2839
2840
2841
2842
2843
2844
2845
2846
2847
2848
2849
2850
2851
2852
2853
2854
2855
2856
2857
2858
2859
2860
2861
2862
2863
2864
2865
2866
2867
2868
2869
2870
2871
2872
2873
2874
2875
2876
2877
2878
2879
2880
2881
2882
2883
2884
2885
2886
2887
2888
2889
2890
2891
2892
2893
2894
2895
2896
2897
2898
2899
2900
2901
2902
2903
2904
2905
2906
2907
2908
2909
2910
2911
2912
2913
2914
2915
2916
2917
2918
2919
2920
2921
2922
2923
2924
2925
2926
2927
2928
2929
2930
2931
2932
2933
2934
2935
2936
2937
2938
2939
2940
2941
2942
2943
2944
2945
2946
2947
2948
2949
2950
2951
2952
2953
2954
2955
2956
2957
2958
2959
2960
def
delete
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP DELETE operation.
## Example
```python
from fastapi import FastAPI
app = FastAPI()
@app.delete("/items/{item_id}")
def delete_item(item_id: str):
return {"message": "Item deleted"}
```
"""
return
self
.
router
.
delete
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
options
options
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP OPTIONS operation.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
options
(
"/items/"
)
def
get_item_options
():
return
{
"additions"
:
[
"Aji"
,
"Guacamole"
]}
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
2962
2963
2964
2965
2966
2967
2968
2969
2970
2971
2972
2973
2974
2975
2976
2977
2978
2979
2980
2981
2982
2983
2984
2985
2986
2987
2988
2989
2990
2991
2992
2993
2994
2995
2996
2997
2998
2999
3000
3001
3002
3003
3004
3005
3006
3007
3008
3009
3010
3011
3012
3013
3014
3015
3016
3017
3018
3019
3020
3021
3022
3023
3024
3025
3026
3027
3028
3029
3030
3031
3032
3033
3034
3035
3036
3037
3038
3039
3040
3041
3042
3043
3044
3045
3046
3047
3048
3049
3050
3051
3052
3053
3054
3055
3056
3057
3058
3059
3060
3061
3062
3063
3064
3065
3066
3067
3068
3069
3070
3071
3072
3073
3074
3075
3076
3077
3078
3079
3080
3081
3082
3083
3084
3085
3086
3087
3088
3089
3090
3091
3092
3093
3094
3095
3096
3097
3098
3099
3100
3101
3102
3103
3104
3105
3106
3107
3108
3109
3110
3111
3112
3113
3114
3115
3116
3117
3118
3119
3120
3121
3122
3123
3124
3125
3126
3127
3128
3129
3130
3131
3132
3133
3134
3135
3136
3137
3138
3139
3140
3141
3142
3143
3144
3145
3146
3147
3148
3149
3150
3151
3152
3153
3154
3155
3156
3157
3158
3159
3160
3161
3162
3163
3164
3165
3166
3167
3168
3169
3170
3171
3172
3173
3174
3175
3176
3177
3178
3179
3180
3181
3182
3183
3184
3185
3186
3187
3188
3189
3190
3191
3192
3193
3194
3195
3196
3197
3198
3199
3200
3201
3202
3203
3204
3205
3206
3207
3208
3209
3210
3211
3212
3213
3214
3215
3216
3217
3218
3219
3220
3221
3222
3223
3224
3225
3226
3227
3228
3229
3230
3231
3232
3233
3234
3235
3236
3237
3238
3239
3240
3241
3242
3243
3244
3245
3246
3247
3248
3249
3250
3251
3252
3253
3254
3255
3256
3257
3258
3259
3260
3261
3262
3263
3264
3265
3266
3267
3268
3269
3270
3271
3272
3273
3274
3275
3276
3277
3278
3279
3280
3281
3282
3283
3284
3285
3286
3287
3288
3289
3290
3291
3292
3293
3294
3295
3296
3297
3298
3299
3300
3301
3302
3303
3304
3305
3306
3307
3308
3309
3310
3311
3312
3313
3314
3315
3316
3317
3318
3319
3320
3321
3322
3323
3324
3325
3326
3327
3328
3329
3330
3331
3332
3333
def
options
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP OPTIONS operation.
## Example
```python
from fastapi import FastAPI
app = FastAPI()
@app.options("/items/")
def get_item_options():
return {"additions": ["Aji", "Guacamole"]}
```
"""
return
self
.
router
.
options
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
head
head
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP HEAD operation.
Example
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
@app
.
head
(
"/items/"
,
status_code
=
204
)
def
get_items_headers
(
response
:
Response
):
response
.
headers
[
"X-Cat-Dog"
]
=
"Alone in the world"
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
3335
3336
3337
3338
3339
3340
3341
3342
3343
3344
3345
3346
3347
3348
3349
3350
3351
3352
3353
3354
3355
3356
3357
3358
3359
3360
3361
3362
3363
3364
3365
3366
3367
3368
3369
3370
3371
3372
3373
3374
3375
3376
3377
3378
3379
3380
3381
3382
3383
3384
3385
3386
3387
3388
3389
3390
3391
3392
3393
3394
3395
3396
3397
3398
3399
3400
3401
3402
3403
3404
3405
3406
3407
3408
3409
3410
3411
3412
3413
3414
3415
3416
3417
3418
3419
3420
3421
3422
3423
3424
3425
3426
3427
3428
3429
3430
3431
3432
3433
3434
3435
3436
3437
3438
3439
3440
3441
3442
3443
3444
3445
3446
3447
3448
3449
3450
3451
3452
3453
3454
3455
3456
3457
3458
3459
3460
3461
3462
3463
3464
3465
3466
3467
3468
3469
3470
3471
3472
3473
3474
3475
3476
3477
3478
3479
3480
3481
3482
3483
3484
3485
3486
3487
3488
3489
3490
3491
3492
3493
3494
3495
3496
3497
3498
3499
3500
3501
3502
3503
3504
3505
3506
3507
3508
3509
3510
3511
3512
3513
3514
3515
3516
3517
3518
3519
3520
3521
3522
3523
3524
3525
3526
3527
3528
3529
3530
3531
3532
3533
3534
3535
3536
3537
3538
3539
3540
3541
3542
3543
3544
3545
3546
3547
3548
3549
3550
3551
3552
3553
3554
3555
3556
3557
3558
3559
3560
3561
3562
3563
3564
3565
3566
3567
3568
3569
3570
3571
3572
3573
3574
3575
3576
3577
3578
3579
3580
3581
3582
3583
3584
3585
3586
3587
3588
3589
3590
3591
3592
3593
3594
3595
3596
3597
3598
3599
3600
3601
3602
3603
3604
3605
3606
3607
3608
3609
3610
3611
3612
3613
3614
3615
3616
3617
3618
3619
3620
3621
3622
3623
3624
3625
3626
3627
3628
3629
3630
3631
3632
3633
3634
3635
3636
3637
3638
3639
3640
3641
3642
3643
3644
3645
3646
3647
3648
3649
3650
3651
3652
3653
3654
3655
3656
3657
3658
3659
3660
3661
3662
3663
3664
3665
3666
3667
3668
3669
3670
3671
3672
3673
3674
3675
3676
3677
3678
3679
3680
3681
3682
3683
3684
3685
3686
3687
3688
3689
3690
3691
3692
3693
3694
3695
3696
3697
3698
3699
3700
3701
3702
3703
3704
3705
3706
def
head
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP HEAD operation.
## Example
```python
from fastapi import FastAPI, Response
app = FastAPI()
@app.head("/items/", status_code=204)
def get_items_headers(response: Response):
response.headers["X-Cat-Dog"] = "Alone in the world"
```
"""
return
self
.
router
.
head
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
patch
patch
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP PATCH operation.
Example
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
patch
(
"/items/"
)
def
update_item
(
item
:
Item
):
return
{
"message"
:
"Item updated in place"
}
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
3708
3709
3710
3711
3712
3713
3714
3715
3716
3717
3718
3719
3720
3721
3722
3723
3724
3725
3726
3727
3728
3729
3730
3731
3732
3733
3734
3735
3736
3737
3738
3739
3740
3741
3742
3743
3744
3745
3746
3747
3748
3749
3750
3751
3752
3753
3754
3755
3756
3757
3758
3759
3760
3761
3762
3763
3764
3765
3766
3767
3768
3769
3770
3771
3772
3773
3774
3775
3776
3777
3778
3779
3780
3781
3782
3783
3784
3785
3786
3787
3788
3789
3790
3791
3792
3793
3794
3795
3796
3797
3798
3799
3800
3801
3802
3803
3804
3805
3806
3807
3808
3809
3810
3811
3812
3813
3814
3815
3816
3817
3818
3819
3820
3821
3822
3823
3824
3825
3826
3827
3828
3829
3830
3831
3832
3833
3834
3835
3836
3837
3838
3839
3840
3841
3842
3843
3844
3845
3846
3847
3848
3849
3850
3851
3852
3853
3854
3855
3856
3857
3858
3859
3860
3861
3862
3863
3864
3865
3866
3867
3868
3869
3870
3871
3872
3873
3874
3875
3876
3877
3878
3879
3880
3881
3882
3883
3884
3885
3886
3887
3888
3889
3890
3891
3892
3893
3894
3895
3896
3897
3898
3899
3900
3901
3902
3903
3904
3905
3906
3907
3908
3909
3910
3911
3912
3913
3914
3915
3916
3917
3918
3919
3920
3921
3922
3923
3924
3925
3926
3927
3928
3929
3930
3931
3932
3933
3934
3935
3936
3937
3938
3939
3940
3941
3942
3943
3944
3945
3946
3947
3948
3949
3950
3951
3952
3953
3954
3955
3956
3957
3958
3959
3960
3961
3962
3963
3964
3965
3966
3967
3968
3969
3970
3971
3972
3973
3974
3975
3976
3977
3978
3979
3980
3981
3982
3983
3984
3985
3986
3987
3988
3989
3990
3991
3992
3993
3994
3995
3996
3997
3998
3999
4000
4001
4002
4003
4004
4005
4006
4007
4008
4009
4010
4011
4012
4013
4014
4015
4016
4017
4018
4019
4020
4021
4022
4023
4024
4025
4026
4027
4028
4029
4030
4031
4032
4033
4034
4035
4036
4037
4038
4039
4040
4041
4042
4043
4044
4045
4046
4047
4048
4049
4050
4051
4052
4053
4054
4055
4056
4057
4058
4059
4060
4061
4062
4063
4064
4065
4066
4067
4068
4069
4070
4071
4072
4073
4074
4075
4076
4077
4078
4079
4080
4081
4082
4083
4084
def
patch
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP PATCH operation.
## Example
```python
from fastapi import FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
@app.patch("/items/")
def update_item(item: Item):
return {"message": "Item updated in place"}
```
"""
return
self
.
router
.
patch
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
trace
trace
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP TRACE operation.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
trace
(
"/items/
{item_id}
"
)
def
trace_item
(
item_id
:
str
):
return
None
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
4086
4087
4088
4089
4090
4091
4092
4093
4094
4095
4096
4097
4098
4099
4100
4101
4102
4103
4104
4105
4106
4107
4108
4109
4110
4111
4112
4113
4114
4115
4116
4117
4118
4119
4120
4121
4122
4123
4124
4125
4126
4127
4128
4129
4130
4131
4132
4133
4134
4135
4136
4137
4138
4139
4140
4141
4142
4143
4144
4145
4146
4147
4148
4149
4150
4151
4152
4153
4154
4155
4156
4157
4158
4159
4160
4161
4162
4163
4164
4165
4166
4167
4168
4169
4170
4171
4172
4173
4174
4175
4176
4177
4178
4179
4180
4181
4182
4183
4184
4185
4186
4187
4188
4189
4190
4191
4192
4193
4194
4195
4196
4197
4198
4199
4200
4201
4202
4203
4204
4205
4206
4207
4208
4209
4210
4211
4212
4213
4214
4215
4216
4217
4218
4219
4220
4221
4222
4223
4224
4225
4226
4227
4228
4229
4230
4231
4232
4233
4234
4235
4236
4237
4238
4239
4240
4241
4242
4243
4244
4245
4246
4247
4248
4249
4250
4251
4252
4253
4254
4255
4256
4257
4258
4259
4260
4261
4262
4263
4264
4265
4266
4267
4268
4269
4270
4271
4272
4273
4274
4275
4276
4277
4278
4279
4280
4281
4282
4283
4284
4285
4286
4287
4288
4289
4290
4291
4292
4293
4294
4295
4296
4297
4298
4299
4300
4301
4302
4303
4304
4305
4306
4307
4308
4309
4310
4311
4312
4313
4314
4315
4316
4317
4318
4319
4320
4321
4322
4323
4324
4325
4326
4327
4328
4329
4330
4331
4332
4333
4334
4335
4336
4337
4338
4339
4340
4341
4342
4343
4344
4345
4346
4347
4348
4349
4350
4351
4352
4353
4354
4355
4356
4357
4358
4359
4360
4361
4362
4363
4364
4365
4366
4367
4368
4369
4370
4371
4372
4373
4374
4375
4376
4377
4378
4379
4380
4381
4382
4383
4384
4385
4386
4387
4388
4389
4390
4391
4392
4393
4394
4395
4396
4397
4398
4399
4400
4401
4402
4403
4404
4405
4406
4407
4408
4409
4410
4411
4412
4413
4414
4415
4416
4417
4418
4419
4420
4421
4422
4423
4424
4425
4426
4427
4428
4429
4430
4431
4432
4433
4434
4435
4436
4437
4438
4439
4440
4441
4442
4443
4444
4445
4446
4447
4448
4449
4450
4451
4452
4453
4454
4455
4456
4457
def
trace
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP TRACE operation.
## Example
```python
from fastapi import FastAPI
app = FastAPI()
@app.trace("/items/{item_id}")
def trace_item(item_id: str):
return None
```
"""
return
self
.
router
.
trace
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
on_event
on_event
(
event_type
)
Add an event handler for the application.
on_event
is deprecated, use
lifespan
event handlers instead.
Read more about it in the
FastAPI docs for Lifespan Events
.
PARAMETER
DESCRIPTION
event_type
The type of event.
startup
or
shutdown
.
TYPE:
str
Source code in
fastapi/applications.py
4468
4469
4470
4471
4472
4473
4474
4475
4476
4477
4478
4479
4480
4481
4482
4483
4484
4485
4486
4487
4488
4489
4490
4491
4492
4493
4494
4495
@deprecated
(
"""
on_event is deprecated, use lifespan event handlers instead.
Read more about it in the
[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
"""
)
def
on_event
(
self
,
event_type
:
Annotated
[
str
,
Doc
(
"""
The type of event. `startup` or `shutdown`.
"""
),
],
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add an event handler for the application.
`on_event` is deprecated, use `lifespan` event handlers instead.
Read more about it in the
[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).
"""
return
self
.
router
.
on_event
(
event_type
)
middleware
middleware
(
middleware_type
)
Add a middleware to the application.
Read more about it in the
FastAPI docs for Middleware
.
Example
import
time
from
typing
import
Awaitable
,
Callable
from
fastapi
import
FastAPI
,
Request
,
Response
app
=
FastAPI
()
@app
.
middleware
(
"http"
)
async
def
add_process_time_header
(
request
:
Request
,
call_next
:
Callable
[[
Request
],
Awaitable
[
Response
]]
)
->
Response
:
start_time
=
time
.
time
()
response
=
await
call_next
(
request
)
process_time
=
time
.
time
()
-
start_time
response
.
headers
[
"X-Process-Time"
]
=
str
(
process_time
)
return
response
PARAMETER
DESCRIPTION
middleware_type
The type of middleware. Currently only supports
http
.
TYPE:
str
Source code in
fastapi/applications.py
4497
4498
4499
4500
4501
4502
4503
4504
4505
4506
4507
4508
4509
4510
4511
4512
4513
4514
4515
4516
4517
4518
4519
4520
4521
4522
4523
4524
4525
4526
4527
4528
4529
4530
4531
4532
4533
4534
4535
4536
4537
4538
4539
4540
4541
def
middleware
(
self
,
middleware_type
:
Annotated
[
str
,
Doc
(
"""
The type of middleware. Currently only supports `http`.
"""
),
],
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a middleware to the application.
Read more about it in the
[FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).
## Example
```python
import time
from typing import Awaitable, Callable
from fastapi import FastAPI, Request, Response
app = FastAPI()
@app.middleware("http")
async def add_process_time_header(
request: Request, call_next: Callable[[Request], Awaitable[Response]]
) -> Response:
start_time = time.time()
response = await call_next(request)
process_time = time.time() - start_time
response.headers["X-Process-Time"] = str(process_time)
return response
```
"""
def
decorator
(
func
:
DecoratedCallable
)
->
DecoratedCallable
:
self
.
add_middleware
(
BaseHTTPMiddleware
,
dispatch
=
func
)
return
func
return
decorator
exception_handler
exception_handler
(
exc_class_or_status_code
)
Add an exception handler to the app.
Read more about it in the
FastAPI docs for Handling Errors
.
Example
from
fastapi
import
FastAPI
,
Request
from
fastapi.responses
import
JSONResponse
class
UnicornException
(
Exception
):
def
__init__
(
self
,
name
:
str
):
self
.
name
=
name
app
=
FastAPI
()
@app
.
exception_handler
(
UnicornException
)
async
def
unicorn_exception_handler
(
request
:
Request
,
exc
:
UnicornException
):
return
JSONResponse
(
status_code
=
418
,
content
=
{
"message"
:
f
"Oops!
{
exc
.
name
}
did something. There goes a rainbow..."
},
)
PARAMETER
DESCRIPTION
exc_class_or_status_code
The Exception class this would handle, or a status code.
TYPE:
Union
[
int
,
Type
[
Exception
]]
Source code in
fastapi/applications.py
4543
4544
4545
4546
4547
4548
4549
4550
4551
4552
4553
4554
4555
4556
4557
4558
4559
4560
4561
4562
4563
4564
4565
4566
4567
4568
4569
4570
4571
4572
4573
4574
4575
4576
4577
4578
4579
4580
4581
4582
4583
4584
4585
4586
4587
4588
def
exception_handler
(
self
,
exc_class_or_status_code
:
Annotated
[
Union
[
int
,
Type
[
Exception
]],
Doc
(
"""
The Exception class this would handle, or a status code.
"""
),
],
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add an exception handler to the app.
Read more about it in the
[FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).
## Example
```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
class UnicornException(Exception):
def __init__(self, name: str):
self.name = name
app = FastAPI()
@app.exception_handler(UnicornException)
async def unicorn_exception_handler(request: Request, exc: UnicornException):
return JSONResponse(
status_code=418,
content={"message": f"Oops! {exc.name} did something. There goes a rainbow..."},
)
```
"""
def
decorator
(
func
:
DecoratedCallable
)
->
DecoratedCallable
:
self
.
add_exception_handler
(
exc_class_or_status_code
,
func
)
return
func
return
decorator

## 089_REFERENCE_HTTPCONNECTION
HTTPConnectionclass¶
---

HTTPConnection
class
When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an
HTTPConnection
instead of a
Request
or a
WebSocket
.
You can import it from
fastapi.requests
:
from
fastapi.requests
import
HTTPConnection
fastapi.requests.HTTPConnection
HTTPConnection
(
scope
,
receive
=
None
)
Bases:
Mapping
[
str
,
Any
]
A base class for incoming HTTP connections, that is used to provide
any functionality that is common to both
Request
and
WebSocket
.
Source code in
starlette/requests.py
76
77
78
def
__init__
(
self
,
scope
:
Scope
,
receive
:
Receive
|
None
=
None
)
->
None
:
assert
scope
[
"type"
]
in
(
"http"
,
"websocket"
)
self
.
scope
=
scope
scope
instance-attribute
scope
=
scope
app
property
app
url
property
url
base_url
property
base_url
headers
property
headers
query_params
property
query_params
path_params
property
path_params
cookies
property
cookies
client
property
client
session
property
session
auth
property
auth
user
property
user
state
property
state
url_for
url_for
(
name
,
/
,
**
path_params
)
Source code in
starlette/requests.py
182
183
184
185
186
187
def
url_for
(
self
,
name
:
str
,
/
,
**
path_params
:
typing
.
Any
)
->
URL
:
url_path_provider
:
Router
|
Starlette
|
None
=
self
.
scope
.
get
(
"router"
)
or
self
.
scope
.
get
(
"app"
)
if
url_path_provider
is
None
:
raise
RuntimeError
(
"The `url_for` method can only be used inside a Starlette application or with a router."
)
url_path
=
url_path_provider
.
url_path_for
(
name
,
**
path_params
)
return
url_path
.
make_absolute_url
(
base_url
=
self
.
base_url
)

## 090_REFERENCE_MIDDLEWARE
Middleware¶
---

Middleware
There are several middlewares available provided by Starlette directly.
Read more about them in the
FastAPI docs for Middleware
.
fastapi.middleware.cors.CORSMiddleware
CORSMiddleware
(
app
,
allow_origins
=
(),
allow_methods
=
(
"GET"
,),
allow_headers
=
(),
allow_credentials
=
False
,
allow_origin_regex
=
None
,
expose_headers
=
(),
max_age
=
600
,
)
Source code in
starlette/middleware/cors.py
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
def
__init__
(
self
,
app
:
ASGIApp
,
allow_origins
:
typing
.
Sequence
[
str
]
=
(),
allow_methods
:
typing
.
Sequence
[
str
]
=
(
"GET"
,),
allow_headers
:
typing
.
Sequence
[
str
]
=
(),
allow_credentials
:
bool
=
False
,
allow_origin_regex
:
str
|
None
=
None
,
expose_headers
:
typing
.
Sequence
[
str
]
=
(),
max_age
:
int
=
600
,
)
->
None
:
if
"*"
in
allow_methods
:
allow_methods
=
ALL_METHODS
compiled_allow_origin_regex
=
None
if
allow_origin_regex
is
not
None
:
compiled_allow_origin_regex
=
re
.
compile
(
allow_origin_regex
)
allow_all_origins
=
"*"
in
allow_origins
allow_all_headers
=
"*"
in
allow_headers
preflight_explicit_allow_origin
=
not
allow_all_origins
or
allow_credentials
simple_headers
=
{}
if
allow_all_origins
:
simple_headers
[
"Access-Control-Allow-Origin"
]
=
"*"
if
allow_credentials
:
simple_headers
[
"Access-Control-Allow-Credentials"
]
=
"true"
if
expose_headers
:
simple_headers
[
"Access-Control-Expose-Headers"
]
=
", "
.
join
(
expose_headers
)
preflight_headers
=
{}
if
preflight_explicit_allow_origin
:
## The origin value will be set in preflight_response() if it is allowed.
preflight_headers
[
"Vary"
]
=
"Origin"
else
:
preflight_headers
[
"Access-Control-Allow-Origin"
]
=
"*"
preflight_headers
.
update
(
{
"Access-Control-Allow-Methods"
:
", "
.
join
(
allow_methods
),
"Access-Control-Max-Age"
:
str
(
max_age
),
}
)
allow_headers
=
sorted
(
SAFELISTED_HEADERS
|
set
(
allow_headers
))
if
allow_headers
and
not
allow_all_headers
:
preflight_headers
[
"Access-Control-Allow-Headers"
]
=
", "
.
join
(
allow_headers
)
if
allow_credentials
:
preflight_headers
[
"Access-Control-Allow-Credentials"
]
=
"true"
self
.
app
=
app
self
.
allow_origins
=
allow_origins
self
.
allow_methods
=
allow_methods
self
.
allow_headers
=
[
h
.
lower
()
for
h
in
allow_headers
]
self
.
allow_all_origins
=
allow_all_origins
self
.
allow_all_headers
=
allow_all_headers
self
.
preflight_explicit_allow_origin
=
preflight_explicit_allow_origin
self
.
allow_origin_regex
=
compiled_allow_origin_regex
self
.
simple_headers
=
simple_headers
self
.
preflight_headers
=
preflight_headers
app
instance-attribute
app
=
app
allow_origins
instance-attribute
allow_origins
=
allow_origins
allow_methods
instance-attribute
allow_methods
=
allow_methods
allow_headers
instance-attribute
allow_headers
=
[
lower
()
for
h
in
allow_headers
]
allow_all_origins
instance-attribute
allow_all_origins
=
allow_all_origins
allow_all_headers
instance-attribute
allow_all_headers
=
allow_all_headers
preflight_explicit_allow_origin
instance-attribute
preflight_explicit_allow_origin
=
(
preflight_explicit_allow_origin
)
allow_origin_regex
instance-attribute
allow_origin_regex
=
compiled_allow_origin_regex
simple_headers
instance-attribute
simple_headers
=
simple_headers
preflight_headers
instance-attribute
preflight_headers
=
preflight_headers
is_allowed_origin
is_allowed_origin
(
origin
)
Source code in
starlette/middleware/cors.py
95
96
97
98
99
100
101
102
def
is_allowed_origin
(
self
,
origin
:
str
)
->
bool
:
if
self
.
allow_all_origins
:
return
True
if
self
.
allow_origin_regex
is
not
None
and
self
.
allow_origin_regex
.
fullmatch
(
origin
):
return
True
return
origin
in
self
.
allow_origins
preflight_response
preflight_response
(
request_headers
)
Source code in
starlette/middleware/cors.py
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
def
preflight_response
(
self
,
request_headers
:
Headers
)
->
Response
:
requested_origin
=
request_headers
[
"origin"
]
requested_method
=
request_headers
[
"access-control-request-method"
]
requested_headers
=
request_headers
.
get
(
"access-control-request-headers"
)
headers
=
dict
(
self
.
preflight_headers
)
failures
=
[]
if
self
.
is_allowed_origin
(
origin
=
requested_origin
):
if
self
.
preflight_explicit_allow_origin
:
## The "else" case is already accounted for in self.preflight_headers
## and the value would be "*".
headers
[
"Access-Control-Allow-Origin"
]
=
requested_origin
else
:
failures
.
append
(
"origin"
)
if
requested_method
not
in
self
.
allow_methods
:
failures
.
append
(
"method"
)
## If we allow all headers, then we have to mirror back any requested
## headers in the response.
if
self
.
allow_all_headers
and
requested_headers
is
not
None
:
headers
[
"Access-Control-Allow-Headers"
]
=
requested_headers
elif
requested_headers
is
not
None
:
for
header
in
[
h
.
lower
()
for
h
in
requested_headers
.
split
(
","
)]:
if
header
.
strip
()
not
in
self
.
allow_headers
:
failures
.
append
(
"headers"
)
break
## We don't strictly need to use 400 responses here, since its up to
## the browser to enforce the CORS policy, but its more informative
## if we do.
if
failures
:
failure_text
=
"Disallowed CORS "
+
", "
.
join
(
failures
)
return
PlainTextResponse
(
failure_text
,
status_code
=
400
,
headers
=
headers
)
return
PlainTextResponse
(
"OK"
,
status_code
=
200
,
headers
=
headers
)
simple_response
async
simple_response
(
scope
,
receive
,
send
,
request_headers
)
Source code in
starlette/middleware/cors.py
142
143
144
async
def
simple_response
(
self
,
scope
:
Scope
,
receive
:
Receive
,
send
:
Send
,
request_headers
:
Headers
)
->
None
:
send
=
functools
.
partial
(
self
.
send
,
send
=
send
,
request_headers
=
request_headers
)
await
self
.
app
(
scope
,
receive
,
send
)
send
async
send
(
message
,
send
,
request_headers
)
Source code in
starlette/middleware/cors.py
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
async
def
send
(
self
,
message
:
Message
,
send
:
Send
,
request_headers
:
Headers
)
->
None
:
if
message
[
"type"
]
!=
"http.response.start"
:
await
send
(
message
)
return
message
.
setdefault
(
"headers"
,
[])
headers
=
MutableHeaders
(
scope
=
message
)
headers
.
update
(
self
.
simple_headers
)
origin
=
request_headers
[
"Origin"
]
has_cookie
=
"cookie"
in
request_headers
## If request includes any cookie headers, then we must respond
## with the specific origin instead of '*'.
if
self
.
allow_all_origins
and
has_cookie
:
self
.
allow_explicit_origin
(
headers
,
origin
)
## If we only allow specific origins, then we have to mirror back
## the Origin header in the response.
elif
not
self
.
allow_all_origins
and
self
.
is_allowed_origin
(
origin
=
origin
):
self
.
allow_explicit_origin
(
headers
,
origin
)
await
send
(
message
)
allow_explicit_origin
staticmethod
allow_explicit_origin
(
headers
,
origin
)
Source code in
starlette/middleware/cors.py
169
170
171
172
@staticmethod
def
allow_explicit_origin
(
headers
:
MutableHeaders
,
origin
:
str
)
->
None
:
headers
[
"Access-Control-Allow-Origin"
]
=
origin
headers
.
add_vary_header
(
"Origin"
)
It can be imported from
fastapi
:
from
fastapi.middleware.cors
import
CORSMiddleware
fastapi.middleware.gzip.GZipMiddleware
GZipMiddleware
(
app
,
minimum_size
=
500
,
compresslevel
=
9
)
Source code in
starlette/middleware/gzip.py
12
13
14
15
def
__init__
(
self
,
app
:
ASGIApp
,
minimum_size
:
int
=
500
,
compresslevel
:
int
=
9
)
->
None
:
self
.
app
=
app
self
.
minimum_size
=
minimum_size
self
.
compresslevel
=
compresslevel
app
instance-attribute
app
=
app
minimum_size
instance-attribute
minimum_size
=
minimum_size
compresslevel
instance-attribute
compresslevel
=
compresslevel
It can be imported from
fastapi
:
from
fastapi.middleware.gzip
import
GZipMiddleware
fastapi.middleware.httpsredirect.HTTPSRedirectMiddleware
HTTPSRedirectMiddleware
(
app
)
Source code in
starlette/middleware/httpsredirect.py
7
8
def
__init__
(
self
,
app
:
ASGIApp
)
->
None
:
self
.
app
=
app
app
instance-attribute
app
=
app
It can be imported from
fastapi
:
from
fastapi.middleware.httpsredirect
import
HTTPSRedirectMiddleware
fastapi.middleware.trustedhost.TrustedHostMiddleware
TrustedHostMiddleware
(
app
,
allowed_hosts
=
None
,
www_redirect
=
True
)
Source code in
starlette/middleware/trustedhost.py
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
def
__init__
(
self
,
app
:
ASGIApp
,
allowed_hosts
:
typing
.
Sequence
[
str
]
|
None
=
None
,
www_redirect
:
bool
=
True
,
)
->
None
:
if
allowed_hosts
is
None
:
allowed_hosts
=
[
"*"
]
for
pattern
in
allowed_hosts
:
assert
"*"
not
in
pattern
[
1
:],
ENFORCE_DOMAIN_WILDCARD
if
pattern
.
startswith
(
"*"
)
and
pattern
!=
"*"
:
assert
pattern
.
startswith
(
"*."
),
ENFORCE_DOMAIN_WILDCARD
self
.
app
=
app
self
.
allowed_hosts
=
list
(
allowed_hosts
)
self
.
allow_any
=
"*"
in
allowed_hosts
self
.
www_redirect
=
www_redirect
app
instance-attribute
app
=
app
allowed_hosts
instance-attribute
allowed_hosts
=
list
(
allowed_hosts
)
allow_any
instance-attribute
allow_any
=
'*'
in
allowed_hosts
www_redirect
instance-attribute
www_redirect
=
www_redirect
It can be imported from
fastapi
:
from
fastapi.middleware.trustedhost
import
TrustedHostMiddleware
fastapi.middleware.wsgi.WSGIMiddleware
WSGIMiddleware
(
app
)
Source code in
starlette/middleware/wsgi.py
74
75
def
__init__
(
self
,
app
:
typing
.
Callable
[
...
,
typing
.
Any
])
->
None
:
self
.
app
=
app
app
instance-attribute
app
=
app
It can be imported from
fastapi
:
from
fastapi.middleware.wsgi
import
WSGIMiddleware

## 091_REFERENCE_OPENAPI
OpenAPI¶
---

OpenAPI
There are several utilities to handle OpenAPI.
You normally don't need to use them unless you have a specific advanced use case that requires it.

## 092_REFERENCE_OPENAPI_DOCS
OpenAPIdocs¶
---

OpenAPI
docs
Utilities to handle OpenAPI automatic UI documentation, including Swagger UI (by default at
/docs
) and ReDoc (by default at
/redoc
).
fastapi.openapi.docs.get_swagger_ui_html
get_swagger_ui_html
(
*
,
openapi_url
,
title
,
swagger_js_url
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css"
,
swagger_favicon_url
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
oauth2_redirect_url
=
None
,
init_oauth
=
None
,
swagger_ui_parameters
=
None
)
Generate and return the HTML that loads Swagger UI for the interactive
API docs (normally served at
/docs
).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load Swagger UI's JavaScript and CSS.
Read more about it in the
FastAPI docs for Configure Swagger UI
and the
FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)
.
PARAMETER
DESCRIPTION
openapi_url
The OpenAPI URL that Swagger UI should load and use.
This is normally done automatically by FastAPI using the default URL
/openapi.json
.
TYPE:
str
title
The HTML
<title>
content, normally shown in the browser tab.
TYPE:
str
swagger_js_url
The URL to use to load the Swagger UI JavaScript.
It is normally set to a CDN URL.
TYPE:
str
DEFAULT:
'https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js'
swagger_css_url
The URL to use to load the Swagger UI CSS.
It is normally set to a CDN URL.
TYPE:
str
DEFAULT:
'https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css'
swagger_favicon_url
The URL of the favicon to use. It is normally shown in the browser tab.
TYPE:
str
DEFAULT:
'https://fastapi.tiangolo.com/img/favicon.png'
oauth2_redirect_url
The OAuth2 redirect URL, it is normally automatically handled by FastAPI.
TYPE:
Optional
[
str
]
DEFAULT:
None
init_oauth
A dictionary with Swagger UI OAuth2 initialization configurations.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
swagger_ui_parameters
Configuration parameters for Swagger UI.
It defaults to
swagger_ui_default_parameters
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
Source code in
fastapi/openapi/docs.py
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
def
get_swagger_ui_html
(
*
,
openapi_url
:
Annotated
[
str
,
Doc
(
"""
The OpenAPI URL that Swagger UI should load and use.
This is normally done automatically by FastAPI using the default URL
`/openapi.json`.
"""
),
],
title
:
Annotated
[
str
,
Doc
(
"""
The HTML `<title>` content, normally shown in the browser tab.
"""
),
],
swagger_js_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the Swagger UI JavaScript.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the Swagger UI CSS.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css"
,
swagger_favicon_url
:
Annotated
[
str
,
Doc
(
"""
The URL of the favicon to use. It is normally shown in the browser tab.
"""
),
]
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
oauth2_redirect_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The OAuth2 redirect URL, it is normally automatically handled by FastAPI.
"""
),
]
=
None
,
init_oauth
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
A dictionary with Swagger UI OAuth2 initialization configurations.
"""
),
]
=
None
,
swagger_ui_parameters
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Configuration parameters for Swagger UI.
It defaults to [swagger_ui_default_parameters][fastapi.openapi.docs.swagger_ui_default_parameters].
"""
),
]
=
None
,
)
->
HTMLResponse
:
"""
Generate and return the HTML that loads Swagger UI for the interactive
API docs (normally served at `/docs`).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load Swagger UI's JavaScript and CSS.
Read more about it in the
[FastAPI docs for Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/)
and the [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
"""
current_swagger_ui_parameters
=
swagger_ui_default_parameters
.
copy
()
if
swagger_ui_parameters
:
current_swagger_ui_parameters
.
update
(
swagger_ui_parameters
)
html
=
f
"""
<!DOCTYPE html>
<html>
<head>
<link type="text/css" rel="stylesheet" href="
{
swagger_css_url
}
">
<link rel="shortcut icon" href="
{
swagger_favicon_url
}
">
<title>
{
title
}
</title>
</head>
<body>
<div id="swagger-ui">
</div>
<script src="
{
swagger_js_url
}
"></script>
<!-- `SwaggerUIBundle` is now available on the page -->
<script>
const ui = SwaggerUIBundle(
{{
url: '
{
openapi_url
}
',
"""
for
key
,
value
in
current_swagger_ui_parameters
.
items
():
html
+=
f
"
{
json
.
dumps
(
key
)
}
:
{
json
.
dumps
(
jsonable_encoder
(
value
))
}
,
\n
"
if
oauth2_redirect_url
:
html
+=
f
"oauth2RedirectUrl: window.location.origin + '
{
oauth2_redirect_url
}
',"
html
+=
"""
presets: [
SwaggerUIBundle.presets.apis,
SwaggerUIBundle.SwaggerUIStandalonePreset
],
})"""
if
init_oauth
:
html
+=
f
"""
ui.initOAuth(
{
json
.
dumps
(
jsonable_encoder
(
init_oauth
))
}
)
"""
html
+=
"""
</script>
</body>
</html>
"""
return
HTMLResponse
(
html
)
fastapi.openapi.docs.get_redoc_html
get_redoc_html
(
*
,
openapi_url
,
title
,
redoc_js_url
=
"https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js"
,
redoc_favicon_url
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
with_google_fonts
=
True
)
Generate and return the HTML response that loads ReDoc for the alternative
API docs (normally served at
/redoc
).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load ReDoc's JavaScript and CSS.
Read more about it in the
FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)
.
PARAMETER
DESCRIPTION
openapi_url
The OpenAPI URL that ReDoc should load and use.
This is normally done automatically by FastAPI using the default URL
/openapi.json
.
TYPE:
str
title
The HTML
<title>
content, normally shown in the browser tab.
TYPE:
str
redoc_js_url
The URL to use to load the ReDoc JavaScript.
It is normally set to a CDN URL.
TYPE:
str
DEFAULT:
'https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js'
redoc_favicon_url
The URL of the favicon to use. It is normally shown in the browser tab.
TYPE:
str
DEFAULT:
'https://fastapi.tiangolo.com/img/favicon.png'
with_google_fonts
Load and use Google Fonts.
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/openapi/docs.py
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
def
get_redoc_html
(
*
,
openapi_url
:
Annotated
[
str
,
Doc
(
"""
The OpenAPI URL that ReDoc should load and use.
This is normally done automatically by FastAPI using the default URL
`/openapi.json`.
"""
),
],
title
:
Annotated
[
str
,
Doc
(
"""
The HTML `<title>` content, normally shown in the browser tab.
"""
),
],
redoc_js_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the ReDoc JavaScript.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js"
,
redoc_favicon_url
:
Annotated
[
str
,
Doc
(
"""
The URL of the favicon to use. It is normally shown in the browser tab.
"""
),
]
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
with_google_fonts
:
Annotated
[
bool
,
Doc
(
"""
Load and use Google Fonts.
"""
),
]
=
True
,
)
->
HTMLResponse
:
"""
Generate and return the HTML response that loads ReDoc for the alternative
API docs (normally served at `/redoc`).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load ReDoc's JavaScript and CSS.
Read more about it in the
[FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
"""
html
=
f
"""
<!DOCTYPE html>
<html>
<head>
<title>
{
title
}
</title>
<!-- needed for adaptive design -->
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
"""
if
with_google_fonts
:
html
+=
"""
<link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
"""
html
+=
f
"""
<link rel="shortcut icon" href="
{
redoc_favicon_url
}
">
<!--
ReDoc doesn't change outer page styles
-->
<style>
body
{{
margin: 0;
padding: 0;
}}
</style>
</head>
<body>
<noscript>
ReDoc requires Javascript to function. Please enable it to browse the documentation.
</noscript>
<redoc spec-url="
{
openapi_url
}
"></redoc>
<script src="
{
redoc_js_url
}
"> </script>
</body>
</html>
"""
return
HTMLResponse
(
html
)
fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html
get_swagger_ui_oauth2_redirect_html
()
Generate the HTML response with the OAuth2 redirection for Swagger UI.
You normally don't need to use or change this.
Source code in
fastapi/openapi/docs.py
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
def
get_swagger_ui_oauth2_redirect_html
()
->
HTMLResponse
:
"""
Generate the HTML response with the OAuth2 redirection for Swagger UI.
You normally don't need to use or change this.
"""
## copied from https://github.com/swagger-api/swagger-ui/blob/v4.14.0/dist/oauth2-redirect.html
html
=
"""
<!doctype html>
<html lang="en-US">
<head>
<title>Swagger UI: OAuth2 Redirect</title>
</head>
<body>
<script>
'use strict';
function run () {
var oauth2 = window.opener.swaggerUIRedirectOauth2;
var sentState = oauth2.state;
var redirectUrl = oauth2.redirectUrl;
var isValid, qp, arr;
if (/code|token|error/.test(window.location.hash)) {
qp = window.location.hash.substring(1).replace('?', '&');
} else {
qp = location.search.substring(1);
}
arr = qp.split("&");
arr.forEach(function (v,i,_arr) { _arr[i] = '"' + v.replace('=', '":"') + '"';});
qp = qp ? JSON.parse('{' + arr.join() + '}',
function (key, value) {
return key === "" ? value : decodeURIComponent(value);
}
) :
{}
;
isValid = qp.state === sentState;
if ((
oauth2.auth.schema.get("flow") === "accessCode" ||
oauth2.auth.schema.get("flow") === "authorizationCode" ||
oauth2.auth.schema.get("flow") === "authorization_code"
) && !oauth2.auth.code) {
if (!isValid) {
oauth2.errCb({
authId: oauth2.auth.name,
source: "auth",
level: "warning",
message: "Authorization may be unsafe, passed state was changed in server. The passed state wasn't returned from auth server."
});
}
if (qp.code) {
delete oauth2.state;
oauth2.auth.code = qp.code;
oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});
} else {
let oauthErrorMsg;
if (qp.error) {
oauthErrorMsg = "["+qp.error+"]: " +
(qp.error_description ? qp.error_description+ ". " : "no accessCode received from the server. ") +
(qp.error_uri ? "More info: "+qp.error_uri : "");
}
oauth2.errCb({
authId: oauth2.auth.name,
source: "auth",
level: "error",
message: oauthErrorMsg || "[Authorization failed]: no accessCode received from the server."
});
}
} else {
oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});
}
window.close();
}
if (document.readyState !== 'loading') {
run();
} else {
document.addEventListener('DOMContentLoaded', function () {
run();
});
}
</script>
</body>
</html>
"""
return
HTMLResponse
(
content
=
html
)
fastapi.openapi.docs.swagger_ui_default_parameters
module-attribute
swagger_ui_default_parameters
=
{
"dom_id"
:
"#swagger-ui"
,
"layout"
:
"BaseLayout"
,
"deepLinking"
:
True
,
"showExtensions"
:
True
,
"showCommonExtensions"
:
True
,
}
Default configurations for Swagger UI.
You can use it as a template to add any other configurations needed.

## 093_REFERENCE_OPENAPI_MODELS
OpenAPImodels¶
---

OpenAPI
models
OpenAPI Pydantic models used to generate and validate the generated OpenAPI.
fastapi.openapi.models
SchemaOrBool
module-attribute
SchemaOrBool
=
Union
[
Schema
,
bool
]
SecurityScheme
module-attribute
SecurityScheme
=
Union
[
APIKey
,
HTTPBase
,
OAuth2
,
OpenIdConnect
,
HTTPBearer
]
BaseModelWithConfig
Bases:
BaseModel
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Contact
Bases:
BaseModelWithConfig
name
class-attribute
instance-attribute
name
=
None
url
class-attribute
instance-attribute
url
=
None
email
class-attribute
instance-attribute
email
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
License
Bases:
BaseModelWithConfig
name
instance-attribute
name
identifier
class-attribute
instance-attribute
identifier
=
None
url
class-attribute
instance-attribute
url
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Info
Bases:
BaseModelWithConfig
title
instance-attribute
title
summary
class-attribute
instance-attribute
summary
=
None
description
class-attribute
instance-attribute
description
=
None
termsOfService
class-attribute
instance-attribute
termsOfService
=
None
contact
class-attribute
instance-attribute
contact
=
None
license
class-attribute
instance-attribute
license
=
None
version
instance-attribute
version
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
ServerVariable
Bases:
BaseModelWithConfig
enum
class-attribute
instance-attribute
enum
=
None
default
instance-attribute
default
description
class-attribute
instance-attribute
description
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Server
Bases:
BaseModelWithConfig
url
instance-attribute
url
description
class-attribute
instance-attribute
description
=
None
variables
class-attribute
instance-attribute
variables
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Reference
Bases:
BaseModel
ref
class-attribute
instance-attribute
ref
=
Field
(
alias
=
'$ref'
)
Discriminator
Bases:
BaseModel
propertyName
instance-attribute
propertyName
mapping
class-attribute
instance-attribute
mapping
=
None
XML
Bases:
BaseModelWithConfig
name
class-attribute
instance-attribute
name
=
None
namespace
class-attribute
instance-attribute
namespace
=
None
prefix
class-attribute
instance-attribute
prefix
=
None
attribute
class-attribute
instance-attribute
attribute
=
None
wrapped
class-attribute
instance-attribute
wrapped
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
ExternalDocumentation
Bases:
BaseModelWithConfig
description
class-attribute
instance-attribute
description
=
None
url
instance-attribute
url
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Schema
Bases:
BaseModelWithConfig
schema_
class-attribute
instance-attribute
schema_
=
Field
(
default
=
None
,
alias
=
'$schema'
)
vocabulary
class-attribute
instance-attribute
vocabulary
=
Field
(
default
=
None
,
alias
=
'$vocabulary'
)
id
class-attribute
instance-attribute
id
=
Field
(
default
=
None
,
alias
=
'$id'
)
anchor
class-attribute
instance-attribute
anchor
=
Field
(
default
=
None
,
alias
=
'$anchor'
)
dynamicAnchor
class-attribute
instance-attribute
dynamicAnchor
=
Field
(
default
=
None
,
alias
=
'$dynamicAnchor'
)
ref
class-attribute
instance-attribute
ref
=
Field
(
default
=
None
,
alias
=
'$ref'
)
dynamicRef
class-attribute
instance-attribute
dynamicRef
=
Field
(
default
=
None
,
alias
=
'$dynamicRef'
)
defs
class-attribute
instance-attribute
defs
=
Field
(
default
=
None
,
alias
=
'$defs'
)
comment
class-attribute
instance-attribute
comment
=
Field
(
default
=
None
,
alias
=
'$comment'
)
allOf
class-attribute
instance-attribute
allOf
=
None
anyOf
class-attribute
instance-attribute
anyOf
=
None
oneOf
class-attribute
instance-attribute
oneOf
=
None
not_
class-attribute
instance-attribute
not_
=
Field
(
default
=
None
,
alias
=
'not'
)
if_
class-attribute
instance-attribute
if_
=
Field
(
default
=
None
,
alias
=
'if'
)
then
class-attribute
instance-attribute
then
=
None
else_
class-attribute
instance-attribute
else_
=
Field
(
default
=
None
,
alias
=
'else'
)
dependentSchemas
class-attribute
instance-attribute
dependentSchemas
=
None
prefixItems
class-attribute
instance-attribute
prefixItems
=
None
items
class-attribute
instance-attribute
items
=
None
contains
class-attribute
instance-attribute
contains
=
None
properties
class-attribute
instance-attribute
properties
=
None
patternProperties
class-attribute
instance-attribute
patternProperties
=
None
additionalProperties
class-attribute
instance-attribute
additionalProperties
=
None
propertyNames
class-attribute
instance-attribute
propertyNames
=
None
unevaluatedItems
class-attribute
instance-attribute
unevaluatedItems
=
None
unevaluatedProperties
class-attribute
instance-attribute
unevaluatedProperties
=
None
type
class-attribute
instance-attribute
type
=
None
enum
class-attribute
instance-attribute
enum
=
None
const
class-attribute
instance-attribute
const
=
None
multipleOf
class-attribute
instance-attribute
multipleOf
=
Field
(
default
=
None
,
gt
=
0
)
maximum
class-attribute
instance-attribute
maximum
=
None
exclusiveMaximum
class-attribute
instance-attribute
exclusiveMaximum
=
None
minimum
class-attribute
instance-attribute
minimum
=
None
exclusiveMinimum
class-attribute
instance-attribute
exclusiveMinimum
=
None
maxLength
class-attribute
instance-attribute
maxLength
=
Field
(
default
=
None
,
ge
=
0
)
minLength
class-attribute
instance-attribute
minLength
=
Field
(
default
=
None
,
ge
=
0
)
pattern
class-attribute
instance-attribute
pattern
=
None
maxItems
class-attribute
instance-attribute
maxItems
=
Field
(
default
=
None
,
ge
=
0
)
minItems
class-attribute
instance-attribute
minItems
=
Field
(
default
=
None
,
ge
=
0
)
uniqueItems
class-attribute
instance-attribute
uniqueItems
=
None
maxContains
class-attribute
instance-attribute
maxContains
=
Field
(
default
=
None
,
ge
=
0
)
minContains
class-attribute
instance-attribute
minContains
=
Field
(
default
=
None
,
ge
=
0
)
maxProperties
class-attribute
instance-attribute
maxProperties
=
Field
(
default
=
None
,
ge
=
0
)
minProperties
class-attribute
instance-attribute
minProperties
=
Field
(
default
=
None
,
ge
=
0
)
required
class-attribute
instance-attribute
required
=
None
dependentRequired
class-attribute
instance-attribute
dependentRequired
=
None
format
class-attribute
instance-attribute
format
=
None
contentEncoding
class-attribute
instance-attribute
contentEncoding
=
None
contentMediaType
class-attribute
instance-attribute
contentMediaType
=
None
contentSchema
class-attribute
instance-attribute
contentSchema
=
None
title
class-attribute
instance-attribute
title
=
None
description
class-attribute
instance-attribute
description
=
None
default
class-attribute
instance-attribute
default
=
None
deprecated
class-attribute
instance-attribute
deprecated
=
None
readOnly
class-attribute
instance-attribute
readOnly
=
None
writeOnly
class-attribute
instance-attribute
writeOnly
=
None
examples
class-attribute
instance-attribute
examples
=
None
discriminator
class-attribute
instance-attribute
discriminator
=
None
xml
class-attribute
instance-attribute
xml
=
None
externalDocs
class-attribute
instance-attribute
externalDocs
=
None
example
class-attribute
instance-attribute
example
=
None
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Example
Bases:
TypedDict
summary
instance-attribute
summary
description
instance-attribute
description
value
instance-attribute
value
externalValue
instance-attribute
externalValue
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
ParameterInType
Bases:
Enum
query
class-attribute
instance-attribute
query
=
'query'
header
class-attribute
instance-attribute
header
=
'header'
path
class-attribute
instance-attribute
path
=
'path'
cookie
class-attribute
instance-attribute
cookie
=
'cookie'
Encoding
Bases:
BaseModelWithConfig
contentType
class-attribute
instance-attribute
contentType
=
None
headers
class-attribute
instance-attribute
headers
=
None
style
class-attribute
instance-attribute
style
=
None
explode
class-attribute
instance-attribute
explode
=
None
allowReserved
class-attribute
instance-attribute
allowReserved
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
MediaType
Bases:
BaseModelWithConfig
schema_
class-attribute
instance-attribute
schema_
=
Field
(
default
=
None
,
alias
=
'schema'
)
example
class-attribute
instance-attribute
example
=
None
examples
class-attribute
instance-attribute
examples
=
None
encoding
class-attribute
instance-attribute
encoding
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
ParameterBase
Bases:
BaseModelWithConfig
description
class-attribute
instance-attribute
description
=
None
required
class-attribute
instance-attribute
required
=
None
deprecated
class-attribute
instance-attribute
deprecated
=
None
style
class-attribute
instance-attribute
style
=
None
explode
class-attribute
instance-attribute
explode
=
None
allowReserved
class-attribute
instance-attribute
allowReserved
=
None
schema_
class-attribute
instance-attribute
schema_
=
Field
(
default
=
None
,
alias
=
'schema'
)
example
class-attribute
instance-attribute
example
=
None
examples
class-attribute
instance-attribute
examples
=
None
content
class-attribute
instance-attribute
content
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Parameter
Bases:
ParameterBase
name
instance-attribute
name
in_
class-attribute
instance-attribute
in_
=
Field
(
alias
=
'in'
)
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
required
class-attribute
instance-attribute
required
=
None
deprecated
class-attribute
instance-attribute
deprecated
=
None
style
class-attribute
instance-attribute
style
=
None
explode
class-attribute
instance-attribute
explode
=
None
allowReserved
class-attribute
instance-attribute
allowReserved
=
None
schema_
class-attribute
instance-attribute
schema_
=
Field
(
default
=
None
,
alias
=
'schema'
)
example
class-attribute
instance-attribute
example
=
None
examples
class-attribute
instance-attribute
examples
=
None
content
class-attribute
instance-attribute
content
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Header
Bases:
ParameterBase
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
required
class-attribute
instance-attribute
required
=
None
deprecated
class-attribute
instance-attribute
deprecated
=
None
style
class-attribute
instance-attribute
style
=
None
explode
class-attribute
instance-attribute
explode
=
None
allowReserved
class-attribute
instance-attribute
allowReserved
=
None
schema_
class-attribute
instance-attribute
schema_
=
Field
(
default
=
None
,
alias
=
'schema'
)
example
class-attribute
instance-attribute
example
=
None
examples
class-attribute
instance-attribute
examples
=
None
content
class-attribute
instance-attribute
content
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
RequestBody
Bases:
BaseModelWithConfig
description
class-attribute
instance-attribute
description
=
None
content
instance-attribute
content
required
class-attribute
instance-attribute
required
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Link
Bases:
BaseModelWithConfig
operationRef
class-attribute
instance-attribute
operationRef
=
None
operationId
class-attribute
instance-attribute
operationId
=
None
parameters
class-attribute
instance-attribute
parameters
=
None
requestBody
class-attribute
instance-attribute
requestBody
=
None
description
class-attribute
instance-attribute
description
=
None
server
class-attribute
instance-attribute
server
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Response
Bases:
BaseModelWithConfig
description
instance-attribute
description
headers
class-attribute
instance-attribute
headers
=
None
content
class-attribute
instance-attribute
content
=
None
links
class-attribute
instance-attribute
links
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Operation
Bases:
BaseModelWithConfig
tags
class-attribute
instance-attribute
tags
=
None
summary
class-attribute
instance-attribute
summary
=
None
description
class-attribute
instance-attribute
description
=
None
externalDocs
class-attribute
instance-attribute
externalDocs
=
None
operationId
class-attribute
instance-attribute
operationId
=
None
parameters
class-attribute
instance-attribute
parameters
=
None
requestBody
class-attribute
instance-attribute
requestBody
=
None
responses
class-attribute
instance-attribute
responses
=
None
callbacks
class-attribute
instance-attribute
callbacks
=
None
deprecated
class-attribute
instance-attribute
deprecated
=
None
security
class-attribute
instance-attribute
security
=
None
servers
class-attribute
instance-attribute
servers
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
PathItem
Bases:
BaseModelWithConfig
ref
class-attribute
instance-attribute
ref
=
Field
(
default
=
None
,
alias
=
'$ref'
)
summary
class-attribute
instance-attribute
summary
=
None
description
class-attribute
instance-attribute
description
=
None
get
class-attribute
instance-attribute
get
=
None
put
class-attribute
instance-attribute
put
=
None
post
class-attribute
instance-attribute
post
=
None
delete
class-attribute
instance-attribute
delete
=
None
options
class-attribute
instance-attribute
options
=
None
head
class-attribute
instance-attribute
head
=
None
patch
class-attribute
instance-attribute
patch
=
None
trace
class-attribute
instance-attribute
trace
=
None
servers
class-attribute
instance-attribute
servers
=
None
parameters
class-attribute
instance-attribute
parameters
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
SecuritySchemeType
Bases:
Enum
apiKey
class-attribute
instance-attribute
apiKey
=
'apiKey'
http
class-attribute
instance-attribute
http
=
'http'
oauth2
class-attribute
instance-attribute
oauth2
=
'oauth2'
openIdConnect
class-attribute
instance-attribute
openIdConnect
=
'openIdConnect'
SecurityBase
Bases:
BaseModelWithConfig
type_
class-attribute
instance-attribute
type_
=
Field
(
alias
=
'type'
)
description
class-attribute
instance-attribute
description
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
APIKeyIn
Bases:
Enum
query
class-attribute
instance-attribute
query
=
'query'
header
class-attribute
instance-attribute
header
=
'header'
cookie
class-attribute
instance-attribute
cookie
=
'cookie'
APIKey
Bases:
SecurityBase
type_
class-attribute
instance-attribute
type_
=
Field
(
default
=
apiKey
,
alias
=
'type'
)
in_
class-attribute
instance-attribute
in_
=
Field
(
alias
=
'in'
)
name
instance-attribute
name
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
HTTPBase
Bases:
SecurityBase
type_
class-attribute
instance-attribute
type_
=
Field
(
default
=
http
,
alias
=
'type'
)
scheme
instance-attribute
scheme
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
HTTPBearer
Bases:
HTTPBase
scheme
class-attribute
instance-attribute
scheme
=
'bearer'
bearerFormat
class-attribute
instance-attribute
bearerFormat
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
type_
class-attribute
instance-attribute
type_
=
Field
(
default
=
http
,
alias
=
'type'
)
description
class-attribute
instance-attribute
description
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlow
Bases:
BaseModelWithConfig
refreshUrl
class-attribute
instance-attribute
refreshUrl
=
None
scopes
class-attribute
instance-attribute
scopes
=
{}
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlowImplicit
Bases:
OAuthFlow
authorizationUrl
instance-attribute
authorizationUrl
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
refreshUrl
class-attribute
instance-attribute
refreshUrl
=
None
scopes
class-attribute
instance-attribute
scopes
=
{}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlowPassword
Bases:
OAuthFlow
tokenUrl
instance-attribute
tokenUrl
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
refreshUrl
class-attribute
instance-attribute
refreshUrl
=
None
scopes
class-attribute
instance-attribute
scopes
=
{}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlowClientCredentials
Bases:
OAuthFlow
tokenUrl
instance-attribute
tokenUrl
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
refreshUrl
class-attribute
instance-attribute
refreshUrl
=
None
scopes
class-attribute
instance-attribute
scopes
=
{}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlowAuthorizationCode
Bases:
OAuthFlow
authorizationUrl
instance-attribute
authorizationUrl
tokenUrl
instance-attribute
tokenUrl
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
refreshUrl
class-attribute
instance-attribute
refreshUrl
=
None
scopes
class-attribute
instance-attribute
scopes
=
{}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlows
Bases:
BaseModelWithConfig
implicit
class-attribute
instance-attribute
implicit
=
None
password
class-attribute
instance-attribute
password
=
None
clientCredentials
class-attribute
instance-attribute
clientCredentials
=
None
authorizationCode
class-attribute
instance-attribute
authorizationCode
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuth2
Bases:
SecurityBase
type_
class-attribute
instance-attribute
type_
=
Field
(
default
=
oauth2
,
alias
=
'type'
)
flows
instance-attribute
flows
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OpenIdConnect
Bases:
SecurityBase
type_
class-attribute
instance-attribute
type_
=
Field
(
default
=
openIdConnect
,
alias
=
'type'
)
openIdConnectUrl
instance-attribute
openIdConnectUrl
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Components
Bases:
BaseModelWithConfig
schemas
class-attribute
instance-attribute
schemas
=
None
responses
class-attribute
instance-attribute
responses
=
None
parameters
class-attribute
instance-attribute
parameters
=
None
examples
class-attribute
instance-attribute
examples
=
None
requestBodies
class-attribute
instance-attribute
requestBodies
=
None
headers
class-attribute
instance-attribute
headers
=
None
securitySchemes
class-attribute
instance-attribute
securitySchemes
=
None
links
class-attribute
instance-attribute
links
=
None
callbacks
class-attribute
instance-attribute
callbacks
=
None
pathItems
class-attribute
instance-attribute
pathItems
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Tag
Bases:
BaseModelWithConfig
name
instance-attribute
name
description
class-attribute
instance-attribute
description
=
None
externalDocs
class-attribute
instance-attribute
externalDocs
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OpenAPI
Bases:
BaseModelWithConfig
openapi
instance-attribute
openapi
info
instance-attribute
info
jsonSchemaDialect
class-attribute
instance-attribute
jsonSchemaDialect
=
None
servers
class-attribute
instance-attribute
servers
=
None
paths
class-attribute
instance-attribute
paths
=
None
webhooks
class-attribute
instance-attribute
webhooks
=
None
components
class-attribute
instance-attribute
components
=
None
security
class-attribute
instance-attribute
security
=
None
tags
class-attribute
instance-attribute
tags
=
None
externalDocs
class-attribute
instance-attribute
externalDocs
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'

## 094_REFERENCE_PARAMETERS
Request Parameters¶
---

Request Parameters
Here's the reference information for the request parameters.
These are the special functions that you can put in
path operation function
parameters or dependency functions with
Annotated
to get data from the request.
It includes:
Query()
Path()
Body()
Cookie()
Header()
Form()
File()
You can import them all directly from
fastapi
:
from
fastapi
import
Body
,
Cookie
,
File
,
Form
,
Header
,
Path
,
Query
fastapi.Query
Query
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
def
Query
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
Query
(
default
=
default
,
default_factory
=
default_factory
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.Path
Path
(
default
=...
,
*
,
default_factory
=
_Unset
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
Declare a path parameter for a
path operation
.
Read more about it in the
FastAPI docs for Path Parameters and Numeric Validations
.
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
):
return
{
"item_id"
:
item_id
}
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Any
DEFAULT:
...
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
def
Path
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
...
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
"""
Declare a path parameter for a *path operation*.
Read more about it in the
[FastAPI docs for Path Parameters and Numeric Validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/).
```python
from typing import Annotated
from fastapi import FastAPI, Path
app = FastAPI()
@app.get("/items/{item_id}")
async def read_items(
item_id: Annotated[int, Path(title="The ID of the item to get")],
):
return {"item_id": item_id}
```
"""
return
params
.
Path
(
default
=
default
,
default_factory
=
default_factory
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.Body
Body
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
embed
=
None
,
media_type
=
"application/json"
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
embed
When
embed
is
True
, the parameter will be expected in a JSON body as a
key instead of being the JSON body itself.
This happens automatically when more than one
Body
parameter is declared.
Read more about it in the
FastAPI docs for Body - Multiple Parameters
.
TYPE:
Union
[
bool
, None]
DEFAULT:
None
media_type
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
TYPE:
str
DEFAULT:
'application/json'
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
1263
1264
1265
1266
1267
1268
1269
1270
1271
1272
1273
1274
1275
1276
1277
1278
1279
1280
1281
1282
1283
1284
1285
1286
1287
1288
1289
1290
1291
1292
1293
1294
1295
1296
1297
1298
1299
1300
1301
1302
1303
1304
1305
1306
1307
1308
1309
1310
1311
1312
1313
1314
1315
1316
1317
1318
1319
1320
1321
1322
1323
1324
1325
1326
1327
1328
1329
1330
1331
1332
1333
1334
1335
1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352
1353
1354
1355
1356
1357
1358
1359
1360
1361
1362
1363
1364
1365
1366
1367
1368
1369
1370
1371
1372
1373
1374
1375
1376
1377
1378
1379
1380
1381
1382
1383
1384
1385
1386
1387
1388
1389
1390
1391
1392
1393
1394
1395
1396
1397
1398
1399
1400
1401
1402
1403
1404
1405
1406
1407
1408
1409
1410
1411
1412
1413
1414
1415
1416
1417
1418
1419
1420
1421
1422
1423
1424
1425
1426
1427
1428
1429
1430
1431
1432
1433
1434
1435
1436
1437
1438
1439
1440
1441
1442
1443
1444
1445
1446
1447
1448
1449
1450
1451
1452
1453
1454
1455
1456
1457
1458
1459
1460
1461
1462
1463
1464
1465
1466
1467
1468
1469
1470
1471
1472
1473
1474
1475
1476
1477
1478
1479
1480
1481
1482
1483
1484
1485
1486
1487
1488
1489
1490
1491
1492
1493
1494
1495
1496
1497
1498
1499
1500
1501
1502
1503
1504
1505
1506
1507
1508
1509
1510
1511
1512
1513
1514
1515
1516
1517
1518
1519
1520
1521
1522
1523
1524
1525
1526
1527
1528
1529
1530
1531
1532
1533
1534
1535
1536
1537
1538
1539
1540
1541
1542
1543
1544
1545
1546
1547
1548
1549
1550
1551
1552
1553
1554
1555
1556
1557
1558
1559
1560
1561
1562
1563
1564
1565
1566
1567
1568
1569
1570
1571
1572
1573
1574
1575
1576
1577
1578
1579
1580
1581
1582
1583
1584
1585
1586
1587
1588
1589
def
Body
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
embed
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
When `embed` is `True`, the parameter will be expected in a JSON body as a
key instead of being the JSON body itself.
This happens automatically when more than one `Body` parameter is declared.
Read more about it in the
[FastAPI docs for Body - Multiple Parameters](https://fastapi.tiangolo.com/tutorial/body-multiple-params/#embed-a-single-body-parameter).
"""
),
]
=
None
,
media_type
:
Annotated
[
str
,
Doc
(
"""
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
"""
),
]
=
"application/json"
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
Body
(
default
=
default
,
default_factory
=
default_factory
,
embed
=
embed
,
media_type
=
media_type
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.Cookie
Cookie
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
959
960
961
962
963
964
965
966
967
968
969
970
971
972
973
974
975
976
977
978
979
980
981
982
983
984
985
986
987
988
989
990
991
992
993
994
995
996
997
998
999
1000
1001
1002
1003
1004
1005
1006
1007
1008
1009
1010
1011
1012
1013
1014
1015
1016
1017
1018
1019
1020
1021
1022
1023
1024
1025
1026
1027
1028
1029
1030
1031
1032
1033
1034
1035
1036
1037
1038
1039
1040
1041
1042
1043
1044
1045
1046
1047
1048
1049
1050
1051
1052
1053
1054
1055
1056
1057
1058
1059
1060
1061
1062
1063
1064
1065
1066
1067
1068
1069
1070
1071
1072
1073
1074
1075
1076
1077
1078
1079
1080
1081
1082
1083
1084
1085
1086
1087
1088
1089
1090
1091
1092
1093
1094
1095
1096
1097
1098
1099
1100
1101
1102
1103
1104
1105
1106
1107
1108
1109
1110
1111
1112
1113
1114
1115
1116
1117
1118
1119
1120
1121
1122
1123
1124
1125
1126
1127
1128
1129
1130
1131
1132
1133
1134
1135
1136
1137
1138
1139
1140
1141
1142
1143
1144
1145
1146
1147
1148
1149
1150
1151
1152
1153
1154
1155
1156
1157
1158
1159
1160
1161
1162
1163
1164
1165
1166
1167
1168
1169
1170
1171
1172
1173
1174
1175
1176
1177
1178
1179
1180
1181
1182
1183
1184
1185
1186
1187
1188
1189
1190
1191
1192
1193
1194
1195
1196
1197
1198
1199
1200
1201
1202
1203
1204
1205
1206
1207
1208
1209
1210
1211
1212
1213
1214
1215
1216
1217
1218
1219
1220
1221
1222
1223
1224
1225
1226
1227
1228
1229
1230
1231
1232
1233
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243
1244
1245
1246
1247
1248
1249
1250
1251
1252
1253
1254
1255
1256
1257
1258
1259
1260
def
Cookie
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
Cookie
(
default
=
default
,
default_factory
=
default_factory
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.Header
Header
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
convert_underscores
=
True
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
convert_underscores
Automatically convert underscores to hyphens in the parameter field name.
Read more about it in the
FastAPI docs for Header Parameters
TYPE:
bool
DEFAULT:
True
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812
813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
890
891
892
893
894
895
896
897
898
899
900
901
902
903
904
905
906
907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924
925
926
927
928
929
930
931
932
933
934
935
936
937
938
939
940
941
942
943
944
945
946
947
948
949
950
951
952
953
954
955
956
def
Header
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
convert_underscores
:
Annotated
[
bool
,
Doc
(
"""
Automatically convert underscores to hyphens in the parameter field name.
Read more about it in the
[FastAPI docs for Header Parameters](https://fastapi.tiangolo.com/tutorial/header-params/#automatic-conversion)
"""
),
]
=
True
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
Header
(
default
=
default
,
default_factory
=
default_factory
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
convert_underscores
=
convert_underscores
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.Form
Form
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
media_type
=
"application/x-www-form-urlencoded"
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
media_type
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
TYPE:
str
DEFAULT:
'application/x-www-form-urlencoded'
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
1592
1593
1594
1595
1596
1597
1598
1599
1600
1601
1602
1603
1604
1605
1606
1607
1608
1609
1610
1611
1612
1613
1614
1615
1616
1617
1618
1619
1620
1621
1622
1623
1624
1625
1626
1627
1628
1629
1630
1631
1632
1633
1634
1635
1636
1637
1638
1639
1640
1641
1642
1643
1644
1645
1646
1647
1648
1649
1650
1651
1652
1653
1654
1655
1656
1657
1658
1659
1660
1661
1662
1663
1664
1665
1666
1667
1668
1669
1670
1671
1672
1673
1674
1675
1676
1677
1678
1679
1680
1681
1682
1683
1684
1685
1686
1687
1688
1689
1690
1691
1692
1693
1694
1695
1696
1697
1698
1699
1700
1701
1702
1703
1704
1705
1706
1707
1708
1709
1710
1711
1712
1713
1714
1715
1716
1717
1718
1719
1720
1721
1722
1723
1724
1725
1726
1727
1728
1729
1730
1731
1732
1733
1734
1735
1736
1737
1738
1739
1740
1741
1742
1743
1744
1745
1746
1747
1748
1749
1750
1751
1752
1753
1754
1755
1756
1757
1758
1759
1760
1761
1762
1763
1764
1765
1766
1767
1768
1769
1770
1771
1772
1773
1774
1775
1776
1777
1778
1779
1780
1781
1782
1783
1784
1785
1786
1787
1788
1789
1790
1791
1792
1793
1794
1795
1796
1797
1798
1799
1800
1801
1802
1803
1804
1805
1806
1807
1808
1809
1810
1811
1812
1813
1814
1815
1816
1817
1818
1819
1820
1821
1822
1823
1824
1825
1826
1827
1828
1829
1830
1831
1832
1833
1834
1835
1836
1837
1838
1839
1840
1841
1842
1843
1844
1845
1846
1847
1848
1849
1850
1851
1852
1853
1854
1855
1856
1857
1858
1859
1860
1861
1862
1863
1864
1865
1866
1867
1868
1869
1870
1871
1872
1873
1874
1875
1876
1877
1878
1879
1880
1881
1882
1883
1884
1885
1886
1887
1888
1889
1890
1891
1892
1893
1894
1895
1896
1897
1898
1899
1900
1901
1902
1903
def
Form
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
media_type
:
Annotated
[
str
,
Doc
(
"""
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
"""
),
]
=
"application/x-www-form-urlencoded"
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
Form
(
default
=
default
,
default_factory
=
default_factory
,
media_type
=
media_type
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.File
File
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
media_type
=
"multipart/form-data"
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
media_type
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
TYPE:
str
DEFAULT:
'multipart/form-data'
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
1906
1907
1908
1909
1910
1911
1912
1913
1914
1915
1916
1917
1918
1919
1920
1921
1922
1923
1924
1925
1926
1927
1928
1929
1930
1931
1932
1933
1934
1935
1936
1937
1938
1939
1940
1941
1942
1943
1944
1945
1946
1947
1948
1949
1950
1951
1952
1953
1954
1955
1956
1957
1958
1959
1960
1961
1962
1963
1964
1965
1966
1967
1968
1969
1970
1971
1972
1973
1974
1975
1976
1977
1978
1979
1980
1981
1982
1983
1984
1985
1986
1987
1988
1989
1990
1991
1992
1993
1994
1995
1996
1997
1998
1999
2000
2001
2002
2003
2004
2005
2006
2007
2008
2009
2010
2011
2012
2013
2014
2015
2016
2017
2018
2019
2020
2021
2022
2023
2024
2025
2026
2027
2028
2029
2030
2031
2032
2033
2034
2035
2036
2037
2038
2039
2040
2041
2042
2043
2044
2045
2046
2047
2048
2049
2050
2051
2052
2053
2054
2055
2056
2057
2058
2059
2060
2061
2062
2063
2064
2065
2066
2067
2068
2069
2070
2071
2072
2073
2074
2075
2076
2077
2078
2079
2080
2081
2082
2083
2084
2085
2086
2087
2088
2089
2090
2091
2092
2093
2094
2095
2096
2097
2098
2099
2100
2101
2102
2103
2104
2105
2106
2107
2108
2109
2110
2111
2112
2113
2114
2115
2116
2117
2118
2119
2120
2121
2122
2123
2124
2125
2126
2127
2128
2129
2130
2131
2132
2133
2134
2135
2136
2137
2138
2139
2140
2141
2142
2143
2144
2145
2146
2147
2148
2149
2150
2151
2152
2153
2154
2155
2156
2157
2158
2159
2160
2161
2162
2163
2164
2165
2166
2167
2168
2169
2170
2171
2172
2173
2174
2175
2176
2177
2178
2179
2180
2181
2182
2183
2184
2185
2186
2187
2188
2189
2190
2191
2192
2193
2194
2195
2196
2197
2198
2199
2200
2201
2202
2203
2204
2205
2206
2207
2208
2209
2210
2211
2212
2213
2214
2215
2216
2217
def
File
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
media_type
:
Annotated
[
str
,
Doc
(
"""
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
"""
),
]
=
"multipart/form-data"
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
File
(
default
=
default
,
default_factory
=
default_factory
,
media_type
=
media_type
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)

## 095_REFERENCE_REQUEST
Requestclass¶
---

Request
class
You can declare a parameter in a
path operation function
or dependency to be of type
Request
and then you can access the raw request object directly, without any validation, etc.
You can import it directly from
fastapi
:
from
fastapi
import
Request
Tip
When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an
HTTPConnection
instead of a
Request
or a
WebSocket
.
fastapi.Request
Request
(
scope
,
receive
=
empty_receive
,
send
=
empty_send
)
Bases:
HTTPConnection
Source code in
starlette/requests.py
201
202
203
204
205
206
207
208
def
__init__
(
self
,
scope
:
Scope
,
receive
:
Receive
=
empty_receive
,
send
:
Send
=
empty_send
):
super
()
.
__init__
(
scope
)
assert
scope
[
"type"
]
==
"http"
self
.
_receive
=
receive
self
.
_send
=
send
self
.
_stream_consumed
=
False
self
.
_is_disconnected
=
False
self
.
_form
=
None
scope
instance-attribute
scope
=
scope
app
property
app
url
property
url
base_url
property
base_url
headers
property
headers
query_params
property
query_params
path_params
property
path_params
cookies
property
cookies
client
property
client
session
property
session
auth
property
auth
user
property
user
state
property
state
method
property
method
receive
property
receive
url_for
url_for
(
name
,
/
,
**
path_params
)
Source code in
starlette/requests.py
182
183
184
185
186
187
def
url_for
(
self
,
name
:
str
,
/
,
**
path_params
:
typing
.
Any
)
->
URL
:
url_path_provider
:
Router
|
Starlette
|
None
=
self
.
scope
.
get
(
"router"
)
or
self
.
scope
.
get
(
"app"
)
if
url_path_provider
is
None
:
raise
RuntimeError
(
"The `url_for` method can only be used inside a Starlette application or with a router."
)
url_path
=
url_path_provider
.
url_path_for
(
name
,
**
path_params
)
return
url_path
.
make_absolute_url
(
base_url
=
self
.
base_url
)
stream
async
stream
()
Source code in
starlette/requests.py
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
async
def
stream
(
self
)
->
typing
.
AsyncGenerator
[
bytes
,
None
]:
if
hasattr
(
self
,
"_body"
):
yield
self
.
_body
yield
b
""
return
if
self
.
_stream_consumed
:
raise
RuntimeError
(
"Stream consumed"
)
while
not
self
.
_stream_consumed
:
message
=
await
self
.
_receive
()
if
message
[
"type"
]
==
"http.request"
:
body
=
message
.
get
(
"body"
,
b
""
)
if
not
message
.
get
(
"more_body"
,
False
):
self
.
_stream_consumed
=
True
if
body
:
yield
body
elif
message
[
"type"
]
==
"http.disconnect"
:
## pragma: no branch
self
.
_is_disconnected
=
True
raise
ClientDisconnect
()
yield
b
""
body
async
body
()
Source code in
starlette/requests.py
238
239
240
241
242
243
244
async
def
body
(
self
)
->
bytes
:
if
not
hasattr
(
self
,
"_body"
):
chunks
:
list
[
bytes
]
=
[]
async
for
chunk
in
self
.
stream
():
chunks
.
append
(
chunk
)
self
.
_body
=
b
""
.
join
(
chunks
)
return
self
.
_body
json
async
json
()
Source code in
starlette/requests.py
246
247
248
249
250
async
def
json
(
self
)
->
typing
.
Any
:
if
not
hasattr
(
self
,
"_json"
):
## pragma: no branch
body
=
await
self
.
body
()
self
.
_json
=
json
.
loads
(
body
)
return
self
.
_json
form
form
(
*
,
max_files
=
1000
,
max_fields
=
1000
,
max_part_size
=
1024
*
1024
)
Source code in
starlette/requests.py
287
288
289
290
291
292
293
294
295
296
def
form
(
self
,
*
,
max_files
:
int
|
float
=
1000
,
max_fields
:
int
|
float
=
1000
,
max_part_size
:
int
=
1024
*
1024
,
)
->
AwaitableOrContextManager
[
FormData
]:
return
AwaitableOrContextManagerWrapper
(
self
.
_get_form
(
max_files
=
max_files
,
max_fields
=
max_fields
,
max_part_size
=
max_part_size
)
)
close
async
close
()
Source code in
starlette/requests.py
298
299
300
async
def
close
(
self
)
->
None
:
if
self
.
_form
is
not
None
:
## pragma: no branch
await
self
.
_form
.
close
()
is_disconnected
async
is_disconnected
()
Source code in
starlette/requests.py
302
303
304
305
306
307
308
309
310
311
312
313
314
async
def
is_disconnected
(
self
)
->
bool
:
if
not
self
.
_is_disconnected
:
message
:
Message
=
{}
## If message isn't immediately available, move on
with
anyio
.
CancelScope
()
as
cs
:
cs
.
cancel
()
message
=
await
self
.
_receive
()
if
message
.
get
(
"type"
)
==
"http.disconnect"
:
self
.
_is_disconnected
=
True
return
self
.
_is_disconnected
send_push_promise
async
send_push_promise
(
path
)
Source code in
starlette/requests.py
316
317
318
319
320
321
322
async
def
send_push_promise
(
self
,
path
:
str
)
->
None
:
if
"http.response.push"
in
self
.
scope
.
get
(
"extensions"
,
{}):
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
for
name
in
SERVER_PUSH_HEADERS_TO_COPY
:
for
value
in
self
.
headers
.
getlist
(
name
):
raw_headers
.
append
((
name
.
encode
(
"latin-1"
),
value
.
encode
(
"latin-1"
)))
await
self
.
_send
({
"type"
:
"http.response.push"
,
"path"
:
path
,
"headers"
:
raw_headers
})

## 096_REFERENCE_RESPONSE
Responseclass¶
---

Response
class
You can declare a parameter in a
path operation function
or dependency to be of type
Response
and then you can set data for the response like headers or cookies.
You can also use it directly to create an instance of it and return it from your
path operations
.
You can import it directly from
fastapi
:
from
fastapi
import
Response
fastapi.Response
Response
(
content
=
None
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Source code in
starlette/responses.py
33
34
35
36
37
38
39
40
41
42
43
44
45
46
def
__init__
(
self
,
content
:
typing
.
Any
=
None
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
self
.
status_code
=
status_code
if
media_type
is
not
None
:
self
.
media_type
=
media_type
self
.
background
=
background
self
.
body
=
self
.
render
(
content
)
self
.
init_headers
(
headers
)
media_type
class-attribute
instance-attribute
media_type
=
None
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
background
instance-attribute
background
=
background
body
instance-attribute
body
=
render
(
content
)
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)

## 097_REFERENCE_RESPONSES
Custom Response Classes - File, HTML, Redirect, Streaming, etc.¶
---

Custom Response Classes - File, HTML, Redirect, Streaming, etc.
There are several custom response classes you can use to create an instance and return them directly from your
path operations
.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
You can import them directly from
fastapi.responses
:
from
fastapi.responses
import
(
FileResponse
,
HTMLResponse
,
JSONResponse
,
ORJSONResponse
,
PlainTextResponse
,
RedirectResponse
,
Response
,
StreamingResponse
,
UJSONResponse
,
)
FastAPI Responses
There are a couple of custom FastAPI response classes, you can use them to optimize JSON performance.
fastapi.responses.UJSONResponse
UJSONResponse
(
content
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
JSONResponse
JSON response using the high-performance ujson library to serialize data to JSON.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
Source code in
starlette/responses.py
174
175
176
177
178
179
180
181
182
def
__init__
(
self
,
content
:
typing
.
Any
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
super
()
.
__init__
(
content
,
status_code
,
headers
,
media_type
,
background
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
'application/json'
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
fastapi/responses.py
31
32
33
def
render
(
self
,
content
:
Any
)
->
bytes
:
assert
ujson
is
not
None
,
"ujson must be installed to use UJSONResponse"
return
ujson
.
dumps
(
content
,
ensure_ascii
=
False
)
.
encode
(
"utf-8"
)
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.ORJSONResponse
ORJSONResponse
(
content
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
JSONResponse
JSON response using the high-performance orjson library to serialize data to JSON.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
Source code in
starlette/responses.py
174
175
176
177
178
179
180
181
182
def
__init__
(
self
,
content
:
typing
.
Any
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
super
()
.
__init__
(
content
,
status_code
,
headers
,
media_type
,
background
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
'application/json'
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
fastapi/responses.py
44
45
46
47
48
def
render
(
self
,
content
:
Any
)
->
bytes
:
assert
orjson
is
not
None
,
"orjson must be installed to use ORJSONResponse"
return
orjson
.
dumps
(
content
,
option
=
orjson
.
OPT_NON_STR_KEYS
|
orjson
.
OPT_SERIALIZE_NUMPY
)
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
Starlette Responses
fastapi.responses.FileResponse
FileResponse
(
path
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
filename
=
None
,
stat_result
=
None
,
method
=
None
,
content_disposition_type
=
"attachment"
,
)
Bases:
Response
Source code in
starlette/responses.py
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
def
__init__
(
self
,
path
:
str
|
os
.
PathLike
[
str
],
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
filename
:
str
|
None
=
None
,
stat_result
:
os
.
stat_result
|
None
=
None
,
method
:
str
|
None
=
None
,
content_disposition_type
:
str
=
"attachment"
,
)
->
None
:
self
.
path
=
path
self
.
status_code
=
status_code
self
.
filename
=
filename
if
method
is
not
None
:
warnings
.
warn
(
"The 'method' parameter is not used, and it will be removed."
,
DeprecationWarning
,
)
if
media_type
is
None
:
media_type
=
guess_type
(
filename
or
path
)[
0
]
or
"text/plain"
self
.
media_type
=
media_type
self
.
background
=
background
self
.
init_headers
(
headers
)
self
.
headers
.
setdefault
(
"accept-ranges"
,
"bytes"
)
if
self
.
filename
is
not
None
:
content_disposition_filename
=
quote
(
self
.
filename
)
if
content_disposition_filename
!=
self
.
filename
:
content_disposition
=
f
"
{
content_disposition_type
}
; filename*=utf-8''
{
content_disposition_filename
}
"
else
:
content_disposition
=
f
'
{
content_disposition_type
}
; filename="
{
self
.
filename
}
"'
self
.
headers
.
setdefault
(
"content-disposition"
,
content_disposition
)
self
.
stat_result
=
stat_result
if
stat_result
is
not
None
:
self
.
set_stat_headers
(
stat_result
)
chunk_size
class-attribute
instance-attribute
chunk_size
=
64
*
1024
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
instance-attribute
media_type
=
media_type
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.HTMLResponse
HTMLResponse
(
content
=
None
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
Response
Source code in
starlette/responses.py
33
34
35
36
37
38
39
40
41
42
43
44
45
46
def
__init__
(
self
,
content
:
typing
.
Any
=
None
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
self
.
status_code
=
status_code
if
media_type
is
not
None
:
self
.
media_type
=
media_type
self
.
background
=
background
self
.
body
=
self
.
render
(
content
)
self
.
init_headers
(
headers
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
'text/html'
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.JSONResponse
JSONResponse
(
content
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
Response
Source code in
starlette/responses.py
174
175
176
177
178
179
180
181
182
def
__init__
(
self
,
content
:
typing
.
Any
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
super
()
.
__init__
(
content
,
status_code
,
headers
,
media_type
,
background
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
'application/json'
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
184
185
186
187
188
189
190
191
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
:
return
json
.
dumps
(
content
,
ensure_ascii
=
False
,
allow_nan
=
False
,
indent
=
None
,
separators
=
(
","
,
":"
),
)
.
encode
(
"utf-8"
)
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.PlainTextResponse
PlainTextResponse
(
content
=
None
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
Response
Source code in
starlette/responses.py
33
34
35
36
37
38
39
40
41
42
43
44
45
46
def
__init__
(
self
,
content
:
typing
.
Any
=
None
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
self
.
status_code
=
status_code
if
media_type
is
not
None
:
self
.
media_type
=
media_type
self
.
background
=
background
self
.
body
=
self
.
render
(
content
)
self
.
init_headers
(
headers
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
'text/plain'
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.RedirectResponse
RedirectResponse
(
url
,
status_code
=
307
,
headers
=
None
,
background
=
None
)
Bases:
Response
Source code in
starlette/responses.py
195
196
197
198
199
200
201
202
203
def
__init__
(
self
,
url
:
str
|
URL
,
status_code
:
int
=
307
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
super
()
.
__init__
(
content
=
b
""
,
status_code
=
status_code
,
headers
=
headers
,
background
=
background
)
self
.
headers
[
"location"
]
=
quote
(
str
(
url
),
safe
=
":/%#?=@[]!$&'()*+,;"
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
None
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.Response
Response
(
content
=
None
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Source code in
starlette/responses.py
33
34
35
36
37
38
39
40
41
42
43
44
45
46
def
__init__
(
self
,
content
:
typing
.
Any
=
None
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
self
.
status_code
=
status_code
if
media_type
is
not
None
:
self
.
media_type
=
media_type
self
.
background
=
background
self
.
body
=
self
.
render
(
content
)
self
.
init_headers
(
headers
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
None
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.StreamingResponse
StreamingResponse
(
content
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
Response
Source code in
starlette/responses.py
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
def
__init__
(
self
,
content
:
ContentStream
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
if
isinstance
(
content
,
typing
.
AsyncIterable
):
self
.
body_iterator
=
content
else
:
self
.
body_iterator
=
iterate_in_threadpool
(
content
)
self
.
status_code
=
status_code
self
.
media_type
=
self
.
media_type
if
media_type
is
None
else
media_type
self
.
background
=
background
self
.
init_headers
(
headers
)
body_iterator
instance-attribute
body_iterator
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
instance-attribute
media_type
=
(
media_type
if
media_type
is
None
else
media_type
)
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)

## 098_REFERENCE_SECURITY
Security Tools¶
---

Security Tools
When you need to declare dependencies with OAuth2 scopes you use
Security()
.
But you still need to define what is the dependable, the callable that you pass as a parameter to
Depends()
or
Security()
.
There are multiple tools that you can use to create those dependables, and they get integrated into OpenAPI so they are shown in the automatic docs UI, they can be used by automatically generated clients and SDKs, etc.
You can import them from
fastapi.security
:
from
fastapi.security
import
(
APIKeyCookie
,
APIKeyHeader
,
APIKeyQuery
,
HTTPAuthorizationCredentials
,
HTTPBasic
,
HTTPBasicCredentials
,
HTTPBearer
,
HTTPDigest
,
OAuth2
,
OAuth2AuthorizationCodeBearer
,
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
OAuth2PasswordRequestFormStrict
,
OpenIdConnect
,
SecurityScopes
,
)
API Key Security Schemes
fastapi.security.APIKeyCookie
APIKeyCookie
(
*
,
name
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
APIKeyBase
API key authentication using a cookie.
This defines the name of the cookie that should be provided in the request with
the API key and integrates that into the OpenAPI documentation. It extracts
the key value sent in the cookie automatically and provides it as the dependency
result. But it doesn't define how to set that cookie.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be a string containing the key value.
Example
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
APIKeyCookie
app
=
FastAPI
()
cookie_scheme
=
APIKeyCookie
(
name
=
"session"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
session
:
str
=
Depends
(
cookie_scheme
)):
return
{
"session"
:
session
}
PARAMETER
DESCRIPTION
name
Cookie name.
TYPE:
str
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the cookie is not provided,
APIKeyCookie
will
automatically cancel the request and send the client an error.
If
auto_error
is set to
False
, when the cookie is not available,
instead of erroring out, the dependency result will be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a cookie or
in an HTTP Bearer token).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/api_key.py
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
def
__init__
(
self
,
*
,
name
:
Annotated
[
str
,
Doc
(
"Cookie name."
)],
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the cookie is not provided, `APIKeyCookie` will
automatically cancel the request and send the client an error.
If `auto_error` is set to `False`, when the cookie is not available,
instead of erroring out, the dependency result will be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a cookie or
in an HTTP Bearer token).
"""
),
]
=
True
,
):
self
.
model
:
APIKey
=
APIKey
(
**
{
"in"
:
APIKeyIn
.
cookie
},
## type: ignore[arg-type]
name
=
name
,
description
=
description
,
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
APIKey
(
**
{
"in"
:
cookie
},
name
=
name
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
check_api_key
staticmethod
check_api_key
(
api_key
,
auto_error
)
Source code in
fastapi/security/api_key.py
12
13
14
15
16
17
18
19
20
@staticmethod
def
check_api_key
(
api_key
:
Optional
[
str
],
auto_error
:
bool
)
->
Optional
[
str
]:
if
not
api_key
:
if
auto_error
:
raise
HTTPException
(
status_code
=
HTTP_403_FORBIDDEN
,
detail
=
"Not authenticated"
)
return
None
return
api_key
fastapi.security.APIKeyHeader
APIKeyHeader
(
*
,
name
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
APIKeyBase
API key authentication using a header.
This defines the name of the header that should be provided in the request with
the API key and integrates that into the OpenAPI documentation. It extracts
the key value sent in the header automatically and provides it as the dependency
result. But it doesn't define how to send that key to the client.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be a string containing the key value.
Example
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
APIKeyHeader
app
=
FastAPI
()
header_scheme
=
APIKeyHeader
(
name
=
"x-key"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
key
:
str
=
Depends
(
header_scheme
)):
return
{
"key"
:
key
}
PARAMETER
DESCRIPTION
name
Header name.
TYPE:
str
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the header is not provided,
APIKeyHeader
will
automatically cancel the request and send the client an error.
If
auto_error
is set to
False
, when the header is not available,
instead of erroring out, the dependency result will be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a header or
in an HTTP Bearer token).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/api_key.py
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
def
__init__
(
self
,
*
,
name
:
Annotated
[
str
,
Doc
(
"Header name."
)],
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the header is not provided, `APIKeyHeader` will
automatically cancel the request and send the client an error.
If `auto_error` is set to `False`, when the header is not available,
instead of erroring out, the dependency result will be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a header or
in an HTTP Bearer token).
"""
),
]
=
True
,
):
self
.
model
:
APIKey
=
APIKey
(
**
{
"in"
:
APIKeyIn
.
header
},
## type: ignore[arg-type]
name
=
name
,
description
=
description
,
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
APIKey
(
**
{
"in"
:
header
},
name
=
name
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
check_api_key
staticmethod
check_api_key
(
api_key
,
auto_error
)
Source code in
fastapi/security/api_key.py
12
13
14
15
16
17
18
19
20
@staticmethod
def
check_api_key
(
api_key
:
Optional
[
str
],
auto_error
:
bool
)
->
Optional
[
str
]:
if
not
api_key
:
if
auto_error
:
raise
HTTPException
(
status_code
=
HTTP_403_FORBIDDEN
,
detail
=
"Not authenticated"
)
return
None
return
api_key
fastapi.security.APIKeyQuery
APIKeyQuery
(
*
,
name
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
APIKeyBase
API key authentication using a query parameter.
This defines the name of the query parameter that should be provided in the request
with the API key and integrates that into the OpenAPI documentation. It extracts
the key value sent in the query parameter automatically and provides it as the
dependency result. But it doesn't define how to send that API key to the client.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be a string containing the key value.
Example
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
APIKeyQuery
app
=
FastAPI
()
query_scheme
=
APIKeyQuery
(
name
=
"api_key"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
api_key
:
str
=
Depends
(
query_scheme
)):
return
{
"api_key"
:
api_key
}
PARAMETER
DESCRIPTION
name
Query parameter name.
TYPE:
str
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the query parameter is not provided,
APIKeyQuery
will
automatically cancel the request and send the client an error.
If
auto_error
is set to
False
, when the query parameter is not
available, instead of erroring out, the dependency result will be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a query
parameter or in an HTTP Bearer token).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/api_key.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
def
__init__
(
self
,
*
,
name
:
Annotated
[
str
,
Doc
(
"Query parameter name."
),
],
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the query parameter is not provided, `APIKeyQuery` will
automatically cancel the request and send the client an error.
If `auto_error` is set to `False`, when the query parameter is not
available, instead of erroring out, the dependency result will be
`None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a query
parameter or in an HTTP Bearer token).
"""
),
]
=
True
,
):
self
.
model
:
APIKey
=
APIKey
(
**
{
"in"
:
APIKeyIn
.
query
},
## type: ignore[arg-type]
name
=
name
,
description
=
description
,
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
APIKey
(
**
{
"in"
:
query
},
name
=
name
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
check_api_key
staticmethod
check_api_key
(
api_key
,
auto_error
)
Source code in
fastapi/security/api_key.py
12
13
14
15
16
17
18
19
20
@staticmethod
def
check_api_key
(
api_key
:
Optional
[
str
],
auto_error
:
bool
)
->
Optional
[
str
]:
if
not
api_key
:
if
auto_error
:
raise
HTTPException
(
status_code
=
HTTP_403_FORBIDDEN
,
detail
=
"Not authenticated"
)
return
None
return
api_key
HTTP Authentication Schemes
fastapi.security.HTTPBasic
HTTPBasic
(
*
,
scheme_name
=
None
,
realm
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
HTTPBase
HTTP Basic authentication.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be an
HTTPBasicCredentials
object containing the
username
and the
password
.
Read more about it in the
FastAPI docs for HTTP Basic Auth
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)]):
return
{
"username"
:
credentials
.
username
,
"password"
:
credentials
.
password
}
PARAMETER
DESCRIPTION
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
realm
HTTP Basic authentication realm.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the HTTP Basic authentication is not provided (a
header),
HTTPBasic
will automatically cancel the request and send the
client an error.
If
auto_error
is set to
False
, when the HTTP Basic authentication
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in HTTP Basic
authentication or in an HTTP Bearer token).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/http.py
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
def
__init__
(
self
,
*
,
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
realm
:
Annotated
[
Optional
[
str
],
Doc
(
"""
HTTP Basic authentication realm.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the HTTP Basic authentication is not provided (a
header), `HTTPBasic` will automatically cancel the request and send the
client an error.
If `auto_error` is set to `False`, when the HTTP Basic authentication
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in HTTP Basic
authentication or in an HTTP Bearer token).
"""
),
]
=
True
,
):
self
.
model
=
HTTPBaseModel
(
scheme
=
"basic"
,
description
=
description
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
realm
=
realm
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
HTTPBase
(
scheme
=
'basic'
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
realm
instance-attribute
realm
=
realm
auto_error
instance-attribute
auto_error
=
auto_error
fastapi.security.HTTPBearer
HTTPBearer
(
*
,
bearerFormat
=
None
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
HTTPBase
HTTP Bearer token authentication.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be an
HTTPAuthorizationCredentials
object containing
the
scheme
and the
credentials
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPAuthorizationCredentials
,
HTTPBearer
app
=
FastAPI
()
security
=
HTTPBearer
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
Annotated
[
HTTPAuthorizationCredentials
,
Depends
(
security
)]
):
return
{
"scheme"
:
credentials
.
scheme
,
"credentials"
:
credentials
.
credentials
}
PARAMETER
DESCRIPTION
bearerFormat
Bearer token format.
TYPE:
Optional
[
str
]
DEFAULT:
None
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the HTTP Bearer token is not provided (in an
Authorization
header),
HTTPBearer
will automatically cancel the
request and send the client an error.
If
auto_error
is set to
False
, when the HTTP Bearer token
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in an HTTP
Bearer token or in a cookie).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/http.py
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
def
__init__
(
self
,
*
,
bearerFormat
:
Annotated
[
Optional
[
str
],
Doc
(
"Bearer token format."
)]
=
None
,
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the HTTP Bearer token is not provided (in an
`Authorization` header), `HTTPBearer` will automatically cancel the
request and send the client an error.
If `auto_error` is set to `False`, when the HTTP Bearer token
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in an HTTP
Bearer token or in a cookie).
"""
),
]
=
True
,
):
self
.
model
=
HTTPBearerModel
(
bearerFormat
=
bearerFormat
,
description
=
description
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
HTTPBearer
(
bearerFormat
=
bearerFormat
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
fastapi.security.HTTPDigest
HTTPDigest
(
*
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
HTTPBase
HTTP Digest authentication.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be an
HTTPAuthorizationCredentials
object containing
the
scheme
and the
credentials
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPAuthorizationCredentials
,
HTTPDigest
app
=
FastAPI
()
security
=
HTTPDigest
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
Annotated
[
HTTPAuthorizationCredentials
,
Depends
(
security
)]
):
return
{
"scheme"
:
credentials
.
scheme
,
"credentials"
:
credentials
.
credentials
}
PARAMETER
DESCRIPTION
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the HTTP Digest is not provided,
HTTPDigest
will
automatically cancel the request and send the client an error.
If
auto_error
is set to
False
, when the HTTP Digest is not
available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in HTTP
Digest or in a cookie).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/http.py
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
def
__init__
(
self
,
*
,
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the HTTP Digest is not provided, `HTTPDigest` will
automatically cancel the request and send the client an error.
If `auto_error` is set to `False`, when the HTTP Digest is not
available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in HTTP
Digest or in a cookie).
"""
),
]
=
True
,
):
self
.
model
=
HTTPBaseModel
(
scheme
=
"digest"
,
description
=
description
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
HTTPBase
(
scheme
=
'digest'
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
HTTP Credentials
fastapi.security.HTTPAuthorizationCredentials
Bases:
BaseModel
The HTTP authorization credentials in the result of using
HTTPBearer
or
HTTPDigest
in a dependency.
The HTTP authorization header value is split by the first space.
The first part is the
scheme
, the second part is the
credentials
.
For example, in an HTTP Bearer token scheme, the client will send a header
like:
Authorization: Bearer deadbeef12346
In this case:
scheme
will have the value
"Bearer"
credentials
will have the value
"deadbeef12346"
scheme
instance-attribute
scheme
The HTTP authorization scheme extracted from the header value.
credentials
instance-attribute
credentials
The HTTP authorization credentials extracted from the header value.
fastapi.security.HTTPBasicCredentials
Bases:
BaseModel
The HTTP Basic credentials given as the result of using
HTTPBasic
in a
dependency.
Read more about it in the
FastAPI docs for HTTP Basic Auth
.
username
instance-attribute
username
The HTTP Basic username.
password
instance-attribute
password
The HTTP Basic password.
OAuth2 Authentication
fastapi.security.OAuth2
OAuth2
(
*
,
flows
=
OAuthFlows
(),
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
SecurityBase
This is the base class for OAuth2 authentication, an instance of it would be used
as a dependency. All other OAuth2 classes inherit from it and customize it for
each OAuth2 flow.
You normally would not create a new class inheriting from it but use one of the
existing subclasses, and maybe compose them if you want to support multiple flows.
Read more about it in the
FastAPI docs for Security
.
PARAMETER
DESCRIPTION
flows
The dictionary of OAuth2 flows.
TYPE:
Union
[
OAuthFlows
,
Dict
[
str
,
Dict
[
str
,
Any
]]]
DEFAULT:
OAuthFlows
()
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If
auto_error
is set to
False
, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/oauth2.py
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
def
__init__
(
self
,
*
,
flows
:
Annotated
[
Union
[
OAuthFlowsModel
,
Dict
[
str
,
Dict
[
str
,
Any
]]],
Doc
(
"""
The dictionary of OAuth2 flows.
"""
),
]
=
OAuthFlowsModel
(),
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If `auto_error` is set to `False`, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
"""
),
]
=
True
,
):
self
.
model
=
OAuth2Model
(
flows
=
cast
(
OAuthFlowsModel
,
flows
),
description
=
description
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
OAuth2
(
flows
=
cast
(
OAuthFlows
,
flows
),
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
fastapi.security.OAuth2AuthorizationCodeBearer
OAuth2AuthorizationCodeBearer
(
authorizationUrl
,
tokenUrl
,
refreshUrl
=
None
,
scheme_name
=
None
,
scopes
=
None
,
description
=
None
,
auto_error
=
True
,
)
Bases:
OAuth2
OAuth2 flow for authentication using a bearer token obtained with an OAuth2 code
flow. An instance of it would be used as a dependency.
PARAMETER
DESCRIPTION
tokenUrl
The URL to obtain the OAuth2 token.
TYPE:
str
refreshUrl
The URL to refresh the token and obtain a new one.
TYPE:
Optional
[
str
]
DEFAULT:
None
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
scopes
The OAuth2 scopes that would be required by the
path operations
that
use this dependency.
TYPE:
Optional
[
Dict
[
str
,
str
]]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If
auto_error
is set to
False
, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/oauth2.py
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
def
__init__
(
self
,
authorizationUrl
:
str
,
tokenUrl
:
Annotated
[
str
,
Doc
(
"""
The URL to obtain the OAuth2 token.
"""
),
],
refreshUrl
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The URL to refresh the token and obtain a new one.
"""
),
]
=
None
,
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
scopes
:
Annotated
[
Optional
[
Dict
[
str
,
str
]],
Doc
(
"""
The OAuth2 scopes that would be required by the *path operations* that
use this dependency.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If `auto_error` is set to `False`, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
"""
),
]
=
True
,
):
if
not
scopes
:
scopes
=
{}
flows
=
OAuthFlowsModel
(
authorizationCode
=
cast
(
Any
,
{
"authorizationUrl"
:
authorizationUrl
,
"tokenUrl"
:
tokenUrl
,
"refreshUrl"
:
refreshUrl
,
"scopes"
:
scopes
,
},
)
)
super
()
.
__init__
(
flows
=
flows
,
scheme_name
=
scheme_name
,
description
=
description
,
auto_error
=
auto_error
,
)
model
instance-attribute
model
=
OAuth2
(
flows
=
cast
(
OAuthFlows
,
flows
),
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
fastapi.security.OAuth2PasswordBearer
OAuth2PasswordBearer
(
tokenUrl
,
scheme_name
=
None
,
scopes
=
None
,
description
=
None
,
auto_error
=
True
,
refreshUrl
=
None
,
)
Bases:
OAuth2
OAuth2 flow for authentication using a bearer token obtained with a password.
An instance of it would be used as a dependency.
Read more about it in the
FastAPI docs for Simple OAuth2 with Password and Bearer
.
PARAMETER
DESCRIPTION
tokenUrl
The URL to obtain the OAuth2 token. This would be the
path operation
that has
OAuth2PasswordRequestForm
as a dependency.
TYPE:
str
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
scopes
The OAuth2 scopes that would be required by the
path operations
that
use this dependency.
TYPE:
Optional
[
Dict
[
str
,
str
]]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If
auto_error
is set to
False
, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
TYPE:
bool
DEFAULT:
True
refreshUrl
The URL to refresh the token and obtain a new one.
TYPE:
Optional
[
str
]
DEFAULT:
None
Source code in
fastapi/security/oauth2.py
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
def
__init__
(
self
,
tokenUrl
:
Annotated
[
str
,
Doc
(
"""
The URL to obtain the OAuth2 token. This would be the *path operation*
that has `OAuth2PasswordRequestForm` as a dependency.
"""
),
],
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
scopes
:
Annotated
[
Optional
[
Dict
[
str
,
str
]],
Doc
(
"""
The OAuth2 scopes that would be required by the *path operations* that
use this dependency.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If `auto_error` is set to `False`, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
"""
),
]
=
True
,
refreshUrl
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The URL to refresh the token and obtain a new one.
"""
),
]
=
None
,
):
if
not
scopes
:
scopes
=
{}
flows
=
OAuthFlowsModel
(
password
=
cast
(
Any
,
{
"tokenUrl"
:
tokenUrl
,
"refreshUrl"
:
refreshUrl
,
"scopes"
:
scopes
,
},
)
)
super
()
.
__init__
(
flows
=
flows
,
scheme_name
=
scheme_name
,
description
=
description
,
auto_error
=
auto_error
,
)
model
instance-attribute
model
=
OAuth2
(
flows
=
cast
(
OAuthFlows
,
flows
),
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
OAuth2 Password Form
fastapi.security.OAuth2PasswordRequestForm
OAuth2PasswordRequestForm
(
*
,
grant_type
=
None
,
username
,
password
,
scope
=
""
,
client_id
=
None
,
client_secret
=
None
)
This is a dependency class to collect the
username
and
password
as form data
for an OAuth2 password flow.
The OAuth2 specification dictates that for a password flow the data should be
collected using form data (instead of JSON) and that it should have the specific
fields
username
and
password
.
All the initialization parameters are extracted from the request.
Read more about it in the
FastAPI docs for Simple OAuth2 with Password and Bearer
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordRequestForm
app
=
FastAPI
()
@app
.
post
(
"/login"
)
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
data
=
{}
data
[
"scopes"
]
=
[]
for
scope
in
form_data
.
scopes
:
data
[
"scopes"
]
.
append
(
scope
)
if
form_data
.
client_id
:
data
[
"client_id"
]
=
form_data
.
client_id
if
form_data
.
client_secret
:
data
[
"client_secret"
]
=
form_data
.
client_secret
return
data
Note that for OAuth2 the scope
items:read
is a single scope in an opaque string.
You could have custom internal logic to separate it by colon characters (
:
) or
similar, and get the two parts
items
and
read
. Many applications do that to
group and organize permissions, you could do it as well in your application, just
know that that it is application specific, it's not part of the specification.
PARAMETER
DESCRIPTION
grant_type
The OAuth2 spec says it is required and MUST be the fixed string
"password". Nevertheless, this dependency class is permissive and
allows not passing it. If you want to enforce it, use instead the
OAuth2PasswordRequestFormStrict
dependency.
TYPE:
Union
[
str
, None]
DEFAULT:
None
username
username
string. The OAuth2 spec requires the exact field name
username
.
TYPE:
str
password
password
string. The OAuth2 spec requires the exact field name
`password".
TYPE:
str
scope
A single string with actually several scopes separated by spaces. Each
scope is also a string.
For example, a single string with:
```python
"items:read items:write users:read profile openid"
````
would represent the scopes:
items:read
items:write
users:read
profile
openid
TYPE:
str
DEFAULT:
''
client_id
If there's a
client_id
, it can be sent as part of the form fields.
But the OAuth2 specification recommends sending the
client_id
and
client_secret
(if any) using HTTP Basic auth.
TYPE:
Union
[
str
, None]
DEFAULT:
None
client_secret
If there's a
client_password
(and a
client_id
), they can be sent
as part of the form fields. But the OAuth2 specification recommends
sending the
client_id
and
client_secret
(if any) using HTTP Basic
auth.
TYPE:
Union
[
str
, None]
DEFAULT:
None
Source code in
fastapi/security/oauth2.py
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
def
__init__
(
self
,
*
,
grant_type
:
Annotated
[
Union
[
str
,
None
],
Form
(
pattern
=
"^password$"
),
Doc
(
"""
The OAuth2 spec says it is required and MUST be the fixed string
"password". Nevertheless, this dependency class is permissive and
allows not passing it. If you want to enforce it, use instead the
`OAuth2PasswordRequestFormStrict` dependency.
"""
),
]
=
None
,
username
:
Annotated
[
str
,
Form
(),
Doc
(
"""
`username` string. The OAuth2 spec requires the exact field name
`username`.
"""
),
],
password
:
Annotated
[
str
,
Form
(
json_schema_extra
=
{
"format"
:
"password"
}),
Doc
(
"""
`password` string. The OAuth2 spec requires the exact field name
`password".
"""
),
],
scope
:
Annotated
[
str
,
Form
(),
Doc
(
"""
A single string with actually several scopes separated by spaces. Each
scope is also a string.
For example, a single string with:
```python
"items:read items:write users:read profile openid"
````
would represent the scopes:
* `items:read`
* `items:write`
* `users:read`
* `profile`
* `openid`
"""
),
]
=
""
,
client_id
:
Annotated
[
Union
[
str
,
None
],
Form
(),
Doc
(
"""
If there's a `client_id`, it can be sent as part of the form fields.
But the OAuth2 specification recommends sending the `client_id` and
`client_secret` (if any) using HTTP Basic auth.
"""
),
]
=
None
,
client_secret
:
Annotated
[
Union
[
str
,
None
],
Form
(
json_schema_extra
=
{
"format"
:
"password"
}),
Doc
(
"""
If there's a `client_password` (and a `client_id`), they can be sent
as part of the form fields. But the OAuth2 specification recommends
sending the `client_id` and `client_secret` (if any) using HTTP Basic
auth.
"""
),
]
=
None
,
):
self
.
grant_type
=
grant_type
self
.
username
=
username
self
.
password
=
password
self
.
scopes
=
scope
.
split
()
self
.
client_id
=
client_id
self
.
client_secret
=
client_secret
grant_type
instance-attribute
grant_type
=
grant_type
username
instance-attribute
username
=
username
password
instance-attribute
password
=
password
scopes
instance-attribute
scopes
=
split
()
client_id
instance-attribute
client_id
=
client_id
client_secret
instance-attribute
client_secret
=
client_secret
fastapi.security.OAuth2PasswordRequestFormStrict
OAuth2PasswordRequestFormStrict
(
grant_type
,
username
,
password
,
scope
=
""
,
client_id
=
None
,
client_secret
=
None
,
)
Bases:
OAuth2PasswordRequestForm
This is a dependency class to collect the
username
and
password
as form data
for an OAuth2 password flow.
The OAuth2 specification dictates that for a password flow the data should be
collected using form data (instead of JSON) and that it should have the specific
fields
username
and
password
.
All the initialization parameters are extracted from the request.
The only difference between
OAuth2PasswordRequestFormStrict
and
OAuth2PasswordRequestForm
is that
OAuth2PasswordRequestFormStrict
requires the
client to send the form field
grant_type
with the value
"password"
, which
is required in the OAuth2 specification (it seems that for no particular reason),
while for
OAuth2PasswordRequestForm
grant_type
is optional.
Read more about it in the
FastAPI docs for Simple OAuth2 with Password and Bearer
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordRequestForm
app
=
FastAPI
()
@app
.
post
(
"/login"
)
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestFormStrict
,
Depends
()]):
data
=
{}
data
[
"scopes"
]
=
[]
for
scope
in
form_data
.
scopes
:
data
[
"scopes"
]
.
append
(
scope
)
if
form_data
.
client_id
:
data
[
"client_id"
]
=
form_data
.
client_id
if
form_data
.
client_secret
:
data
[
"client_secret"
]
=
form_data
.
client_secret
return
data
Note that for OAuth2 the scope
items:read
is a single scope in an opaque string.
You could have custom internal logic to separate it by colon characters (
:
) or
similar, and get the two parts
items
and
read
. Many applications do that to
group and organize permissions, you could do it as well in your application, just
know that that it is application specific, it's not part of the specification.
the OAuth2 spec says it is required and MUST be the fixed string "password".
This dependency is strict about it. If you want to be permissive, use instead the
OAuth2PasswordRequestForm dependency class.
username: username string. The OAuth2 spec requires the exact field name "username".
password: password string. The OAuth2 spec requires the exact field name "password".
scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.
"items:read items:write users:read profile openid"
client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)
using HTTP Basic auth, as: client_id:client_secret
client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)
using HTTP Basic auth, as: client_id:client_secret
PARAMETER
DESCRIPTION
grant_type
The OAuth2 spec says it is required and MUST be the fixed string
"password". This dependency is strict about it. If you want to be
permissive, use instead the
OAuth2PasswordRequestForm
dependency
class.
TYPE:
str
username
username
string. The OAuth2 spec requires the exact field name
username
.
TYPE:
str
password
password
string. The OAuth2 spec requires the exact field name
`password".
TYPE:
str
scope
A single string with actually several scopes separated by spaces. Each
scope is also a string.
For example, a single string with:
```python
"items:read items:write users:read profile openid"
````
would represent the scopes:
items:read
items:write
users:read
profile
openid
TYPE:
str
DEFAULT:
''
client_id
If there's a
client_id
, it can be sent as part of the form fields.
But the OAuth2 specification recommends sending the
client_id
and
client_secret
(if any) using HTTP Basic auth.
TYPE:
Union
[
str
, None]
DEFAULT:
None
client_secret
If there's a
client_password
(and a
client_id
), they can be sent
as part of the form fields. But the OAuth2 specification recommends
sending the
client_id
and
client_secret
(if any) using HTTP Basic
auth.
TYPE:
Union
[
str
, None]
DEFAULT:
None
Source code in
fastapi/security/oauth2.py
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
def
__init__
(
self
,
grant_type
:
Annotated
[
str
,
Form
(
pattern
=
"^password$"
),
Doc
(
"""
The OAuth2 spec says it is required and MUST be the fixed string
"password". This dependency is strict about it. If you want to be
permissive, use instead the `OAuth2PasswordRequestForm` dependency
class.
"""
),
],
username
:
Annotated
[
str
,
Form
(),
Doc
(
"""
`username` string. The OAuth2 spec requires the exact field name
`username`.
"""
),
],
password
:
Annotated
[
str
,
Form
(),
Doc
(
"""
`password` string. The OAuth2 spec requires the exact field name
`password".
"""
),
],
scope
:
Annotated
[
str
,
Form
(),
Doc
(
"""
A single string with actually several scopes separated by spaces. Each
scope is also a string.
For example, a single string with:
```python
"items:read items:write users:read profile openid"
````
would represent the scopes:
* `items:read`
* `items:write`
* `users:read`
* `profile`
* `openid`
"""
),
]
=
""
,
client_id
:
Annotated
[
Union
[
str
,
None
],
Form
(),
Doc
(
"""
If there's a `client_id`, it can be sent as part of the form fields.
But the OAuth2 specification recommends sending the `client_id` and
`client_secret` (if any) using HTTP Basic auth.
"""
),
]
=
None
,
client_secret
:
Annotated
[
Union
[
str
,
None
],
Form
(),
Doc
(
"""
If there's a `client_password` (and a `client_id`), they can be sent
as part of the form fields. But the OAuth2 specification recommends
sending the `client_id` and `client_secret` (if any) using HTTP Basic
auth.
"""
),
]
=
None
,
):
super
()
.
__init__
(
grant_type
=
grant_type
,
username
=
username
,
password
=
password
,
scope
=
scope
,
client_id
=
client_id
,
client_secret
=
client_secret
,
)
grant_type
instance-attribute
grant_type
=
grant_type
username
instance-attribute
username
=
username
password
instance-attribute
password
=
password
scopes
instance-attribute
scopes
=
split
()
client_id
instance-attribute
client_id
=
client_id
client_secret
instance-attribute
client_secret
=
client_secret
OAuth2 Security Scopes in Dependencies
fastapi.security.SecurityScopes
SecurityScopes
(
scopes
=
None
)
This is a special class that you can define in a parameter in a dependency to
obtain the OAuth2 scopes required by all the dependencies in the same chain.
This way, multiple dependencies can have different scopes, even when used in the
same
path operation
. And with this, you can access all the scopes required in
all those dependencies in a single place.
Read more about it in the
FastAPI docs for OAuth2 scopes
.
PARAMETER
DESCRIPTION
scopes
This will be filled by FastAPI.
TYPE:
Optional
[
List
[
str
]]
DEFAULT:
None
Source code in
fastapi/security/oauth2.py
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
def
__init__
(
self
,
scopes
:
Annotated
[
Optional
[
List
[
str
]],
Doc
(
"""
This will be filled by FastAPI.
"""
),
]
=
None
,
):
self
.
scopes
:
Annotated
[
List
[
str
],
Doc
(
"""
The list of all the scopes required by dependencies.
"""
),
]
=
scopes
or
[]
self
.
scope_str
:
Annotated
[
str
,
Doc
(
"""
All the scopes required by all the dependencies in a single string
separated by spaces, as defined in the OAuth2 specification.
"""
),
]
=
" "
.
join
(
self
.
scopes
)
scopes
instance-attribute
scopes
=
scopes
or
[]
The list of all the scopes required by dependencies.
scope_str
instance-attribute
scope_str
=
join
(
scopes
)
All the scopes required by all the dependencies in a single string
separated by spaces, as defined in the OAuth2 specification.
OpenID Connect
fastapi.security.OpenIdConnect
OpenIdConnect
(
*
,
openIdConnectUrl
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
SecurityBase
OpenID Connect authentication class. An instance of it would be used as a
dependency.
PARAMETER
DESCRIPTION
openIdConnectUrl
The OpenID Connect URL.
TYPE:
str
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if no HTTP Authorization header is provided, required for
OpenID Connect authentication, it will automatically cancel the request
and send the client an error.
If
auto_error
is set to
False
, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OpenID
Connect or in a cookie).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/open_id_connect_url.py
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
def
__init__
(
self
,
*
,
openIdConnectUrl
:
Annotated
[
str
,
Doc
(
"""
The OpenID Connect URL.
"""
),
],
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if no HTTP Authorization header is provided, required for
OpenID Connect authentication, it will automatically cancel the request
and send the client an error.
If `auto_error` is set to `False`, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OpenID
Connect or in a cookie).
"""
),
]
=
True
,
):
self
.
model
=
OpenIdConnectModel
(
openIdConnectUrl
=
openIdConnectUrl
,
description
=
description
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
OpenIdConnect
(
openIdConnectUrl
=
openIdConnectUrl
,
description
=
description
,
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error

## 099_REFERENCE_STATICFILES
Static Files -StaticFiles¶
---

Static Files -
StaticFiles
You can use the
StaticFiles
class to serve static files, like JavaScript, CSS, images, etc.
Read more about it in the
FastAPI docs for Static Files
.
You can import it directly from
fastapi.staticfiles
:
from
fastapi.staticfiles
import
StaticFiles
fastapi.staticfiles.StaticFiles
StaticFiles
(
*
,
directory
=
None
,
packages
=
None
,
html
=
False
,
check_dir
=
True
,
follow_symlink
=
False
)
Source code in
starlette/staticfiles.py
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
def
__init__
(
self
,
*
,
directory
:
PathLike
|
None
=
None
,
packages
:
list
[
str
|
tuple
[
str
,
str
]]
|
None
=
None
,
html
:
bool
=
False
,
check_dir
:
bool
=
True
,
follow_symlink
:
bool
=
False
,
)
->
None
:
self
.
directory
=
directory
self
.
packages
=
packages
self
.
all_directories
=
self
.
get_directories
(
directory
,
packages
)
self
.
html
=
html
self
.
config_checked
=
False
self
.
follow_symlink
=
follow_symlink
if
check_dir
and
directory
is
not
None
and
not
os
.
path
.
isdir
(
directory
):
raise
RuntimeError
(
f
"Directory '
{
directory
}
' does not exist"
)
directory
instance-attribute
directory
=
directory
packages
instance-attribute
packages
=
packages
all_directories
instance-attribute
all_directories
=
get_directories
(
directory
,
packages
)
html
instance-attribute
html
=
html
config_checked
instance-attribute
config_checked
=
False
follow_symlink
instance-attribute
follow_symlink
=
follow_symlink
get_directories
get_directories
(
directory
=
None
,
packages
=
None
)
Given
directory
and
packages
arguments, return a list of all the
directories that should be used for serving static files from.
Source code in
starlette/staticfiles.py
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
def
get_directories
(
self
,
directory
:
PathLike
|
None
=
None
,
packages
:
list
[
str
|
tuple
[
str
,
str
]]
|
None
=
None
,
)
->
list
[
PathLike
]:
"""
Given `directory` and `packages` arguments, return a list of all the
directories that should be used for serving static files from.
"""
directories
=
[]
if
directory
is
not
None
:
directories
.
append
(
directory
)
for
package
in
packages
or
[]:
if
isinstance
(
package
,
tuple
):
package
,
statics_dir
=
package
else
:
statics_dir
=
"statics"
spec
=
importlib
.
util
.
find_spec
(
package
)
assert
spec
is
not
None
,
f
"Package
{
package
!r}
could not be found."
assert
spec
.
origin
is
not
None
,
f
"Package
{
package
!r}
could not be found."
package_directory
=
os
.
path
.
normpath
(
os
.
path
.
join
(
spec
.
origin
,
".."
,
statics_dir
))
assert
os
.
path
.
isdir
(
package_directory
),
(
f
"Directory '
{
statics_dir
!r}
' in package
{
package
!r}
could not be found."
)
directories
.
append
(
package_directory
)
return
directories
get_path
get_path
(
scope
)
Given the ASGI scope, return the
path
string to serve up,
with OS specific path separators, and any '..', '.' components removed.
Source code in
starlette/staticfiles.py
101
102
103
104
105
106
107
def
get_path
(
self
,
scope
:
Scope
)
->
str
:
"""
Given the ASGI scope, return the `path` string to serve up,
with OS specific path separators, and any '..', '.' components removed.
"""
route_path
=
get_route_path
(
scope
)
return
os
.
path
.
normpath
(
os
.
path
.
join
(
*
route_path
.
split
(
"/"
)))
get_response
async
get_response
(
path
,
scope
)
Returns an HTTP response, given the incoming path, method and request headers.
Source code in
starlette/staticfiles.py
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
async
def
get_response
(
self
,
path
:
str
,
scope
:
Scope
)
->
Response
:
"""
Returns an HTTP response, given the incoming path, method and request headers.
"""
if
scope
[
"method"
]
not
in
(
"GET"
,
"HEAD"
):
raise
HTTPException
(
status_code
=
405
)
try
:
full_path
,
stat_result
=
await
anyio
.
to_thread
.
run_sync
(
self
.
lookup_path
,
path
)
except
PermissionError
:
raise
HTTPException
(
status_code
=
401
)
except
OSError
as
exc
:
## Filename is too long, so it can't be a valid static file.
if
exc
.
errno
==
errno
.
ENAMETOOLONG
:
raise
HTTPException
(
status_code
=
404
)
raise
exc
if
stat_result
and
stat
.
S_ISREG
(
stat_result
.
st_mode
):
## We have a static file to serve.
return
self
.
file_response
(
full_path
,
stat_result
,
scope
)
elif
stat_result
and
stat
.
S_ISDIR
(
stat_result
.
st_mode
)
and
self
.
html
:
## We're in HTML mode, and have got a directory URL.
## Check if we have 'index.html' file to serve.
index_path
=
os
.
path
.
join
(
path
,
"index.html"
)
full_path
,
stat_result
=
await
anyio
.
to_thread
.
run_sync
(
self
.
lookup_path
,
index_path
)
if
stat_result
is
not
None
and
stat
.
S_ISREG
(
stat_result
.
st_mode
):
if
not
scope
[
"path"
]
.
endswith
(
"/"
):
## Directory URLs should redirect to always end in "/".
url
=
URL
(
scope
=
scope
)
url
=
url
.
replace
(
path
=
url
.
path
+
"/"
)
return
RedirectResponse
(
url
=
url
)
return
self
.
file_response
(
full_path
,
stat_result
,
scope
)
if
self
.
html
:
## Check for '404.html' if we're in HTML mode.
full_path
,
stat_result
=
await
anyio
.
to_thread
.
run_sync
(
self
.
lookup_path
,
"404.html"
)
if
stat_result
and
stat
.
S_ISREG
(
stat_result
.
st_mode
):
return
FileResponse
(
full_path
,
stat_result
=
stat_result
,
status_code
=
404
)
raise
HTTPException
(
status_code
=
404
)
lookup_path
lookup_path
(
path
)
Source code in
starlette/staticfiles.py
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
def
lookup_path
(
self
,
path
:
str
)
->
tuple
[
str
,
os
.
stat_result
|
None
]:
for
directory
in
self
.
all_directories
:
joined_path
=
os
.
path
.
join
(
directory
,
path
)
if
self
.
follow_symlink
:
full_path
=
os
.
path
.
abspath
(
joined_path
)
directory
=
os
.
path
.
abspath
(
directory
)
else
:
full_path
=
os
.
path
.
realpath
(
joined_path
)
directory
=
os
.
path
.
realpath
(
directory
)
if
os
.
path
.
commonpath
([
full_path
,
directory
])
!=
str
(
directory
):
## Don't allow misbehaving clients to break out of the static files directory.
continue
try
:
return
full_path
,
os
.
stat
(
full_path
)
except
(
FileNotFoundError
,
NotADirectoryError
):
continue
return
""
,
None
file_response
file_response
(
full_path
,
stat_result
,
scope
,
status_code
=
200
)
Source code in
starlette/staticfiles.py
169
170
171
172
173
174
175
176
177
178
179
180
181
def
file_response
(
self
,
full_path
:
PathLike
,
stat_result
:
os
.
stat_result
,
scope
:
Scope
,
status_code
:
int
=
200
,
)
->
Response
:
request_headers
=
Headers
(
scope
=
scope
)
response
=
FileResponse
(
full_path
,
status_code
=
status_code
,
stat_result
=
stat_result
)
if
self
.
is_not_modified
(
response
.
headers
,
request_headers
):
return
NotModifiedResponse
(
response
.
headers
)
return
response
check_config
async
check_config
()
Perform a one-off configuration check that StaticFiles is actually
pointed at a directory, so that we can raise loud errors rather than
just returning 404 responses.
Source code in
starlette/staticfiles.py
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
async
def
check_config
(
self
)
->
None
:
"""
Perform a one-off configuration check that StaticFiles is actually
pointed at a directory, so that we can raise loud errors rather than
just returning 404 responses.
"""
if
self
.
directory
is
None
:
return
try
:
stat_result
=
await
anyio
.
to_thread
.
run_sync
(
os
.
stat
,
self
.
directory
)
except
FileNotFoundError
:
raise
RuntimeError
(
f
"StaticFiles directory '
{
self
.
directory
}
' does not exist."
)
if
not
(
stat
.
S_ISDIR
(
stat_result
.
st_mode
)
or
stat
.
S_ISLNK
(
stat_result
.
st_mode
)):
raise
RuntimeError
(
f
"StaticFiles path '
{
self
.
directory
}
' is not a directory."
)
is_not_modified
is_not_modified
(
response_headers
,
request_headers
)
Given the request and response headers, return
True
if an HTTP
"Not Modified" response could be returned instead.
Source code in
starlette/staticfiles.py
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
def
is_not_modified
(
self
,
response_headers
:
Headers
,
request_headers
:
Headers
)
->
bool
:
"""
Given the request and response headers, return `True` if an HTTP
"Not Modified" response could be returned instead.
"""
try
:
if_none_match
=
request_headers
[
"if-none-match"
]
etag
=
response_headers
[
"etag"
]
if
etag
in
[
tag
.
strip
(
" W/"
)
for
tag
in
if_none_match
.
split
(
","
)]:
return
True
except
KeyError
:
pass
try
:
if_modified_since
=
parsedate
(
request_headers
[
"if-modified-since"
])
last_modified
=
parsedate
(
response_headers
[
"last-modified"
])
if
if_modified_since
is
not
None
and
last_modified
is
not
None
and
if_modified_since
>=
last_modified
:
return
True
except
KeyError
:
pass
return
False

## 100_REFERENCE_STATUS
Status Codes¶
---

Status Codes
You can import the
status
module from
fastapi
:
from
fastapi
import
status
status
is provided directly by Starlette.
It contains a group of named constants (variables) with integer status codes.
For example:
200:
status.HTTP_200_OK
403:
status.HTTP_403_FORBIDDEN
etc.
It can be convenient to quickly access HTTP (and WebSocket) status codes in your app, using autocompletion for the name without having to remember the integer status codes by memory.
Read more about it in the
FastAPI docs about Response Status Code
.
Example
from
fastapi
import
FastAPI
,
status
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
status_code
=
status
.
HTTP_418_IM_A_TEAPOT
)
def
read_items
():
return
[{
"name"
:
"Plumbus"
},
{
"name"
:
"Portal Gun"
}]
fastapi.status
HTTP codes
See HTTP Status Code Registry:
https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
And RFC 2324 - https://tools.ietf.org/html/rfc2324
HTTP_100_CONTINUE
module-attribute
HTTP_100_CONTINUE
=
100
HTTP_101_SWITCHING_PROTOCOLS
module-attribute
HTTP_101_SWITCHING_PROTOCOLS
=
101
HTTP_102_PROCESSING
module-attribute
HTTP_102_PROCESSING
=
102
HTTP_103_EARLY_HINTS
module-attribute
HTTP_103_EARLY_HINTS
=
103
HTTP_200_OK
module-attribute
HTTP_200_OK
=
200
HTTP_201_CREATED
module-attribute
HTTP_201_CREATED
=
201
HTTP_202_ACCEPTED
module-attribute
HTTP_202_ACCEPTED
=
202
HTTP_203_NON_AUTHORITATIVE_INFORMATION
module-attribute
HTTP_203_NON_AUTHORITATIVE_INFORMATION
=
203
HTTP_204_NO_CONTENT
module-attribute
HTTP_204_NO_CONTENT
=
204
HTTP_205_RESET_CONTENT
module-attribute
HTTP_205_RESET_CONTENT
=
205
HTTP_206_PARTIAL_CONTENT
module-attribute
HTTP_206_PARTIAL_CONTENT
=
206
HTTP_207_MULTI_STATUS
module-attribute
HTTP_207_MULTI_STATUS
=
207
HTTP_208_ALREADY_REPORTED
module-attribute
HTTP_208_ALREADY_REPORTED
=
208
HTTP_226_IM_USED
module-attribute
HTTP_226_IM_USED
=
226
HTTP_300_MULTIPLE_CHOICES
module-attribute
HTTP_300_MULTIPLE_CHOICES
=
300
HTTP_301_MOVED_PERMANENTLY
module-attribute
HTTP_301_MOVED_PERMANENTLY
=
301
HTTP_302_FOUND
module-attribute
HTTP_302_FOUND
=
302
HTTP_303_SEE_OTHER
module-attribute
HTTP_303_SEE_OTHER
=
303
HTTP_304_NOT_MODIFIED
module-attribute
HTTP_304_NOT_MODIFIED
=
304
HTTP_305_USE_PROXY
module-attribute
HTTP_305_USE_PROXY
=
305
HTTP_306_RESERVED
module-attribute
HTTP_306_RESERVED
=
306
HTTP_307_TEMPORARY_REDIRECT
module-attribute
HTTP_307_TEMPORARY_REDIRECT
=
307
HTTP_308_PERMANENT_REDIRECT
module-attribute
HTTP_308_PERMANENT_REDIRECT
=
308
HTTP_400_BAD_REQUEST
module-attribute
HTTP_400_BAD_REQUEST
=
400
HTTP_401_UNAUTHORIZED
module-attribute
HTTP_401_UNAUTHORIZED
=
401
HTTP_402_PAYMENT_REQUIRED
module-attribute
HTTP_402_PAYMENT_REQUIRED
=
402
HTTP_403_FORBIDDEN
module-attribute
HTTP_403_FORBIDDEN
=
403
HTTP_404_NOT_FOUND
module-attribute
HTTP_404_NOT_FOUND
=
404
HTTP_405_METHOD_NOT_ALLOWED
module-attribute
HTTP_405_METHOD_NOT_ALLOWED
=
405
HTTP_406_NOT_ACCEPTABLE
module-attribute
HTTP_406_NOT_ACCEPTABLE
=
406
HTTP_407_PROXY_AUTHENTICATION_REQUIRED
module-attribute
HTTP_407_PROXY_AUTHENTICATION_REQUIRED
=
407
HTTP_408_REQUEST_TIMEOUT
module-attribute
HTTP_408_REQUEST_TIMEOUT
=
408
HTTP_409_CONFLICT
module-attribute
HTTP_409_CONFLICT
=
409
HTTP_410_GONE
module-attribute
HTTP_410_GONE
=
410
HTTP_411_LENGTH_REQUIRED
module-attribute
HTTP_411_LENGTH_REQUIRED
=
411
HTTP_412_PRECONDITION_FAILED
module-attribute
HTTP_412_PRECONDITION_FAILED
=
412
HTTP_413_REQUEST_ENTITY_TOO_LARGE
module-attribute
HTTP_413_REQUEST_ENTITY_TOO_LARGE
=
413
HTTP_414_REQUEST_URI_TOO_LONG
module-attribute
HTTP_414_REQUEST_URI_TOO_LONG
=
414
HTTP_415_UNSUPPORTED_MEDIA_TYPE
module-attribute
HTTP_415_UNSUPPORTED_MEDIA_TYPE
=
415
HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE
module-attribute
HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE
=
416
HTTP_417_EXPECTATION_FAILED
module-attribute
HTTP_417_EXPECTATION_FAILED
=
417
HTTP_418_IM_A_TEAPOT
module-attribute
HTTP_418_IM_A_TEAPOT
=
418
HTTP_421_MISDIRECTED_REQUEST
module-attribute
HTTP_421_MISDIRECTED_REQUEST
=
421
HTTP_422_UNPROCESSABLE_ENTITY
module-attribute
HTTP_422_UNPROCESSABLE_ENTITY
=
422
HTTP_423_LOCKED
module-attribute
HTTP_423_LOCKED
=
423
HTTP_424_FAILED_DEPENDENCY
module-attribute
HTTP_424_FAILED_DEPENDENCY
=
424
HTTP_425_TOO_EARLY
module-attribute
HTTP_425_TOO_EARLY
=
425
HTTP_426_UPGRADE_REQUIRED
module-attribute
HTTP_426_UPGRADE_REQUIRED
=
426
HTTP_428_PRECONDITION_REQUIRED
module-attribute
HTTP_428_PRECONDITION_REQUIRED
=
428
HTTP_429_TOO_MANY_REQUESTS
module-attribute
HTTP_429_TOO_MANY_REQUESTS
=
429
HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE
module-attribute
HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE
=
431
HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS
module-attribute
HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS
=
451
HTTP_500_INTERNAL_SERVER_ERROR
module-attribute
HTTP_500_INTERNAL_SERVER_ERROR
=
500
HTTP_501_NOT_IMPLEMENTED
module-attribute
HTTP_501_NOT_IMPLEMENTED
=
501
HTTP_502_BAD_GATEWAY
module-attribute
HTTP_502_BAD_GATEWAY
=
502
HTTP_503_SERVICE_UNAVAILABLE
module-attribute
HTTP_503_SERVICE_UNAVAILABLE
=
503
HTTP_504_GATEWAY_TIMEOUT
module-attribute
HTTP_504_GATEWAY_TIMEOUT
=
504
HTTP_505_HTTP_VERSION_NOT_SUPPORTED
module-attribute
HTTP_505_HTTP_VERSION_NOT_SUPPORTED
=
505
HTTP_506_VARIANT_ALSO_NEGOTIATES
module-attribute
HTTP_506_VARIANT_ALSO_NEGOTIATES
=
506
HTTP_507_INSUFFICIENT_STORAGE
module-attribute
HTTP_507_INSUFFICIENT_STORAGE
=
507
HTTP_508_LOOP_DETECTED
module-attribute
HTTP_508_LOOP_DETECTED
=
508
HTTP_510_NOT_EXTENDED
module-attribute
HTTP_510_NOT_EXTENDED
=
510
HTTP_511_NETWORK_AUTHENTICATION_REQUIRED
module-attribute
HTTP_511_NETWORK_AUTHENTICATION_REQUIRED
=
511
WebSocket codes
https://www.iana.org/assignments/websocket/websocket.xml#close-code-number
https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
WS_1000_NORMAL_CLOSURE
module-attribute
WS_1000_NORMAL_CLOSURE
=
1000
WS_1001_GOING_AWAY
module-attribute
WS_1001_GOING_AWAY
=
1001
WS_1002_PROTOCOL_ERROR
module-attribute
WS_1002_PROTOCOL_ERROR
=
1002
WS_1003_UNSUPPORTED_DATA
module-attribute
WS_1003_UNSUPPORTED_DATA
=
1003
WS_1005_NO_STATUS_RCVD
module-attribute
WS_1005_NO_STATUS_RCVD
=
1005
WS_1006_ABNORMAL_CLOSURE
module-attribute
WS_1006_ABNORMAL_CLOSURE
=
1006
WS_1007_INVALID_FRAME_PAYLOAD_DATA
module-attribute
WS_1007_INVALID_FRAME_PAYLOAD_DATA
=
1007
WS_1008_POLICY_VIOLATION
module-attribute
WS_1008_POLICY_VIOLATION
=
1008
WS_1009_MESSAGE_TOO_BIG
module-attribute
WS_1009_MESSAGE_TOO_BIG
=
1009
WS_1010_MANDATORY_EXT
module-attribute
WS_1010_MANDATORY_EXT
=
1010
WS_1011_INTERNAL_ERROR
module-attribute
WS_1011_INTERNAL_ERROR
=
1011
WS_1012_SERVICE_RESTART
module-attribute
WS_1012_SERVICE_RESTART
=
1012
WS_1013_TRY_AGAIN_LATER
module-attribute
WS_1013_TRY_AGAIN_LATER
=
1013
WS_1014_BAD_GATEWAY
module-attribute
WS_1014_BAD_GATEWAY
=
1014
WS_1015_TLS_HANDSHAKE
module-attribute
WS_1015_TLS_HANDSHAKE
=
1015

## 101_REFERENCE_TEMPLATING
Templating -Jinja2Templates¶
---

Templating -
Jinja2Templates
You can use the
Jinja2Templates
class to render Jinja templates.
Read more about it in the
FastAPI docs for Templates
.
You can import it directly from
fastapi.templating
:
from
fastapi.templating
import
Jinja2Templates
fastapi.templating.Jinja2Templates
Jinja2Templates
(
directory
:
(
str
|
PathLike
[
str
]
|
Sequence
[
str
|
PathLike
[
str
]]
),
*
,
context_processors
:
(
list
[
Callable
[[
Request
],
dict
[
str
,
Any
]]]
|
None
)
=
None
,
**
env_options
:
Any
)
Jinja2Templates
(
*
,
env
:
Environment
,
context_processors
:
(
list
[
Callable
[[
Request
],
dict
[
str
,
Any
]]]
|
None
)
=
None
)
Jinja2Templates
(
directory
=
None
,
*
,
context_processors
=
None
,
env
=
None
,
**
env_options
)
templates = Jinja2Templates("templates")
return templates.TemplateResponse("index.html", {"request": request})
Source code in
starlette/templating.py
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
def
__init__
(
self
,
directory
:
str
|
PathLike
[
str
]
|
typing
.
Sequence
[
str
|
PathLike
[
str
]]
|
None
=
None
,
*
,
context_processors
:
list
[
typing
.
Callable
[[
Request
],
dict
[
str
,
typing
.
Any
]]]
|
None
=
None
,
env
:
jinja2
.
Environment
|
None
=
None
,
**
env_options
:
typing
.
Any
,
)
->
None
:
if
env_options
:
warnings
.
warn
(
"Extra environment options are deprecated. Use a preconfigured jinja2.Environment instead."
,
DeprecationWarning
,
)
assert
jinja2
is
not
None
,
"jinja2 must be installed to use Jinja2Templates"
assert
bool
(
directory
)
^
bool
(
env
),
"either 'directory' or 'env' arguments must be passed"
self
.
context_processors
=
context_processors
or
[]
if
directory
is
not
None
:
self
.
env
=
self
.
_create_env
(
directory
,
**
env_options
)
elif
env
is
not
None
:
## pragma: no branch
self
.
env
=
env
self
.
_setup_env_defaults
(
self
.
env
)
context_processors
instance-attribute
context_processors
=
context_processors
or
[]
env
instance-attribute
env
=
_create_env
(
directory
,
**
env_options
)
get_template
get_template
(
name
)
Source code in
starlette/templating.py
130
131
def
get_template
(
self
,
name
:
str
)
->
jinja2
.
Template
:
return
self
.
env
.
get_template
(
name
)
TemplateResponse
TemplateResponse
(
request
:
Request
,
name
:
str
,
context
:
dict
[
str
,
Any
]
|
None
=
None
,
status_code
:
int
=
200
,
headers
:
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
_TemplateResponse
TemplateResponse
(
name
:
str
,
context
:
dict
[
str
,
Any
]
|
None
=
None
,
status_code
:
int
=
200
,
headers
:
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
_TemplateResponse
TemplateResponse
(
*
args
,
**
kwargs
)
Source code in
starlette/templating.py
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
def
TemplateResponse
(
self
,
*
args
:
typing
.
Any
,
**
kwargs
:
typing
.
Any
)
->
_TemplateResponse
:
if
args
:
if
isinstance
(
args
[
0
],
str
):
## the first argument is template name (old style)
warnings
.
warn
(
"The `name` is not the first parameter anymore. "
"The first parameter should be the `Request` instance.
\n
"
'Replace `TemplateResponse(name, {"request": request})` by `TemplateResponse(request, name)`.'
,
DeprecationWarning
,
)
name
=
args
[
0
]
context
=
args
[
1
]
if
len
(
args
)
>
1
else
kwargs
.
get
(
"context"
,
{})
status_code
=
args
[
2
]
if
len
(
args
)
>
2
else
kwargs
.
get
(
"status_code"
,
200
)
headers
=
args
[
3
]
if
len
(
args
)
>
3
else
kwargs
.
get
(
"headers"
)
media_type
=
args
[
4
]
if
len
(
args
)
>
4
else
kwargs
.
get
(
"media_type"
)
background
=
args
[
5
]
if
len
(
args
)
>
5
else
kwargs
.
get
(
"background"
)
if
"request"
not
in
context
:
raise
ValueError
(
'context must include a "request" key'
)
request
=
context
[
"request"
]
else
:
## the first argument is a request instance (new style)
request
=
args
[
0
]
name
=
args
[
1
]
if
len
(
args
)
>
1
else
kwargs
[
"name"
]
context
=
args
[
2
]
if
len
(
args
)
>
2
else
kwargs
.
get
(
"context"
,
{})
status_code
=
args
[
3
]
if
len
(
args
)
>
3
else
kwargs
.
get
(
"status_code"
,
200
)
headers
=
args
[
4
]
if
len
(
args
)
>
4
else
kwargs
.
get
(
"headers"
)
media_type
=
args
[
5
]
if
len
(
args
)
>
5
else
kwargs
.
get
(
"media_type"
)
background
=
args
[
6
]
if
len
(
args
)
>
6
else
kwargs
.
get
(
"background"
)
else
:
## all arguments are kwargs
if
"request"
not
in
kwargs
:
warnings
.
warn
(
"The `TemplateResponse` now requires the `request` argument.
\n
"
'Replace `TemplateResponse(name, {"context": context})` by `TemplateResponse(request, name)`.'
,
DeprecationWarning
,
)
if
"request"
not
in
kwargs
.
get
(
"context"
,
{}):
raise
ValueError
(
'context must include a "request" key'
)
context
=
kwargs
.
get
(
"context"
,
{})
request
=
kwargs
.
get
(
"request"
,
context
.
get
(
"request"
))
name
=
typing
.
cast
(
str
,
kwargs
[
"name"
])
status_code
=
kwargs
.
get
(
"status_code"
,
200
)
headers
=
kwargs
.
get
(
"headers"
)
media_type
=
kwargs
.
get
(
"media_type"
)
background
=
kwargs
.
get
(
"background"
)
context
.
setdefault
(
"request"
,
request
)
for
context_processor
in
self
.
context_processors
:
context
.
update
(
context_processor
(
request
))
template
=
self
.
get_template
(
name
)
return
_TemplateResponse
(
template
,
context
,
status_code
=
status_code
,
headers
=
headers
,
media_type
=
media_type
,
background
=
background
,
)

## 102_REFERENCE_TESTCLIENT
Test Client -TestClient¶
---

Test Client -
TestClient
You can use the
TestClient
class to test FastAPI applications without creating an actual HTTP and socket connection, just communicating directly with the FastAPI code.
Read more about it in the
FastAPI docs for Testing
.
You can import it directly from
fastapi.testclient
:
from
fastapi.testclient
import
TestClient
fastapi.testclient.TestClient
TestClient
(
app
,
base_url
=
"http://testserver"
,
raise_server_exceptions
=
True
,
root_path
=
""
,
backend
=
"asyncio"
,
backend_options
=
None
,
cookies
=
None
,
headers
=
None
,
follow_redirects
=
True
,
client
=
(
"testclient"
,
50000
),
)
Bases:
Client
Source code in
starlette/testclient.py
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
def
__init__
(
self
,
app
:
ASGIApp
,
base_url
:
str
=
"http://testserver"
,
raise_server_exceptions
:
bool
=
True
,
root_path
:
str
=
""
,
backend
:
typing
.
Literal
[
"asyncio"
,
"trio"
]
=
"asyncio"
,
backend_options
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
headers
:
dict
[
str
,
str
]
|
None
=
None
,
follow_redirects
:
bool
=
True
,
client
:
tuple
[
str
,
int
]
=
(
"testclient"
,
50000
),
)
->
None
:
self
.
async_backend
=
_AsyncBackend
(
backend
=
backend
,
backend_options
=
backend_options
or
{})
if
_is_asgi3
(
app
):
asgi_app
=
app
else
:
app
=
typing
.
cast
(
ASGI2App
,
app
)
## type: ignore[assignment]
asgi_app
=
_WrapASGI2
(
app
)
## type: ignore[arg-type]
self
.
app
=
asgi_app
self
.
app_state
:
dict
[
str
,
typing
.
Any
]
=
{}
transport
=
_TestClientTransport
(
self
.
app
,
portal_factory
=
self
.
_portal_factory
,
raise_server_exceptions
=
raise_server_exceptions
,
root_path
=
root_path
,
app_state
=
self
.
app_state
,
client
=
client
,
)
if
headers
is
None
:
headers
=
{}
headers
.
setdefault
(
"user-agent"
,
"testclient"
)
super
()
.
__init__
(
base_url
=
base_url
,
headers
=
headers
,
transport
=
transport
,
follow_redirects
=
follow_redirects
,
cookies
=
cookies
,
)
headers
property
writable
headers
HTTP headers to include when sending requests.
follow_redirects
instance-attribute
follow_redirects
=
follow_redirects
max_redirects
instance-attribute
max_redirects
=
max_redirects
is_closed
property
is_closed
Check if the client being closed
trust_env
property
trust_env
timeout
property
writable
timeout
event_hooks
property
writable
event_hooks
auth
property
writable
auth
Authentication class used when none is passed at the request-level.
See also
Authentication
.
base_url
property
writable
base_url
Base URL to use when sending requests with relative URLs.
cookies
property
writable
cookies
Cookie values to include when sending requests.
params
property
writable
params
Query parameters to include in the URL when sending requests.
task
instance-attribute
task
portal
class-attribute
instance-attribute
portal
=
None
async_backend
instance-attribute
async_backend
=
_AsyncBackend
(
backend
=
backend
,
backend_options
=
backend_options
or
{}
)
app
instance-attribute
app
=
asgi_app
app_state
instance-attribute
app_state
=
{}
build_request
build_request
(
method
,
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Build and return a request instance.
The
params
,
headers
and
cookies
arguments
are merged with any values set on the client.
The
url
argument is merged with any
base_url
set on the client.
See also:
Request instances
Source code in
httpx/_client.py
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
def
build_request
(
self
,
method
:
str
,
url
:
URL
|
str
,
*
,
content
:
RequestContent
|
None
=
None
,
data
:
RequestData
|
None
=
None
,
files
:
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
|
None
=
None
,
params
:
QueryParamTypes
|
None
=
None
,
headers
:
HeaderTypes
|
None
=
None
,
cookies
:
CookieTypes
|
None
=
None
,
timeout
:
TimeoutTypes
|
UseClientDefault
=
USE_CLIENT_DEFAULT
,
extensions
:
RequestExtensions
|
None
=
None
,
)
->
Request
:
"""
Build and return a request instance.
* The `params`, `headers` and `cookies` arguments
are merged with any values set on the client.
* The `url` argument is merged with any `base_url` set on the client.
See also: [Request instances][0]
[0]: /advanced/clients/#request-instances
"""
url
=
self
.
_merge_url
(
url
)
headers
=
self
.
_merge_headers
(
headers
)
cookies
=
self
.
_merge_cookies
(
cookies
)
params
=
self
.
_merge_queryparams
(
params
)
extensions
=
{}
if
extensions
is
None
else
extensions
if
"timeout"
not
in
extensions
:
timeout
=
(
self
.
timeout
if
isinstance
(
timeout
,
UseClientDefault
)
else
Timeout
(
timeout
)
)
extensions
=
dict
(
**
extensions
,
timeout
=
timeout
.
as_dict
())
return
Request
(
method
,
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
extensions
=
extensions
,
)
stream
stream
(
method
,
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Alternative to
httpx.request()
that streams the response body
instead of loading it into memory at once.
Parameters
: See
httpx.request
.
See also:
Streaming Responses
Source code in
httpx/_client.py
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
@contextmanager
def
stream
(
self
,
method
:
str
,
url
:
URL
|
str
,
*
,
content
:
RequestContent
|
None
=
None
,
data
:
RequestData
|
None
=
None
,
files
:
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
|
None
=
None
,
params
:
QueryParamTypes
|
None
=
None
,
headers
:
HeaderTypes
|
None
=
None
,
cookies
:
CookieTypes
|
None
=
None
,
auth
:
AuthTypes
|
UseClientDefault
|
None
=
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
UseClientDefault
=
USE_CLIENT_DEFAULT
,
timeout
:
TimeoutTypes
|
UseClientDefault
=
USE_CLIENT_DEFAULT
,
extensions
:
RequestExtensions
|
None
=
None
,
)
->
typing
.
Iterator
[
Response
]:
"""
Alternative to `httpx.request()` that streams the response body
instead of loading it into memory at once.
**Parameters**: See `httpx.request`.
See also: [Streaming Responses][0]
[0]: /quickstart#streaming-responses
"""
request
=
self
.
build_request
(
method
=
method
,
url
=
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
timeout
=
timeout
,
extensions
=
extensions
,
)
response
=
self
.
send
(
request
=
request
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
stream
=
True
,
)
try
:
yield
response
finally
:
response
.
close
()
send
send
(
request
,
*
,
stream
=
False
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
)
Send a request.
The request is sent as-is, unmodified.
Typically you'll want to build one with
Client.build_request()
so that any client-level configuration is merged into the request,
but passing an explicit
httpx.Request()
is supported as well.
See also:
Request instances
Source code in
httpx/_client.py
891
892
893
894
895
896
897
898
899
900
901
902
903
904
905
906
907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924
925
926
927
928
929
930
931
932
933
934
935
936
937
938
939
940
def
send
(
self
,
request
:
Request
,
*
,
stream
:
bool
=
False
,
auth
:
AuthTypes
|
UseClientDefault
|
None
=
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
UseClientDefault
=
USE_CLIENT_DEFAULT
,
)
->
Response
:
"""
Send a request.
The request is sent as-is, unmodified.
Typically you'll want to build one with `Client.build_request()`
so that any client-level configuration is merged into the request,
but passing an explicit `httpx.Request()` is supported as well.
See also: [Request instances][0]
[0]: /advanced/clients/#request-instances
"""
if
self
.
_state
==
ClientState
.
CLOSED
:
raise
RuntimeError
(
"Cannot send a request, as the client has been closed."
)
self
.
_state
=
ClientState
.
OPENED
follow_redirects
=
(
self
.
follow_redirects
if
isinstance
(
follow_redirects
,
UseClientDefault
)
else
follow_redirects
)
self
.
_set_timeout
(
request
)
auth
=
self
.
_build_request_auth
(
request
,
auth
)
response
=
self
.
_send_handling_auth
(
request
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
history
=
[],
)
try
:
if
not
stream
:
response
.
read
()
return
response
except
BaseException
as
exc
:
response
.
close
()
raise
exc
close
close
()
Close transport and proxies.
Source code in
httpx/_client.py
1276
1277
1278
1279
1280
1281
1282
1283
1284
1285
1286
def
close
(
self
)
->
None
:
"""
Close transport and proxies.
"""
if
self
.
_state
!=
ClientState
.
CLOSED
:
self
.
_state
=
ClientState
.
CLOSED
self
.
_transport
.
close
()
for
transport
in
self
.
_mounts
.
values
():
if
transport
is
not
None
:
transport
.
close
()
request
request
(
method
,
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
def
request
(
## type: ignore[override]
self
,
method
:
str
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
content
:
httpx
.
_types
.
RequestContent
|
None
=
None
,
data
:
_RequestData
|
None
=
None
,
files
:
httpx
.
_types
.
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
=
None
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
if
timeout
is
not
httpx
.
USE_CLIENT_DEFAULT
:
warnings
.
warn
(
"You should not use the 'timeout' argument with the TestClient. "
"See https://github.com/encode/starlette/issues/1108 for more information."
,
DeprecationWarning
,
)
url
=
self
.
_merge_url
(
url
)
return
super
()
.
request
(
method
,
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
get
get
(
url
,
*
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
def
get
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
get
(
url
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
options
options
(
url
,
*
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
def
options
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
options
(
url
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
head
head
(
url
,
*
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
def
head
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
head
(
url
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
post
post
(
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
def
post
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
content
:
httpx
.
_types
.
RequestContent
|
None
=
None
,
data
:
_RequestData
|
None
=
None
,
files
:
httpx
.
_types
.
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
=
None
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
post
(
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
put
put
(
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
def
put
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
content
:
httpx
.
_types
.
RequestContent
|
None
=
None
,
data
:
_RequestData
|
None
=
None
,
files
:
httpx
.
_types
.
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
=
None
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
put
(
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
patch
patch
(
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
def
patch
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
content
:
httpx
.
_types
.
RequestContent
|
None
=
None
,
data
:
_RequestData
|
None
=
None
,
files
:
httpx
.
_types
.
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
=
None
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
patch
(
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
delete
delete
(
url
,
*
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
def
delete
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
delete
(
url
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
websocket_connect
websocket_connect
(
url
,
subprotocols
=
None
,
**
kwargs
)
Source code in
starlette/testclient.py
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
def
websocket_connect
(
self
,
url
:
str
,
subprotocols
:
typing
.
Sequence
[
str
]
|
None
=
None
,
**
kwargs
:
typing
.
Any
,
)
->
WebSocketTestSession
:
url
=
urljoin
(
"ws://testserver"
,
url
)
headers
=
kwargs
.
get
(
"headers"
,
{})
headers
.
setdefault
(
"connection"
,
"upgrade"
)
headers
.
setdefault
(
"sec-websocket-key"
,
"testserver=="
)
headers
.
setdefault
(
"sec-websocket-version"
,
"13"
)
if
subprotocols
is
not
None
:
headers
.
setdefault
(
"sec-websocket-protocol"
,
", "
.
join
(
subprotocols
))
kwargs
[
"headers"
]
=
headers
try
:
super
()
.
request
(
"GET"
,
url
,
**
kwargs
)
except
_Upgrade
as
exc
:
session
=
exc
.
session
else
:
raise
RuntimeError
(
"Expected WebSocket upgrade"
)
## pragma: no cover
return
session
lifespan
async
lifespan
()
Source code in
starlette/testclient.py
693
694
695
696
697
698
async
def
lifespan
(
self
)
->
None
:
scope
=
{
"type"
:
"lifespan"
,
"state"
:
self
.
app_state
}
try
:
await
self
.
app
(
scope
,
self
.
stream_receive
.
receive
,
self
.
stream_send
.
send
)
finally
:
await
self
.
stream_send
.
send
(
None
)
wait_startup
async
wait_startup
()
Source code in
starlette/testclient.py
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
async
def
wait_startup
(
self
)
->
None
:
await
self
.
stream_receive
.
send
({
"type"
:
"lifespan.startup"
})
async
def
receive
()
->
typing
.
Any
:
message
=
await
self
.
stream_send
.
receive
()
if
message
is
None
:
self
.
task
.
result
()
return
message
message
=
await
receive
()
assert
message
[
"type"
]
in
(
"lifespan.startup.complete"
,
"lifespan.startup.failed"
,
)
if
message
[
"type"
]
==
"lifespan.startup.failed"
:
await
receive
()
wait_shutdown
async
wait_shutdown
()
Source code in
starlette/testclient.py
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
async
def
wait_shutdown
(
self
)
->
None
:
async
def
receive
()
->
typing
.
Any
:
message
=
await
self
.
stream_send
.
receive
()
if
message
is
None
:
self
.
task
.
result
()
return
message
await
self
.
stream_receive
.
send
({
"type"
:
"lifespan.shutdown"
})
message
=
await
receive
()
assert
message
[
"type"
]
in
(
"lifespan.shutdown.complete"
,
"lifespan.shutdown.failed"
,
)
if
message
[
"type"
]
==
"lifespan.shutdown.failed"
:
await
receive
()

## 103_REFERENCE_UPLOADFILE
UploadFileclass¶
---

UploadFile
class
You can define
path operation function
parameters to be of the type
UploadFile
to receive files from the request.
You can import it directly from
fastapi
:
from
fastapi
import
UploadFile
fastapi.UploadFile
UploadFile
(
file
,
*
,
size
=
None
,
filename
=
None
,
headers
=
None
)
Bases:
UploadFile
A file uploaded in a request.
Define it as a
path operation function
(or dependency) parameter.
If you are using a regular
def
function, you can use the
upload_file.file
attribute to access the raw standard Python file (blocking, not async), useful and
needed for non-async code.
Read more about it in the
FastAPI docs for Request Files
.
Example
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Source code in
starlette/datastructures.py
414
415
416
417
418
419
420
421
422
423
424
425
def
__init__
(
self
,
file
:
typing
.
BinaryIO
,
*
,
size
:
int
|
None
=
None
,
filename
:
str
|
None
=
None
,
headers
:
Headers
|
None
=
None
,
)
->
None
:
self
.
filename
=
filename
self
.
file
=
file
self
.
size
=
size
self
.
headers
=
headers
or
Headers
()
file
instance-attribute
file
The standard Python file object (non-async).
filename
instance-attribute
filename
The original file name.
size
instance-attribute
size
The size of the file in bytes.
headers
instance-attribute
headers
The headers of the request.
content_type
instance-attribute
content_type
The content type of the request, from the headers.
read
async
read
(
size
=-
1
)
Read some bytes from the file.
To be awaitable, compatible with async, this is run in threadpool.
PARAMETER
DESCRIPTION
size
The number of bytes to read from the file.
TYPE:
int
DEFAULT:
-1
Source code in
fastapi/datastructures.py
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
async
def
read
(
self
,
size
:
Annotated
[
int
,
Doc
(
"""
The number of bytes to read from the file.
"""
),
]
=
-
1
,
)
->
bytes
:
"""
Read some bytes from the file.
To be awaitable, compatible with async, this is run in threadpool.
"""
return
await
super
()
.
read
(
size
)
write
async
write
(
data
)
Write some bytes to the file.
You normally wouldn't use this from a file you read in a request.
To be awaitable, compatible with async, this is run in threadpool.
PARAMETER
DESCRIPTION
data
The bytes to write to the file.
TYPE:
bytes
Source code in
fastapi/datastructures.py
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
async
def
write
(
self
,
data
:
Annotated
[
bytes
,
Doc
(
"""
The bytes to write to the file.
"""
),
],
)
->
None
:
"""
Write some bytes to the file.
You normally wouldn't use this from a file you read in a request.
To be awaitable, compatible with async, this is run in threadpool.
"""
return
await
super
()
.
write
(
data
)
seek
async
seek
(
offset
)
Move to a position in the file.
Any next read or write will be done from that position.
To be awaitable, compatible with async, this is run in threadpool.
PARAMETER
DESCRIPTION
offset
The position in bytes to seek to in the file.
TYPE:
int
Source code in
fastapi/datastructures.py
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
async
def
seek
(
self
,
offset
:
Annotated
[
int
,
Doc
(
"""
The position in bytes to seek to in the file.
"""
),
],
)
->
None
:
"""
Move to a position in the file.
Any next read or write will be done from that position.
To be awaitable, compatible with async, this is run in threadpool.
"""
return
await
super
()
.
seek
(
offset
)
close
async
close
()
Close the file.
To be awaitable, compatible with async, this is run in threadpool.
Source code in
fastapi/datastructures.py
133
134
135
136
137
138
139
async
def
close
(
self
)
->
None
:
"""
Close the file.
To be awaitable, compatible with async, this is run in threadpool.
"""
return
await
super
()
.
close
()

## 104_REFERENCE_WEBSOCKETS
WebSockets¶
---

WebSockets
When defining WebSockets, you normally declare a parameter of type
WebSocket
and with it you can read data from the client and send data to it.
It is provided directly by Starlette, but you can import it from
fastapi
:
from
fastapi
import
WebSocket
Tip
When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an
HTTPConnection
instead of a
Request
or a
WebSocket
.
fastapi.WebSocket
WebSocket
(
scope
,
receive
,
send
)
Bases:
HTTPConnection
Source code in
starlette/websockets.py
26
27
28
29
30
31
32
def
__init__
(
self
,
scope
:
Scope
,
receive
:
Receive
,
send
:
Send
)
->
None
:
super
()
.
__init__
(
scope
)
assert
scope
[
"type"
]
==
"websocket"
self
.
_receive
=
receive
self
.
_send
=
send
self
.
client_state
=
WebSocketState
.
CONNECTING
self
.
application_state
=
WebSocketState
.
CONNECTING
scope
instance-attribute
scope
=
scope
app
property
app
url
property
url
base_url
property
base_url
headers
property
headers
query_params
property
query_params
path_params
property
path_params
cookies
property
cookies
client
property
client
state
property
state
client_state
instance-attribute
client_state
=
CONNECTING
application_state
instance-attribute
application_state
=
CONNECTING
url_for
url_for
(
name
,
/
,
**
path_params
)
Source code in
starlette/requests.py
182
183
184
185
186
187
def
url_for
(
self
,
name
:
str
,
/
,
**
path_params
:
typing
.
Any
)
->
URL
:
url_path_provider
:
Router
|
Starlette
|
None
=
self
.
scope
.
get
(
"router"
)
or
self
.
scope
.
get
(
"app"
)
if
url_path_provider
is
None
:
raise
RuntimeError
(
"The `url_for` method can only be used inside a Starlette application or with a router."
)
url_path
=
url_path_provider
.
url_path_for
(
name
,
**
path_params
)
return
url_path
.
make_absolute_url
(
base_url
=
self
.
base_url
)
receive
async
receive
()
Receive ASGI websocket messages, ensuring valid state transitions.
Source code in
starlette/websockets.py
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
async
def
receive
(
self
)
->
Message
:
"""
Receive ASGI websocket messages, ensuring valid state transitions.
"""
if
self
.
client_state
==
WebSocketState
.
CONNECTING
:
message
=
await
self
.
_receive
()
message_type
=
message
[
"type"
]
if
message_type
!=
"websocket.connect"
:
raise
RuntimeError
(
f
'Expected ASGI message "websocket.connect", but got
{
message_type
!r}
'
)
self
.
client_state
=
WebSocketState
.
CONNECTED
return
message
elif
self
.
client_state
==
WebSocketState
.
CONNECTED
:
message
=
await
self
.
_receive
()
message_type
=
message
[
"type"
]
if
message_type
not
in
{
"websocket.receive"
,
"websocket.disconnect"
}:
raise
RuntimeError
(
f
'Expected ASGI message "websocket.receive" or "websocket.disconnect", but got
{
message_type
!r}
'
)
if
message_type
==
"websocket.disconnect"
:
self
.
client_state
=
WebSocketState
.
DISCONNECTED
return
message
else
:
raise
RuntimeError
(
'Cannot call "receive" once a disconnect message has been received.'
)
send
async
send
(
message
)
Send ASGI websocket messages, ensuring valid state transitions.
Source code in
starlette/websockets.py
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
async
def
send
(
self
,
message
:
Message
)
->
None
:
"""
Send ASGI websocket messages, ensuring valid state transitions.
"""
if
self
.
application_state
==
WebSocketState
.
CONNECTING
:
message_type
=
message
[
"type"
]
if
message_type
not
in
{
"websocket.accept"
,
"websocket.close"
,
"websocket.http.response.start"
}:
raise
RuntimeError
(
'Expected ASGI message "websocket.accept", "websocket.close" or "websocket.http.response.start", '
f
"but got
{
message_type
!r}
"
)
if
message_type
==
"websocket.close"
:
self
.
application_state
=
WebSocketState
.
DISCONNECTED
elif
message_type
==
"websocket.http.response.start"
:
self
.
application_state
=
WebSocketState
.
RESPONSE
else
:
self
.
application_state
=
WebSocketState
.
CONNECTED
await
self
.
_send
(
message
)
elif
self
.
application_state
==
WebSocketState
.
CONNECTED
:
message_type
=
message
[
"type"
]
if
message_type
not
in
{
"websocket.send"
,
"websocket.close"
}:
raise
RuntimeError
(
f
'Expected ASGI message "websocket.send" or "websocket.close", but got
{
message_type
!r}
'
)
if
message_type
==
"websocket.close"
:
self
.
application_state
=
WebSocketState
.
DISCONNECTED
try
:
await
self
.
_send
(
message
)
except
OSError
:
self
.
application_state
=
WebSocketState
.
DISCONNECTED
raise
WebSocketDisconnect
(
code
=
1006
)
elif
self
.
application_state
==
WebSocketState
.
RESPONSE
:
message_type
=
message
[
"type"
]
if
message_type
!=
"websocket.http.response.body"
:
raise
RuntimeError
(
f
'Expected ASGI message "websocket.http.response.body", but got
{
message_type
!r}
'
)
if
not
message
.
get
(
"more_body"
,
False
):
self
.
application_state
=
WebSocketState
.
DISCONNECTED
await
self
.
_send
(
message
)
else
:
raise
RuntimeError
(
'Cannot call "send" once a close message has been sent.'
)
accept
async
accept
(
subprotocol
=
None
,
headers
=
None
)
Source code in
starlette/websockets.py
99
100
101
102
103
104
105
106
107
108
109
async
def
accept
(
self
,
subprotocol
:
str
|
None
=
None
,
headers
:
typing
.
Iterable
[
tuple
[
bytes
,
bytes
]]
|
None
=
None
,
)
->
None
:
headers
=
headers
or
[]
if
self
.
client_state
==
WebSocketState
.
CONNECTING
:
## pragma: no branch
## If we haven't yet seen the 'connect' message, then wait for it first.
await
self
.
receive
()
await
self
.
send
({
"type"
:
"websocket.accept"
,
"subprotocol"
:
subprotocol
,
"headers"
:
headers
})
receive_text
async
receive_text
()
Source code in
starlette/websockets.py
115
116
117
118
119
120
async
def
receive_text
(
self
)
->
str
:
if
self
.
application_state
!=
WebSocketState
.
CONNECTED
:
raise
RuntimeError
(
'WebSocket is not connected. Need to call "accept" first.'
)
message
=
await
self
.
receive
()
self
.
_raise_on_disconnect
(
message
)
return
typing
.
cast
(
str
,
message
[
"text"
])
receive_bytes
async
receive_bytes
()
Source code in
starlette/websockets.py
122
123
124
125
126
127
async
def
receive_bytes
(
self
)
->
bytes
:
if
self
.
application_state
!=
WebSocketState
.
CONNECTED
:
raise
RuntimeError
(
'WebSocket is not connected. Need to call "accept" first.'
)
message
=
await
self
.
receive
()
self
.
_raise_on_disconnect
(
message
)
return
typing
.
cast
(
bytes
,
message
[
"bytes"
])
receive_json
async
receive_json
(
mode
=
'text'
)
Source code in
starlette/websockets.py
129
130
131
132
133
134
135
136
137
138
139
140
141
async
def
receive_json
(
self
,
mode
:
str
=
"text"
)
->
typing
.
Any
:
if
mode
not
in
{
"text"
,
"binary"
}:
raise
RuntimeError
(
'The "mode" argument should be "text" or "binary".'
)
if
self
.
application_state
!=
WebSocketState
.
CONNECTED
:
raise
RuntimeError
(
'WebSocket is not connected. Need to call "accept" first.'
)
message
=
await
self
.
receive
()
self
.
_raise_on_disconnect
(
message
)
if
mode
==
"text"
:
text
=
message
[
"text"
]
else
:
text
=
message
[
"bytes"
]
.
decode
(
"utf-8"
)
return
json
.
loads
(
text
)
iter_text
async
iter_text
()
Source code in
starlette/websockets.py
143
144
145
146
147
148
async
def
iter_text
(
self
)
->
typing
.
AsyncIterator
[
str
]:
try
:
while
True
:
yield
await
self
.
receive_text
()
except
WebSocketDisconnect
:
pass
iter_bytes
async
iter_bytes
()
Source code in
starlette/websockets.py
150
151
152
153
154
155
async
def
iter_bytes
(
self
)
->
typing
.
AsyncIterator
[
bytes
]:
try
:
while
True
:
yield
await
self
.
receive_bytes
()
except
WebSocketDisconnect
:
pass
iter_json
async
iter_json
()
Source code in
starlette/websockets.py
157
158
159
160
161
162
async
def
iter_json
(
self
)
->
typing
.
AsyncIterator
[
typing
.
Any
]:
try
:
while
True
:
yield
await
self
.
receive_json
()
except
WebSocketDisconnect
:
pass
send_text
async
send_text
(
data
)
Source code in
starlette/websockets.py
164
165
async
def
send_text
(
self
,
data
:
str
)
->
None
:
await
self
.
send
({
"type"
:
"websocket.send"
,
"text"
:
data
})
send_bytes
async
send_bytes
(
data
)
Source code in
starlette/websockets.py
167
168
async
def
send_bytes
(
self
,
data
:
bytes
)
->
None
:
await
self
.
send
({
"type"
:
"websocket.send"
,
"bytes"
:
data
})
send_json
async
send_json
(
data
,
mode
=
'text'
)
Source code in
starlette/websockets.py
170
171
172
173
174
175
176
177
async
def
send_json
(
self
,
data
:
typing
.
Any
,
mode
:
str
=
"text"
)
->
None
:
if
mode
not
in
{
"text"
,
"binary"
}:
raise
RuntimeError
(
'The "mode" argument should be "text" or "binary".'
)
text
=
json
.
dumps
(
data
,
separators
=
(
","
,
":"
),
ensure_ascii
=
False
)
if
mode
==
"text"
:
await
self
.
send
({
"type"
:
"websocket.send"
,
"text"
:
text
})
else
:
await
self
.
send
({
"type"
:
"websocket.send"
,
"bytes"
:
text
.
encode
(
"utf-8"
)})
close
async
close
(
code
=
1000
,
reason
=
None
)
Source code in
starlette/websockets.py
179
180
async
def
close
(
self
,
code
:
int
=
1000
,
reason
:
str
|
None
=
None
)
->
None
:
await
self
.
send
({
"type"
:
"websocket.close"
,
"code"
:
code
,
"reason"
:
reason
or
""
})
When a client disconnects, a
WebSocketDisconnect
exception is raised, you can catch it.
You can import it directly form
fastapi
:
from
fastapi
import
WebSocketDisconnect
fastapi.WebSocketDisconnect
WebSocketDisconnect
(
code
=
1000
,
reason
=
None
)
Bases:
Exception
Source code in
starlette/websockets.py
20
21
22
def
__init__
(
self
,
code
:
int
=
1000
,
reason
:
str
|
None
=
None
)
->
None
:
self
.
code
=
code
self
.
reason
=
reason
or
""
code
instance-attribute
code
=
code
reason
instance-attribute
reason
=
reason
or
''
WebSockets - additional classes
Additional classes for handling WebSockets.
Provided directly by Starlette, but you can import it from
fastapi
:
from
fastapi.websockets
import
WebSocketDisconnect
,
WebSocketState
fastapi.websockets.WebSocketDisconnect
WebSocketDisconnect
(
code
=
1000
,
reason
=
None
)
Bases:
Exception
Source code in
starlette/websockets.py
20
21
22
def
__init__
(
self
,
code
:
int
=
1000
,
reason
:
str
|
None
=
None
)
->
None
:
self
.
code
=
code
self
.
reason
=
reason
or
""
code
instance-attribute
code
=
code
reason
instance-attribute
reason
=
reason
or
''
fastapi.websockets.WebSocketState
Bases:
Enum
CONNECTING
class-attribute
instance-attribute
CONNECTING
=
0
CONNECTED
class-attribute
instance-attribute
CONNECTED
=
1
DISCONNECTED
class-attribute
instance-attribute
DISCONNECTED
=
2
RESPONSE
class-attribute
instance-attribute
RESPONSE
=
3

## 105_RELEASE_NOTES
Release Notes¶
---

Release Notes
Latest Changes
Docs
📝 Update Speakeasy URL to Speakeasy Sandbox. PR
## 13697
by
@ndimares
.
Translations
🌐 Add Russian translation for
docs/ru/docs/advanced/index.md
. PR
## 13797
by
@NavesSapnis
.
0.115.13
Fixes
🐛 Fix truncating the model's description with form feed (
\f
) character for Pydantic V2. PR
## 13698
by
@YuriiMotov
.
Refactors
✨ Add
refreshUrl
parameter in
OAuth2PasswordBearer
. PR
## 11460
by
@snosratiershad
.
🚸 Set format to password for fields
password
and
client_secret
in
OAuth2PasswordRequestForm
, make docs show password fields for passwords. PR
## 11032
by
@Thodoris1999
.
✅ Simplify tests for
settings
. PR
## 13505
by
@valentinDruzhinin
.
✅ Simplify tests for
validate_response_recursive
. PR
## 13507
by
@valentinDruzhinin
.
Upgrades
⬆️ Update ReDoc to version 2.x. PR
## 9700
by
@joakimnordling
.
Docs
📝 Add annotations to HTTP middleware example. PR
## 11530
by
@Kilo59
.
📝 Clarify in CORS docs that wildcards and credentials are mutually exclusive. PR
## 9829
by
@dfioravanti
.
✏️ Fix typo in docstring. PR
## 13532
by
@comp64
.
📝 Clarify guidance on using
async def
without
await
. PR
## 13642
by
@swastikpradhan1999
.
📝 Update exclude-parameters-from-openapi documentation links. PR
## 13600
by
@timonrieger
.
📝 Clarify the middleware execution order in docs. PR
## 13699
by
@YuriiMotov
.
🍱 Update Drawio diagrams SVGs, single file per diagram, sans-serif font. PR
## 13706
by
@tiangolo
.
📝 Update docs for "Help FastAPI", simplify and reduce "sponsor" section. PR
## 13670
by
@tiangolo
.
📝 Remove unnecessary bullet from docs. PR
## 13641
by
@Adamowoc
.
✏️ Fix syntax error in
docs/en/docs/tutorial/handling-errors.md
. PR
## 13623
by
@gsheni
.
📝 Fix typo in documentation. PR
## 13599
by
@Taoup
.
📝 Fix liblab client generation doc link. PR
## 13571
by
@EFord36
.
✏️ Fix talk information typo. PR
## 13544
by
@blueswen
.
📝 Add External Link: Taiwanese talk on FastAPI with observability . PR
## 13527
by
@blueswen
.
Translations
🌐 Add Russian Translation for
docs/ru/docs/advanced/response-change-status-code.md
. PR
## 13791
by
@NavesSapnis
.
🌐 Add Persian translation for
docs/fa/docs/learn/index.md
. PR
## 13518
by
@Mohammad222PR
.
🌐 Add Korean translation for
docs/ko/docs/advanced/sub-applications.md
. PR
## 4543
by
@NinaHwang
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/schema-extra-example.md
. PR
## 13769
by
@valentinDruzhinin
.
✏️ Remove redundant words in docs/zh/docs/python-types.md. PR
## 13774
by
@CharleeWa
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/query-param-models.md
. PR
## 13748
by
@valentinDruzhinin
.
🌐 Add Bengali translation for
docs/bn/docs/environment-variables.md
. PR
## 13629
by
@SakibSibly
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/query-params-str-validations.md
page. PR
## 13546
by
@valentinDruzhinin
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/cookie-param-models.md
. PR
## 13616
by
@EgorOnishchuk
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/extra-models.md
. PR
## 13063
by
@timothy-jeong
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/path-params-numeric-validations.md
page. PR
## 13548
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/middleware.md
page. PR
## 13520
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/background-tasks.md
page. PR
## 13502
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/cors.md
page. PR
## 13519
by
@valentinDruzhinin
.
🌐 Update Korean translation for
docs/ko/docs/advanced/events.md
. PR
## 13487
by
@bom1215
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/handling-errors.md
page. PR
## 13420
by
@valentinDruzhinin
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/request-form-models.md
. PR
## 13552
by
@EgorOnishchuk
.
📝 Fix internal anchor link in Spanish deployment docs. PR
## 13737
by
@fabianfalon
.
🌐 Update Korean translation for
docs/ko/docs/virtual-environments.md
. PR
## 13630
by
@sungchan1
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/header-param-models.md
. PR
## 13526
by
@minaton-ru
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/index.md
. PR
## 13374
by
@Zhongheng-Cheng
.
🌐 Update Chinese translation for
docs/zh/docs/deployment/manually.md
. PR
## 13324
by
@Zhongheng-Cheng
.
🌐 Update Chinese translation for
docs/zh/docs/deployment/server-workers.md
. PR
## 13292
by
@Zhongheng-Cheng
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/first-steps.md
. PR
## 13348
by
@Zhongheng-Cheng
.
Internal
🔨 Resolve Pydantic deprecation warnings in internal script. PR
## 13696
by
@emmanuel-ferdman
.
🔧 Update sponsors: remove Porter. PR
## 13783
by
@tiangolo
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 13781
by
@pre-commit-ci[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 13757
by
@pre-commit-ci[bot]
.
⬆ Bump griffe-typingdoc from 0.2.7 to 0.2.8. PR
## 13751
by
@dependabot[bot]
.
🍱 Update sponsors: Dribia badge size. PR
## 13773
by
@tiangolo
.
🔧 Update sponsors: add Dribia. PR
## 13771
by
@tiangolo
.
⬆ Bump typer from 0.15.3 to 0.16.0. PR
## 13752
by
@dependabot[bot]
.
👥 Update FastAPI GitHub topic repositories. PR
## 13754
by
@tiangolo
.
👥 Update FastAPI People - Sponsors. PR
## 13750
by
@tiangolo
.
👥 Update FastAPI People - Contributors and Translators. PR
## 13749
by
@tiangolo
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 13736
by
@pre-commit-ci[bot]
.
🔧 Update sponsors: Add InterviewPal. PR
## 13728
by
@tiangolo
.
🔧 Remove Google Analytics. PR
## 13727
by
@tiangolo
.
🔧 Update sponsors: remove MongoDB. PR
## 13725
by
@tiangolo
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 13711
by
@pre-commit-ci[bot]
.
🔧 Update sponsors: add Subtotal. PR
## 13701
by
@tiangolo
.
🔧 Update sponsors: remove deepset / Haystack. PR
## 13700
by
@tiangolo
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 13688
by
@pre-commit-ci[bot]
.
👥 Update FastAPI People - Experts. PR
## 13671
by
@tiangolo
.
⬆ Bump typer from 0.12.5 to 0.15.3. PR
## 13666
by
@dependabot[bot]
.
⬆ Bump sqlmodel from 0.0.23 to 0.0.24. PR
## 13665
by
@dependabot[bot]
.
🔧 Update Sponsors: Zuplo logo and alt text. PR
## 13645
by
@martyndavies
.
👥 Update FastAPI GitHub topic repositories. PR
## 13667
by
@tiangolo
.
🔧 Update links for LinkedIn and bottom. PR
## 13669
by
@tiangolo
.
🔧 Update sponsors: remove Bump.sh and Coherence. PR
## 13668
by
@tiangolo
.
👥 Update FastAPI People - Sponsors. PR
## 13664
by
@tiangolo
.
👥 Update FastAPI People - Contributors and Translators. PR
## 13662
by
@tiangolo
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 13656
by
@pre-commit-ci[bot]
.
✅ Use
inline-snapshot
to support different Pydantic versions in the test suite. PR
## 12534
by
@15r10nk
.
⬆ Bump astral-sh/setup-uv from 5 to 6. PR
## 13648
by
@dependabot[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 13634
by
@pre-commit-ci[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 13619
by
@pre-commit-ci[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 13594
by
@pre-commit-ci[bot]
.
👥 Update FastAPI People - Experts. PR
## 13568
by
@tiangolo
.
👥 Update FastAPI GitHub topic repositories. PR
## 13565
by
@tiangolo
.
👥 Update FastAPI People - Sponsors. PR
## 13559
by
@tiangolo
.
👥 Update FastAPI People - Contributors and Translators. PR
## 13558
by
@tiangolo
.
⬆ Bump dirty-equals from 0.8.0 to 0.9.0. PR
## 13561
by
@dependabot[bot]
.
🔧 Clean up
docs/en/mkdocs.yml
configuration file. PR
## 13542
by
@svlandeg
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12986
by
@pre-commit-ci[bot]
.
0.115.12
Fixes
🐛 Fix
convert_underscores=False
for header Pydantic models. PR
## 13515
by
@tiangolo
.
Docs
📝 Update
docs/en/docs/tutorial/middleware.md
. PR
## 13444
by
@Rishat-F
.
👥 Update FastAPI People - Experts. PR
## 13493
by
@tiangolo
.
Translations
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/metadata.md
page. PR
## 13459
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/response-status-code.md
page. PR
## 13462
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/cookie-param-models.md
page. PR
## 13460
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/header-param-models.md
page. PR
## 13461
by
@valentinDruzhinin
.
🌐 Add Japanese translation for
docs/ja/docs/virtual-environments.md
. PR
## 13304
by
@k94-ishi
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/security/oauth2-jwt.md
. PR
## 13333
by
@yes0ng
.
🌐 Add Vietnamese translation for
docs/vi/docs/deployment/cloud.md
. PR
## 13407
by
@ptt3199
.
Internal
⬆ Bump pydantic-ai from 0.0.15 to 0.0.30. PR
## 13438
by
@dependabot[bot]
.
⬆ Bump sqlmodel from 0.0.22 to 0.0.23. PR
## 13437
by
@dependabot[bot]
.
⬆ Bump black from 24.10.0 to 25.1.0. PR
## 13436
by
@dependabot[bot]
.
⬆ Bump ruff to 0.9.4. PR
## 13299
by
@dependabot[bot]
.
🔧 Update sponsors: pause TestDriven. PR
## 13446
by
@tiangolo
.
0.115.11
Fixes
🐛 Add docs examples and tests (support) for
Annotated
custom validations, like
AfterValidator
, revert
## 13440
. PR
## 13442
by
@tiangolo
.
New docs:
Query Parameters and String Validations - Custom Validation
.
Translations
🌐 Add Russian translation for
docs/ru/docs/tutorial/middleware.md
. PR
## 13412
by
@alv2017
.
Internal
👥 Update FastAPI GitHub topic repositories. PR
## 13439
by
@tiangolo
.
👥 Update FastAPI People - Contributors and Translators. PR
## 13432
by
@tiangolo
.
👥 Update FastAPI People - Sponsors. PR
## 13433
by
@tiangolo
.
0.115.10
Fixes
♻️ Update internal annotation usage for compatibility with Pydantic 2.11. PR
## 13314
by
@Viicos
.
Upgrades
⬆️ Bump Starlette to allow up to 0.46.0:
>=0.40.0,<0.47.0
. PR
## 13426
by
@musicinmybrain
.
Translations
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/debugging.md
. PR
## 13370
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/query-params.md
. PR
## 13362
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/path-params.md
. PR
## 13354
by
@valentinDruzhinin
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/cookie-param-models.md
. PR
## 13330
by
@k94-ishi
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/body-multiple-params.md
. PR
## 13408
by
@valentinDruzhinin
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/query-param-models.md
. PR
## 13323
by
@k94-ishi
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/body-nested-models.md
. PR
## 13409
by
@valentinDruzhinin
.
🌐 Add Vietnamese translation for
docs/vi/docs/deployment/versions.md
. PR
## 13406
by
@ptt3199
.
🌐 Add Vietnamese translation for
docs/vi/docs/deployment/index.md
. PR
## 13405
by
@ptt3199
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/request-forms.md
. PR
## 13383
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/testing.md
. PR
## 13371
by
@valentinDruzhinin
.
0.115.9
Fixes
🐛 Ensure that
HTTPDigest
only raises an exception when
auto_error is True
. PR
## 2939
by
@arthurio
.
Refactors
✅ Simplify tests for
query_params_str_validations
. PR
## 13218
by
@alv2017
.
✅ Simplify tests for
app_testing
. PR
## 13220
by
@alv2017
.
✅ Simplify tests for
dependency_testing
. PR
## 13223
by
@alv2017
.
Docs
🍱 Update sponsors: CodeRabbit logo. PR
## 13424
by
@tiangolo
.
🩺 Unify the badges across all tutorial translations. PR
## 13329
by
@svlandeg
.
📝 Fix typos in virtual environments documentation. PR
## 13396
by
@bullet-ant
.
🐛 Fix issue with Swagger theme change example in the official tutorial. PR
## 13289
by
@Zerohertz
.
📝 Add more precise description of HTTP status code range in docs. PR
## 13347
by
@DanielYang59
.
🔥 Remove manual type annotations in JWT tutorial to avoid typing expectations (JWT doesn't provide more types). PR
## 13378
by
@tiangolo
.
📝 Update docs for Query Params and String Validations, remove obsolete Ellipsis docs (
...
). PR
## 13377
by
@tiangolo
.
✏️ Remove duplicate title in docs
body-multiple-params
. PR
## 13345
by
@DanielYang59
.
📝 Fix test badge. PR
## 13313
by
@esadek
.
Translations
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/header-params.md
. PR
## 13381
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/request-files.md
. PR
## 13395
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/request-form-models.md
. PR
## 13384
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/request-forms-and-files.md
. PR
## 13386
by
@valentinDruzhinin
.
🌐 Update Korean translation for
docs/ko/docs/help-fastapi.md
. PR
## 13262
by
@Zerohertz
.
🌐 Add Korean translation for
docs/ko/docs/advanced/custom-response.md
. PR
## 13265
by
@11kkw
.
🌐 Update Korean translation for
docs/ko/docs/tutorial/security/simple-oauth2.md
. PR
## 13335
by
@yes0ng
.
🌐 Add Russian translation for
docs/ru/docs/advanced/response-cookies.md
. PR
## 13327
by
@Stepakinoyan
.
🌐 Add Vietnamese translation for
docs/vi/docs/tutorial/static-files.md
. PR
## 11291
by
@ptt3199
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 13257
by
@11kkw
.
🌐 Add Vietnamese translation for
docs/vi/docs/virtual-environments.md
. PR
## 13282
by
@ptt3199
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/static-files.md
. PR
## 13285
by
@valentinDruzhinin
.
🌐 Add Vietnamese translation for
docs/vi/docs/environment-variables.md
. PR
## 13287
by
@ptt3199
.
🌐 Add Vietnamese translation for
docs/vi/docs/fastapi-cli.md
. PR
## 13294
by
@ptt3199
.
🌐 Add Ukrainian translation for
docs/uk/docs/features.md
. PR
## 13308
by
@valentinDruzhinin
.
🌐 Add Ukrainian translation for
docs/uk/docs/learn/index.md
. PR
## 13306
by
@valentinDruzhinin
.
🌐 Update Portuguese Translation for
docs/pt/docs/deployment/https.md
. PR
## 13317
by
@Joao-Pedro-P-Holanda
.
🌐 Update Portuguese Translation for
docs/pt/docs/index.md
. PR
## 13328
by
@ceb10n
.
🌐 Add Russian translation for
docs/ru/docs/advanced/websockets.md
. PR
## 13279
by
@Rishat-F
.
Internal
✅ Fix a minor bug in the test
tests/test_modules_same_name_body/test_main.py
. PR
## 13411
by
@alv2017
.
👷 Use
wrangler-action
v3. PR
## 13415
by
@joakimnordling
.
🔧 Update sponsors: add CodeRabbit. PR
## 13402
by
@tiangolo
.
🔧 Update team: Add Ludovico. PR
## 13390
by
@tiangolo
.
🔧 Update sponsors: Add LambdaTest. PR
## 13389
by
@tiangolo
.
⬆ Bump cloudflare/wrangler-action from 3.13 to 3.14. PR
## 13350
by
@dependabot[bot]
.
⬆ Bump mkdocs-material from 9.5.18 to 9.6.1. PR
## 13301
by
@dependabot[bot]
.
⬆ Bump pillow from 11.0.0 to 11.1.0. PR
## 13300
by
@dependabot[bot]
.
👥 Update FastAPI People - Sponsors. PR
## 13295
by
@tiangolo
.
👥 Update FastAPI People - Experts. PR
## 13303
by
@tiangolo
.
👥 Update FastAPI GitHub topic repositories. PR
## 13302
by
@tiangolo
.
👥 Update FastAPI People - Contributors and Translators. PR
## 13293
by
@tiangolo
.
⬆ Bump inline-snapshot from 0.18.1 to 0.19.3. PR
## 13298
by
@dependabot[bot]
.
🔧 Update sponsors, add Permit. PR
## 13288
by
@tiangolo
.
0.115.8
Fixes
🐛 Fix
OAuth2PasswordRequestForm
and
OAuth2PasswordRequestFormStrict
fixed
grant_type
"password" RegEx. PR
## 9783
by
@skarfie123
.
Refactors
✅ Simplify tests for body_multiple_params . PR
## 13237
by
@alejsdev
.
♻️ Move duplicated code portion to a static method in the
APIKeyBase
super class. PR
## 3142
by
@ShahriyarR
.
✅ Simplify tests for request_files. PR
## 13182
by
@alejsdev
.
Docs
📝 Change the word "unwrap" to "unpack" in
docs/en/docs/tutorial/extra-models.md
. PR
## 13061
by
@timothy-jeong
.
📝 Update Request Body's
tutorial002
to deal with
tax=0
case. PR
## 13230
by
@togogh
.
👥 Update FastAPI People - Experts. PR
## 13269
by
@tiangolo
.
Translations
🌐 Add Japanese translation for
docs/ja/docs/environment-variables.md
. PR
## 13226
by
@k94-ishi
.
🌐 Add Russian translation for
docs/ru/docs/advanced/async-tests.md
. PR
## 13227
by
@Rishat-F
.
🌐 Update Russian translation for
docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 13252
by
@Rishat-F
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/bigger-applications.md
. PR
## 13154
by
@alv2017
.
Internal
⬆️ Add support for Python 3.13. PR
## 13274
by
@tiangolo
.
⬆️ Upgrade AnyIO max version for tests, new range:
>=3.2.1,<5.0.0
. PR
## 13273
by
@tiangolo
.
🔧 Update Sponsors badges. PR
## 13271
by
@tiangolo
.
♻️ Fix
notify_translations.py
empty env var handling for PR label events vs workflow_dispatch. PR
## 13272
by
@tiangolo
.
♻️ Refactor and move
scripts/notify_translations.py
, no need for a custom GitHub Action. PR
## 13270
by
@tiangolo
.
🔨 Update FastAPI People Experts script, refactor and optimize data fetching to handle rate limits. PR
## 13267
by
@tiangolo
.
⬆ Bump pypa/gh-action-pypi-publish from 1.12.3 to 1.12.4. PR
## 13251
by
@dependabot[bot]
.
0.115.7
Upgrades
⬆️ Upgrade
python-multipart
to >=0.0.18. PR
## 13219
by
@DanielKusyDev
.
⬆️ Bump Starlette to allow up to 0.45.0:
>=0.40.0,<0.46.0
. PR
## 13117
by
@Kludex
.
⬆️ Upgrade
jinja2
to >=3.1.5. PR
## 13194
by
@DanielKusyDev
.
Refactors
✅ Simplify tests for websockets. PR
## 13202
by
@alejsdev
.
✅ Simplify tests for request_form_models . PR
## 13183
by
@alejsdev
.
✅ Simplify tests for separate_openapi_schemas. PR
## 13201
by
@alejsdev
.
✅ Simplify tests for security. PR
## 13200
by
@alejsdev
.
✅ Simplify tests for schema_extra_example. PR
## 13197
by
@alejsdev
.
✅ Simplify tests for request_model. PR
## 13195
by
@alejsdev
.
✅ Simplify tests for request_forms_and_files. PR
## 13185
by
@alejsdev
.
✅ Simplify tests for request_forms. PR
## 13184
by
@alejsdev
.
✅ Simplify tests for path_query_params. PR
## 13181
by
@alejsdev
.
✅ Simplify tests for path_operation_configurations. PR
## 13180
by
@alejsdev
.
✅ Simplify tests for header_params. PR
## 13179
by
@alejsdev
.
✅ Simplify tests for extra_models. PR
## 13178
by
@alejsdev
.
✅ Simplify tests for extra_data_types. PR
## 13177
by
@alejsdev
.
✅ Simplify tests for cookie_params. PR
## 13176
by
@alejsdev
.
✅ Simplify tests for dependencies. PR
## 13174
by
@alejsdev
.
✅ Simplify tests for body_updates. PR
## 13172
by
@alejsdev
.
✅ Simplify tests for body_nested_models. PR
## 13171
by
@alejsdev
.
✅ Simplify tests for body_multiple_params. PR
## 13170
by
@alejsdev
.
✅ Simplify tests for body_fields. PR
## 13169
by
@alejsdev
.
✅ Simplify tests for body. PR
## 13168
by
@alejsdev
.
✅ Simplify tests for bigger_applications. PR
## 13167
by
@alejsdev
.
✅ Simplify tests for background_tasks. PR
## 13166
by
@alejsdev
.
✅ Simplify tests for additional_status_codes. PR
## 13149
by
@tiangolo
.
Docs
✏️ Update Strawberry integration docs. PR
## 13155
by
@kinuax
.
🔥 Remove unused Peewee tutorial files. PR
## 13158
by
@alejsdev
.
📝 Update image in body-nested-model docs. PR
## 11063
by
@untilhamza
.
📝 Update
fastapi-cli
UI examples in docs. PR
## 13107
by
@Zhongheng-Cheng
.
👷 Add new GitHub Action to update contributors, translators, and translation reviewers. PR
## 13136
by
@tiangolo
.
✏️ Fix typo in
docs/en/docs/virtual-environments.md
. PR
## 13124
by
@tiangolo
.
✏️ Fix error in
docs/en/docs/contributing.md
. PR
## 12899
by
@kingsubin
.
📝 Minor corrections in
docs/en/docs/tutorial/sql-databases.md
. PR
## 13081
by
@alv2017
.
📝 Update includes in
docs/ru/docs/tutorial/query-param-models.md
. PR
## 12994
by
@alejsdev
.
✏️ Fix typo in README installation instructions. PR
## 13011
by
@dave-hay
.
📝 Update docs for
fastapi-cli
. PR
## 13031
by
@tiangolo
.
Translations
🌐 Update Portuguese Translation for
docs/pt/docs/tutorial/request-forms.md
. PR
## 13216
by
@Joao-Pedro-P-Holanda
.
🌐 Update Portuguese translation for
docs/pt/docs/advanced/settings.md
. PR
## 13209
by
@ceb10n
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/security/oauth2-jwt.md
. PR
## 13205
by
@ceb10n
.
🌐 Add Indonesian translation for
docs/id/docs/index.md
. PR
## 13191
by
@gerry-sabar
.
🌐 Add Indonesian translation for
docs/id/docs/tutorial/static-files.md
. PR
## 13092
by
@guspan-tanadi
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/security/get-current-user.md
. PR
## 13188
by
@ceb10n
.
🌐 Remove Wrong Portuguese translations location for
docs/pt/docs/advanced/benchmarks.md
. PR
## 13187
by
@ceb10n
.
🌐 Update Portuguese translations. PR
## 13156
by
@nillvitor
.
🌐 Update Russian translation for
docs/ru/docs/tutorial/security/first-steps.md
. PR
## 13159
by
@Yarous
.
✏️ Delete unnecessary backspace in
docs/ja/docs/tutorial/path-params-numeric-validations.md
. PR
## 12238
by
@FakeDocument
.
🌐 Update Chinese translation for
docs/zh/docs/fastapi-cli.md
. PR
## 13102
by
@Zhongheng-Cheng
.
🌐 Add new Spanish translations for all docs with new LLM-assisted system using PydanticAI. PR
## 13122
by
@tiangolo
.
🌐 Update existing Spanish translations using the new LLM-assisted system using PydanticAI. PR
## 13118
by
@tiangolo
.
🌐 Update Chinese translation for
docs/zh/docs/advanced/security/oauth2-scopes.md
. PR
## 13110
by
@ChenPu2002
.
🌐 Add Indonesian translation for
docs/id/docs/tutorial/path-params.md
. PR
## 13086
by
@gerry-sabar
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/sql-databases.md
. PR
## 13093
by
@GeumBinLee
.
🌐 Update Chinese translation for
docs/zh/docs/async.md
. PR
## 13095
by
@Zhongheng-Cheng
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/openapi-webhooks.md
. PR
## 13091
by
@Zhongheng-Cheng
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/async-tests.md
. PR
## 13074
by
@Zhongheng-Cheng
.
🌐 Add Ukrainian translation for
docs/uk/docs/fastapi-cli.md
. PR
## 13020
by
@ykertytsky
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/events.md
. PR
## 12512
by
@ZhibangYue
.
🌐 Add Russian translation for
/docs/ru/docs/tutorial/sql-databases.md
. PR
## 13079
by
@alv2017
.
🌐 Update Chinese translation for
docs/zh/docs/advanced/testing-dependencies.md
. PR
## 13066
by
@Zhongheng-Cheng
.
🌐 Update Traditional Chinese translation for
docs/zh-hant/docs/tutorial/index.md
. PR
## 13075
by
@codingjenny
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/sql-databases.md
. PR
## 13051
by
@Zhongheng-Cheng
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/query-params-str-validations.md
. PR
## 12928
by
@Vincy1230
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/header-param-models.md
. PR
## 13040
by
@Zhongheng-Cheng
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/path-params.md
. PR
## 12926
by
@Vincy1230
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/first-steps.md
. PR
## 12923
by
@Vincy1230
.
🌐 Update Russian translation for
docs/ru/docs/deployment/docker.md
. PR
## 13048
by
@anklav24
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/generate-clients.md
. PR
## 13030
by
@vitumenezes
.
🌐 Add Indonesian translation for
docs/id/docs/tutorial/first-steps.md
. PR
## 13042
by
@gerry-sabar
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/cookie-param-models.md
. PR
## 13038
by
@Zhongheng-Cheng
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/request-form-models.md
. PR
## 13045
by
@Zhongheng-Cheng
.
🌐 Add Russian translation for
docs/ru/docs/virtual-environments.md
. PR
## 13026
by
@alv2017
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/testing.md
. PR
## 12968
by
@jts8257
.
🌐 Add Korean translation for
docs/ko/docs/advanced/async-test.md
. PR
## 12918
by
@icehongssii
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/security/oauth2-jwt.md
. PR
## 10601
by
@AlertRED
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/security/simple-oauth2.md
. PR
## 10599
by
@AlertRED
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/security/get-current-user.md
. PR
## 10594
by
@AlertRED
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/features.md
. PR
## 12441
by
@codingjenny
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/virtual-environments.md
. PR
## 12791
by
@Vincy1230
.
🌐 Add Korean translation for
docs/ko/docs/advanced/templates.md
. PR
## 12726
by
@Heumhub
.
🌐 Add Russian translation for
docs/ru/docs/fastapi-cli.md
. PR
## 13041
by
@alv2017
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/cookie-param-models.md
. PR
## 13000
by
@hard-coders
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/header-param-models.md
. PR
## 13001
by
@hard-coders
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/request-form-models.md
. PR
## 13002
by
@hard-coders
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/request-forms.md
. PR
## 13003
by
@hard-coders
.
🌐 Add Korean translation for
docs/ko/docs/resources/index.md
. PR
## 13004
by
@hard-coders
.
🌐 Add Korean translation for
docs/ko/docs/how-to/configure-swagger-ui.md
. PR
## 12898
by
@nahyunkeem
.
🌐 Add Korean translation to
docs/ko/docs/advanced/additional-status-codes.md
. PR
## 12715
by
@nahyunkeem
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/tutorial/first-steps.md
. PR
## 12467
by
@codingjenny
.
Internal
🔧 Add Pydantic 2 trove classifier. PR
## 13199
by
@johnthagen
.
👥 Update FastAPI People - Sponsors. PR
## 13231
by
@tiangolo
.
👷 Refactor FastAPI People Sponsors to use 2 tokens. PR
## 13228
by
@tiangolo
.
👷 Update token for FastAPI People - Sponsors. PR
## 13225
by
@tiangolo
.
👷 Add independent CI automation for FastAPI People - Sponsors. PR
## 13221
by
@tiangolo
.
👷 Add retries to Smokeshow. PR
## 13151
by
@tiangolo
.
🔧 Update Speakeasy sponsor graphic. PR
## 13147
by
@chailandau
.
👥 Update FastAPI GitHub topic repositories. PR
## 13146
by
@tiangolo
.
👷‍♀️ Add script for GitHub Topic Repositories and update External Links. PR
## 13135
by
@alejsdev
.
👥 Update FastAPI People - Contributors and Translators. PR
## 13145
by
@tiangolo
.
⬆ Bump markdown-include-variants from 0.0.3 to 0.0.4. PR
## 13129
by
@dependabot[bot]
.
⬆ Bump inline-snapshot from 0.14.0 to 0.18.1. PR
## 13132
by
@dependabot[bot]
.
⬆ Bump mkdocs-macros-plugin from 1.0.5 to 1.3.7. PR
## 13133
by
@dependabot[bot]
.
🔨 Add internal scripts to generate language translations with PydanticAI, include Spanish prompt. PR
## 13123
by
@tiangolo
.
⬆ Bump astral-sh/setup-uv from 4 to 5. PR
## 13096
by
@dependabot[bot]
.
🔧 Update sponsors: rename CryptAPI to BlockBee. PR
## 13078
by
@tiangolo
.
⬆ Bump pypa/gh-action-pypi-publish from 1.12.2 to 1.12.3. PR
## 13055
by
@dependabot[bot]
.
⬆ Bump types-ujson from 5.7.0.1 to 5.10.0.20240515. PR
## 13018
by
@dependabot[bot]
.
⬆ Bump black from 24.3.0 to 24.10.0. PR
## 13014
by
@dependabot[bot]
.
⬆ Bump inline-snapshot from 0.13.0 to 0.14.0. PR
## 13017
by
@dependabot[bot]
.
⬆ Bump dirty-equals from 0.6.0 to 0.8.0. PR
## 13015
by
@dependabot[bot]
.
⬆ Bump cloudflare/wrangler-action from 3.12 to 3.13. PR
## 12996
by
@dependabot[bot]
.
⬆ Bump astral-sh/setup-uv from 3 to 4. PR
## 12982
by
@dependabot[bot]
.
🔧 Remove duplicate actions/checkout in
notify-translations.yml
. PR
## 12915
by
@tinyboxvk
.
🔧 Update team members. PR
## 13033
by
@tiangolo
.
📝 Update sponsors: remove Codacy. PR
## 13032
by
@tiangolo
.
0.115.6
Fixes
🐛 Preserve traceback when an exception is raised in sync dependency with
yield
. PR
## 5823
by
@sombek
.
Refactors
♻️ Update tests and internals for compatibility with Pydantic >=2.10. PR
## 12971
by
@tamird
.
Docs
📝 Update includes format in docs with an automated script. PR
## 12950
by
@tiangolo
.
📝 Update includes for
docs/de/docs/advanced/using-request-directly.md
. PR
## 12685
by
@alissadb
.
📝 Update includes for
docs/de/docs/how-to/conditional-openapi.md
. PR
## 12689
by
@alissadb
.
Translations
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/async.md
. PR
## 12990
by
@ILoveSorasakiHina
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/tutorial/query-param-models.md
. PR
## 12932
by
@Vincy1230
.
🌐 Add Korean translation for
docs/ko/docs/advanced/testing-dependencies.md
. PR
## 12992
by
@Limsunoh
.
🌐 Add Korean translation for
docs/ko/docs/advanced/websockets.md
. PR
## 12991
by
@kwang1215
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/response-model.md
. PR
## 12933
by
@AndreBBM
.
🌐 Add Korean translation for
docs/ko/docs/advanced/middlewares.md
. PR
## 12753
by
@nahyunkeem
.
🌐 Add Korean translation for
docs/ko/docs/advanced/openapi-webhooks.md
. PR
## 12752
by
@saeye
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/query-param-models.md
. PR
## 12931
by
@Vincy1230
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/query-param-models.md
. PR
## 12445
by
@gitgernit
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/query-param-models.md
. PR
## 12940
by
@jts8257
.
🔥 Remove obsolete tutorial translation to Chinese for
docs/zh/docs/tutorial/sql-databases.md
, it references files that are no longer on the repo. PR
## 12949
by
@tiangolo
.
Internal
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12954
by
@pre-commit-ci[bot]
.
0.115.5
Refactors
♻️ Update internal checks to support Pydantic 2.10. PR
## 12914
by
@tiangolo
.
Docs
📝 Update includes for
docs/en/docs/tutorial/body.md
. PR
## 12757
by
@gsheni
.
📝 Update includes in
docs/en/docs/advanced/testing-dependencies.md
. PR
## 12647
by
@AyushSinghal1794
.
📝 Update includes for
docs/en/docs/tutorial/metadata.md
. PR
## 12773
by
@Nimitha-jagadeesha
.
📝 Update
docs/en/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 12045
by
@xuvjso
.
📝 Update includes for
docs/en/docs/tutorial/dependencies/global-dependencies.md
. PR
## 12653
by
@vishnuvskvkl
.
📝 Update includes for
docs/en/docs/tutorial/body-updates.md
. PR
## 12712
by
@davioc
.
📝 Remove mention of Celery in the project generators. PR
## 12742
by
@david-caro
.
📝 Update includes in
docs/en/docs/tutorial/header-param-models.md
. PR
## 12814
by
@zhaohan-dong
.
📝 Update
contributing.md
docs, include note to not translate this page. PR
## 12841
by
@tiangolo
.
📝 Update includes in
docs/en/docs/tutorial/request-forms.md
. PR
## 12648
by
@vishnuvskvkl
.
📝 Update includes in
docs/en/docs/tutorial/request-form-models.md
. PR
## 12649
by
@vishnuvskvkl
.
📝 Update includes in
docs/en/docs/tutorial/security/oauth2-jwt.md
. PR
## 12650
by
@OCE1960
.
📝 Update includes in
docs/vi/docs/tutorial/first-steps.md
. PR
## 12754
by
@MxPy
.
📝 Update includes for
docs/pt/docs/advanced/wsgi.md
. PR
## 12769
by
@Nimitha-jagadeesha
.
📝 Update includes for
docs/en/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 12815
by
@handabaldeep
.
📝 Update includes for
docs/en/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 12813
by
@handabaldeep
.
✏️ Fix error in
docs/en/docs/tutorial/middleware.md
. PR
## 12819
by
@alejsdev
.
📝 Update includes for
docs/en/docs/tutorial/security/get-current-user.md
. PR
## 12645
by
@OCE1960
.
📝 Update includes for
docs/en/docs/tutorial/security/first-steps.md
. PR
## 12643
by
@OCE1960
.
📝 Update includes in
docs/de/docs/advanced/additional-responses.md
. PR
## 12821
by
@zhaohan-dong
.
📝 Update includes in
docs/en/docs/advanced/generate-clients.md
. PR
## 12642
by
@AyushSinghal1794
.
📝 Fix admonition double quotes with new syntax. PR
## 12835
by
@tiangolo
.
📝 Update includes in
docs/zh/docs/advanced/additional-responses.md
. PR
## 12828
by
@zhaohan-dong
.
📝 Update includes in
docs/en/docs/tutorial/path-params-numeric-validations.md
. PR
## 12825
by
@zhaohan-dong
.
📝 Update includes for
docs/en/docs/advanced/testing-websockets.md
. PR
## 12761
by
@hamidrasti
.
📝 Update includes for
docs/en/docs/advanced/using-request-directly.md
. PR
## 12760
by
@hamidrasti
.
📝 Update includes for
docs/advanced/wsgi.md
. PR
## 12758
by
@hamidrasti
.
📝 Update includes in
docs/de/docs/tutorial/middleware.md
. PR
## 12729
by
@paintdog
.
📝 Update includes for
docs/en/docs/tutorial/schema-extra-example.md
. PR
## 12822
by
@tiangolo
.
📝 Update includes in
docs/fr/docs/advanced/additional-responses.md
. PR
## 12634
by
@fegmorte
.
📝 Update includes in
docs/fr/docs/advanced/path-operation-advanced-configuration.md
. PR
## 12633
by
@kantandane
.
📝 Update includes in
docs/fr/docs/advanced/response-directly.md
. PR
## 12632
by
@kantandane
.
📝 Update includes for
docs/en/docs/tutorial/header-params.md
. PR
## 12640
by
@vishnuvskvkl
.
📝 Update includes in
docs/en/docs/tutorial/cookie-param-models.md
. PR
## 12639
by
@vishnuvskvkl
.
📝 Update includes for
docs/en/docs/tutorial/extra-models.md
. PR
## 12638
by
@vishnuvskvkl
.
📝 Update includes for
docs/en/docs/tutorial/cors.md
. PR
## 12637
by
@vishnuvskvkl
.
📝 Update includes for
docs/en/docs/tutorial/dependencies/sub-dependencies.md
. PR
## 12810
by
@handabaldeep
.
📝 Update includes in
docs/en/docs/tutorial/body-nested-models.md
. PR
## 12812
by
@zhaohan-dong
.
📝 Update includes in
docs/en/docs/tutorial/path-operation-configuration.md
. PR
## 12809
by
@AlexWendland
.
📝 Update includes in
docs/en/docs/tutorial/request-files.md
. PR
## 12818
by
@zhaohan-dong
.
📝 Update includes for
docs/en/docs/tutorial/query-param-models.md
. PR
## 12817
by
@handabaldeep
.
📝 Update includes in
docs/en/docs/tutorial/path-params.md
. PR
## 12811
by
@AlexWendland
.
📝 Update includes in
docs/en/docs/tutorial/response-model.md
. PR
## 12621
by
@kantandane
.
📝 Update includes in
docs/en/docs/advanced/websockets.md
. PR
## 12606
by
@vishnuvskvkl
.
📝 Updates include for
docs/en/docs/tutorial/cookie-params.md
. PR
## 12808
by
@handabaldeep
.
📝 Update includes in
docs/en/docs/tutorial/middleware.md
. PR
## 12807
by
@AlexWendland
.
📝 Update includes in
docs/en/docs/advanced/sub-applications.md
. PR
## 12806
by
@zhaohan-dong
.
📝 Update includes in
docs/en/docs/advanced/response-headers.md
. PR
## 12805
by
@zhaohan-dong
.
📝 Update includes in
docs/fr/docs/tutorial/first-steps.md
. PR
## 12594
by
@kantandane
.
📝 Update includes in
docs/en/docs/advanced/response-cookies.md
. PR
## 12804
by
@zhaohan-dong
.
📝 Update includes in
docs/en/docs/advanced/path-operation-advanced-configuration.md
. PR
## 12802
by
@zhaohan-dong
.
📝 Update includes for
docs/en/docs/advanced/response-directly.md
. PR
## 12803
by
@handabaldeep
.
📝 Update includes in
docs/zh/docs/tutorial/background-tasks.md
. PR
## 12798
by
@zhaohan-dong
.
📝 Update includes for
docs/de/docs/tutorial/body-multiple-params.md
. PR
## 12699
by
@alissadb
.
📝 Update includes in
docs/em/docs/tutorial/body-updates.md
. PR
## 12799
by
@AlexWendland
.
📝 Update includes
docs/en/docs/advanced/response-change-status-code.md
. PR
## 12801
by
@handabaldeep
.
📝 Update includes
docs/en/docs/advanced/openapi-callbacks.md
. PR
## 12800
by
@handabaldeep
.
📝 Update includes in
docs/fr/docs/tutorial/body-multiple-params.md
. PR
## 12598
by
@kantandane
.
📝 Update includes in
docs/en/docs/tutorial/body-multiple-params.md
. PR
## 12593
by
@Tashanam-Shahbaz
.
📝 Update includes in
docs/pt/docs/tutorial/background-tasks.md
. PR
## 12736
by
@bhunao
.
📝 Update includes for
docs/en/docs/advanced/custom-response.md
. PR
## 12797
by
@handabaldeep
.
📝 Update includes for
docs/pt/docs/python-types.md
. PR
## 12671
by
@ceb10n
.
📝 Update includes for
docs/de/docs/python-types.md
. PR
## 12660
by
@alissadb
.
📝 Update includes for
docs/de/docs/advanced/dataclasses.md
. PR
## 12658
by
@alissadb
.
📝 Update includes in
docs/fr/docs/tutorial/path-params.md
. PR
## 12592
by
@kantandane
.
📝 Update includes for
docs/de/docs/how-to/configure-swagger-ui.md
. PR
## 12690
by
@alissadb
.
📝 Update includes in
docs/en/docs/advanced/security/oauth2-scopes.md
. PR
## 12572
by
@krishnamadhavan
.
📝 Update includes for
docs/en/docs/how-to/conditional-openapi.md
. PR
## 12624
by
@rabinlamadong
.
📝 Update includes in
docs/en/docs/tutorial/dependencies/index.md
. PR
## 12615
by
@bharara
.
📝 Update includes in
docs/en/docs/tutorial/response-status-code.md
. PR
## 12620
by
@kantandane
.
📝 Update includes in
docs/en/docs/how-to/custom-docs-ui-assets.md
. PR
## 12623
by
@rabinlamadong
.
📝 Update includes in
docs/en/docs/advanced/openapi-webhooks.md
. PR
## 12605
by
@salmantec
.
📝 Update includes in
docs/en/docs/advanced/events.md
. PR
## 12604
by
@salmantec
.
📝 Update includes in
docs/en/docs/advanced/dataclasses.md
. PR
## 12603
by
@salmantec
.
📝 Update includes in
docs/es/docs/tutorial/cookie-params.md
. PR
## 12602
by
@antonyare93
.
📝 Update includes in
docs/fr/docs/tutorial/path-params-numeric-validations.md
. PR
## 12601
by
@kantandane
.
📝 Update includes in
docs/fr/docs/tutorial/background-tasks.md
. PR
## 12600
by
@kantandane
.
📝 Update includes in
docs/en/docs/tutorial/encoder.md
. PR
## 12597
by
@tonyjly
.
📝 Update includes in
docs/en/docs/how-to/custom-docs-ui-assets.md
. PR
## 12557
by
@philipokiokio
.
🎨 Adjust spacing. PR
## 12635
by
@alejsdev
.
📝 Update includes in
docs/en/docs/how-to/custom-request-and-route.md
. PR
## 12560
by
@philipokiokio
.
Translations
🌐 Add Korean translation for
docs/ko/docs/advanced/testing-websockets.md
. PR
## 12739
by
@Limsunoh
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/environment-variables.md
. PR
## 12785
by
@Vincy1230
.
🌐 Add Chinese translation for
docs/zh/docs/environment-variables.md
. PR
## 12784
by
@Vincy1230
.
🌐 Add Korean translation for
ko/docs/advanced/response-headers.md
. PR
## 12740
by
@kwang1215
.
🌐 Add Chinese translation for
docs/zh/docs/virtual-environments.md
. PR
## 12790
by
@Vincy1230
.
🌐 Add Korean translation for
/docs/ko/docs/environment-variables.md
. PR
## 12526
by
@Tolerblanc
.
🌐 Add Korean translation for
docs/ko/docs/history-design-future.md
. PR
## 12646
by
@saeye
.
🌐 Add Korean translation for
docs/ko/docs/advanced/advanced-dependencies.md
. PR
## 12675
by
@kim-sangah
.
🌐 Add Korean translation for
docs/ko/docs/how-to/conditional-openapi.md
. PR
## 12731
by
@sptcnl
.
🌐 Add Korean translation for
docs/ko/docs/advanced/using_request_directly.md
. PR
## 12738
by
@kwang1215
.
🌐 Add Korean translation for
docs/ko/docs/advanced/testing-events.md
. PR
## 12741
by
@9zimin9
.
🌐 Add Korean translation for
docs/ko/docs/security/index.md
. PR
## 12743
by
@kim-sangah
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/path-operation-advanced-configuration.md
. PR
## 12762
by
@Joao-Pedro-P-Holanda
.
🌐 Add Korean translation for
docs/ko/docs/advanced/wsgi.md
. PR
## 12659
by
@Limsunoh
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/websockets.md
. PR
## 12703
by
@devfernandoa
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/security/simple-oauth2.md
. PR
## 12520
by
@LidiaDomingos
.
🌐 Add Korean translation for
docs/ko/docs/advanced/response-directly.md
. PR
## 12674
by
@9zimin9
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/middleware.md
. PR
## 12704
by
@devluisrodrigues
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/openapi-callbacks.md
. PR
## 12705
by
@devfernandoa
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/request-files.md
. PR
## 12706
by
@devluisrodrigues
.
🌐 Add Portuguese Translation for
docs/pt/docs/advanced/custom-response.md
. PR
## 12631
by
@Joao-Pedro-P-Holanda
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/metadata.md
. PR
## 12538
by
@LinkolnR
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/metadata.md
. PR
## 12541
by
@kwang1215
.
🌐 Add Korean Translation for
docs/ko/docs/advanced/response-cookies.md
. PR
## 12546
by
@kim-sangah
.
🌐 Add Korean translation for
docs/ko/docs/fastapi-cli.md
. PR
## 12515
by
@dhdld
.
🌐 Add Korean Translation for
docs/ko/docs/advanced/response-change-status-code.md
. PR
## 12547
by
@9zimin9
.
Internal
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12907
by
@pre-commit-ci[bot]
.
🔨 Update docs preview script to show previous version and English version. PR
## 12856
by
@tiangolo
.
⬆ Bump tiangolo/latest-changes from 0.3.1 to 0.3.2. PR
## 12794
by
@dependabot[bot]
.
⬆ Bump pypa/gh-action-pypi-publish from 1.12.0 to 1.12.2. PR
## 12788
by
@dependabot[bot]
.
⬆ Bump pypa/gh-action-pypi-publish from 1.11.0 to 1.12.0. PR
## 12781
by
@dependabot[bot]
.
⬆ Bump cloudflare/wrangler-action from 3.11 to 3.12. PR
## 12777
by
@dependabot[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12766
by
@pre-commit-ci[bot]
.
⬆ Bump pypa/gh-action-pypi-publish from 1.10.3 to 1.11.0. PR
## 12721
by
@dependabot[bot]
.
⬆ Update pre-commit requirement from <4.0.0,>=2.17.0 to >=2.17.0,<5.0.0. PR
## 12749
by
@dependabot[bot]
.
⬆ Bump typer from 0.12.3 to 0.12.5. PR
## 12748
by
@dependabot[bot]
.
⬆ Update flask requirement from <3.0.0,>=1.1.2 to >=1.1.2,<4.0.0. PR
## 12747
by
@dependabot[bot]
.
⬆ Bump pillow from 10.4.0 to 11.0.0. PR
## 12746
by
@dependabot[bot]
.
⬆ Update pytest requirement from <8.0.0,>=7.1.3 to >=7.1.3,<9.0.0. PR
## 12745
by
@dependabot[bot]
.
🔧 Update sponsors: add Render. PR
## 12733
by
@tiangolo
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12707
by
@pre-commit-ci[bot]
.
0.115.4
Refactors
♻️ Update logic to import and check
python-multipart
for compatibility with newer version. PR
## 12627
by
@tiangolo
.
Docs
📝 Update includes in
docs/fr/docs/tutorial/body.md
. PR
## 12596
by
@kantandane
.
📝 Update includes in
docs/fr/docs/tutorial/debugging.md
. PR
## 12595
by
@kantandane
.
📝 Update includes in
docs/fr/docs/tutorial/query-params-str-validations.md
. PR
## 12591
by
@kantandane
.
📝 Update includes in
docs/fr/docs/tutorial/query-params.md
. PR
## 12589
by
@kantandane
.
📝 Update includes in
docs/en/tutorial/body-fields.md
. PR
## 12588
by
@lucaromagnoli
.
📝 Update includes in
docs/de/docs/tutorial/response-status-code.md
. PR
## 12585
by
@abejaranoh
.
📝 Update includes in
docs/en/docs/tutorial/body.md
. PR
## 12586
by
@lucaromagnoli
.
📝 Update includes in
docs/en/docs/advanced/behind-a-proxy.md
. PR
## 12583
by
@imjuanleonard
.
📝 Update includes syntax for
docs/pl/docs/tutorial/first-steps.md
. PR
## 12584
by
@sebkozlo
.
📝 Update includes in
docs/en/docs/advanced/middleware.md
. PR
## 12582
by
@montanarograziano
.
📝 Update includes in
docs/en/docs/advanced/additional-status-codes.md
. PR
## 12577
by
@krishnamadhavan
.
📝 Update includes in
docs/en/docs/advanced/advanced-dependencies.md
. PR
## 12578
by
@krishnamadhavan
.
📝 Update includes in
docs/en/docs/advanced/additional-responses.md
. PR
## 12576
by
@krishnamadhavan
.
📝 Update includes in
docs/en/docs/tutorial/static-files.md
. PR
## 12575
by
@lucaromagnoli
.
📝 Update includes in
docs/en/docs/advanced/async-tests.md
. PR
## 12568
by
@krishnamadhavan
.
📝 Update includes in
docs/pt/docs/advanced/behind-a-proxy.md
. PR
## 12563
by
@asmioglou
.
📝 Update includes in
docs/de/docs/advanced/security/http-basic-auth.md
. PR
## 12561
by
@Nimitha-jagadeesha
.
📝 Update includes in
docs/en/docs/tutorial/background-tasks.md
. PR
## 12559
by
@FarhanAliRaza
.
📝 Update includes in
docs/fr/docs/python-types.md
. PR
## 12558
by
@Ismailtlem
.
📝 Update includes in
docs/en/docs/how-to/graphql.md
. PR
## 12564
by
@philipokiokio
.
📝 Update includes in
docs/en/docs/how-to/extending-openapi.md
. PR
## 12562
by
@philipokiokio
.
📝 Update includes for
docs/en/docs/how-to/configure-swagger-ui.md
. PR
## 12556
by
@tiangolo
.
📝 Update includes for
docs/en/docs/how-to/separate-openapi-schemas.md
. PR
## 12555
by
@tiangolo
.
📝 Update includes for
docs/en/docs/advanced/security/http-basic-auth.md
. PR
## 12553
by
@tiangolo
.
📝 Update includes in
docs/en/docs/tutorial/first-steps.md
. PR
## 12552
by
@tiangolo
.
📝 Update includes in
docs/en/docs/python-types.md
. PR
## 12551
by
@tiangolo
.
📝 Fix link in OAuth2 docs. PR
## 12550
by
@tiangolo
.
📝 Add External Link: FastAPI do Zero. PR
## 12533
by
@rennerocha
.
📝 Fix minor typos. PR
## 12516
by
@kkirsche
.
🌐 Fix rendering issue in translations. PR
## 12509
by
@alejsdev
.
Translations
📝 Update includes in
docs/de/docs/advanced/async-tests.md
. PR
## 12567
by
@imjuanleonard
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/sql-databases.md
. PR
## 12530
by
@ilacftemp
.
🌐 Add Korean translation for
docs/ko/docs/benchmarks.md
. PR
## 12540
by
@Limsunoh
.
🌐 Add Portuguese translation for
docs/pt/docs/how-to/separate-openapi-schemas.md
. PR
## 12518
by
@ilacftemp
.
🌐 Update Traditional Chinese translation for
docs/zh-hant/docs/deployment/index.md
. PR
## 12521
by
@codingjenny
.
🌐 Update Traditional Chinese translation for
docs/zh-hant/docs/deployment/cloud.md
. PR
## 12522
by
@codingjenny
.
🌐 Update Traditional Chinese translation for
docs/zh-hant/docs/how-to/index.md
. PR
## 12523
by
@codingjenny
.
🌐 Update Traditional Chinese translation for
docs/zh-hant/docs/tutorial/index.md
. PR
## 12524
by
@codingjenny
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/how-to/index.md
. PR
## 12468
by
@codingjenny
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/tutorial/index.md
. PR
## 12466
by
@codingjenny
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/header-param-models.md
. PR
## 12437
by
@Joao-Pedro-P-Holanda
.
🌐 Add Portuguese translation for
docs/pt/docs/how-to/extending-openapi.md
. PR
## 12470
by
@ilacftemp
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/dataclasses.md
. PR
## 12475
by
@leoscarlato
.
🌐 Add Portuguese translation for
docs/pt/docs/how-to/custom-request-and-route.md
. PR
## 12483
by
@devfernandoa
.
Internal
⬆ Bump cloudflare/wrangler-action from 3.9 to 3.11. PR
## 12544
by
@dependabot[bot]
.
👷 Update GitHub Action to deploy docs previews to handle missing deploy comments. PR
## 12527
by
@tiangolo
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12505
by
@pre-commit-ci[bot]
.
0.115.3
Upgrades
⬆️ Upgrade Starlette to
>=0.40.0,<0.42.0
. PR
## 12469
by
@defnull
.
Docs
📝 Fix broken link in docs. PR
## 12495
by
@eltonjncorreia
.
Translations
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/fastapi-cli.md
. PR
## 12444
by
@codingjenny
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/deployment/index.md
. PR
## 12439
by
@codingjenny
.
🌐 Add Portuguese translation for
docs/pt/docs/how-to/testing-database.md
. PR
## 12472
by
@GuilhermeRameh
.
🌐 Add Portuguese translation for
docs/pt/docs/how-to/custom-docs-ui-assets.md
. PR
## 12473
by
@devluisrodrigues
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/response-headers.md
. PR
## 12458
by
@leonardopaloschi
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/deployment/cloud.md
. PR
## 12440
by
@codingjenny
.
🌐 Update Portuguese translation for
docs/pt/docs/python-types.md
. PR
## 12428
by
@ceb10n
.
🌐 Add Russian translation for
docs/ru/docs/environment-variables.md
. PR
## 12436
by
@wisderfin
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/resources/index.md
. PR
## 12443
by
@codingjenny
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/about/index.md
. PR
## 12438
by
@codingjenny
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/query-param-models.md
. PR
## 12414
by
@ceb10n
.
🌐 Remove Portuguese translation for
docs/pt/docs/deployment.md
. PR
## 12427
by
@ceb10n
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/body-updates.md
. PR
## 12381
by
@andersonrocha0
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/response-cookies.md
. PR
## 12417
by
@Paulofalcao2002
.
Internal
👷 Update issue manager workflow . PR
## 12457
by
@alejsdev
.
🔧 Update team, include YuriiMotov 🚀. PR
## 12453
by
@tiangolo
.
👷 Refactor label-approved, make it an internal script instead of an external GitHub Action. PR
## 12280
by
@tiangolo
.
👷 Fix smokeshow, checkout files on CI. PR
## 12434
by
@tiangolo
.
👷 Use uv in CI. PR
## 12281
by
@tiangolo
.
⬆ Update httpx requirement from <0.25.0,>=0.23.0 to >=0.23.0,<0.28.0. PR
## 11509
by
@dependabot[bot]
.
0.115.2
Upgrades
⬆️ Upgrade Starlette to
>=0.37.2,<0.41.0
. PR
## 12431
by
@tiangolo
.
0.115.1
Fixes
🐛 Fix openapi generation with responses kwarg. PR
## 10895
by
@flxdot
.
🐛 Remove
Required
shadowing from fastapi using Pydantic v2. PR
## 12197
by
@pachewise
.
Refactors
♻️ Update type annotations for improved
python-multipart
. PR
## 12407
by
@tiangolo
.
Docs
✨ Add new tutorial for SQL databases with SQLModel. PR
## 12285
by
@tiangolo
.
📝 Add External Link: How to profile a FastAPI asynchronous request. PR
## 12389
by
@brouberol
.
🔧 Remove
base_path
for
mdx_include
Markdown extension in MkDocs. PR
## 12391
by
@tiangolo
.
📝 Update link to Swagger UI configuration docs. PR
## 12264
by
@makisukurisu
.
📝 Adding links for Playwright and Vite in
docs/project-generation.md
. PR
## 12274
by
@kayqueGovetri
.
📝 Fix small typos in the documentation. PR
## 12213
by
@svlandeg
.
Translations
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/cookie-param-models.md
. PR
## 12298
by
@ceb10n
.
🌐 Add Portuguese translation for
docs/pt/docs/how-to/graphql.md
. PR
## 12215
by
@AnandaCampelo
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/security/oauth2-scopes.md
. PR
## 12263
by
@ceb10n
.
🌐 Add Portuguese translation for
docs/pt/docs/deployment/concepts.md
. PR
## 12219
by
@marcelomarkus
.
🌐 Add Portuguese translation for
docs/pt/docs/how-to/conditional-openapi.md
. PR
## 12221
by
@marcelomarkus
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/response-directly.md
. PR
## 12266
by
@Joao-Pedro-P-Holanda
.
🌐 Update Portuguese translation for
docs/pt/docs/tutorial/cookie-params.md
. PR
## 12297
by
@ceb10n
.
🌐 Fix Korean translation for
docs/ko/docs/tutorial/index.md
. PR
## 12278
by
@kkotipy
.
🌐 Update Portuguese translation for
docs/pt/docs/advanced/security/http-basic-auth.md
. PR
## 12275
by
@andersonrocha0
.
🌐 Add Portuguese translation for
docs/pt/docs/deployment/cloud.md
. PR
## 12217
by
@marcelomarkus
.
✏️ Fix typo in
docs/es/docs/python-types.md
. PR
## 12235
by
@JavierSanchezCastro
.
🌐 Add Dutch translation for
docs/nl/docs/environment-variables.md
. PR
## 12200
by
@maxscheijen
.
🌐 Add Portuguese translation for
docs/pt/docs/deployment/manually.md
. PR
## 12210
by
@JoaoGustavoRogel
.
🌐 Add Portuguese translation for
docs/pt/docs/deployment/server-workers.md
. PR
## 12220
by
@marcelomarkus
.
🌐 Add Portuguese translation for
docs/pt/docs/how-to/configure-swagger-ui.md
. PR
## 12222
by
@marcelomarkus
.
Internal
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12396
by
@pre-commit-ci[bot]
.
🔨 Add script to generate variants of files. PR
## 12405
by
@tiangolo
.
🔧 Add speakeasy-api to
sponsors_badge.yml
. PR
## 12404
by
@tiangolo
.
➕ Add docs dependency: markdown-include-variants. PR
## 12399
by
@tiangolo
.
📝 Fix extra mdx-base-path paths. PR
## 12397
by
@tiangolo
.
👷 Tweak labeler to not override custom labels. PR
## 12398
by
@tiangolo
.
👷 Update worfkow deploy-docs-notify URL. PR
## 12392
by
@tiangolo
.
👷 Update Cloudflare GitHub Action. PR
## 12387
by
@tiangolo
.
⬆ Bump pypa/gh-action-pypi-publish from 1.10.1 to 1.10.3. PR
## 12386
by
@dependabot[bot]
.
⬆ Bump mkdocstrings[python] from 0.25.1 to 0.26.1. PR
## 12371
by
@dependabot[bot]
.
⬆ Bump griffe-typingdoc from 0.2.6 to 0.2.7. PR
## 12370
by
@dependabot[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12331
by
@pre-commit-ci[bot]
.
🔧 Update sponsors, remove Fine.dev. PR
## 12271
by
@tiangolo
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12253
by
@pre-commit-ci[bot]
.
✏️ Fix docstring typos in http security. PR
## 12223
by
@albertvillanova
.
0.115.0
Highlights
Now you can declare
Query
,
Header
, and
Cookie
parameters with Pydantic models. 🎉
Query
Parameter Models
Use Pydantic models for
Query
parameters:
from
typing
import
Annotated
,
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
Read the new docs:
Query Parameter Models
.
Header
Parameter Models
Use Pydantic models for
Header
parameters:
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
Read the new docs:
Header Parameter Models
.
Cookie
Parameter Models
Use Pydantic models for
Cookie
parameters:
from
typing
import
Annotated
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
str
|
None
=
None
googall_tracker
:
str
|
None
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
Read the new docs:
Cookie Parameter Models
.
Forbid Extra Query (Cookie, Header) Parameters
Use Pydantic models to restrict extra values for
Query
parameters (also applies to
Header
and
Cookie
parameters).
To achieve it, use Pydantic's
model_config = {"extra": "forbid"}
:
from
typing
import
Annotated
,
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
This applies to
Query
,
Header
, and
Cookie
parameters, read the new docs:
Forbid Extra Query Parameters
Forbid Extra Headers
Forbid Extra Cookies
Features
✨ Add support for Pydantic models for parameters using
Query
,
Cookie
,
Header
. PR
## 12199
by
@tiangolo
.
Translations
🌐 Add Portuguese translation for
docs/pt/docs/advanced/security/http-basic-auth.md
. PR
## 12195
by
@ceb10n
.
Internal
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12204
by
@pre-commit-ci[bot]
.
0.114.2
Fixes
🐛 Fix form field regression with
alias
. PR
## 12194
by
@Wurstnase
.
Translations
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/request-form-models.md
. PR
## 12175
by
@ceb10n
.
🌐 Add Chinese translation for
docs/zh/docs/project-generation.md
. PR
## 12170
by
@waketzheng
.
🌐 Add Dutch translation for
docs/nl/docs/python-types.md
. PR
## 12158
by
@maxscheijen
.
Internal
💡 Add comments with instructions for Playwright screenshot scripts. PR
## 12193
by
@tiangolo
.
➕ Add inline-snapshot for tests. PR
## 12189
by
@tiangolo
.
0.114.1
Refactors
⚡️ Improve performance in request body parsing with a cache for internal model fields. PR
## 12184
by
@tiangolo
.
Docs
📝 Remove duplicate line in docs for
docs/en/docs/environment-variables.md
. PR
## 12169
by
@prometek
.
Translations
🌐 Add Portuguese translation for
docs/pt/docs/virtual-environments.md
. PR
## 12163
by
@marcelomarkus
.
🌐 Add Portuguese translation for
docs/pt/docs/environment-variables.md
. PR
## 12162
by
@marcelomarkus
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/testing.md
. PR
## 12164
by
@marcelomarkus
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/debugging.md
. PR
## 12165
by
@marcelomarkus
.
🌐 Add Korean translation for
docs/ko/docs/project-generation.md
. PR
## 12157
by
@BORA040126
.
Internal
⬆ Bump tiangolo/issue-manager from 0.5.0 to 0.5.1. PR
## 12173
by
@dependabot[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12176
by
@pre-commit-ci[bot]
.
👷 Update
issue-manager.yml
. PR
## 12159
by
@tiangolo
.
✏️ Fix typo in
fastapi/params.py
. PR
## 12143
by
@surreal30
.
0.114.0
You can restrict form fields to only include those declared in a Pydantic model and forbid any extra field sent in the request using Pydantic's
model_config = {"extra": "forbid"}
:
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
model_config
=
{
"extra"
:
"forbid"
}
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
Read the new docs:
Form Models - Forbid Extra Form Fields
.
Features
✨ Add support for forbidding extra form fields with Pydantic models. PR
## 12134
by
@tiangolo
.
Docs
📝 Update docs, Form Models section title, to match config name. PR
## 12152
by
@tiangolo
.
Internal
✅ Update internal tests for latest Pydantic, including CI tweaks to install the latest Pydantic. PR
## 12147
by
@tiangolo
.
0.113.0
Now you can declare form fields with Pydantic models:
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
Read the new docs:
Form Models
.
Features
✨ Add support for Pydantic models in
Form
parameters. PR
## 12129
by
@tiangolo
.
Internal
🔧 Update sponsors: Coherence link. PR
## 12130
by
@tiangolo
.
0.112.4
This release is mainly a big internal refactor to enable adding support for Pydantic models for
Form
fields, but that feature comes in the next release.
This release shouldn't affect apps using FastAPI in any way. You don't even have to upgrade to this version yet. It's just a checkpoint. 🤓
Refactors
♻️ Refactor deciding if
embed
body fields, do not overwrite fields, compute once per router, refactor internals in preparation for Pydantic models in
Form
,
Query
and others. PR
## 12117
by
@tiangolo
.
Internal
⏪️ Temporarily revert "✨ Add support for Pydantic models in
Form
parameters" to make a checkpoint release. PR
## 12128
by
@tiangolo
. Restored by PR
## 12129
.
✨ Add support for Pydantic models in
Form
parameters. PR
## 12127
by
@tiangolo
. Reverted by PR
## 12128
to make a checkpoint release with only refactors. Restored by PR
## 12129
.
0.112.3
This release is mainly internal refactors, it shouldn't affect apps using FastAPI in any way. You don't even have to upgrade to this version yet. There are a few bigger releases coming right after. 🚀
Refactors
♻️ Refactor internal
check_file_field()
, rename to
ensure_multipart_is_installed()
to clarify its purpose. PR
## 12106
by
@tiangolo
.
♻️ Rename internal
create_response_field()
to
create_model_field()
as it's used for more than response models. PR
## 12103
by
@tiangolo
.
♻️ Refactor and simplify internal data from
solve_dependencies()
using dataclasses. PR
## 12100
by
@tiangolo
.
♻️ Refactor and simplify internal
analyze_param()
to structure data with dataclasses instead of tuple. PR
## 12099
by
@tiangolo
.
♻️ Refactor and simplify dependencies data structures with dataclasses. PR
## 12098
by
@tiangolo
.
Docs
📝 Add External Link: Techniques and applications of SQLAlchemy global filters in FastAPI. PR
## 12109
by
@TheShubhendra
.
📝 Add note about
time.perf_counter()
in middlewares. PR
## 12095
by
@tiangolo
.
📝 Tweak middleware code sample
time.time()
to
time.perf_counter()
. PR
## 11957
by
@domdent
.
🔧 Update sponsors: Coherence. PR
## 12093
by
@tiangolo
.
📝 Fix async test example not to trigger DeprecationWarning. PR
## 12084
by
@marcinsulikowski
.
📝 Update
docs_src/path_params_numeric_validations/tutorial006.py
. PR
## 11478
by
@MuhammadAshiqAmeer
.
📝 Update comma in
docs/en/docs/async.md
. PR
## 12062
by
@Alec-Gillis
.
📝 Update docs about serving FastAPI: ASGI servers, Docker containers, etc.. PR
## 12069
by
@tiangolo
.
📝 Clarify
response_class
parameter, validations, and returning a response directly. PR
## 12067
by
@tiangolo
.
📝 Fix minor typos and issues in the documentation. PR
## 12063
by
@svlandeg
.
📝 Add note in Docker docs about ensuring graceful shutdowns and lifespan events with
CMD
exec form. PR
## 11960
by
@GPla
.
Translations
🌐 Add Dutch translation for
docs/nl/docs/features.md
. PR
## 12101
by
@maxscheijen
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/testing-events.md
. PR
## 12108
by
@ceb10n
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/security/index.md
. PR
## 12114
by
@ceb10n
.
🌐 Add Dutch translation for
docs/nl/docs/index.md
. PR
## 12042
by
@svlandeg
.
🌐 Update Chinese translation for
docs/zh/docs/how-to/index.md
. PR
## 12070
by
@synthpop123
.
Internal
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12115
by
@pre-commit-ci[bot]
.
⬆ Bump pypa/gh-action-pypi-publish from 1.10.0 to 1.10.1. PR
## 12120
by
@dependabot[bot]
.
⬆ Bump pillow from 10.3.0 to 10.4.0. PR
## 12105
by
@dependabot[bot]
.
💚 Set
include-hidden-files
to
True
when using the
upload-artifact
GH action. PR
## 12118
by
@svlandeg
.
⬆ Bump pypa/gh-action-pypi-publish from 1.9.0 to 1.10.0. PR
## 12112
by
@dependabot[bot]
.
🔧 Update sponsors link: Coherence. PR
## 12097
by
@tiangolo
.
🔧 Update labeler config to handle sponsorships data. PR
## 12096
by
@tiangolo
.
🔧 Update sponsors, remove Kong. PR
## 12085
by
@tiangolo
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12076
by
@pre-commit-ci[bot]
.
👷 Update
latest-changes
GitHub Action. PR
## 12073
by
@tiangolo
.
0.112.2
Fixes
🐛 Fix
allow_inf_nan
option for Param and Body classes. PR
## 11867
by
@giunio-prc
.
🐛 Ensure that
app.include_router
merges nested lifespans. PR
## 9630
by
@Lancetnik
.
Refactors
🎨 Fix typing annotation for semi-internal
FastAPI.add_api_route()
. PR
## 10240
by
@ordinary-jamie
.
⬆️ Upgrade version of Ruff and reformat. PR
## 12032
by
@tiangolo
.
Docs
📝 Fix a typo in
docs/en/docs/virtual-environments.md
. PR
## 12064
by
@aymenkrifa
.
📝 Add docs about Environment Variables and Virtual Environments. PR
## 12054
by
@tiangolo
.
📝 Add Asyncer mention in async docs. PR
## 12037
by
@tiangolo
.
📝 Move the Features docs to the top level to improve the main page menu. PR
## 12036
by
@tiangolo
.
✏️ Fix import typo in reference example for
Security
. PR
## 11168
by
@0shah0
.
📝 Highlight correct line in tutorial
docs/en/docs/tutorial/body-multiple-params.md
. PR
## 11978
by
@svlandeg
.
🔥 Remove Sentry link from Advanced Middleware docs. PR
## 12031
by
@alejsdev
.
📝 Clarify management tasks for translations, multiples files in one PR. PR
## 12030
by
@tiangolo
.
📝 Edit the link to the OpenAPI "Responses Object" and "Response Object" sections in the "Additional Responses in OpenAPI" section. PR
## 11996
by
@VaitoSoi
.
🔨 Specify
email-validator
dependency with dash. PR
## 11515
by
@jirikuncar
.
🌐 Add Spanish translation for
docs/es/docs/project-generation.md
. PR
## 11947
by
@alejsdev
.
📝 Fix minor typo. PR
## 12026
by
@MicaelJarniac
.
📝 Several docs improvements, tweaks, and clarifications. PR
## 11390
by
@nilslindemann
.
📝 Add missing
compresslevel
parameter on docs for
GZipMiddleware
. PR
## 11350
by
@junah201
.
📝 Fix inconsistent response code when item already exists in docs for testing. PR
## 11818
by
@lokomilo
.
📝 Update
docs/en/docs/tutorial/body.md
with Python 3.10 union type example. PR
## 11415
by
@rangzen
.
Translations
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/request_file.md
. PR
## 12018
by
@Joao-Pedro-P-Holanda
.
🌐 Add Japanese translation for
docs/ja/docs/learn/index.md
. PR
## 11592
by
@ukwhatn
.
📝 Update Spanish translation docs for consistency. PR
## 12044
by
@alejsdev
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 12028
by
@xuvjso
.
📝 Update FastAPI People, do not translate to have the most recent info. PR
## 12034
by
@tiangolo
.
🌐 Update Urdu translation for
docs/ur/docs/benchmarks.md
. PR
## 10046
by
@AhsanSheraz
.
Internal
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 12046
by
@pre-commit-ci[bot]
.
🔧 Update coverage config files. PR
## 12035
by
@tiangolo
.
🔨 Standardize shebang across shell scripts. PR
## 11942
by
@gitworkflows
.
⬆ Update sqlalchemy requirement from <1.4.43,>=1.3.18 to >=1.3.18,<2.0.33. PR
## 11979
by
@dependabot[bot]
.
🔊 Remove old ignore warnings. PR
## 11950
by
@tiangolo
.
⬆️ Upgrade griffe-typingdoc for the docs. PR
## 12029
by
@tiangolo
.
🙈 Add .coverage* to
.gitignore
. PR
## 11940
by
@gitworkflows
.
⚙️ Record and show test coverage contexts (what test covers which line). PR
## 11518
by
@slafs
.
0.112.1
Upgrades
⬆️ Allow Starlette 0.38.x, update the pin to
>=0.37.2,<0.39.0
. PR
## 11876
by
@musicinmybrain
.
Docs
📝 Update docs section about "Don't Translate these Pages". PR
## 12022
by
@tiangolo
.
📝 Add documentation for non-translated pages and scripts to verify them. PR
## 12020
by
@tiangolo
.
📝 Update docs about discussions questions. PR
## 11985
by
@tiangolo
.
Translations
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/bigger-applications.md
. PR
## 11971
by
@marcelomarkus
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/testing-websockets.md
. PR
## 11994
by
@ceb10n
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/testing-dependencies.md
. PR
## 11995
by
@ceb10n
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/using-request-directly.md
. PR
## 11956
by
@ceb10n
.
🌐 Add French translation for
docs/fr/docs/tutorial/body-multiple-params.md
. PR
## 11796
by
@pe-brian
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/query-params.md
. PR
## 11557
by
@caomingpei
.
🌐 Update typo in Chinese translation for
docs/zh/docs/advanced/testing-dependencies.md
. PR
## 11944
by
@bestony
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/sub-applications.md
and
docs/pt/docs/advanced/behind-a-proxy.md
. PR
## 11856
by
@marcelomarkus
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/cors.md
and
docs/pt/docs/tutorial/middleware.md
. PR
## 11916
by
@wesinalves
.
🌐 Add French translation for
docs/fr/docs/tutorial/path-params-numeric-validations.md
. PR
## 11788
by
@pe-brian
.
Internal
⬆ Bump pypa/gh-action-pypi-publish from 1.8.14 to 1.9.0. PR
## 11727
by
@dependabot[bot]
.
🔧 Add changelog URL to
pyproject.toml
, shows in PyPI. PR
## 11152
by
@Pierre-VF
.
👷 Do not sync labels as it overrides manually added labels. PR
## 12024
by
@tiangolo
.
👷🏻 Update Labeler GitHub Actions. PR
## 12019
by
@tiangolo
.
🔧 Update configs for MkDocs for languages and social cards. PR
## 12016
by
@tiangolo
.
👷 Update permissions and config for labeler GitHub Action. PR
## 12008
by
@tiangolo
.
👷🏻 Add GitHub Action label-checker. PR
## 12005
by
@tiangolo
.
👷 Add label checker GitHub Action. PR
## 12004
by
@tiangolo
.
👷 Update GitHub Action add-to-project. PR
## 12002
by
@tiangolo
.
🔧 Update labeler GitHub Action. PR
## 12001
by
@tiangolo
.
👷 Add GitHub Action labeler. PR
## 12000
by
@tiangolo
.
👷 Add GitHub Action add-to-project. PR
## 11999
by
@tiangolo
.
📝 Update admonitions in docs missing. PR
## 11998
by
@tiangolo
.
🔨 Update docs.py script to enable dirty reload conditionally. PR
## 11986
by
@tiangolo
.
🔧 Update MkDocs instant previews. PR
## 11982
by
@tiangolo
.
🐛 Fix deploy docs previews script to handle mkdocs.yml files. PR
## 11984
by
@tiangolo
.
💡 Add comment about custom Termynal line-height. PR
## 11976
by
@tiangolo
.
👷 Add alls-green for test-redistribute. PR
## 11974
by
@tiangolo
.
👷 Update docs-previews to handle no docs changes. PR
## 11975
by
@tiangolo
.
🔨 Refactor script
deploy_docs_status.py
to account for deploy URLs with or without trailing slash. PR
## 11965
by
@tiangolo
.
🔒️ Update permissions for deploy-docs action. PR
## 11964
by
@tiangolo
.
👷🏻 Add deploy docs status and preview links to PRs. PR
## 11961
by
@tiangolo
.
🔧 Update docs setup with latest configs and plugins. PR
## 11953
by
@tiangolo
.
🔇 Ignore warning from attrs in Trio. PR
## 11949
by
@tiangolo
.
0.112.0
Breaking Changes
♻️ Add support for
pip install "fastapi[standard]"
with standard dependencies and
python -m fastapi
. PR
## 11935
by
@tiangolo
.
Summary
Install with:
pip
install
"fastapi[standard]"
Other Changes
This adds support for calling the CLI as:
python
-m
fastapi
And it upgrades
fastapi-cli[standard] >=0.0.5
.
Technical Details
Before this,
fastapi
would include the standard dependencies, with Uvicorn and the
fastapi-cli
, etc.
And
fastapi-slim
would not include those standard dependencies.
Now
fastapi
doesn't include those standard dependencies unless you install with
pip install "fastapi[standard]"
.
Before, you would install
pip install fastapi
, now you should include the
standard
optional dependencies (unless you want to exclude one of those):
pip install "fastapi[standard]"
.
This change is because having the standard optional dependencies installed by default was being inconvenient to several users, and having to install instead
fastapi-slim
was not being a feasible solution.
Discussed here:
## 11522
and here:
## 11525
Docs
✏️ Fix typos in docs. PR
## 11926
by
@jianghuyiyuan
.
📝 Tweak management docs. PR
## 11918
by
@tiangolo
.
🚚 Rename GitHub links from tiangolo/fastapi to fastapi/fastapi. PR
## 11913
by
@tiangolo
.
📝 Add docs about FastAPI team and project management. PR
## 11908
by
@tiangolo
.
📝 Re-structure docs main menu. PR
## 11904
by
@tiangolo
.
📝 Update Speakeasy URL. PR
## 11871
by
@ndimares
.
Translations
🌐 Update Portuguese translation for
docs/pt/docs/alternatives.md
. PR
## 11931
by
@ceb10n
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/dependencies/sub-dependencies.md
. PR
## 10515
by
@AlertRED
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/response-change-status-code.md
. PR
## 11863
by
@ceb10n
.
🌐 Add Portuguese translation for
docs/pt/docs/reference/background.md
. PR
## 11849
by
@lucasbalieiro
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 11848
by
@Joao-Pedro-P-Holanda
.
🌐 Add Portuguese translation for
docs/pt/docs/reference/apirouter.md
. PR
## 11843
by
@lucasbalieiro
.
Internal
🔧 Update sponsors: add liblab. PR
## 11934
by
@tiangolo
.
👷 Update GitHub Action label-approved permissions. PR
## 11933
by
@tiangolo
.
👷 Refactor GitHub Action to comment docs deployment URLs and update token. PR
## 11925
by
@tiangolo
.
👷 Update tokens for GitHub Actions. PR
## 11924
by
@tiangolo
.
👷 Update token permissions to comment deployment URL in docs. PR
## 11917
by
@tiangolo
.
👷 Update token permissions for GitHub Actions. PR
## 11915
by
@tiangolo
.
👷 Update GitHub Actions token usage. PR
## 11914
by
@tiangolo
.
👷 Update GitHub Action to notify translations with label
approved-1
. PR
## 11907
by
@tiangolo
.
🔧 Update sponsors, remove Reflex. PR
## 11875
by
@tiangolo
.
🔧 Update sponsors: remove TalkPython. PR
## 11861
by
@tiangolo
.
🔨 Update docs Termynal scripts to not include line nums for local dev. PR
## 11854
by
@tiangolo
.
0.111.1
Upgrades
➖ Remove
orjson
and
ujson
from default dependencies. PR
## 11842
by
@tiangolo
.
These dependencies are still installed when you install with
pip install "fastapi[all]"
. But they are not included in
pip install fastapi
.
📝 Restored Swagger-UI links to use the latest version possible. PR
## 11459
by
@UltimateLobster
.
Docs
✏️ Rewording in
docs/en/docs/fastapi-cli.md
. PR
## 11716
by
@alejsdev
.
📝 Update Hypercorn links in all the docs. PR
## 11744
by
@kittydoor
.
📝 Update docs with Ariadne reference from Starlette to FastAPI. PR
## 11797
by
@DamianCzajkowski
.
📝 Update fastapi instrumentation external link. PR
## 11317
by
@softwarebloat
.
✏️ Fix links to alembic example repo in docs. PR
## 11628
by
@augiwan
.
✏️ Update
docs/en/docs/fastapi-cli.md
. PR
## 11715
by
@alejsdev
.
📝 Update External Links . PR
## 11500
by
@devon2018
.
📝 Add External Link: Tutorial de FastAPI, ¿el mejor framework de Python?. PR
## 11618
by
@EduardoZepeda
.
📝 Fix typo in
docs/en/docs/tutorial/body-multiple-params.md
. PR
## 11698
by
@mwb-u
.
📝 Add External Link: Deploy a Serverless FastAPI App with Neon Postgres and AWS App Runner at any scale. PR
## 11633
by
@ananis25
.
📝 Update
security/first-steps.md
. PR
## 11674
by
@alejsdev
.
📝 Update
security/first-steps.md
. PR
## 11673
by
@alejsdev
.
📝 Update note in
path-params-numeric-validations.md
. PR
## 11672
by
@alejsdev
.
📝 Tweak intro docs about
Annotated
and
Query()
params. PR
## 11664
by
@tiangolo
.
📝 Update JWT auth documentation to use PyJWT instead of pyhon-jose. PR
## 11589
by
@estebanx64
.
📝 Update docs. PR
## 11603
by
@alejsdev
.
✏️ Fix typo: convert every 're-use' to 'reuse'.. PR
## 11598
by
@hasansezertasan
.
✏️ Fix typo in
fastapi/applications.py
. PR
## 11593
by
@petarmaric
.
✏️ Fix link in
fastapi-cli.md
. PR
## 11524
by
@svlandeg
.
Translations
🌐 Add Spanish translation for
docs/es/docs/how-to/graphql.md
. PR
## 11697
by
@camigomezdev
.
🌐 Add Portuguese translation for
docs/pt/docs/reference/index.md
. PR
## 11840
by
@lucasbalieiro
.
🌐 Fix link in German translation. PR
## 11836
by
@anitahammer
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/sub-dependencies.md
. PR
## 11792
by
@Joao-Pedro-P-Holanda
.
🌐 Add Turkish translation for
docs/tr/docs/tutorial/request-forms.md
. PR
## 11553
by
@hasansezertasan
.
🌐 Add Portuguese translation for
docs/pt/docs/reference/exceptions.md
. PR
## 11834
by
@lucasbalieiro
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/global-dependencies.md
. PR
## 11826
by
@Joao-Pedro-P-Holanda
.
🌐 Add Portuguese translation for
docs/pt/docs/how-to/general.md
. PR
## 11825
by
@lucasbalieiro
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/async-tests.md
. PR
## 11808
by
@ceb10n
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/first-steps.md
. PR
## 11809
by
@vkhoroshchak
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/dependencies-in-path-operation-operators.md
. PR
## 11804
by
@Joao-Pedro-P-Holanda
.
🌐 Add Chinese translation for
docs/zh/docs/fastapi-cli.md
. PR
## 11786
by
@logan2d5
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/openapi-webhooks.md
. PR
## 11791
by
@ceb10n
.
🌐 Update Chinese translation for
docs/tutorial/security/oauth2-jwt.md
. PR
## 11781
by
@logan2d5
.
📝 Fix image missing in French translation for
docs/fr/docs/async.md
. PR
## 11787
by
@pe-brian
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/advanced-dependencies.md
. PR
## 11775
by
@ceb10n
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 11768
by
@Joao-Pedro-P-Holanda
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/additional-status-codes.md
. PR
## 11753
by
@ceb10n
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/index.md
. PR
## 11757
by
@Joao-Pedro-P-Holanda
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/settings.md
. PR
## 11739
by
@Joao-Pedro-P-Holanda
.
🌐 Add French translation for
docs/fr/docs/learn/index.md
. PR
## 11712
by
@benjaminvandammeholberton
.
🌐 Add Portuguese translation for
docs/pt/docs/how-to/index.md
. PR
## 11731
by
@vhsenna
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/additional-responses.md
. PR
## 11736
by
@ceb10n
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/benchmarks.md
. PR
## 11713
by
@ceb10n
.
🌐 Fix Korean translation for
docs/ko/docs/tutorial/response-status-code.md
. PR
## 11718
by
@nayeonkinn
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/extra-data-types.md
. PR
## 11711
by
@nayeonkinn
.
🌐 Fix Korean translation for
docs/ko/docs/tutorial/body-nested-models.md
. PR
## 11710
by
@nayeonkinn
.
🌐 Add Portuguese translation for
docs/pt/docs/advanced/fastapi-cli.md
. PR
## 11641
by
@ayr-ton
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/fastapi-people.md
. PR
## 11639
by
@hsuanchi
.
🌐 Add Turkish translation for
docs/tr/docs/advanced/index.md
. PR
## 11606
by
@hasansezertasan
.
🌐 Add Turkish translation for
docs/tr/docs/deployment/cloud.md
. PR
## 11610
by
@hasansezertasan
.
🌐 Add Turkish translation for
docs/tr/docs/advanced/security/index.md
. PR
## 11609
by
@hasansezertasan
.
🌐 Add Turkish translation for
docs/tr/docs/advanced/testing-websockets.md
. PR
## 11608
by
@hasansezertasan
.
🌐 Add Turkish translation for
docs/tr/docs/how-to/general.md
. PR
## 11607
by
@hasansezertasan
.
🌐 Update Chinese translation for
docs/zh/docs/advanced/templates.md
. PR
## 11620
by
@chaoless
.
🌐 Add Turkish translation for
docs/tr/docs/deployment/index.md
. PR
## 11605
by
@hasansezertasan
.
🌐 Add Turkish translation for
docs/tr/docs/tutorial/static-files.md
. PR
## 11599
by
@hasansezertasan
.
🌐 Polish translation for
docs/pl/docs/fastapi-people.md
. PR
## 10196
by
@isulim
.
🌐 Add Turkish translation for
docs/tr/docs/advanced/wsgi.md
. PR
## 11575
by
@hasansezertasan
.
🌐 Add Turkish translation for
docs/tr/docs/tutorial/cookie-params.md
. PR
## 11561
by
@hasansezertasan
.
🌐 Add Russian translation for
docs/ru/docs/about/index.md
. PR
## 10961
by
@s111d
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/sql-databases.md
. PR
## 11539
by
@chaoless
.
🌐 Add Chinese translation for
docs/zh/docs/how-to/configure-swagger-ui.md
. PR
## 11501
by
@Lucas-lyh
.
🌐 Update Chinese translation for
/docs/advanced/security/http-basic-auth.md
. PR
## 11512
by
@nick-cjyx9
.
Internal
♻️ Simplify internal docs script. PR
## 11777
by
@gitworkflows
.
🔧 Update sponsors: add Fine. PR
## 11784
by
@tiangolo
.
🔧 Tweak sponsors: Kong URL. PR
## 11765
by
@tiangolo
.
🔧 Tweak sponsors: Kong URL. PR
## 11764
by
@tiangolo
.
🔧 Update sponsors, add Stainless. PR
## 11763
by
@tiangolo
.
🔧 Update sponsors, add Zuplo. PR
## 11729
by
@tiangolo
.
🔧 Update Sponsor link: Coherence. PR
## 11730
by
@tiangolo
.
👥 Update FastAPI People. PR
## 11669
by
@tiangolo
.
🔧 Add sponsor Kong. PR
## 11662
by
@tiangolo
.
👷 Update Smokeshow, fix sync download artifact and smokeshow configs. PR
## 11563
by
@tiangolo
.
👷 Update Smokeshow download artifact GitHub Action. PR
## 11562
by
@tiangolo
.
👷 Update GitHub actions to download and upload artifacts to v4, for docs and coverage. PR
## 11550
by
@tamird
.
👷 Tweak CI for test-redistribute, add needed env vars for slim. PR
## 11549
by
@tiangolo
.
👥 Update FastAPI People. PR
## 11511
by
@tiangolo
.
0.111.0
Features
✨ Add FastAPI CLI, the new
fastapi
command. PR
## 11522
by
@tiangolo
.
New docs:
FastAPI CLI
.
Try it out with:
$
pip
install
--upgrade
fastapi
$
fastapi
dev
main.py
╭────────── FastAPI CLI - Development mode ───────────╮
│ │
│ Serving at: http://127.0.0.1:8000 │
│ │
│ API docs: http://127.0.0.1:8000/docs │
│ │
│ Running in development mode, for production use: │
│ │
│ fastapi run │
│ │
╰─────────────────────────────────────────────────────╯
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
Refactors
🔧 Add configs and setup for
fastapi-slim
including optional extras
fastapi-slim[standard]
, and
fastapi
including by default the same
standard
extras. PR
## 11503
by
@tiangolo
.
0.110.3
Docs
📝 Update references to Python version, FastAPI supports all the current versions, no need to make the version explicit. PR
## 11496
by
@tiangolo
.
✏️ Fix typo in
fastapi/security/api_key.py
. PR
## 11481
by
@ch33zer
.
✏️ Fix typo in
security/http.py
. PR
## 11455
by
@omarmoo5
.
Translations
🌐 Add Traditional Chinese translation for
docs/zh-hant/benchmarks.md
. PR
## 11484
by
@KNChiu
.
🌐 Update Chinese translation for
docs/zh/docs/fastapi-people.md
. PR
## 11476
by
@billzhong
.
🌐 Add Chinese translation for
docs/zh/docs/how-to/index.md
and
docs/zh/docs/how-to/general.md
. PR
## 11443
by
@billzhong
.
🌐 Add Spanish translation for cookie-params
docs/es/docs/tutorial/cookie-params.md
. PR
## 11410
by
@fabianfalon
.
Internal
⬆ Bump mkdocstrings[python] from 0.23.0 to 0.24.3. PR
## 11469
by
@dependabot[bot]
.
🔨 Update internal scripts and remove unused ones. PR
## 11499
by
@tiangolo
.
🔧 Migrate from Hatch to PDM for the internal build. PR
## 11498
by
@tiangolo
.
⬆️ Upgrade MkDocs Material and re-enable cards. PR
## 11466
by
@tiangolo
.
⬆ Bump pillow from 10.2.0 to 10.3.0. PR
## 11403
by
@dependabot[bot]
.
🔧 Ungroup dependabot updates. PR
## 11465
by
@tiangolo
.
0.110.2
Fixes
🐛 Fix support for query parameters with list types, handle JSON encoding Pydantic
UndefinedType
. PR
## 9929
by
@arjwilliams
.
Refactors
♻️ Simplify Pydantic configs in OpenAPI models in
fastapi/openapi/models.py
. PR
## 10886
by
@JoeTanto2
.
✨ Add support for Pydantic's 2.7 new deprecated Field parameter, remove URL from validation errors response. PR
## 11461
by
@tiangolo
.
Docs
📝 Fix types in examples under
docs_src/extra_data_types
. PR
## 10535
by
@nilslindemann
.
📝 Update references to UJSON. PR
## 11464
by
@tiangolo
.
📝 Tweak docs and translations links, typos, format. PR
## 11389
by
@nilslindemann
.
📝 Fix typo in
docs/es/docs/async.md
. PR
## 11400
by
@fabianfalon
.
📝 Update OpenAPI client generation docs to use
@hey-api/openapi-ts
. PR
## 11339
by
@jordanshatford
.
Translations
🌐 Update Chinese translation for
docs/zh/docs/index.html
. PR
## 11430
by
@waketzheng
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 11411
by
@anton2yakovlev
.
🌐 Add Portuguese translations for
learn/index.md
resources/index.md
help/index.md
about/index.md
. PR
## 10807
by
@nazarepiedady
.
🌐 Update Russian translations for deployments docs. PR
## 11271
by
@Lufa1u
.
🌐 Add Bengali translations for
docs/bn/docs/python-types.md
. PR
## 11376
by
@imtiaz101325
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/security/simple-oauth2.md
. PR
## 5744
by
@KdHyeon0661
.
🌐 Add Korean translation for
docs/ko/docs/help-fastapi.md
. PR
## 4139
by
@kty4119
.
🌐 Add Korean translation for
docs/ko/docs/advanced/events.md
. PR
## 5087
by
@pers0n4
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/path-operation-configuration.md
. PR
## 1954
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/request-forms-and-files.md
. PR
## 1946
by
@SwftAlpc
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 10532
by
@AlertRED
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/debugging.md
. PR
## 5695
by
@JungWooGeon
.
Internal
⬆️ Upgrade version of typer for docs. PR
## 11393
by
@tiangolo
.
0.110.1
Fixes
🐛 Fix parameterless
Depends()
with generics. PR
## 9479
by
@nzig
.
Refactors
♻️ Update mypy. PR
## 11049
by
@k0t3n
.
♻️ Simplify string format with f-strings in
fastapi/applications.py
. PR
## 11335
by
@igeni
.
Upgrades
⬆️ Upgrade Starlette to >=0.37.2,<0.38.0, remove Starlette filterwarning for internal tests. PR
## 11266
by
@nothielf
.
Docs
📝 Tweak docs and translations links and remove old docs translations. PR
## 11381
by
@tiangolo
.
✏️ Fix typo in
fastapi/security/oauth2.py
. PR
## 11368
by
@shandongbinzhou
.
📝 Update links to Pydantic docs to point to new website. PR
## 11328
by
@alejsdev
.
✏️ Fix typo in
docs/en/docs/tutorial/extra-models.md
. PR
## 11329
by
@alejsdev
.
📝 Update
project-generation.md
. PR
## 11326
by
@alejsdev
.
📝 Update External Links. PR
## 11327
by
@alejsdev
.
🔥 Remove link to Pydantic's benchmark, on other i18n pages.. PR
## 11224
by
@hirotoKirimaru
.
✏️ Fix typos in docstrings. PR
## 11295
by
@davidhuser
.
🛠️ Improve Node.js script in docs to generate TypeScript clients. PR
## 11293
by
@alejsdev
.
📝 Update examples for tests to replace "inexistent" for "nonexistent". PR
## 11220
by
@Homesteady
.
📝 Update
python-multipart
GitHub link in all docs from
https://andrew-d.github.io/python-multipart/
to
https://github.com/Kludex/python-multipart
. PR
## 11239
by
@joshjhans
.
Translations
🌐 Add German translation for
docs/de/docs/tutorial/response-status-code.md
. PR
## 10357
by
@nilslindemann
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/query-params.md
. PR
## 3480
by
@jaystone776
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/body.md
. PR
## 3481
by
@jaystone776
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/path-params.md
. PR
## 3479
by
@jaystone776
.
🌐 Update Chinese translation for
docs/tutorial/body-fields.md
. PR
## 3496
by
@jaystone776
.
🌐 Update Chinese translation for
docs/tutorial/extra-models.md
. PR
## 3497
by
@jaystone776
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/metadata.md
. PR
## 2667
by
@tokusumi
.
🌐 Add German translation for
docs/de/docs/contributing.md
. PR
## 10487
by
@nilslindemann
.
🌐 Update Japanese translation of
docs/ja/docs/tutorial/query-params.md
. PR
## 10808
by
@urushio
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/security/get-current-user.md
. PR
## 3842
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/openapi-callbacks.md
. PR
## 3825
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/extending-openapi.md
. PR
## 3823
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/testing-dependencies.md
. PR
## 3819
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/custom-request-and-route.md
. PR
## 3816
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/external-links.md
. PR
## 3833
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/templates.md
. PR
## 3812
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/sub-applications.md
. PR
## 3811
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/async-sql-databases.md
. PR
## 3805
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/middleware.md
. PR
## 3804
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/dataclasses.md
. PR
## 3803
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/using-request-directly.md
. PR
## 3802
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/security/http-basic-auth.md
. PR
## 3801
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/security/oauth2-scopes.md
. PR
## 3800
by
@jaystone776
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/cookie-params.md
. PR
## 3486
by
@jaystone776
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/header-params.md
. PR
## 3487
by
@jaystone776
.
🌐 Update Chinese translation for
docs/tutorial/response-status-code.md
. PR
## 3498
by
@jaystone776
.
🌐 Add German translation for
docs/de/docs/tutorial/security/first-steps.md
. PR
## 10432
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/events.md
. PR
## 10693
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/deployment/cloud.md
. PR
## 10746
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/behind-a-proxy.md
. PR
## 10675
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/help-fastapi.md
. PR
## 10455
by
@nilslindemann
.
🌐 Update German translation for
docs/de/docs/python-types.md
. PR
## 10287
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/path-params.md
. PR
## 10290
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/handling-errors.md
. PR
## 10379
by
@nilslindemann
.
🌐 Update German translation for
docs/de/docs/index.md
. PR
## 10283
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/security/http-basic-auth.md
. PR
## 10651
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/bigger-applications.md
. PR
## 10554
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/path-operation-advanced-configuration.md
. PR
## 10612
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/static-files.md
. PR
## 10584
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/security/oauth2-jwt.md
. PR
## 10522
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/response-model.md
. PR
## 10345
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/extra-models.md
. PR
## 10351
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/body-updates.md
. PR
## 10396
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/alternatives.md
. PR
## 10855
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/templates.md
. PR
## 10678
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/security/oauth2-scopes.md
. PR
## 10643
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/async-tests.md
. PR
## 10708
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/metadata.md
. PR
## 10581
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/testing.md
. PR
## 10586
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/schema-extra-example.md
. PR
## 10597
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/index.md
. PR
## 10611
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/response-directly.md
. PR
## 10618
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/additional-responses.md
. PR
## 10626
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/response-cookies.md
. PR
## 10627
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/response-headers.md
. PR
## 10628
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/response-change-status-code.md
. PR
## 10632
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/advanced-dependencies.md
. PR
## 10633
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/security/index.md
. PR
## 10635
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/using-request-directly.md
. PR
## 10653
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/dataclasses.md
. PR
## 10667
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/middleware.md
. PR
## 10668
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/sub-applications.md
. PR
## 10671
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/websockets.md
. PR
## 10687
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/testing-websockets.md
. PR
## 10703
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/testing-events.md
. PR
## 10704
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/testing-dependencies.md
. PR
## 10706
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/openapi-callbacks.md
. PR
## 10710
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/settings.md
. PR
## 10709
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/wsgi.md
. PR
## 10713
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/deployment/index.md
. PR
## 10733
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/deployment/https.md
. PR
## 10737
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/deployment/manually.md
. PR
## 10738
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/deployment/concepts.md
. PR
## 10744
by
@nilslindemann
.
🌐 Update German translation for
docs/de/docs/features.md
. PR
## 10284
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/deployment/server-workers.md
. PR
## 10747
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/deployment/docker.md
. PR
## 10759
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/how-to/index.md
. PR
## 10769
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/how-to/general.md
. PR
## 10770
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/how-to/graphql.md
. PR
## 10788
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/how-to/custom-request-and-route.md
. PR
## 10789
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/how-to/conditional-openapi.md
. PR
## 10790
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/how-to/separate-openapi-schemas.md
. PR
## 10796
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/how-to/configure-swagger-ui.md
. PR
## 10804
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/how-to/custom-docs-ui-assets.md
. PR
## 10803
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/parameters.md
. PR
## 10814
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/status.md
. PR
## 10815
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/uploadfile.md
. PR
## 10816
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/exceptions.md
. PR
## 10817
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/dependencies.md
. PR
## 10818
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/apirouter.md
. PR
## 10819
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/websockets.md
. PR
## 10822
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/httpconnection.md
. PR
## 10823
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/response.md
. PR
## 10824
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/middleware.md
. PR
## 10837
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/openapi/*.md
. PR
## 10838
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/security/index.md
. PR
## 10839
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/staticfiles.md
. PR
## 10841
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/testclient.md
. PR
## 10843
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/project-generation.md
. PR
## 10851
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/history-design-future.md
. PR
## 10865
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 10422
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/dependencies/global-dependencies.md
. PR
## 10420
by
@nilslindemann
.
🌐 Update German translation for
docs/de/docs/fastapi-people.md
. PR
## 10285
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/dependencies/sub-dependencies.md
. PR
## 10409
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/security/index.md
. PR
## 10429
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 10411
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/extra-data-types.md
. PR
## 10534
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/security/simple-oauth2.md
. PR
## 10504
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/security/get-current-user.md
. PR
## 10439
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/request-forms-and-files.md
. PR
## 10368
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/encoder.md
. PR
## 10385
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/request-forms.md
. PR
## 10361
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/deployment/versions.md
. PR
## 10491
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/async.md
. PR
## 10449
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/cookie-params.md
. PR
## 10323
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 10407
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/dependencies/index.md
. PR
## 10399
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/header-params.md
. PR
## 10326
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/path-params-numeric-validations.md
. PR
## 10307
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/query-params-str-validations.md
. PR
## 10304
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/request-files.md
. PR
## 10364
by
@nilslindemann
.
:globe_with_meridians: Add Portuguese translation for
docs/pt/docs/advanced/templates.md
. PR
## 11338
by
@SamuelBFavarin
.
🌐 Add Bengali translations for
docs/bn/docs/learn/index.md
. PR
## 11337
by
@imtiaz101325
.
🌐 Fix Korean translation for
docs/ko/docs/index.md
. PR
## 11296
by
@choi-haram
.
🌐 Add Korean translation for
docs/ko/docs/about/index.md
. PR
## 11299
by
@choi-haram
.
🌐 Add Korean translation for
docs/ko/docs/advanced/index.md
. PR
## 9613
by
@ElliottLarsen
.
🌐 Add German translation for
docs/de/docs/how-to/extending-openapi.md
. PR
## 10794
by
@nilslindemann
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/metadata.md
. PR
## 11286
by
@jackleeio
.
🌐 Update Chinese translation for
docs/zh/docs/contributing.md
. PR
## 10887
by
@Aruelius
.
🌐 Add Azerbaijani translation for
docs/az/docs/fastapi-people.md
. PR
## 11195
by
@vusallyv
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/dependencies/index.md
. PR
## 11223
by
@kohiry
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/query-params.md
. PR
## 11242
by
@jackleeio
.
🌐 Add Azerbaijani translation for
docs/az/learn/index.md
. PR
## 11192
by
@vusallyv
.
Internal
👥 Update FastAPI People. PR
## 11387
by
@tiangolo
.
⬆ Bump actions/cache from 3 to 4. PR
## 10988
by
@dependabot[bot]
.
⬆ Bump pypa/gh-action-pypi-publish from 1.8.11 to 1.8.14. PR
## 11318
by
@dependabot[bot]
.
⬆ Bump pillow from 10.1.0 to 10.2.0. PR
## 11011
by
@dependabot[bot]
.
⬆ Bump black from 23.3.0 to 24.3.0. PR
## 11325
by
@dependabot[bot]
.
👷 Add cron to run test once a week on monday. PR
## 11377
by
@estebanx64
.
➕ Replace mkdocs-markdownextradata-plugin with mkdocs-macros-plugin. PR
## 11383
by
@tiangolo
.
👷 Disable MkDocs insiders social plugin while an issue in MkDocs Material is handled. PR
## 11373
by
@tiangolo
.
👷 Fix logic for when to install and use MkDocs Insiders. PR
## 11372
by
@tiangolo
.
👷 Do not use Python packages cache for publish. PR
## 11366
by
@tiangolo
.
👷 Add CI to test sdists for redistribution (e.g. Linux distros). PR
## 11365
by
@tiangolo
.
👷 Update build-docs GitHub Action path filter. PR
## 11354
by
@tiangolo
.
🔧 Update Ruff config, add extra ignore rule from SQLModel. PR
## 11353
by
@tiangolo
.
⬆️ Upgrade configuration for Ruff v0.2.0. PR
## 11075
by
@charliermarsh
.
🔧 Update sponsors, add MongoDB. PR
## 11346
by
@tiangolo
.
⬆ Bump dorny/paths-filter from 2 to 3. PR
## 11028
by
@dependabot[bot]
.
⬆ Bump dawidd6/action-download-artifact from 3.0.0 to 3.1.4. PR
## 11310
by
@dependabot[bot]
.
♻️ Refactor computing FastAPI People, include 3 months, 6 months, 1 year, based on comment date, not discussion date. PR
## 11304
by
@tiangolo
.
👥 Update FastAPI People. PR
## 11228
by
@tiangolo
.
🔥 Remove Jina AI QA Bot from the docs. PR
## 11268
by
@nan-wang
.
🔧 Update sponsors, remove Jina, remove Powens, move TestDriven.io. PR
## 11213
by
@tiangolo
.
0.110.0
Breaking Changes
🐛 Fix unhandled growing memory for internal server errors, refactor dependencies with
yield
and
except
to require raising again as in regular Python. PR
## 11191
by
@tiangolo
.
This is a breaking change (and only slightly) if you used dependencies with
yield
, used
except
in those dependencies, and didn't raise again.
This was reported internally by
@rushilsrivastava
as a memory leak when the server had unhandled exceptions that would produce internal server errors, the memory allocated before that point would not be released.
Read the new docs:
Dependencies with
yield
and
except
.
In short, if you had dependencies that looked like:
def
my_dep
():
try
:
yield
except
SomeException
:
pass
Now you need to make sure you raise again after
except
, just as you would in regular Python:
def
my_dep
():
try
:
yield
except
SomeException
:
raise
Docs
✏️ Fix minor typos in
docs/ko/docs/
. PR
## 11126
by
@KaniKim
.
✏️ Fix minor typo in
fastapi/applications.py
. PR
## 11099
by
@JacobHayes
.
Translations
🌐 Add German translation for
docs/de/docs/reference/background.md
. PR
## 10820
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/templating.md
. PR
## 10842
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/external-links.md
. PR
## 10852
by
@nilslindemann
.
🌐 Update Turkish translation for
docs/tr/docs/tutorial/query-params.md
. PR
## 11162
by
@hasansezertasan
.
🌐 Add German translation for
docs/de/docs/reference/encoders.md
. PR
## 10840
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/responses.md
. PR
## 10825
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/reference/request.md
. PR
## 10821
by
@nilslindemann
.
🌐 Add Turkish translation for
docs/tr/docs/tutorial/query-params.md
. PR
## 11078
by
@emrhnsyts
.
🌐 Add German translation for
docs/de/docs/reference/fastapi.md
. PR
## 10813
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/newsletter.md
. PR
## 10853
by
@nilslindemann
.
🌐 Add Traditional Chinese translation for
docs/zh-hant/docs/learn/index.md
. PR
## 11142
by
@hsuanchi
.
🌐 Add Korean translation for
/docs/ko/docs/tutorial/dependencies/global-dependencies.md
. PR
## 11123
by
@riroan
.
🌐 Add Korean translation for
/docs/ko/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 11124
by
@riroan
.
🌐 Add Korean translation for
/docs/ko/docs/tutorial/schema-extra-example.md
. PR
## 11121
by
@KaniKim
.
🌐 Add Korean translation for
/docs/ko/docs/tutorial/body-fields.md
. PR
## 11112
by
@KaniKim
.
🌐 Add Korean translation for
/docs/ko/docs/tutorial/cookie-params.md
. PR
## 11118
by
@riroan
.
🌐 Update Korean translation for
/docs/ko/docs/dependencies/index.md
. PR
## 11114
by
@KaniKim
.
🌐 Update Korean translation for
/docs/ko/docs/deployment/docker.md
. PR
## 11113
by
@KaniKim
.
🌐 Update Turkish translation for
docs/tr/docs/tutorial/first-steps.md
. PR
## 11094
by
@hasansezertasan
.
🌐 Add Spanish translation for
docs/es/docs/advanced/security/index.md
. PR
## 2278
by
@Xaraxx
.
🌐 Add Spanish translation for
docs/es/docs/advanced/response-headers.md
. PR
## 2276
by
@Xaraxx
.
🌐 Add Spanish translation for
docs/es/docs/deployment/index.md
and
~/deployment/versions.md
. PR
## 9669
by
@pabloperezmoya
.
🌐 Add Spanish translation for
docs/es/docs/benchmarks.md
. PR
## 10928
by
@pablocm83
.
🌐 Add Spanish translation for
docs/es/docs/advanced/response-change-status-code.md
. PR
## 11100
by
@alejsdev
.
0.109.2
Upgrades
⬆️ Upgrade version of Starlette to
>= 0.36.3
. PR
## 11086
by
@tiangolo
.
Translations
🌐 Update Turkish translation for
docs/tr/docs/fastapi-people.md
. PR
## 10547
by
@alperiox
.
Internal
🍱 Add new FastAPI logo. PR
## 11090
by
@tiangolo
.
0.109.1
Security fixes
⬆️ Upgrade minimum version of
python-multipart
to
>=0.0.7
to fix a vulnerability when using form data with a ReDos attack. You can also simply upgrade
python-multipart
.
Read more in the
advisory: Content-Type Header ReDoS
.
Features
✨ Include HTTP 205 in status codes with no body. PR
## 10969
by
@tiangolo
.
Refactors
✅ Refactor tests for duplicate operation ID generation for compatibility with other tools running the FastAPI test suite. PR
## 10876
by
@emmettbutler
.
♻️ Simplify string format with f-strings in
fastapi/utils.py
. PR
## 10576
by
@eukub
.
🔧 Fix Ruff configuration unintentionally enabling and re-disabling mccabe complexity check. PR
## 10893
by
@jiridanek
.
✅ Re-enable test in
tests/test_tutorial/test_header_params/test_tutorial003.py
after fix in Starlette. PR
## 10904
by
@ooknimm
.
Docs
📝 Tweak wording in
help-fastapi.md
. PR
## 11040
by
@tiangolo
.
📝 Tweak docs for Behind a Proxy. PR
## 11038
by
@tiangolo
.
📝 Add External Link: 10 Tips for adding SQLAlchemy to FastAPI. PR
## 11036
by
@Donnype
.
📝 Add External Link: Tips on migrating from Flask to FastAPI and vice-versa. PR
## 11029
by
@jtemporal
.
📝 Deprecate old tutorials: Peewee, Couchbase, encode/databases. PR
## 10979
by
@tiangolo
.
✏️ Fix typo in
fastapi/security/oauth2.py
. PR
## 10972
by
@RafalSkolasinski
.
📝 Update
HTTPException
details in
docs/en/docs/tutorial/handling-errors.md
. PR
## 5418
by
@papb
.
✏️ A few tweaks in
docs/de/docs/tutorial/first-steps.md
. PR
## 10959
by
@nilslindemann
.
✏️ Fix link in
docs/en/docs/advanced/async-tests.md
. PR
## 10960
by
@nilslindemann
.
✏️ Fix typos for Spanish documentation. PR
## 10957
by
@jlopezlira
.
📝 Add warning about lifespan functions and backwards compatibility with events. PR
## 10734
by
@jacob-indigo
.
✏️ Fix broken link in
docs/tutorial/sql-databases.md
in several languages. PR
## 10716
by
@theoohoho
.
✏️ Remove broken links from
external_links.yml
. PR
## 10943
by
@Torabek
.
📝 Update template docs with more info about
url_for
. PR
## 5937
by
@EzzEddin
.
📝 Update usage of Token model in security docs. PR
## 9313
by
@piotrszacilowski
.
✏️ Update highlighted line in
docs/en/docs/tutorial/bigger-applications.md
. PR
## 5490
by
@papb
.
📝 Add External Link: Explore How to Effectively Use JWT With FastAPI. PR
## 10212
by
@aanchlia
.
📝 Add hyperlink to
docs/en/docs/tutorial/static-files.md
. PR
## 10243
by
@hungtsetse
.
📝 Add External Link: Instrument a FastAPI service adding tracing with OpenTelemetry and send/show traces in Grafana Tempo. PR
## 9440
by
@softwarebloat
.
📝 Review and rewording of
en/docs/contributing.md
. PR
## 10480
by
@nilslindemann
.
📝 Add External Link: ML serving and monitoring with FastAPI and Evidently. PR
## 9701
by
@mnrozhkov
.
📝 Reword in docs, from "have in mind" to "keep in mind". PR
## 10376
by
@malicious
.
📝 Add External Link: Talk by Jeny Sadadia. PR
## 10265
by
@JenySadadia
.
📝 Add location info to
tutorial/bigger-applications.md
. PR
## 10552
by
@nilslindemann
.
✏️ Fix Pydantic method name in
docs/en/docs/advanced/path-operation-advanced-configuration.md
. PR
## 10826
by
@ahmedabdou14
.
Translations
🌐 Add Spanish translation for
docs/es/docs/external-links.md
. PR
## 10933
by
@pablocm83
.
🌐 Update Korean translation for
docs/ko/docs/tutorial/first-steps.md
,
docs/ko/docs/tutorial/index.md
,
docs/ko/docs/tutorial/path-params.md
, and
docs/ko/docs/tutorial/query-params.md
. PR
## 4218
by
@SnowSuno
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 10870
by
@zhiquanchi
.
🌐 Add Chinese translation for
docs/zh/docs/deployment/concepts.md
. PR
## 10282
by
@xzmeng
.
🌐 Add Azerbaijani translation for
docs/az/docs/index.md
. PR
## 11047
by
@aykhans
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/middleware.md
. PR
## 2829
by
@JeongHyeongKim
.
🌐 Add German translation for
docs/de/docs/tutorial/body-nested-models.md
. PR
## 10313
by
@nilslindemann
.
🌐 Add Persian translation for
docs/fa/docs/tutorial/middleware.md
. PR
## 9695
by
@mojtabapaso
.
🌐 Update Farsi translation for
docs/fa/docs/index.md
. PR
## 10216
by
@theonlykingpin
.
🌐 Add German translation for
docs/de/docs/tutorial/body-fields.md
. PR
## 10310
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/body.md
. PR
## 10295
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/body-multiple-params.md
. PR
## 10308
by
@nilslindemann
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/security/get-current-user.md
. PR
## 2681
by
@sh0nk
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/advanced-dependencies.md
. PR
## 3798
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/events.md
. PR
## 3815
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/behind-a-proxy.md
. PR
## 3820
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/testing-events.md
. PR
## 3818
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/testing-websockets.md
. PR
## 3817
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/testing-database.md
. PR
## 3821
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/deployment/deta.md
. PR
## 3837
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/history-design-future.md
. PR
## 3832
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/project-generation.md
. PR
## 3831
by
@jaystone776
.
🌐 Add Chinese translation for
docs/zh/docs/deployment/docker.md
. PR
## 10296
by
@xzmeng
.
🌐 Update Spanish translation for
docs/es/docs/features.md
. PR
## 10884
by
@pablocm83
.
🌐 Add Spanish translation for
docs/es/docs/newsletter.md
. PR
## 10922
by
@pablocm83
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/background-tasks.md
. PR
## 5910
by
@junah201
.
:globe_with_meridians: Add Turkish translation for
docs/tr/docs/alternatives.md
. PR
## 10502
by
@alperiox
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/dependencies/index.md
. PR
## 10989
by
@KaniKim
.
🌐 Add Korean translation for
/docs/ko/docs/tutorial/body.md
. PR
## 11000
by
@KaniKim
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/schema-extra-example.md
. PR
## 4065
by
@luccasmmg
.
🌐 Add Turkish translation for
docs/tr/docs/history-design-future.md
. PR
## 11012
by
@hasansezertasan
.
🌐 Add Turkish translation for
docs/tr/docs/resources/index.md
. PR
## 11020
by
@hasansezertasan
.
🌐 Add Turkish translation for
docs/tr/docs/how-to/index.md
. PR
## 11021
by
@hasansezertasan
.
🌐 Add German translation for
docs/de/docs/tutorial/query-params.md
. PR
## 10293
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/benchmarks.md
. PR
## 10866
by
@nilslindemann
.
🌐 Add Turkish translation for
docs/tr/docs/learn/index.md
. PR
## 11014
by
@hasansezertasan
.
🌐 Add Persian translation for
docs/fa/docs/tutorial/security/index.md
. PR
## 9945
by
@mojtabapaso
.
🌐 Add Turkish translation for
docs/tr/docs/help/index.md
. PR
## 11013
by
@hasansezertasan
.
🌐 Add Turkish translation for
docs/tr/docs/about/index.md
. PR
## 11006
by
@hasansezertasan
.
🌐 Update Turkish translation for
docs/tr/docs/benchmarks.md
. PR
## 11005
by
@hasansezertasan
.
🌐 Add Italian translation for
docs/it/docs/index.md
. PR
## 5233
by
@matteospanio
.
🌐 Add Korean translation for
docs/ko/docs/help/index.md
. PR
## 10983
by
@KaniKim
.
🌐 Add Korean translation for
docs/ko/docs/features.md
. PR
## 10976
by
@KaniKim
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/security/get-current-user.md
. PR
## 5737
by
@KdHyeon0661
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/security/first-steps.md
. PR
## 10541
by
@AlertRED
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/handling-errors.md
. PR
## 10375
by
@AlertRED
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/encoder.md
. PR
## 10374
by
@AlertRED
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/body-updates.md
. PR
## 10373
by
@AlertRED
.
🌐 Russian translation: updated
fastapi-people.md
.. PR
## 10255
by
@NiKuma0
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/security/index.md
. PR
## 5798
by
@3w36zj6
.
🌐 Add German translation for
docs/de/docs/advanced/generate-clients.md
. PR
## 10725
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/openapi-webhooks.md
. PR
## 10712
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/custom-response.md
. PR
## 10624
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/advanced/additional-status-codes.md
. PR
## 10617
by
@nilslindemann
.
🌐 Add German translation for
docs/de/docs/tutorial/middleware.md
. PR
## 10391
by
@JohannesJungbluth
.
🌐 Add German translation for introduction documents. PR
## 10497
by
@nilslindemann
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/encoder.md
. PR
## 1955
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/extra-data-types.md
. PR
## 1932
by
@SwftAlpc
.
🌐 Add Turkish translation for
docs/tr/docs/async.md
. PR
## 5191
by
@BilalAlpaslan
.
🌐 Add Turkish translation for
docs/tr/docs/project-generation.md
. PR
## 5192
by
@BilalAlpaslan
.
🌐 Add Korean translation for
docs/ko/docs/deployment/docker.md
. PR
## 5657
by
@nearnear
.
🌐 Add Korean translation for
docs/ko/docs/deployment/server-workers.md
. PR
## 4935
by
@jujumilk3
.
🌐 Add Korean translation for
docs/ko/docs/deployment/index.md
. PR
## 4561
by
@jujumilk3
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/path-operation-configuration.md
. PR
## 3639
by
@jungsu-kwon
.
🌐 Modify the description of
zh
- Traditional Chinese. PR
## 10889
by
@cherinyy
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/static-files.md
. PR
## 2957
by
@jeesang7
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/response-model.md
. PR
## 2766
by
@hard-coders
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/body-multiple-params.md
. PR
## 2461
by
@PandaHun
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/query-params-str-validations.md
. PR
## 2415
by
@hard-coders
.
🌐 Add Korean translation for
docs/ko/docs/python-types.md
. PR
## 2267
by
@jrim
.
🌐 Add Korean translation for
docs/ko/docs/tutorial/body-nested-models.md
. PR
## 2506
by
@hard-coders
.
🌐 Add Korean translation for
docs/ko/docs/learn/index.md
. PR
## 10977
by
@KaniKim
.
🌐 Initialize translations for Traditional Chinese. PR
## 10505
by
@hsuanchi
.
✏️ Tweak the german translation of
docs/de/docs/tutorial/index.md
. PR
## 10962
by
@nilslindemann
.
✏️ Fix typo error in
docs/ko/docs/tutorial/path-params.md
. PR
## 10758
by
@2chanhaeng
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 1961
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 1960
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/dependencies/sub-dependencies.md
. PR
## 1959
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/background-tasks.md
. PR
## 2668
by
@tokusumi
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/dependencies/index.md
and
docs/ja/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 1958
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/response-model.md
. PR
## 1938
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/body-multiple-params.md
. PR
## 1903
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/path-params-numeric-validations.md
. PR
## 1902
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/python-types.md
. PR
## 1899
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/handling-errors.md
. PR
## 1953
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/response-status-code.md
. PR
## 1942
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/extra-models.md
. PR
## 1941
by
@SwftAlpc
.
🌐 Add Japanese tranlsation for
docs/ja/docs/tutorial/schema-extra-example.md
. PR
## 1931
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/body-nested-models.md
. PR
## 1930
by
@SwftAlpc
.
🌐 Add Japanese translation for
docs/ja/docs/tutorial/body-fields.md
. PR
## 1923
by
@SwftAlpc
.
🌐 Add German translation for
docs/de/docs/tutorial/index.md
. PR
## 9502
by
@fhabers21
.
🌐 Add German translation for
docs/de/docs/tutorial/background-tasks.md
. PR
## 10566
by
@nilslindemann
.
✏️ Fix typo in
docs/ru/docs/index.md
. PR
## 10672
by
@Delitel-WEB
.
✏️ Fix typos in
docs/zh/docs/tutorial/extra-data-types.md
. PR
## 10727
by
@HiemalBeryl
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 10410
by
@AlertRED
.
Internal
👥 Update FastAPI People. PR
## 11074
by
@tiangolo
.
🔧 Update sponsors: add Coherence. PR
## 11066
by
@tiangolo
.
👷 Upgrade GitHub Action issue-manager. PR
## 11056
by
@tiangolo
.
🍱 Update sponsors: TalkPython badge. PR
## 11052
by
@tiangolo
.
🔧 Update sponsors: TalkPython badge image. PR
## 11048
by
@tiangolo
.
🔧 Update sponsors, remove Deta. PR
## 11041
by
@tiangolo
.
💄 Fix CSS breaking RTL languages (erroneously introduced by a previous RTL PR). PR
## 11039
by
@tiangolo
.
🔧 Add Italian to
mkdocs.yml
. PR
## 11016
by
@alejsdev
.
🔨 Verify
mkdocs.yml
languages in CI, update
docs.py
. PR
## 11009
by
@tiangolo
.
🔧 Update config in
label-approved.yml
to accept translations with 1 reviewer. PR
## 11007
by
@alejsdev
.
👷 Add changes-requested handling in GitHub Action issue manager. PR
## 10971
by
@tiangolo
.
🔧 Group dependencies on dependabot updates. PR
## 10952
by
@Kludex
.
⬆ Bump actions/setup-python from 4 to 5. PR
## 10764
by
@dependabot[bot]
.
⬆ Bump pypa/gh-action-pypi-publish from 1.8.10 to 1.8.11. PR
## 10731
by
@dependabot[bot]
.
⬆ Bump dawidd6/action-download-artifact from 2.28.0 to 3.0.0. PR
## 10777
by
@dependabot[bot]
.
🔧 Add support for translations to languages with a longer code name, like
zh-hant
. PR
## 10950
by
@tiangolo
.
0.109.0
Features
✨ Add support for Python 3.12. PR
## 10666
by
@Jamim
.
Upgrades
⬆️ Upgrade Starlette to >=0.35.0,<0.36.0. PR
## 10938
by
@tiangolo
.
Docs
✏️ Fix typo in
docs/en/docs/alternatives.md
. PR
## 10931
by
@s111d
.
📝 Replace
email
with
username
in
docs_src/security/tutorial007
code examples. PR
## 10649
by
@nilslindemann
.
📝 Add VS Code tutorial link. PR
## 10592
by
@nilslindemann
.
📝 Add notes about Pydantic v2's new
.model_dump()
. PR
## 10929
by
@tiangolo
.
📝 Fix broken link in
docs/en/docs/tutorial/sql-databases.md
. PR
## 10765
by
@HurSungYun
.
📝 Add External Link: FastAPI application monitoring made easy. PR
## 10917
by
@tiangolo
.
✨ Generate automatic language names for docs translations. PR
## 5354
by
@jakul
.
✏️ Fix typos in
docs/en/docs/alternatives.md
and
docs/en/docs/tutorial/dependencies/index.md
. PR
## 10906
by
@s111d
.
✏️ Fix typos in
docs/en/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 10834
by
@Molkree
.
📝 Add article: "Building a RESTful API with FastAPI: Secure Signup and Login Functionality Included". PR
## 9733
by
@dxphilo
.
📝 Add warning about lifecycle events with
AsyncClient
. PR
## 4167
by
@andrew-chang-dewitt
.
✏️ Fix typos in
/docs/reference/exceptions.md
and
/en/docs/reference/status.md
. PR
## 10809
by
@clarencepenz
.
✏️ Fix typo in
openapi-callbacks.md
. PR
## 10673
by
@kayjan
.
✏️ Fix typo in
fastapi/routing.py
. PR
## 10520
by
@sepsh
.
📝 Replace HTTP code returned in case of existing user error in docs for testing. PR
## 4482
by
@TristanMarion
.
📝 Add blog for FastAPI & Supabase. PR
## 6018
by
@theinfosecguy
.
📝 Update example source files for SQL databases with SQLAlchemy. PR
## 9508
by
@s-mustafa
.
📝 Update code examples in docs for body, replace name
create_item
with
update_item
when appropriate. PR
## 5913
by
@OttoAndrey
.
✏️ Fix typo in dependencies with yield source examples. PR
## 10847
by
@tiangolo
.
Translations
🌐 Add Bengali translation for
docs/bn/docs/index.md
. PR
## 9177
by
@Fahad-Md-Kamal
.
✏️ Update Python version in
index.md
in several languages. PR
## 10711
by
@tamago3keran
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/request-forms-and-files.md
. PR
## 10347
by
@AlertRED
.
🌐 Add Ukrainian translation for
docs/uk/docs/index.md
. PR
## 10362
by
@rostik1410
.
✏️ Update Python version in
docs/ko/docs/index.md
. PR
## 10680
by
@Eeap
.
🌐 Add Persian translation for
docs/fa/docs/features.md
. PR
## 5887
by
@amirilf
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/additional-responses.md
. PR
## 10325
by
@ShuibeiC
.
🌐 Fix typos in Russian translations for
docs/ru/docs/tutorial/background-tasks.md
,
docs/ru/docs/tutorial/body-nested-models.md
,
docs/ru/docs/tutorial/debugging.md
,
docs/ru/docs/tutorial/testing.md
. PR
## 10311
by
@AlertRED
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/request-files.md
. PR
## 10332
by
@AlertRED
.
🌐 Add Chinese translation for
docs/zh/docs/deployment/server-workers.md
. PR
## 10292
by
@xzmeng
.
🌐 Add Chinese translation for
docs/zh/docs/deployment/cloud.md
. PR
## 10291
by
@xzmeng
.
🌐 Add Chinese translation for
docs/zh/docs/deployment/manually.md
. PR
## 10279
by
@xzmeng
.
🌐 Add Chinese translation for
docs/zh/docs/deployment/https.md
. PR
## 10277
by
@xzmeng
.
🌐 Add Chinese translation for
docs/zh/docs/deployment/index.md
. PR
## 10275
by
@xzmeng
.
🌐 Add German translation for
docs/de/docs/tutorial/first-steps.md
. PR
## 9530
by
@fhabers21
.
🌐 Update Turkish translation for
docs/tr/docs/index.md
. PR
## 10444
by
@hasansezertasan
.
🌐 Add Chinese translation for
docs/zh/docs/learn/index.md
. PR
## 10479
by
@KAZAMA-DREAM
.
🌐 Add Russian translation for
docs/ru/docs/learn/index.md
. PR
## 10539
by
@AlertRED
.
🌐 Update SQLAlchemy instruction in Chinese translation
docs/zh/docs/tutorial/sql-databases.md
. PR
## 9712
by
@Royc30ne
.
🌐 Add Turkish translation for
docs/tr/docs/external-links.md
. PR
## 10549
by
@hasansezertasan
.
🌐 Add Spanish translation for
docs/es/docs/learn/index.md
. PR
## 10885
by
@pablocm83
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/body-fields.md
. PR
## 10670
by
@ArtemKhymenko
.
🌐 Add Hungarian translation for
/docs/hu/docs/index.md
. PR
## 10812
by
@takacs
.
🌐 Add Turkish translation for
docs/tr/docs/newsletter.md
. PR
## 10550
by
@hasansezertasan
.
🌐 Add Spanish translation for
docs/es/docs/help/index.md
. PR
## 10907
by
@pablocm83
.
🌐 Add Spanish translation for
docs/es/docs/about/index.md
. PR
## 10908
by
@pablocm83
.
🌐 Add Spanish translation for
docs/es/docs/resources/index.md
. PR
## 10909
by
@pablocm83
.
Internal
👥 Update FastAPI People. PR
## 10871
by
@tiangolo
.
👷 Upgrade custom GitHub Action comment-docs-preview-in-pr. PR
## 10916
by
@tiangolo
.
⬆️ Upgrade GitHub Action latest-changes. PR
## 10915
by
@tiangolo
.
👷 Upgrade GitHub Action label-approved. PR
## 10913
by
@tiangolo
.
⬆️ Upgrade GitHub Action label-approved. PR
## 10905
by
@tiangolo
.
0.108.0
Upgrades
⬆️ Upgrade Starlette to
>=0.29.0,<0.33.0
, update docs and usage of templates with new Starlette arguments. Remove pin of AnyIO
>=3.7.1,<4.0.0
, add support for AnyIO 4.x.x. PR
## 10846
by
@tiangolo
.
0.107.0
Upgrades
⬆️ Upgrade Starlette to 0.28.0. PR
## 9636
by
@adriangb
.
Docs
📝 Add docs: Node.js script alternative to update OpenAPI for generated clients. PR
## 10845
by
@alejsdev
.
📝 Restructure Docs section in Contributing page. PR
## 10844
by
@alejsdev
.
0.106.0
Breaking Changes
Using resources from dependencies with
yield
in background tasks is no longer supported.
This change is what supports the new features, read below. 🤓
Dependencies with
yield
,
HTTPException
and Background Tasks
Dependencies with
yield
now can raise
HTTPException
and other exceptions after
yield
. 🎉
Read the new docs here:
Dependencies with
yield
and
HTTPException
.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
data
=
{
"plumbus"
:
{
"description"
:
"Freshly pickled plumbus"
,
"owner"
:
"Morty"
},
"portal-gun"
:
{
"description"
:
"Gun to create portals"
,
"owner"
:
"Rick"
},
}
class
OwnerError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
OwnerError
as
e
:
raise
HTTPException
(
status_code
=
400
,
detail
=
f
"Owner error:
{
e
}
"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
not
in
data
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
item
=
data
[
item_id
]
if
item
[
"owner"
]
!=
username
:
raise
OwnerError
(
username
)
return
item
Before FastAPI 0.106.0, raising exceptions after
yield
was not possible, the exit code in dependencies with
yield
was executed
after
the response was sent, so
Exception Handlers
would have already run.
This was designed this way mainly to allow using the same objects "yielded" by dependencies inside of background tasks, because the exit code would be executed after the background tasks were finished.
Nevertheless, as this would mean waiting for the response to travel through the network while unnecessarily holding a resource in a dependency with yield (for example a database connection), this was changed in FastAPI 0.106.0.
Additionally, a background task is normally an independent set of logic that should be handled separately, with its own resources (e.g. its own database connection).
If you used to rely on this behavior, now you should create the resources for background tasks inside the background task itself, and use internally only data that doesn't depend on the resources of dependencies with
yield
.
For example, instead of using the same database session, you would create a new database session inside of the background task, and you would obtain the objects from the database using this new session. And then instead of passing the object from the database as a parameter to the background task function, you would pass the ID of that object and then obtain the object again inside the background task function.
The sequence of execution before FastAPI 0.106.0 was like this diagram:
Time flows from top to bottom. And each column is one of the parts interacting or executing code.
The new execution flow can be found in the docs:
Execution of dependencies with
yield
.
Features
✨ Add support for raising exceptions (including
HTTPException
) in dependencies with
yield
in the exit code, do not support them in background tasks. PR
## 10831
by
@tiangolo
.
Internal
👥 Update FastAPI People. PR
## 10567
by
@tiangolo
.
0.105.0
Features
✨ Add support for multiple Annotated annotations, e.g.
Annotated[str, Field(), Query()]
. PR
## 10773
by
@tiangolo
.
Refactors
🔥 Remove unused NoneType. PR
## 10774
by
@tiangolo
.
Docs
📝 Tweak default suggested configs for generating clients. PR
## 10736
by
@tiangolo
.
Internal
🔧 Update sponsors, add Scalar. PR
## 10728
by
@tiangolo
.
🔧 Update sponsors, add PropelAuth. PR
## 10760
by
@tiangolo
.
👷 Update build docs, verify README on CI. PR
## 10750
by
@tiangolo
.
🔧 Update sponsors, remove Fern. PR
## 10729
by
@tiangolo
.
🔧 Update sponsors, add Codacy. PR
## 10677
by
@tiangolo
.
🔧 Update sponsors, add Reflex. PR
## 10676
by
@tiangolo
.
📝 Update release notes, move and check latest-changes. PR
## 10588
by
@tiangolo
.
👷 Upgrade latest-changes GitHub Action. PR
## 10587
by
@tiangolo
.
0.104.1
Fixes
📌 Pin Swagger UI version to 5.9.0 temporarily to handle a bug crashing it in 5.9.1. PR
## 10529
by
@alejandraklachquin
.
This is not really a bug in FastAPI but in Swagger UI, nevertheless pinning the version will work while a solution is found on the
Swagger UI side
.
Docs
📝 Update data structure and render for external-links. PR
## 10495
by
@tiangolo
.
✏️ Fix link to SPDX license identifier in
docs/en/docs/tutorial/metadata.md
. PR
## 10433
by
@worldworm
.
📝 Update example validation error from Pydantic v1 to match Pydantic v2 in
docs/en/docs/tutorial/path-params.md
. PR
## 10043
by
@giuliowaitforitdavide
.
✏️ Fix typos in emoji docs and in some source examples. PR
## 10438
by
@afuetterer
.
✏️ Fix typo in
docs/en/docs/reference/dependencies.md
. PR
## 10465
by
@suravshresth
.
✏️ Fix typos and rewordings in
docs/en/docs/tutorial/body-nested-models.md
. PR
## 10468
by
@yogabonito
.
📝 Update docs, remove references to removed
pydantic.Required
in
docs/en/docs/tutorial/query-params-str-validations.md
. PR
## 10469
by
@yogabonito
.
✏️ Fix typo in
docs/en/docs/reference/index.md
. PR
## 10467
by
@tarsil
.
🔥 Remove unnecessary duplicated docstrings. PR
## 10484
by
@tiangolo
.
Internal
✏️ Update Pydantic links to dotenv support. PR
## 10511
by
@White-Mask
.
✏️ Update links in
docs/en/docs/async.md
and
docs/zh/docs/async.md
to make them relative. PR
## 10498
by
@hasnatsajid
.
✏️ Fix links in
docs/em/docs/async.md
. PR
## 10507
by
@hasnatsajid
.
✏️ Fix typo in
docs/em/docs/index.md
, Python 3.8. PR
## 10521
by
@kerriop
.
⬆ Bump pillow from 9.5.0 to 10.1.0. PR
## 10446
by
@dependabot[bot]
.
⬆ Update mkdocs-material requirement from <9.0.0,>=8.1.4 to >=8.1.4,<10.0.0. PR
## 5862
by
@dependabot[bot]
.
⬆ Bump mkdocs-material from 9.1.21 to 9.4.7. PR
## 10545
by
@dependabot[bot]
.
👷 Install MkDocs Material Insiders only when secrets are available, for Dependabot. PR
## 10544
by
@tiangolo
.
🔧 Update sponsors badges, Databento. PR
## 10519
by
@tiangolo
.
👷 Adopt Ruff format. PR
## 10517
by
@tiangolo
.
🔧 Add
CITATION.cff
file for academic citations. PR
## 10496
by
@tiangolo
.
🐛 Fix overriding MKDocs theme lang in hook. PR
## 10490
by
@tiangolo
.
🔥 Drop/close Gitter chat. Questions should go to GitHub Discussions, free conversations to Discord.. PR
## 10485
by
@tiangolo
.
0.104.0
Features
✨ Add reference (code API) docs with PEP 727, add subclass with custom docstrings for
BackgroundTasks
, refactor docs structure. PR
## 10392
by
@tiangolo
. New docs at
FastAPI Reference - Code API
.
Upgrades
⬆️ Drop support for Python 3.7, require Python 3.8 or above. PR
## 10442
by
@tiangolo
.
Internal
⬆ Bump dawidd6/action-download-artifact from 2.27.0 to 2.28.0. PR
## 10268
by
@dependabot[bot]
.
⬆ Bump actions/checkout from 3 to 4. PR
## 10208
by
@dependabot[bot]
.
⬆ Bump pypa/gh-action-pypi-publish from 1.8.6 to 1.8.10. PR
## 10061
by
@dependabot[bot]
.
🔧 Update sponsors, Bump.sh images. PR
## 10381
by
@tiangolo
.
👥 Update FastAPI People. PR
## 10363
by
@tiangolo
.
0.103.2
Refactors
⬆️ Upgrade compatibility with Pydantic v2.4, new renamed functions and JSON Schema input/output models with default values. PR
## 10344
by
@tiangolo
.
Translations
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/extra-data-types.md
. PR
## 10132
by
@ArtemKhymenko
.
🌐 Fix typos in French translations for
docs/fr/docs/advanced/path-operation-advanced-configuration.md
,
docs/fr/docs/alternatives.md
,
docs/fr/docs/async.md
,
docs/fr/docs/features.md
,
docs/fr/docs/help-fastapi.md
,
docs/fr/docs/index.md
,
docs/fr/docs/python-types.md
,
docs/fr/docs/tutorial/body.md
,
docs/fr/docs/tutorial/first-steps.md
,
docs/fr/docs/tutorial/query-params.md
. PR
## 10154
by
@s-rigaud
.
🌐 Add Chinese translation for
docs/zh/docs/async.md
. PR
## 5591
by
@mkdir700
.
🌐 Update Chinese translation for
docs/tutorial/security/simple-oauth2.md
. PR
## 3844
by
@jaystone776
.
🌐 Add Korean translation for
docs/ko/docs/deployment/cloud.md
. PR
## 10191
by
@Sion99
.
🌐 Add Japanese translation for
docs/ja/docs/deployment/https.md
. PR
## 10298
by
@tamtam-fitness
.
🌐 Fix typo in Russian translation for
docs/ru/docs/tutorial/body-fields.md
. PR
## 10224
by
@AlertRED
.
🌐 Add Polish translation for
docs/pl/docs/help-fastapi.md
. PR
## 10121
by
@romabozhanovgithub
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/header-params.md
. PR
## 10226
by
@AlertRED
.
🌐 Add Chinese translation for
docs/zh/docs/deployment/versions.md
. PR
## 10276
by
@xzmeng
.
Internal
🔧 Update sponsors, remove Flint. PR
## 10349
by
@tiangolo
.
🔧 Rename label "awaiting review" to "awaiting-review" to simplify search queries. PR
## 10343
by
@tiangolo
.
🔧 Update sponsors, enable Svix (revert #10228). PR
## 10253
by
@tiangolo
.
🔧 Update sponsors, remove Svix. PR
## 10228
by
@tiangolo
.
🔧 Update sponsors, add Bump.sh. PR
## 10227
by
@tiangolo
.
0.103.1
Fixes
📌 Pin AnyIO to < 4.0.0 to handle an incompatibility while upgrading to Starlette 0.31.1. PR
## 10194
by
@tiangolo
.
Docs
✏️ Fix validation parameter name in docs, from
regex
to
pattern
. PR
## 10085
by
@pablodorrio
.
✏️ Fix indent format in
docs/en/docs/deployment/server-workers.md
. PR
## 10066
by
@tamtam-fitness
.
✏️ Fix Pydantic examples in tutorial for Python types. PR
## 9961
by
@rahulsalgare
.
✏️ Fix link to Pydantic docs in
docs/en/docs/tutorial/extra-data-types.md
. PR
## 10155
by
@hasnatsajid
.
✏️ Fix typo in
docs/en/docs/tutorial/handling-errors.md
. PR
## 10170
by
@poupapaa
.
✏️ Fix typo in
docs/en/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 10172
by
@ragul-kachiappan
.
Translations
🌐 Remove duplicate line in translation for
docs/pt/docs/tutorial/path-params.md
. PR
## 10126
by
@LecoOliveira
.
🌐 Add Yoruba translation for
docs/yo/docs/index.md
. PR
## 10033
by
@AfolabiOlaoluwa
.
🌐 Add Ukrainian translation for
docs/uk/docs/python-types.md
. PR
## 10080
by
@rostik1410
.
🌐 Add Vietnamese translations for
docs/vi/docs/tutorial/first-steps.md
and
docs/vi/docs/tutorial/index.md
. PR
## 10088
by
@magiskboy
.
🌐 Add Ukrainian translation for
docs/uk/docs/alternatives.md
. PR
## 10060
by
@whysage
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/index.md
. PR
## 10079
by
@rostik1410
.
✏️ Fix typos in
docs/en/docs/how-to/separate-openapi-schemas.md
and
docs/en/docs/tutorial/schema-extra-example.md
. PR
## 10189
by
@xzmeng
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/generate-clients.md
. PR
## 9883
by
@funny-cat-happy
.
Refactors
✏️ Fix typos in comment in
fastapi/applications.py
. PR
## 10045
by
@AhsanSheraz
.
✅ Add missing test for OpenAPI examples, it was missing in coverage. PR
## 10188
by
@tiangolo
.
Internal
👥 Update FastAPI People. PR
## 10186
by
@tiangolo
.
0.103.0
Features
✨ Add support for
openapi_examples
in all FastAPI parameters. PR
## 10152
by
@tiangolo
.
New docs:
OpenAPI-specific examples
.
Docs
📝 Add note to docs about Separate Input and Output Schemas with FastAPI version. PR
## 10150
by
@tiangolo
.
0.102.0
Features
✨ Add support for disabling the separation of input and output JSON Schemas in OpenAPI with Pydantic v2 with
separate_input_output_schemas=False
. PR
## 10145
by
@tiangolo
.
New docs
Separate OpenAPI Schemas for Input and Output or Not
.
This PR also includes a new setup (internal tools) for generating screenshots for the docs.
Refactors
♻️ Refactor tests for new Pydantic 2.2.1. PR
## 10115
by
@tiangolo
.
Docs
📝 Add new docs section, How To - Recipes, move docs that don't have to be read by everyone to How To. PR
## 10114
by
@tiangolo
.
📝 Update Advanced docs, add links to sponsor courses. PR
## 10113
by
@tiangolo
.
📝 Update docs for generating clients. PR
## 10112
by
@tiangolo
.
📝 Tweak MkDocs and add redirects. PR
## 10111
by
@tiangolo
.
📝 Restructure docs for cloud providers, include links to sponsors. PR
## 10110
by
@tiangolo
.
Internal
🔧 Update sponsors, add Speakeasy. PR
## 10098
by
@tiangolo
.
0.101.1
Fixes
✨ Add
ResponseValidationError
printable details, to show up in server error logs. PR
## 10078
by
@tiangolo
.
Refactors
✏️ Fix typo in deprecation warnings in
fastapi/params.py
. PR
## 9854
by
@russbiggs
.
✏️ Fix typos in comments on internal code in
fastapi/concurrency.py
and
fastapi/routing.py
. PR
## 9590
by
@ElliottLarsen
.
Docs
✏️ Fix typo in release notes. PR
## 9835
by
@francisbergin
.
📝 Add external article: Build an SMS Spam Classifier Serverless Database with FaunaDB and FastAPI. PR
## 9847
by
@adejumoridwan
.
📝 Fix typo in
docs/en/docs/contributing.md
. PR
## 9878
by
@VicenteMerino
.
📝 Fix code highlighting in
docs/en/docs/tutorial/bigger-applications.md
. PR
## 9806
by
@theonlykingpin
.
Translations
🌐 Add Japanese translation for
docs/ja/docs/deployment/concepts.md
. PR
## 10062
by
@tamtam-fitness
.
🌐 Add Japanese translation for
docs/ja/docs/deployment/server-workers.md
. PR
## 10064
by
@tamtam-fitness
.
🌐 Update Japanese translation for
docs/ja/docs/deployment/docker.md
. PR
## 10073
by
@tamtam-fitness
.
🌐 Add Ukrainian translation for
docs/uk/docs/fastapi-people.md
. PR
## 10059
by
@rostik1410
.
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/cookie-params.md
. PR
## 10032
by
@rostik1410
.
🌐 Add Russian translation for
docs/ru/docs/deployment/docker.md
. PR
## 9971
by
@Xewus
.
🌐 Add Vietnamese translation for
docs/vi/docs/python-types.md
. PR
## 10047
by
@magiskboy
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/dependencies/global-dependencies.md
. PR
## 9970
by
@dudyaosuplayer
.
🌐 Add Urdu translation for
docs/ur/docs/benchmarks.md
. PR
## 9974
by
@AhsanSheraz
.
Internal
🔧 Add sponsor Porter. PR
## 10051
by
@tiangolo
.
🔧 Update sponsors, add Jina back as bronze sponsor. PR
## 10050
by
@tiangolo
.
⬆ Bump mypy from 1.4.0 to 1.4.1. PR
## 9756
by
@dependabot[bot]
.
⬆ Bump mkdocs-material from 9.1.17 to 9.1.21. PR
## 9960
by
@dependabot[bot]
.
0.101.0
Features
✨ Enable Pydantic's serialization mode for responses, add support for Pydantic's
computed_field
, better OpenAPI for response models, proper required attributes, better generated clients. PR
## 10011
by
@tiangolo
.
Refactors
✅ Fix tests for compatibility with pydantic 2.1.1. PR
## 9943
by
@dmontagu
.
✅ Fix test error in Windows for
jsonable_encoder
. PR
## 9840
by
@iudeen
.
Upgrades
📌 Do not allow Pydantic 2.1.0 that breaks (require 2.1.1). PR
## 10012
by
@tiangolo
.
Translations
🌐 Add Russian translation for
docs/ru/docs/tutorial/security/index.md
. PR
## 9963
by
@eVery1337
.
🌐 Remove Vietnamese note about missing translation. PR
## 9957
by
@tiangolo
.
Internal
👷 Add GitHub Actions step dump context to debug external failures. PR
## 10008
by
@tiangolo
.
🔧 Restore MkDocs Material pin after the fix. PR
## 10001
by
@tiangolo
.
🔧 Update the Question template to ask for the Pydantic version. PR
## 10000
by
@tiangolo
.
📍 Update MkDocs Material dependencies. PR
## 9986
by
@tiangolo
.
👥 Update FastAPI People. PR
## 9999
by
@tiangolo
.
🐳 Update Dockerfile with compatibility versions, to upgrade later. PR
## 9998
by
@tiangolo
.
➕ Add pydantic-settings to FastAPI People dependencies. PR
## 9988
by
@tiangolo
.
♻️ Update FastAPI People logic with new Pydantic. PR
## 9985
by
@tiangolo
.
🍱 Update sponsors, Fern badge. PR
## 9982
by
@tiangolo
.
👷 Deploy docs to Cloudflare Pages. PR
## 9978
by
@tiangolo
.
🔧 Update sponsor Fern. PR
## 9979
by
@tiangolo
.
👷 Update CI debug mode with Tmate. PR
## 9977
by
@tiangolo
.
0.100.1
Fixes
🐛 Replace
MultHostUrl
to
AnyUrl
for compatibility with older versions of Pydantic v1. PR
## 9852
by
@Kludex
.
Docs
📝 Update links for self-hosted Swagger UI, point to v5, for OpenAPI 31.0. PR
## 9834
by
@tiangolo
.
Translations
🌐 Add Ukrainian translation for
docs/uk/docs/tutorial/body.md
. PR
## 4574
by
@ss-o-furda
.
🌐 Add Vietnamese translation for
docs/vi/docs/features.md
and
docs/vi/docs/index.md
. PR
## 3006
by
@magiskboy
.
🌐 Add Korean translation for
docs/ko/docs/async.md
. PR
## 4179
by
@NinaHwang
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/background-tasks.md
. PR
## 9812
by
@wdh99
.
🌐 Add French translation for
docs/fr/docs/tutorial/query-params-str-validations.md
. PR
## 4075
by
@Smlep
.
🌐 Add French translation for
docs/fr/docs/tutorial/index.md
. PR
## 2234
by
@JulianMaurin
.
🌐 Add French translation for
docs/fr/docs/contributing.md
. PR
## 2132
by
@JulianMaurin
.
🌐 Add French translation for
docs/fr/docs/benchmarks.md
. PR
## 2155
by
@clemsau
.
🌐 Update Chinese translations with new source files. PR
## 9738
by
@mahone3297
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/request-forms.md
. PR
## 9841
by
@dedkot01
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/handling-errors.md
. PR
## 9485
by
@Creat55
.
Internal
🔧 Update sponsors, add Fern. PR
## 9956
by
@tiangolo
.
👷 Update FastAPI People token. PR
## 9844
by
@tiangolo
.
👥 Update FastAPI People. PR
## 9775
by
@tiangolo
.
👷 Update MkDocs Material token. PR
## 9843
by
@tiangolo
.
👷 Update token for latest changes. PR
## 9842
by
@tiangolo
.
0.100.0
✨ Support for
Pydantic v2
✨
Pydantic version 2 has the
core
re-written in
Rust
and includes a lot of improvements and features, for example:
Improved
correctness
in corner cases.
Safer
types.
Better
performance
and
less energy
consumption.
Better
extensibility
.
etc.
...all this while keeping the
same Python API
. In most of the cases, for simple models, you can simply upgrade the Pydantic version and get all the benefits. 🚀
In some cases, for pure data validation and processing, you can get performance improvements of
20x
or more. This means 2,000% or more. 🤯
When you use
FastAPI
, there's a lot more going on, processing the request and response, handling dependencies, executing
your own code
, and particularly,
waiting for the network
. But you will probably still get some nice performance improvements just from the upgrade.
The focus of this release is
compatibility
with Pydantic v1 and v2, to make sure your current apps keep working. Later there will be more focus on refactors, correctness, code improvements, and then
performance
improvements. Some third-party early beta testers that ran benchmarks on the beta releases of FastAPI reported improvements of
2x - 3x
. Which is not bad for just doing
pip install --upgrade fastapi pydantic
. This was not an official benchmark and I didn't check it myself, but it's a good sign.
Migration
Check out the
Pydantic migration guide
.
For the things that need changes in your Pydantic models, the Pydantic team built
bump-pydantic
.
A command line tool that will
process your code
and update most of the things
automatically
for you. Make sure you have your code in git first, and review each of the changes to make sure everything is correct before committing the changes.
Pydantic v1
This version of FastAPI still supports Pydantic v1
. And although Pydantic v1 will be deprecated at some point, it will still be supported for a while.
This means that you can install the new Pydantic v2, and if something fails, you can install Pydantic v1 while you fix any problems you might have, but having the latest FastAPI.
There are
tests for both Pydantic v1 and v2
, and test
coverage
is kept at
100%
.
Changes
There are
new parameter
fields supported by Pydantic
Field()
for:
Path()
Query()
Header()
Cookie()
Body()
Form()
File()
The new parameter fields are:
default_factory
alias_priority
validation_alias
serialization_alias
discriminator
strict
multiple_of
allow_inf_nan
max_digits
decimal_places
json_schema_extra
...you can read about them in the Pydantic docs.
The parameter
regex
has been deprecated and replaced by
pattern
.
You can read more about it in the docs for
Query Parameters and String Validations: Add regular expressions
.
New Pydantic models use an improved and simplified attribute
model_config
that takes a simple dict instead of an internal class
Config
for their configuration.
You can read more about it in the docs for
Declare Request Example Data
.
The attribute
schema_extra
for the internal class
Config
has been replaced by the key
json_schema_extra
in the new
model_config
dict.
You can read more about it in the docs for
Declare Request Example Data
.
When you install
"fastapi[all]"
it now also includes:
pydantic-settings
- for settings management.
pydantic-extra-types
- for extra types to be used with Pydantic.
Now Pydantic Settings is an additional optional package (included in
"fastapi[all]"
). To use settings you should now import
from pydantic_settings import BaseSettings
instead of importing from
pydantic
directly.
You can read more about it in the docs for
Settings and Environment Variables
.
PR
## 9816
by
@tiangolo
, included all the work done (in multiple PRs) on the beta branch (
main-pv2
).
0.99.1
Fixes
🐛 Fix JSON Schema accepting bools as valid JSON Schemas, e.g.
additionalProperties: false
. PR
## 9781
by
@tiangolo
.
Docs
📝 Update source examples to use new JSON Schema examples field. PR
## 9776
by
@tiangolo
.
0.99.0
Features
✨ Add support for OpenAPI 3.1.0. PR
## 9770
by
@tiangolo
.
New support for documenting
webhooks
, read the new docs here:
Advanced User Guide: OpenAPI Webhooks
.
Upgrade OpenAPI 3.1.0, this uses JSON Schema 2020-12.
Upgrade Swagger UI to version 5.x.x, that supports OpenAPI 3.1.0.
Updated
examples
field in
Query()
,
Cookie()
,
Body()
, etc. based on the latest JSON Schema and OpenAPI. Now it takes a list of examples and they are included directly in the JSON Schema, not outside. Read more about it (including the historical technical details) in the updated docs:
Tutorial: Declare Request Example Data
.
✨ Add support for
deque
objects and children in
jsonable_encoder
. PR
## 9433
by
@cranium
.
Docs
📝 Fix form for the FastAPI and friends newsletter. PR
## 9749
by
@tiangolo
.
Translations
🌐 Add Persian translation for
docs/fa/docs/advanced/sub-applications.md
. PR
## 9692
by
@mojtabapaso
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/response-model.md
. PR
## 9675
by
@glsglsgls
.
Internal
🔨 Enable linenums in MkDocs Material during local live development to simplify highlighting code. PR
## 9769
by
@tiangolo
.
⬆ Update httpx requirement from <0.24.0,>=0.23.0 to >=0.23.0,<0.25.0. PR
## 9724
by
@dependabot[bot]
.
⬆ Bump mkdocs-material from 9.1.16 to 9.1.17. PR
## 9746
by
@dependabot[bot]
.
🔥 Remove missing translation dummy pages, no longer necessary. PR
## 9751
by
@tiangolo
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 9259
by
@pre-commit-ci[bot]
.
✨ Add Material for MkDocs Insiders features and cards. PR
## 9748
by
@tiangolo
.
🔥 Remove languages without translations. PR
## 9743
by
@tiangolo
.
✨ Refactor docs for building scripts, use MkDocs hooks, simplify (remove) configs for languages. PR
## 9742
by
@tiangolo
.
🔨 Add MkDocs hook that renames sections based on the first index file. PR
## 9737
by
@tiangolo
.
👷 Make cron jobs run only on main repo, not on forks, to avoid error notifications from missing tokens. PR
## 9735
by
@tiangolo
.
🔧 Update MkDocs for other languages. PR
## 9734
by
@tiangolo
.
👷 Refactor Docs CI, run in multiple workers with a dynamic matrix to optimize speed. PR
## 9732
by
@tiangolo
.
🔥 Remove old internal GitHub Action watch-previews that is no longer needed. PR
## 9730
by
@tiangolo
.
⬆️ Upgrade MkDocs and MkDocs Material. PR
## 9729
by
@tiangolo
.
👷 Build and deploy docs only on docs changes. PR
## 9728
by
@tiangolo
.
0.98.0
Features
✨ Allow disabling
redirect_slashes
at the FastAPI app level. PR
## 3432
by
@cyberlis
.
Docs
📝 Update docs on Pydantic using ujson internally. PR
## 5804
by
@mvasilkov
.
✏ Rewording in
docs/en/docs/tutorial/debugging.md
. PR
## 9581
by
@ivan-abc
.
📝 Add german blog post (Domain-driven Design mit Python und FastAPI). PR
## 9261
by
@msander
.
✏️ Tweak wording in
docs/en/docs/tutorial/security/index.md
. PR
## 9561
by
@jyothish-mohan
.
📝 Update
Annotated
notes in
docs/en/docs/tutorial/schema-extra-example.md
. PR
## 9620
by
@Alexandrhub
.
✏️ Fix typo
Annotation
->
Annotated
in
docs/en/docs/tutorial/query-params-str-validations.md
. PR
## 9625
by
@mccricardo
.
📝 Use in memory database for testing SQL in docs. PR
## 1223
by
@HarshaLaxman
.
Translations
🌐 Add Russian translation for
docs/ru/docs/tutorial/metadata.md
. PR
## 9681
by
@TabarakoAkula
.
🌐 Fix typo in Spanish translation for
docs/es/docs/tutorial/first-steps.md
. PR
## 9571
by
@lilidl-nft
.
🌐 Add Russian translation for
docs/tutorial/path-operation-configuration.md
. PR
## 9696
by
@TabarakoAkula
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/security/index.md
. PR
## 9666
by
@lordqyxz
.
🌐 Add Chinese translations for
docs/zh/docs/advanced/settings.md
. PR
## 9652
by
@ChoyeonChern
.
🌐 Add Chinese translations for
docs/zh/docs/advanced/websockets.md
. PR
## 9651
by
@ChoyeonChern
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/testing.md
. PR
## 9641
by
@wdh99
.
🌐 Add Russian translation for
docs/tutorial/extra-models.md
. PR
## 9619
by
@ivan-abc
.
🌐 Add Russian translation for
docs/tutorial/cors.md
. PR
## 9608
by
@ivan-abc
.
🌐 Add Polish translation for
docs/pl/docs/features.md
. PR
## 5348
by
@mbroton
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/body-nested-models.md
. PR
## 9605
by
@Alexandrhub
.
Internal
⬆ Bump ruff from 0.0.272 to 0.0.275. PR
## 9721
by
@dependabot[bot]
.
⬆ Update uvicorn[standard] requirement from <0.21.0,>=0.12.0 to >=0.12.0,<0.23.0. PR
## 9463
by
@dependabot[bot]
.
⬆ Bump mypy from 1.3.0 to 1.4.0. PR
## 9719
by
@dependabot[bot]
.
⬆ Update pre-commit requirement from <3.0.0,>=2.17.0 to >=2.17.0,<4.0.0. PR
## 9251
by
@dependabot[bot]
.
⬆ Bump pypa/gh-action-pypi-publish from 1.8.5 to 1.8.6. PR
## 9482
by
@dependabot[bot]
.
✏️ Fix tooltips for light/dark theme toggler in docs. PR
## 9588
by
@pankaj1707k
.
🔧 Set minimal hatchling version needed to build the package. PR
## 9240
by
@mgorny
.
📝 Add repo link to PyPI. PR
## 9559
by
@JacobCoffee
.
✏️ Fix typos in data for tests. PR
## 4958
by
@ryanrussell
.
🔧 Update sponsors, add Flint. PR
## 9699
by
@tiangolo
.
👷 Lint in CI only once, only with one version of Python, run tests with all of them. PR
## 9686
by
@tiangolo
.
0.97.0
Features
✨ Add support for
dependencies
in WebSocket routes. PR
## 4534
by
@paulo-raca
.
✨ Add exception handler for
WebSocketRequestValidationError
(which also allows to override it). PR
## 6030
by
@kristjanvalur
.
Refactors
⬆️ Upgrade and fully migrate to Ruff, remove isort, includes a couple of tweaks suggested by the new version of Ruff. PR
## 9660
by
@tiangolo
.
♻️ Update internal type annotations and upgrade mypy. PR
## 9658
by
@tiangolo
.
♻️ Simplify
AsyncExitStackMiddleware
as without Python 3.6
AsyncExitStack
is always available. PR
## 9657
by
@tiangolo
.
Upgrades
⬆️ Upgrade Black. PR
## 9661
by
@tiangolo
.
Internal
💚 Update CI cache to fix installs when dependencies change. PR
## 9659
by
@tiangolo
.
⬇️ Separate requirements for development into their own requirements.txt files, they shouldn't be extras. PR
## 9655
by
@tiangolo
.
0.96.1
Fixes
🐛 Fix
HTTPException
header type annotations. PR
## 9648
by
@tiangolo
.
🐛 Fix OpenAPI model fields int validations,
gte
to
ge
. PR
## 9635
by
@tiangolo
.
Upgrades
📌 Update minimum version of Pydantic to >=1.7.4. This fixes an issue when trying to use an old version of Pydantic. PR
## 9567
by
@Kludex
.
Refactors
♻ Remove
media_type
from
ORJSONResponse
as it's inherited from the parent class. PR
## 5805
by
@Kludex
.
♻ Instantiate
HTTPException
only when needed, optimization refactor. PR
## 5356
by
@pawamoy
.
Docs
🔥 Remove link to Pydantic's benchmark, as it was removed there. PR
## 5811
by
@Kludex
.
Translations
🌐 Fix spelling in Indonesian translation of
docs/id/docs/tutorial/index.md
. PR
## 5635
by
@purwowd
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/index.md
. PR
## 5896
by
@Wilidon
.
🌐 Add Chinese translations for
docs/zh/docs/advanced/response-change-status-code.md
and
docs/zh/docs/advanced/response-headers.md
. PR
## 9544
by
@ChoyeonChern
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/schema-extra-example.md
. PR
## 9621
by
@Alexandrhub
.
Internal
🔧 Add sponsor Platform.sh. PR
## 9650
by
@tiangolo
.
👷 Add custom token to Smokeshow and Preview Docs for download-artifact, to prevent API rate limits. PR
## 9646
by
@tiangolo
.
👷 Add custom tokens for GitHub Actions to avoid rate limits. PR
## 9647
by
@tiangolo
.
0.96.0
Features
⚡ Update
create_cloned_field
to use a global cache and improve startup performance. PR
## 4645
by
@madkinsz
and previous original PR by
@huonw
.
Docs
📝 Update Deta deployment tutorial for compatibility with Deta Space. PR
## 6004
by
@mikBighne98
.
✏️ Fix typo in Deta deployment tutorial. PR
## 9501
by
@lemonyte
.
Translations
🌐 Add Russian translation for
docs/tutorial/body.md
. PR
## 3885
by
@solomein-sv
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/static-files.md
. PR
## 9580
by
@Alexandrhub
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/query-params.md
. PR
## 9584
by
@Alexandrhub
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/first-steps.md
. PR
## 9471
by
@AGolicyn
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/debugging.md
. PR
## 9579
by
@Alexandrhub
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/path-params.md
. PR
## 9519
by
@AGolicyn
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/static-files.md
. PR
## 9436
by
@wdh99
.
🌐 Update Spanish translation including new illustrations in
docs/es/docs/async.md
. PR
## 9483
by
@andresbermeoq
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/path-params-numeric-validations.md
. PR
## 9563
by
@ivan-abc
.
🌐 Add Russian translation for
docs/ru/docs/deployment/concepts.md
. PR
## 9577
by
@Xewus
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/body-multiple-params.md
. PR
## 9586
by
@Alexandrhub
.
Internal
👥 Update FastAPI People. PR
## 9602
by
@github-actions[bot]
.
🔧 Update sponsors, remove InvestSuite. PR
## 9612
by
@tiangolo
.
0.95.2
⬆️ Upgrade Starlette version to
>=0.27.0
for a security release. PR
## 9541
by
@tiangolo
. Details on
Starlette's security advisory
.
Translations
🌐 Add Portuguese translation for
docs/pt/docs/advanced/events.md
. PR
## 9326
by
@oandersonmagalhaes
.
🌐 Add Russian translation for
docs/ru/docs/deployment/manually.md
. PR
## 9417
by
@Xewus
.
🌐 Add setup for translations to Lao. PR
## 9396
by
@TheBrown
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/testing.md
. PR
## 9403
by
@Xewus
.
🌐 Add Russian translation for
docs/ru/docs/deployment/https.md
. PR
## 9428
by
@Xewus
.
✏ Fix command to install requirements in Windows. PR
## 9445
by
@MariiaRomanuik
.
🌐 Add French translation for
docs/fr/docs/advanced/response-directly.md
. PR
## 9415
by
@axel584
.
🌐 Initiate Czech translation setup. PR
## 9288
by
@3p1463k
.
✏ Fix typo in Portuguese docs for
docs/pt/docs/index.md
. PR
## 9337
by
@lucasbalieiro
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/response-status-code.md
. PR
## 9370
by
@nadia3373
.
Internal
🐛 Fix
flask.escape
warning for internal tests. PR
## 9468
by
@samuelcolvin
.
✅ Refactor 2 tests, for consistency and simplification. PR
## 9504
by
@tiangolo
.
✅ Refactor OpenAPI tests, prepare for Pydantic v2. PR
## 9503
by
@tiangolo
.
⬆ Bump dawidd6/action-download-artifact from 2.26.0 to 2.27.0. PR
## 9394
by
@dependabot[bot]
.
💚 Disable setup-python pip cache in CI. PR
## 9438
by
@tiangolo
.
⬆ Bump pypa/gh-action-pypi-publish from 1.6.4 to 1.8.5. PR
## 9346
by
@dependabot[bot]
.
0.95.1
Fixes
🐛 Fix using
Annotated
in routers or path operations decorated multiple times. PR
## 9315
by
@sharonyogev
.
Docs
🌐 🔠 📄 🐢 Translate docs to Emoji 🥳 🎉 💥 🤯 🤯. PR
## 5385
by
@LeeeeT
.
📝 Add notification message warning about old versions of FastAPI not supporting
Annotated
. PR
## 9298
by
@grdworkin
.
📝 Fix typo in
docs/en/docs/advanced/behind-a-proxy.md
. PR
## 5681
by
@Leommjr
.
✏ Fix wrong import from typing module in Persian translations for
docs/fa/docs/index.md
. PR
## 6083
by
@Kimiaattaei
.
✏️ Fix format, remove unnecessary asterisks in
docs/en/docs/help-fastapi.md
. PR
## 9249
by
@armgabrielyan
.
✏ Fix typo in
docs/en/docs/tutorial/query-params-str-validations.md
. PR
## 9272
by
@nicornk
.
✏ Fix typo/bug in inline code example in
docs/en/docs/tutorial/query-params-str-validations.md
. PR
## 9273
by
@tim-habitat
.
✏ Fix typo in
docs/en/docs/tutorial/path-params-numeric-validations.md
. PR
## 9282
by
@aadarsh977
.
✏ Fix typo: 'wll' to 'will' in
docs/en/docs/tutorial/query-params-str-validations.md
. PR
## 9380
by
@dasstyxx
.
Translations
🌐 Add French translation for
docs/fr/docs/advanced/index.md
. PR
## 5673
by
@axel584
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/body-nested-models.md
. PR
## 4053
by
@luccasmmg
.
🌐 Add Russian translation for
docs/ru/docs/alternatives.md
. PR
## 5994
by
@Xewus
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/extra-models.md
. PR
## 5912
by
@LorhanSohaky
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/path-operation-configuration.md
. PR
## 5936
by
@LorhanSohaky
.
🌐 Add Russian translation for
docs/ru/docs/contributing.md
. PR
## 6002
by
@stigsanek
.
🌐 Add Korean translation for
docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 9176
by
@sehwan505
.
🌐 Add Russian translation for
docs/ru/docs/project-generation.md
. PR
## 9243
by
@Xewus
.
🌐 Add French translation for
docs/fr/docs/index.md
. PR
## 9265
by
@frabc
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/query-params-str-validations.md
. PR
## 9267
by
@dedkot01
.
🌐 Add Russian translation for
docs/ru/docs/benchmarks.md
. PR
## 9271
by
@Xewus
.
Internal
🔧 Update sponsors: remove Jina. PR
## 9388
by
@tiangolo
.
🔧 Update sponsors, add databento, remove Ines's course and StriveWorks. PR
## 9351
by
@tiangolo
.
0.95.0
Highlights
This release adds support for dependencies and parameters using
Annotated
and recommends its usage. ✨
This has
several benefits
, one of the main ones is that now the parameters of your functions with
Annotated
would
not be affected
at all.
If you call those functions in
other places in your code
, the actual
default values
will be kept, your editor will help you notice missing
required arguments
, Python will require you to pass required arguments at
runtime
, you will be able to
use the same functions
for different things and with different libraries (e.g.
Typer
will soon support
Annotated
too, then you could use the same function for an API and a CLI), etc.
Because
Annotated
is
standard Python
, you still get all the
benefits
from editors and tools, like
autocompletion
,
inline errors
, etc.
One of the
biggest benefits
is that now you can create
Annotated
dependencies that are then shared by multiple
path operation functions
, this will allow you to
reduce
a lot of
code duplication
in your codebase, while keeping all the support from editors and tools.
For example, you could have code like this:
def
get_current_user
(
token
:
str
):
## authenticate user
return
User
()
@app
.
get
(
"/items/"
)
def
read_items
(
user
:
User
=
Depends
(
get_current_user
)):
...
@app
.
post
(
"/items/"
)
def
create_item
(
*
,
user
:
User
=
Depends
(
get_current_user
),
item
:
Item
):
...
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
*
,
user
:
User
=
Depends
(
get_current_user
),
item_id
:
int
):
...
@app
.
delete
(
"/items/
{item_id}
"
)
def
delete_item
(
*
,
user
:
User
=
Depends
(
get_current_user
),
item_id
:
int
):
...
There's a bit of code duplication for the dependency:
user
:
User
=
Depends
(
get_current_user
)
...the bigger the codebase, the more noticeable it is.
Now you can create an annotated dependency once, like this:
CurrentUser
=
Annotated
[
User
,
Depends
(
get_current_user
)]
And then you can reuse this
Annotated
dependency:
CurrentUser
=
Annotated
[
User
,
Depends
(
get_current_user
)]
@app
.
get
(
"/items/"
)
def
read_items
(
user
:
CurrentUser
):
...
@app
.
post
(
"/items/"
)
def
create_item
(
user
:
CurrentUser
,
item
:
Item
):
...
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
user
:
CurrentUser
,
item_id
:
int
):
...
@app
.
delete
(
"/items/
{item_id}
"
)
def
delete_item
(
user
:
CurrentUser
,
item_id
:
int
):
...
...and
CurrentUser
has all the typing information as
User
, so your editor will work as expected (autocompletion and everything), and
FastAPI
will be able to understand the dependency defined in
Annotated
. 😎
Roughly
all the docs
have been rewritten to use
Annotated
as the main way to declare
parameters
and
dependencies
. All the
examples
in the docs now include a version with
Annotated
and a version without it, for each of the specific Python versions (when there are small differences/improvements in more recent versions). There were around 23K new lines added between docs, examples, and tests. 🚀
The key updated docs are:
Python Types Intro:
Type Hints with Metadata Annotations
.
Tutorial:
Query Parameters and String Validations - Additional validation
Advantages of
Annotated
Path Parameters and Numeric Validations - Order the parameters as you need, tricks
Better with
Annotated
Dependencies - First Steps - Share
Annotated
dependencies
Special thanks to
@nzig
for the core implementation and to
@adriangb
for the inspiration and idea with
Xpresso
! 🚀
Features
✨Add support for PEP-593
Annotated
for specifying dependencies and parameters. PR
## 4871
by
@nzig
.
Docs
📝 Tweak tip recommending
Annotated
in docs. PR
## 9270
by
@tiangolo
.
📝 Update order of examples, latest Python version first, and simplify version tab names. PR
## 9269
by
@tiangolo
.
📝 Update all docs to use
Annotated
as the main recommendation, with new examples and tests. PR
## 9268
by
@tiangolo
.
0.94.1
Fixes
🎨 Fix types for lifespan, upgrade Starlette to 0.26.1. PR
## 9245
by
@tiangolo
.
0.94.0
Upgrades
⬆ Upgrade python-multipart to support 0.0.6. PR
## 9212
by
@musicinmybrain
.
⬆️ Upgrade Starlette version, support new
lifespan
with state. PR
## 9239
by
@tiangolo
.
Docs
📝 Update Sentry link in docs. PR
## 9218
by
@smeubank
.
Translations
🌐 Add Russian translation for
docs/ru/docs/history-design-future.md
. PR
## 5986
by
@Xewus
.
Internal
➕ Add
pydantic
to PyPI classifiers. PR
## 5914
by
@yezz123
.
⬆ Bump black from 22.10.0 to 23.1.0. PR
## 5953
by
@dependabot[bot]
.
⬆ Bump types-ujson from 5.6.0.0 to 5.7.0.1. PR
## 6027
by
@dependabot[bot]
.
⬆ Bump dawidd6/action-download-artifact from 2.24.3 to 2.26.0. PR
## 6034
by
@dependabot[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 5709
by
@pre-commit-ci[bot]
.
0.93.0
Features
✨ Add support for
lifespan
async context managers (superseding
startup
and
shutdown
events). Initial PR
## 2944
by
@uSpike
.
Now, instead of using independent
startup
and
shutdown
events, you can define that logic in a single function with
yield
decorated with
@asynccontextmanager
(an async context manager).
For example:
from
contextlib
import
asynccontextmanager
from
fastapi
import
FastAPI
def
fake_answer_to_everything_ml_model
(
x
:
float
):
return
x
*
42
ml_models
=
{}
@asynccontextmanager
async
def
lifespan
(
app
:
FastAPI
):
## Load the ML model
ml_models
[
"answer_to_everything"
]
=
fake_answer_to_everything_ml_model
yield
## Clean up the ML models and release the resources
ml_models
.
clear
()
app
=
FastAPI
(
lifespan
=
lifespan
)
@app
.
get
(
"/predict"
)
async
def
predict
(
x
:
float
):
result
=
ml_models
[
"answer_to_everything"
](
x
)
return
{
"result"
:
result
}
Note
: This is the recommended way going forward, instead of using
startup
and
shutdown
events.
Read more about it in the new docs:
Advanced User Guide: Lifespan Events
.
Docs
✏ Fix formatting in
docs/en/docs/tutorial/metadata.md
for
ReDoc
. PR
## 6005
by
@eykamp
.
Translations
🌐 Tamil translations - initial setup. PR
## 5564
by
@gusty1g
.
🌐 Add French translation for
docs/fr/docs/advanced/path-operation-advanced-configuration.md
. PR
## 9221
by
@axel584
.
🌐 Add French translation for
docs/tutorial/debugging.md
. PR
## 9175
by
@frabc
.
🌐 Initiate Armenian translation setup. PR
## 5844
by
@har8
.
🌐 Add French translation for
deployment/manually.md
. PR
## 3693
by
@rjNemo
.
Internal
👷 Update translation bot messages. PR
## 9206
by
@tiangolo
.
👷 Update translations bot to use Discussions, and notify when a PR is done. PR
## 9183
by
@tiangolo
.
🔧 Update sponsors-badges. PR
## 9182
by
@tiangolo
.
👥 Update FastAPI People. PR
## 9181
by
@github-actions[bot]
.
🔊 Log GraphQL errors in FastAPI People, because it returns 200, with a payload with an error. PR
## 9171
by
@tiangolo
.
💚 Fix/workaround GitHub Actions in Docker with git for FastAPI People. PR
## 9169
by
@tiangolo
.
♻️ Refactor FastAPI Experts to use only discussions now that questions are migrated. PR
## 9165
by
@tiangolo
.
⬆️ Upgrade analytics. PR
## 6025
by
@tiangolo
.
⬆️ Upgrade and re-enable installing Typer-CLI. PR
## 6008
by
@tiangolo
.
0.92.0
🚨 This is a security fix. Please upgrade as soon as possible.
Upgrades
⬆️ Upgrade Starlette to 0.25.0. PR
## 5996
by
@tiangolo
.
This solves a vulnerability that could allow denial of service attacks by using many small multipart fields/files (parts), consuming high CPU and memory.
Only applications using forms (e.g. file uploads) could be affected.
For most cases, upgrading won't have any breaking changes.
0.91.0
Upgrades
⬆️ Upgrade Starlette version to
0.24.0
and refactor internals for compatibility. PR
## 5985
by
@tiangolo
.
This can solve nuanced errors when using middlewares. Before Starlette
0.24.0
, a new instance of each middleware class would be created when a new middleware was added. That normally was not a problem, unless the middleware class expected to be created only once, with only one instance, that happened in some cases. This upgrade would solve those cases (thanks
@adriangb
! Starlette PR
## 2017
). Now the middleware class instances are created once, right before the first request (the first time the app is called).
If you depended on that previous behavior, you might need to update your code. As always, make sure your tests pass before merging the upgrade.
0.90.1
Upgrades
⬆️ Upgrade Starlette range to allow 0.23.1. PR
## 5980
by
@tiangolo
.
Docs
✏ Tweak wording to clarify
docs/en/docs/project-generation.md
. PR
## 5930
by
@chandra-deb
.
✏ Update Pydantic GitHub URLs. PR
## 5952
by
@yezz123
.
📝 Add opinion from Cisco. PR
## 5981
by
@tiangolo
.
Translations
🌐 Add Russian translation for
docs/ru/docs/tutorial/cookie-params.md
. PR
## 5890
by
@bnzone
.
Internal
✏ Update
zip-docs.sh
internal script, remove extra space. PR
## 5931
by
@JuanPerdomo00
.
0.90.0
Upgrades
⬆️ Bump Starlette from 0.22.0 to 0.23.0. Initial PR
## 5739
by
@Kludex
.
Docs
📝 Add article "Tortoise ORM / FastAPI 整合快速筆記" to External Links. PR
## 5496
by
@Leon0824
.
👥 Update FastAPI People. PR
## 5954
by
@github-actions[bot]
.
📝 Micro-tweak help docs. PR
## 5960
by
@tiangolo
.
🔧 Update new issue chooser to direct to GitHub Discussions. PR
## 5948
by
@tiangolo
.
📝 Recommend GitHub Discussions for questions. PR
## 5944
by
@tiangolo
.
Translations
🌐 Add Russian translation for
docs/ru/docs/tutorial/body-fields.md
. PR
## 5898
by
@simatheone
.
🌐 Add Russian translation for
docs/ru/docs/help-fastapi.md
. PR
## 5970
by
@tiangolo
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/static-files.md
. PR
## 5858
by
@batlopes
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/encoder.md
. PR
## 5525
by
@felipebpl
.
🌐 Add Russian translation for
docs/ru/docs/contributing.md
. PR
## 5870
by
@Xewus
.
Internal
⬆️ Upgrade Ubuntu version for docs workflow. PR
## 5971
by
@tiangolo
.
🔧 Update sponsors badges. PR
## 5943
by
@tiangolo
.
✨ Compute FastAPI Experts including GitHub Discussions. PR
## 5941
by
@tiangolo
.
⬆️ Upgrade isort and update pre-commit. PR
## 5940
by
@tiangolo
.
🔧 Add template for questions in Discussions. PR
## 5920
by
@tiangolo
.
🔧 Update Sponsor Budget Insight to Powens. PR
## 5916
by
@tiangolo
.
🔧 Update GitHub Sponsors badge data. PR
## 5915
by
@tiangolo
.
0.89.1
Fixes
🐛 Ignore Response classes on return annotation. PR
## 5855
by
@Kludex
. See the new docs in the PR below.
Docs
📝 Update docs and examples for Response Model with Return Type Annotations, and update runtime error. PR
## 5873
by
@tiangolo
. New docs at
Response Model - Return Type: Other Return Type Annotations
.
📝 Add External Link: FastAPI lambda container: serverless simplified. PR
## 5784
by
@rafrasenberg
.
Translations
🌐 Add Turkish translation for
docs/tr/docs/tutorial/first_steps.md
. PR
## 5691
by
@Kadermiyanyedi
.
0.89.0
Features
✨ Add support for function return type annotations to declare the
response_model
. Initial PR
## 1436
by
@uriyyo
.
Now you can declare the return type /
response_model
in the function return type annotation:
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
@app
.
get
(
"/items/"
)
async
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
price
=
42.0
),
Item
(
name
=
"Plumbus"
,
price
=
32.0
),
]
FastAPI will use the return type annotation to perform:
Data validation
Automatic documentation
It could power automatic client generators
Data filtering
Before this version it was only supported via the
response_model
parameter.
Read more about it in the new docs:
Response Model - Return Type
.
Docs
📝 Add External Link: Authorization on FastAPI with Casbin. PR
## 5712
by
@Xhy-5000
.
✏ Fix typo in
docs/en/docs/async.md
. PR
## 5785
by
@Kingdageek
.
✏ Fix typo in
docs/en/docs/deployment/concepts.md
. PR
## 5824
by
@kelbyfaessler
.
Translations
🌐 Add Russian translation for
docs/ru/docs/fastapi-people.md
. PR
## 5577
by
@Xewus
.
🌐 Fix typo in Chinese translation for
docs/zh/docs/benchmarks.md
. PR
## 4269
by
@15027668g
.
🌐 Add Korean translation for
docs/tutorial/cors.md
. PR
## 3764
by
@NinaHwang
.
Internal
⬆ Update coverage[toml] requirement from <7.0,>=6.5.0 to >=6.5.0,<8.0. PR
## 5801
by
@dependabot[bot]
.
⬆ Update uvicorn[standard] requirement from <0.19.0,>=0.12.0 to >=0.12.0,<0.21.0 for development. PR
## 5795
by
@dependabot[bot]
.
⬆ Bump dawidd6/action-download-artifact from 2.24.2 to 2.24.3. PR
## 5842
by
@dependabot[bot]
.
👥 Update FastAPI People. PR
## 5825
by
@github-actions[bot]
.
⬆ Bump types-ujson from 5.5.0 to 5.6.0.0. PR
## 5735
by
@dependabot[bot]
.
⬆ Bump pypa/gh-action-pypi-publish from 1.5.2 to 1.6.4. PR
## 5750
by
@dependabot[bot]
.
👷 Add GitHub Action gate/check. PR
## 5492
by
@webknjaz
.
🔧 Update sponsors, add Svix. PR
## 5848
by
@tiangolo
.
🔧 Remove Doist sponsor. PR
## 5847
by
@tiangolo
.
⬆ Update sqlalchemy requirement from <=1.4.41,>=1.3.18 to >=1.3.18,<1.4.43. PR
## 5540
by
@dependabot[bot]
.
⬆ Bump nwtgck/actions-netlify from 1.2.4 to 2.0.0. PR
## 5757
by
@dependabot[bot]
.
👷 Refactor CI artifact upload/download for docs previews. PR
## 5793
by
@tiangolo
.
⬆ Bump pypa/gh-action-pypi-publish from 1.5.1 to 1.5.2. PR
## 5714
by
@dependabot[bot]
.
👥 Update FastAPI People. PR
## 5722
by
@github-actions[bot]
.
🔧 Update sponsors, disable course bundle. PR
## 5713
by
@tiangolo
.
⬆ Update typer[all] requirement from <0.7.0,>=0.6.1 to >=0.6.1,<0.8.0. PR
## 5639
by
@dependabot[bot]
.
0.88.0
Upgrades
⬆ Bump Starlette to version
0.22.0
to fix bad encoding for query parameters in new
TestClient
. PR
## 5659
by
@azogue
.
Docs
✏️ Fix typo in docs for
docs/en/docs/advanced/middleware.md
. PR
## 5376
by
@rifatrakib
.
Translations
🌐 Add Portuguese translation for
docs/pt/docs/deployment/docker.md
. PR
## 5663
by
@ayr-ton
.
Internal
👷 Tweak build-docs to improve CI performance. PR
## 5699
by
@tiangolo
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 5566
by
@pre-commit-ci[bot]
.
⬆️ Upgrade Ruff. PR
## 5698
by
@tiangolo
.
👷 Remove pip cache for Smokeshow as it depends on a requirements.txt. PR
## 5700
by
@tiangolo
.
💚 Fix pip cache for Smokeshow. PR
## 5697
by
@tiangolo
.
👷 Fix and tweak CI cache handling. PR
## 5696
by
@tiangolo
.
👷 Update
setup-python
action in tests to use new caching feature. PR
## 5680
by
@madkinsz
.
⬆ Bump black from 22.8.0 to 22.10.0. PR
## 5569
by
@dependabot[bot]
.
0.87.0
Highlights of this release:
Upgraded Starlette
Now the
TestClient
is based on HTTPX instead of Requests. 🚀
There are some possible
breaking changes
in the
TestClient
usage, but
@Kludex
built
bump-testclient
to help you automatize migrating your tests. Make sure you are using Git and that you can undo any unnecessary changes (false positive changes, etc) before using
bump-testclient
.
New
WebSocketException (and docs)
, re-exported from Starlette.
Upgraded and relaxed dependencies for package extras
all
(including new Uvicorn version), when you install
"fastapi[all]"
.
New docs about how to
Help Maintain FastAPI
.
Features
⬆️ Upgrade and relax dependencies for extras "all". PR
## 5634
by
@tiangolo
.
✨ Re-export Starlette's
WebSocketException
and add it to docs. PR
## 5629
by
@tiangolo
.
📝 Update references to Requests for tests to HTTPX, and add HTTPX to extras. PR
## 5628
by
@tiangolo
.
⬆ Upgrade Starlette to
0.21.0
, including the new
TestClient
based on HTTPX
. PR
## 5471
by
@pawelrubin
.
Docs
✏️ Tweak Help FastAPI from PR review after merging. PR
## 5633
by
@tiangolo
.
✏️ Clarify docs on CORS. PR
## 5627
by
@paxcodes
.
📝 Update Help FastAPI: Help Maintain FastAPI. PR
## 5632
by
@tiangolo
.
Translations
🌐 Fix highlight lines for Japanese translation for
docs/tutorial/query-params.md
. PR
## 2969
by
@ftnext
.
🌐 Add French translation for
docs/fr/docs/advanced/additional-status-code.md
. PR
## 5477
by
@axel584
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/request-forms-and-files.md
. PR
## 5579
by
@batlopes
.
🌐 Add Japanese translation for
docs/ja/docs/advanced/websockets.md
. PR
## 4983
by
@xryuseix
.
Internal
✨ Use Ruff for linting. PR
## 5630
by
@tiangolo
.
🛠 Add Arabic issue number to Notify Translations GitHub Action. PR
## 5610
by
@tiangolo
.
⬆ Bump dawidd6/action-download-artifact from 2.24.1 to 2.24.2. PR
## 5609
by
@dependabot[bot]
.
⬆ Bump dawidd6/action-download-artifact from 2.24.0 to 2.24.1. PR
## 5603
by
@dependabot[bot]
.
📝 Update coverage badge to use Samuel Colvin's Smokeshow. PR
## 5585
by
@tiangolo
.
0.86.0
Features
⬆ Add Python 3.11 to the officially supported versions. PR
## 5587
by
@tiangolo
.
✅ Enable tests for Python 3.11. PR
## 4881
by
@tiangolo
.
Fixes
🐛 Close FormData (uploaded files) after the request is done. PR
## 5465
by
@adriangb
.
Docs
✏ Fix typo in
docs/en/docs/tutorial/security/oauth2-jwt.md
. PR
## 5584
by
@vivekashok1221
.
Translations
🌐 Update wording in Chinese translation for
docs/zh/docs/python-types.md
. PR
## 5416
by
@supercaizehua
.
🌐 Add Russian translation for
docs/ru/docs/deployment/index.md
. PR
## 5336
by
@Xewus
.
🌐 Update Chinese translation for
docs/tutorial/security/oauth2-jwt.md
. PR
## 3846
by
@jaystone776
.
Internal
👷 Update FastAPI People to exclude bots: pre-commit-ci, dependabot. PR
## 5586
by
@tiangolo
.
🎨 Format OpenAPI JSON in
test_starlette_exception.py
. PR
## 5379
by
@iudeen
.
👷 Switch from Codecov to Smokeshow plus pytest-cov to pure coverage for internal tests. PR
## 5583
by
@tiangolo
.
👥 Update FastAPI People. PR
## 5571
by
@github-actions[bot]
.
0.85.2
Docs
✏ Fix grammar and add helpful links to dependencies in
docs/en/docs/async.md
. PR
## 5432
by
@pamelafox
.
✏ Fix broken link in
alternatives.md
. PR
## 5455
by
@su-shubham
.
✏ Fix typo in docs about contributing, for compatibility with
pip
in Zsh. PR
## 5523
by
@zhangbo2012
.
📝 Fix typo in docs with examples for Python 3.10 instead of 3.9. PR
## 5545
by
@feliciss
.
Translations
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/request-forms.md
. PR
## 4934
by
@batlopes
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 4971
by
@Zssaer
.
🌐 Add French translation for
deployment/deta.md
. PR
## 3692
by
@rjNemo
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/query-params-str-validations.md
. PR
## 5255
by
@hjlarry
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/sql-databases.md
. PR
## 4999
by
@Zssaer
.
🌐 Add Chinese translation for
docs/zh/docs/advanced/wsgi.md
. PR
## 4505
by
@ASpathfinder
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/body-multiple-params.md
. PR
## 4111
by
@lbmendes
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/path-params-numeric-validations.md
. PR
## 4099
by
@lbmendes
.
🌐 Add French translation for
deployment/versions.md
. PR
## 3690
by
@rjNemo
.
🌐 Add French translation for
docs/fr/docs/help-fastapi.md
. PR
## 2233
by
@JulianMaurin
.
🌐 Fix typo in Chinese translation for
docs/zh/docs/tutorial/security/first-steps.md
. PR
## 5530
by
@yuki1sntSnow
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/response-status-code.md
. PR
## 4922
by
@batlopes
.
🔧 Add config for Tamil translations. PR
## 5563
by
@tiangolo
.
Internal
⬆ Bump internal dependency mypy from 0.971 to 0.982. PR
## 5541
by
@dependabot[bot]
.
⬆ Bump nwtgck/actions-netlify from 1.2.3 to 1.2.4. PR
## 5507
by
@dependabot[bot]
.
⬆ Bump internal dependency types-ujson from 5.4.0 to 5.5.0. PR
## 5537
by
@dependabot[bot]
.
⬆ Bump dawidd6/action-download-artifact from 2.23.0 to 2.24.0. PR
## 5508
by
@dependabot[bot]
.
⬆ Update internal dependency pytest-cov requirement from <4.0.0,>=2.12.0 to >=2.12.0,<5.0.0. PR
## 5539
by
@dependabot[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 5536
by
@pre-commit-ci[bot]
.
🐛 Fix internal Trio test warnings. PR
## 5547
by
@samuelcolvin
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 5408
by
@pre-commit-ci[bot]
.
⬆️ Upgrade Typer to include Rich in scripts for docs. PR
## 5502
by
@tiangolo
.
🐛 Fix calling
mkdocs
for languages as a subprocess to fix/enable MkDocs Material search plugin. PR
## 5501
by
@tiangolo
.
0.85.1
Fixes
🐛 Fix support for strings in OpenAPI status codes:
default
,
1XX
,
2XX
,
3XX
,
4XX
,
5XX
. PR
## 5187
by
@JarroVGIT
.
Docs
📝 Add WayScript x FastAPI Tutorial to External Links section. PR
## 5407
by
@moneeka
.
Internal
👥 Update FastAPI People. PR
## 5447
by
@github-actions[bot]
.
🔧 Disable Material for MkDocs search plugin. PR
## 5495
by
@tiangolo
.
🔇 Ignore Trio warning in tests for CI. PR
## 5483
by
@samuelcolvin
.
0.85.0
Features
⬆ Upgrade version required of Starlette from
0.19.1
to
0.20.4
. Initial PR
## 4820
by
@Kludex
.
This includes several bug fixes in Starlette.
⬆️ Upgrade Uvicorn max version in public extras: all. From
>=0.12.0,<0.18.0
to
>=0.12.0,<0.19.0
. PR
## 5401
by
@tiangolo
.
Internal
⬆️ Upgrade dependencies for doc and dev internal extras: Typer, Uvicorn. PR
## 5400
by
@tiangolo
.
⬆️ Upgrade test dependencies: Black, HTTPX, databases, types-ujson. PR
## 5399
by
@tiangolo
.
⬆️ Upgrade mypy and tweak internal type annotations. PR
## 5398
by
@tiangolo
.
🔧 Update test dependencies, upgrade Pytest, move dependencies from dev to test. PR
## 5396
by
@tiangolo
.
0.84.0
Breaking Changes
This version of FastAPI drops support for Python 3.6. 🔥 Please upgrade to a supported version of Python (3.7 or above), Python 3.6 reached the end-of-life a long time ago. 😅☠
🔧 Update package metadata, drop support for Python 3.6, move build internals from Flit to Hatch. PR
## 5240
by
@ofek
.
0.83.0
🚨 This is probably the last release (or one of the last releases) to support Python 3.6. 🔥
Python 3.6 reached the
end-of-life and is no longer supported by Python
since around a year ago.
You hopefully updated to a supported version of Python a while ago. If you haven't, you really should.
Features
✨ Add support in
jsonable_encoder
for include and exclude with dataclasses. PR
## 4923
by
@DCsunset
.
Fixes
🐛 Fix
RuntimeError
raised when
HTTPException
has a status code with no content. PR
## 5365
by
@iudeen
.
🐛 Fix empty reponse body when default
status_code
is empty but the a
Response
parameter with
response.status_code
is set. PR
## 5360
by
@tmeckel
.
Docs
📝 Update
SECURITY.md
. PR
## 5377
by
@Kludex
.
Internal
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 5352
by
@pre-commit-ci[bot]
.
0.82.0
🚨 This is probably the last release (or one of the last releases) to support Python 3.6. 🔥
Python 3.6 reached the
end-of-life and is no longer supported by Python
since around a year ago.
You hopefully updated to a supported version of Python a while ago. If you haven't, you really should.
Features
✨ Export
WebSocketState
in
fastapi.websockets
. PR
## 4376
by
@matiuszka
.
✨ Support Python internal description on Pydantic model's docstring. PR
## 3032
by
@Kludex
.
✨ Update
ORJSONResponse
to support non
str
keys and serializing Numpy arrays. PR
## 3892
by
@baby5
.
Fixes
🐛 Allow exit code for dependencies with
yield
to always execute, by removing capacity limiter for them, to e.g. allow closing DB connections without deadlocks. PR
## 5122
by
@adriangb
.
🐛 Fix FastAPI People GitHub Action: set HTTPX timeout for GraphQL query request. PR
## 5222
by
@iudeen
.
🐛 Make sure a parameter defined as required is kept required in OpenAPI even if defined as optional in another dependency. PR
## 4319
by
@cd17822
.
🐛 Fix support for path parameters in WebSockets. PR
## 3879
by
@davidbrochart
.
Docs
✏ Update Hypercorn link, now pointing to GitHub. PR
## 5346
by
@baconfield
.
✏ Tweak wording in
docs/en/docs/advanced/dataclasses.md
. PR
## 3698
by
@pfackeldey
.
📝 Add note about Python 3.10
X | Y
operator in explanation about Response Models. PR
## 5307
by
@MendyLanda
.
📝 Add link to New Relic article: "How to monitor FastAPI application performance using Python agent". PR
## 5260
by
@sjyothi54
.
📝 Update docs for
ORJSONResponse
with details about improving performance. PR
## 2615
by
@falkben
.
📝 Add docs for creating a custom Response class. PR
## 5331
by
@tiangolo
.
📝 Add tip about using alias for form data fields. PR
## 5329
by
@tiangolo
.
Translations
🌐 Add Russian translation for
docs/ru/docs/features.md
. PR
## 5315
by
@Xewus
.
🌐 Update Chinese translation for
docs/zh/docs/tutorial/request-files.md
. PR
## 4529
by
@ASpathfinder
.
🌐 Add Chinese translation for
docs/zh/docs/tutorial/encoder.md
. PR
## 4969
by
@Zssaer
.
🌐 Fix MkDocs file line for Portuguese translation of
background-task.md
. PR
## 5242
by
@ComicShrimp
.
Internal
👥 Update FastAPI People. PR
## 5347
by
@github-actions[bot]
.
⬆ Bump dawidd6/action-download-artifact from 2.22.0 to 2.23.0. PR
## 5321
by
@dependabot[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 5318
by
@pre-commit-ci[bot]
.
✏ Fix a small code highlight line error. PR
## 5256
by
@hjlarry
.
♻ Internal small refactor, move
operation_id
parameter position in delete method for consistency with the code. PR
## 4474
by
@hiel
.
🔧 Update sponsors, disable ImgWhale. PR
## 5338
by
@tiangolo
.
0.81.0
Features
✨ Add ReDoc
<noscript>
warning when JS is disabled. PR
## 5074
by
@evroon
.
✨ Add support for
FrozenSet
in parameters (e.g. query). PR
## 2938
by
@juntatalor
.
✨ Allow custom middlewares to raise
HTTPException
s and propagate them. PR
## 2036
by
@ghandic
.
✨ Preserve
json.JSONDecodeError
information when handling invalid JSON in request body, to support custom exception handlers that use its information. PR
## 4057
by
@UKnowWhoIm
.
Fixes
🐛 Fix
jsonable_encoder
for dataclasses with pydantic-compatible fields. PR
## 3607
by
@himbeles
.
🐛 Fix support for extending
openapi_extras
with parameter lists. PR
## 4267
by
@orilevari
.
Docs
✏ Fix a simple typo in
docs/en/docs/python-types.md
. PR
## 5193
by
@GlitchingCore
.
✏ Fix typos in
tests/test_schema_extra_examples.py
. PR
## 5126
by
@supraaxdd
.
✏ Fix typos in
docs/en/docs/tutorial/path-params-numeric-validations.md
. PR
## 5142
by
@invisibleroads
.
📝 Add step about upgrading pip in the venv to avoid errors when installing dependencies
docs/en/docs/contributing.md
. PR
## 5181
by
@edisnake
.
✏ Reword and clarify text in tutorial
docs/en/docs/tutorial/body-nested-models.md
. PR
## 5169
by
@papb
.
✏ Fix minor typo in
docs/en/docs/features.md
. PR
## 5206
by
@OtherBarry
.
✏ Fix minor typos in
docs/en/docs/async.md
. PR
## 5125
by
@Ksenofanex
.
📝 Add external link to docs: "Fastapi, Docker(Docker compose) and Postgres". PR
## 5033
by
@krishnardt
.
📝 Simplify example for docs for Additional Responses, remove unnecessary
else
. PR
## 4693
by
@adriangb
.
📝 Update docs, compare enums with identity instead of equality. PR
## 4905
by
@MicaelJarniac
.
✏ Fix typo in
docs/en/docs/python-types.md
. PR
## 4886
by
@MicaelJarniac
.
🎨 Fix syntax highlighting in docs for OpenAPI Callbacks. PR
## 4368
by
@xncbf
.
✏ Reword confusing sentence in docs file
typo-fix-path-params-numeric-validations.md
. PR
## 3219
by
@ccrenfroe
.
📝 Update docs for handling HTTP Basic Auth with
secrets.compare_digest()
to account for non-ASCII characters. PR
## 3536
by
@lewoudar
.
📝 Update docs for testing, fix examples with relative imports. PR
## 5302
by
@tiangolo
.
Translations
🌐 Add Russian translation for
docs/ru/docs/index.md
. PR
## 5289
by
@impocode
.
🌐 Add Russian translation for
docs/ru/docs/deployment/versions.md
. PR
## 4985
by
@emp7yhead
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/header-params.md
. PR
## 4921
by
@batlopes
.
🌐 Update
ko/mkdocs.yml
for a missing link. PR
## 5020
by
@dalinaum
.
Internal
⬆ Bump dawidd6/action-download-artifact from 2.21.1 to 2.22.0. PR
## 5258
by
@dependabot[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 5196
by
@pre-commit-ci[bot]
.
🔥 Delete duplicated tests in
tests/test_tutorial/test_sql_databases/test_sql_databases.py
. PR
## 5040
by
@raccoonyy
.
♻ Simplify internal RegEx in
fastapi/utils.py
. PR
## 5057
by
@pylounge
.
🔧 Fix Type hint of
auto_error
which does not need to be
Optional[bool]
. PR
## 4933
by
@DavidKimDY
.
🔧 Update mypy config, use
strict = true
instead of manual configs. PR
## 4605
by
@michaeloliverx
.
♻ Change a
dict()
for
{}
in
fastapi/utils.py
. PR
## 3138
by
@ShahriyarR
.
♻ Move internal variable for errors in
jsonable_encoder
to put related code closer. PR
## 4560
by
@GuilleQP
.
♻ Simplify conditional assignment in
fastapi/dependencies/utils.py
. PR
## 4597
by
@cikay
.
⬆ Upgrade version pin accepted for Flake8, for internal code, to
flake8 >=3.8.3,<6.0.0
. PR
## 4097
by
@jamescurtin
.
🍱 Update Jina banner, fix typo. PR
## 5301
by
@tiangolo
.
0.80.0
Breaking Changes - Fixes
🐛 Fix
response_model
not invalidating
None
. PR
## 2725
by
@hukkin
.
If you are using
response_model
with some type that doesn't include
None
but the function is returning
None
, it will now raise an internal server error, because you are returning invalid data that violates the contract in
response_model
. Before this release it would allow breaking that contract returning
None
.
For example, if you have an app like this:
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
price
:
Optional
[
float
]
=
None
owner_ids
:
Optional
[
List
[
int
]]
=
None
app
=
FastAPI
()
@app
.
get
(
"/items/invalidnone"
,
response_model
=
Item
)
def
get_invalid_none
():
return
None
...calling the path
/items/invalidnone
will raise an error, because
None
is not a valid type for the
response_model
declared with
Item
.
You could also be implicitly returning
None
without realizing, for example:
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
price
:
Optional
[
float
]
=
None
owner_ids
:
Optional
[
List
[
int
]]
=
None
app
=
FastAPI
()
@app
.
get
(
"/items/invalidnone"
,
response_model
=
Item
)
def
get_invalid_none
():
if
flag
:
return
{
"name"
:
"foo"
}
## if flag is False, at this point the function will implicitly return None
If you have
path operations
using
response_model
that need to be allowed to return
None
, make it explicit in
response_model
using
Union[Something, None]
:
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
price
:
Optional
[
float
]
=
None
owner_ids
:
Optional
[
List
[
int
]]
=
None
app
=
FastAPI
()
@app
.
get
(
"/items/invalidnone"
,
response_model
=
Union
[
Item
,
None
])
def
get_invalid_none
():
return
None
This way the data will be correctly validated, you won't have an internal server error, and the documentation will also reflect that this
path operation
could return
None
(or
null
in JSON).
Fixes
⬆ Upgrade Swagger UI copy of
oauth2-redirect.html
to include fixes for flavors of authorization code flows in Swagger UI. PR
## 3439
initial PR by
@koonpeng
.
♻ Strip empty whitespace from description extracted from docstrings. PR
## 2821
by
@and-semakin
.
🐛 Fix cached dependencies when using a dependency in
Security()
and other places (e.g.
Depends()
) with different OAuth2 scopes. PR
## 2945
by
@laggardkernel
.
🎨 Update type annotations for
response_model
, allow things like
Union[str, None]
. PR
## 5294
by
@tiangolo
.
Translations
🌐 Fix typos in German translation for
docs/de/docs/features.md
. PR
## 4533
by
@0xflotus
.
🌐 Add missing navigator for
encoder.md
in Korean translation. PR
## 5238
by
@joonas-yoon
.
(Empty PR merge by accident)
## 4913
.
0.79.1
Fixes
🐛 Fix
jsonable_encoder
using
include
and
exclude
parameters for non-Pydantic objects. PR
## 2606
by
@xaviml
.
🐛 Fix edge case with repeated aliases names not shown in OpenAPI. PR
## 2351
by
@klaa97
.
📝 Add misc dependency installs to tutorial docs. PR
## 2126
by
@TeoZosa
.
Docs
📝 Add note giving credit for illustrations to
Ketrina Thompson
. PR
## 5284
by
@tiangolo
.
✏ Fix typo in
python-types.md
. PR
## 5116
by
@Kludex
.
✏ Fix typo in
docs/en/docs/python-types.md
. PR
## 5007
by
@atiabbz
.
📝 Remove unneeded Django/Flask references from async topic intro. PR
## 5280
by
@carltongibson
.
✨ Add illustrations for Concurrent burgers and Parallel burgers. PR
## 5277
by
@tiangolo
. Updated docs at:
Concurrency and Burgers
.
Translations
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/query-params.md
. PR
## 4775
by
@batlopes
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/security/first-steps.md
. PR
## 4954
by
@FLAIR7
.
🌐 Add translation for
docs/zh/docs/advanced/response-cookies.md
. PR
## 4638
by
@zhangbo2012
.
🌐 Add French translation for
docs/fr/docs/deployment/index.md
. PR
## 3689
by
@rjNemo
.
🌐 Add Portuguese translation for
tutorial/handling-errors.md
. PR
## 4769
by
@frnsimoes
.
🌐 Add French translation for
docs/fr/docs/history-design-future.md
. PR
## 3451
by
@rjNemo
.
🌐 Add Russian translation for
docs/ru/docs/tutorial/background-tasks.md
. PR
## 4854
by
@AdmiralDesu
.
🌐 Add Chinese translation for
docs/tutorial/security/first-steps.md
. PR
## 3841
by
@jaystone776
.
🌐 Add Japanese translation for
docs/ja/docs/advanced/nosql-databases.md
. PR
## 4205
by
@sUeharaE4
.
🌐 Add Indonesian translation for
docs/id/docs/tutorial/index.md
. PR
## 4705
by
@bas-baskara
.
🌐 Add Persian translation for
docs/fa/docs/index.md
and tweak right-to-left CSS. PR
## 2395
by
@mohsen-mahmoodi
.
Internal
🔧 Update Jina sponsorship. PR
## 5283
by
@tiangolo
.
🔧 Update Jina sponsorship. PR
## 5272
by
@tiangolo
.
🔧 Update sponsors, Striveworks badge. PR
## 5179
by
@tiangolo
.
0.79.0
Fixes - Breaking Changes
🐛 Fix removing body from status codes that do not support it. PR
## 5145
by
@tiangolo
.
Setting
status_code
to
204
,
304
, or any code below
200
(1xx) will remove the body from the response.
This fixes an error in Uvicorn that otherwise would be thrown:
RuntimeError: Response content longer than Content-Length
.
This removes
fastapi.openapi.constants.STATUS_CODES_WITH_NO_BODY
, it is replaced by a function in utils.
Translations
🌐 Start of Hebrew translation. PR
## 5050
by
@itay-raveh
.
🔧 Add config for Swedish translations notification. PR
## 5147
by
@tiangolo
.
🌐 Start of Swedish translation. PR
## 5062
by
@MrRawbin
.
🌐 Add Japanese translation for
docs/ja/docs/advanced/index.md
. PR
## 5043
by
@wakabame
.
🌐🇵🇱 Add Polish translation for
docs/pl/docs/tutorial/first-steps.md
. PR
## 5024
by
@Valaraucoo
.
Internal
🔧 Update translations notification for Hebrew. PR
## 5158
by
@tiangolo
.
🔧 Update Dependabot commit message. PR
## 5156
by
@tiangolo
.
⬆ Bump actions/upload-artifact from 2 to 3. PR
## 5148
by
@dependabot[bot]
.
⬆ Bump actions/cache from 2 to 3. PR
## 5149
by
@dependabot[bot]
.
🔧 Update sponsors badge configs. PR
## 5155
by
@tiangolo
.
👥 Update FastAPI People. PR
## 5154
by
@tiangolo
.
🔧 Update Jina sponsor badges. PR
## 5151
by
@tiangolo
.
⬆ Bump actions/checkout from 2 to 3. PR
## 5133
by
@dependabot[bot]
.
⬆ [pre-commit.ci] pre-commit autoupdate. PR
## 5030
by
@pre-commit-ci[bot]
.
⬆ Bump nwtgck/actions-netlify from 1.1.5 to 1.2.3. PR
## 5132
by
@dependabot[bot]
.
⬆ Bump codecov/codecov-action from 2 to 3. PR
## 5131
by
@dependabot[bot]
.
⬆ Bump dawidd6/action-download-artifact from 2.9.0 to 2.21.1. PR
## 5130
by
@dependabot[bot]
.
⬆ Bump actions/setup-python from 2 to 4. PR
## 5129
by
@dependabot[bot]
.
👷 Add Dependabot. PR
## 5128
by
@tiangolo
.
♻️ Move from
Optional[X]
to
Union[X, None]
for internal utils. PR
## 5124
by
@tiangolo
.
🔧 Update sponsors, remove Dropbase, add Doist. PR
## 5096
by
@tiangolo
.
🔧 Update sponsors, remove Classiq, add ImgWhale. PR
## 5079
by
@tiangolo
.
0.78.0
Features
✨ Add support for omitting
...
as default value when declaring required parameters with:
Path()
Query()
Header()
Cookie()
Body()
Form()
File()
New docs at
Tutorial - Query Parameters and String Validations - Make it required
. PR
## 4906
by
@tiangolo
.
Up to now, declaring a required parameter while adding additional validation or metadata needed using
...
(Ellipsis).
For example:
from
fastapi
import
Cookie
,
FastAPI
,
Header
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
def
main
(
item_id
:
int
=
Path
(
default
=...
,
gt
=
0
),
query
:
str
=
Query
(
default
=...
,
max_length
=
10
),
session
:
str
=
Cookie
(
default
=...
,
min_length
=
3
),
x_trace
:
str
=
Header
(
default
=...
,
title
=
"Tracing header"
),
):
return
{
"message"
:
"Hello World"
}
...all these parameters are required because the default value is
...
(Ellipsis).
But now it's possible and supported to just omit the default value, as would be done with Pydantic fields, and the parameters would still be required.
✨ For example, this is now supported:
from
fastapi
import
Cookie
,
FastAPI
,
Header
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
def
main
(
item_id
:
int
=
Path
(
gt
=
0
),
query
:
str
=
Query
(
max_length
=
10
),
session
:
str
=
Cookie
(
min_length
=
3
),
x_trace
:
str
=
Header
(
title
=
"Tracing header"
),
):
return
{
"message"
:
"Hello World"
}
To declare parameters as optional (not required), you can set a default value as always, for example using
None
:
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
,
Header
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
def
main
(
item_id
:
int
=
Path
(
gt
=
0
),
query
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
max_length
=
10
),
session
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
,
min_length
=
3
),
x_trace
:
Union
[
str
,
None
]
=
Header
(
default
=
None
,
title
=
"Tracing header"
),
):
return
{
"message"
:
"Hello World"
}
Docs
📝 Add docs recommending
Union
over
Optional
and migrate source examples. New docs at
Python Types Intro - Using
Union
or
Optional
. PR
## 4908
by
@tiangolo
.
🎨 Fix default value as set in tutorial for Path Operations Advanced Configurations. PR
## 4899
by
@tiangolo
.
📝 Add documentation for redefined path operations. PR
## 4864
by
@madkinsz
.
📝 Updates links for Celery documentation. PR
## 4736
by
@sammyzord
.
✏ Fix example code with sets in tutorial for body nested models. PR
## 3030
by
@hitrust
.
✏ Fix links to Pydantic docs. PR
## 4670
by
@kinuax
.
📝 Update docs about Swagger UI self-hosting with newer source links. PR
## 4813
by
@Kastakin
.
📝 Add link to external article: Building the Poll App From Django Tutorial With FastAPI And React. PR
## 4778
by
@jbrocher
.
📝 Add OpenAPI warning to "Body - Fields" docs with extra schema extensions. PR
## 4846
by
@ml-evs
.
Translations
🌐 Fix code examples in Japanese translation for
docs/ja/docs/tutorial/testing.md
. PR
## 4623
by
@hirotoKirimaru
.
Internal
♻ Refactor dict value extraction to minimize key lookups
fastapi/utils.py
. PR
## 3139
by
@ShahriyarR
.
✅ Add tests for required nonable parameters and body fields. PR
## 4907
by
@tiangolo
.
👷 Fix installing Material for MkDocs Insiders in CI. PR
## 4897
by
@tiangolo
.
👷 Add pre-commit CI instead of custom GitHub Action. PR
## 4896
by
@tiangolo
.
👷 Add pre-commit GitHub Action workflow. PR
## 4895
by
@tiangolo
.
📝 Add dark mode auto switch to docs based on OS preference. PR
## 4869
by
@ComicShrimp
.
🔥 Remove un-used old pending tests, already covered in other places. PR
## 4891
by
@tiangolo
.
🔧 Add Python formatting hooks to pre-commit. PR
## 4890
by
@tiangolo
.
🔧 Add pre-commit with first config and first formatting pass. PR
## 4888
by
@tiangolo
.
👷 Disable CI installing Material for MkDocs in forks. PR
## 4410
by
@dolfinus
.
0.77.1
Upgrades
⬆ Upgrade Starlette from 0.19.0 to 0.19.1. PR
## 4819
by
@Kludex
.
Docs
📝 Add link to german article: REST-API Programmieren mittels Python und dem FastAPI Modul. PR
## 4624
by
@fschuermeyer
.
📝 Add external link: PyCharm Guide to FastAPI. PR
## 4512
by
@mukulmantosh
.
📝 Add external link to article: Building an API with FastAPI and Supabase and Deploying on Deta. PR
## 4440
by
@aUnicornDev
.
✏ Fix small typo in
docs/en/docs/tutorial/security/first-steps.md
. PR
## 4515
by
@KikoIlievski
.
Translations
🌐 Add Polish translation for
docs/pl/docs/tutorial/index.md
. PR
## 4516
by
@MKaczkow
.
✏ Fix typo in deployment. PR
## 4629
by
@raisulislam541
.
🌐 Add Portuguese translation for
docs/pt/docs/help-fastapi.md
. PR
## 4583
by
@mateusjs
.
Internal
🔧 Add notifications in issue for Uzbek translations. PR
## 4884
by
@tiangolo
.
0.77.0
Upgrades
⬆ Upgrade Starlette from 0.18.0 to 0.19.0. PR
## 4488
by
@Kludex
.
When creating an explicit
JSONResponse
the
content
argument is now required.
Docs
📝 Add external link to article: Seamless FastAPI Configuration with ConfZ. PR
## 4414
by
@silvanmelchior
.
📝 Add external link to article: 5 Advanced Features of FastAPI You Should Try. PR
## 4436
by
@kaustubhgupta
.
✏ Reword to improve legibility of docs about
TestClient
. PR
## 4389
by
@rgilton
.
📝 Add external link to blog post about Kafka, FastAPI, and Ably. PR
## 4044
by
@Ugbot
.
✏ Fix typo in
docs/en/docs/tutorial/sql-databases.md
. PR
## 4875
by
@wpyoga
.
✏ Fix typo in
docs/en/docs/async.md
. PR
## 4726
by
@Prezu
.
Translations
🌐 Update source example highlights for
docs/zh/docs/tutorial/query-params-str-validations.md
. PR
## 4237
by
@caimaoy
.
🌐 Remove translation docs references to aiofiles as it's no longer needed since AnyIO. PR
## 3594
by
@alonme
.
✏ 🌐 Fix typo in Portuguese translation for
docs/pt/docs/tutorial/path-params.md
. PR
## 4722
by
@CleoMenezesJr
.
🌐 Fix live docs server for translations for some languages. PR
## 4729
by
@wakabame
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/cookie-params.md
. PR
## 4112
by
@lbmendes
.
🌐 Fix French translation for
docs/tutorial/body.md
. PR
## 4332
by
@Smlep
.
🌐 Add Japanese translation for
docs/ja/docs/advanced/conditional-openapi.md
. PR
## 2631
by
@sh0nk
.
🌐 Fix Japanese translation of
docs/ja/docs/tutorial/body.md
. PR
## 3062
by
@a-takahashi223
.
🌐 Add Portuguese translation for
docs/pt/docs/tutorial/background-tasks.md
. PR
## 2170
by
@izaguerreiro
.
🌐 Add Portuguese translation for
docs/deployment/deta.md
. PR
## 4442
by
@lsglucas
.
🌐 Add Russian translation for
docs/async.md
. PR
## 4036
by
@Winand
.
🌐 Add Portuguese translation for
docs/tutorial/body.md
. PR
## 3960
by
@leandrodesouzadev
.
🌐 Add Portuguese translation of
tutorial/extra-data-types.md
. PR
## 4077
by
@luccasmmg
.
🌐 Update German translation for
docs/features.md
. PR
## 3905
by
@jomue
.
0.76.0
Upgrades
⬆ Upgrade Starlette from 0.17.1 to 0.18.0. PR
## 4483
by
@Kludex
.
Internal
👥 Update FastAPI People. PR
## 4847
by
@github-actions[bot]
.
🔧 Add Budget Insight sponsor. PR
## 4824
by
@tiangolo
.
🍱 Update sponsor, ExoFlare badge. PR
## 4822
by
@tiangolo
.
🔧 Update sponsors, enable Dropbase again, update TalkPython link. PR
## 4821
by
@tiangolo
.
0.75.2
This release includes upgrades to third-party packages that handle security issues. Although there's a chance these issues don't affect you in particular, please upgrade as soon as possible.
Fixes
✅ Fix new/recent tests with new fixed
ValidationError
JSON Schema. PR
## 4806
by
@tiangolo
.
🐛 Fix JSON Schema for
ValidationError
at field
loc
. PR
## 3810
by
@dconathan
.
🐛 Fix support for prefix on APIRouter WebSockets. PR
## 2640
by
@Kludex
.
Upgrades
⬆️ Update ujson ranges for CVE-2021-45958. PR
## 4804
by
@tiangolo
.
⬆️ Upgrade dependencies upper range for extras "all". PR
## 4803
by
@tiangolo
.
⬆ Upgrade Swagger UI - swagger-ui-dist@4. This handles a security issue in Swagger UI itself where it could be possible to inject HTML into Swagger UI. Please upgrade as soon as you can, in particular if you expose your Swagger UI (
/docs
) publicly to non-expert users. PR
## 4347
by
@RAlanWright
.
Internal
🔧 Update sponsors, add: ExoFlare, Ines Course; remove: Dropbase, Vim.so, Calmcode; update: Striveworks, TalkPython and TestDriven.io. PR
## 4805
by
@tiangolo
.
⬆️ Upgrade Codecov GitHub Action. PR
## 4801
by
@tiangolo
.
0.75.1
Translations
🌐 Start Dutch translations. PR
## 4703
by
@tiangolo
.
🌐 Start Persian/Farsi translations. PR
## 4243
by
@aminalaee
.
✏ Reword sentence about handling errors. PR
## 1993
by
@khuhroproeza
.
Internal
👥 Update FastAPI People. PR
## 4752
by
@github-actions[bot]
.
➖ Temporarily remove typer-cli from dependencies and upgrade Black to unblock Pydantic CI. PR
## 4754
by
@tiangolo
.
🔧 Add configuration to notify Dutch translations. PR
## 4702
by
@tiangolo
.
👥 Update FastAPI People. PR
## 4699
by
@github-actions[bot]
.
🐛 Fix FastAPI People generation to include missing file in commit. PR
## 4695
by
@tiangolo
.
🔧 Update Classiq sponsor links. PR
## 4688
by
@tiangolo
.
🔧 Add Classiq sponsor. PR
## 4671
by
@tiangolo
.
📝 Add Jina's QA Bot to the docs to help people that want to ask quick questions. PR
## 4655
by
@tiangolo
based on original PR
## 4626
by
@hanxiao
.
0.75.0
Features
✨ Add support for custom
generate_unique_id_function
and docs for generating clients. New docs:
Advanced - Generate Clients
. PR
## 4650
by
@tiangolo
.
0.74.1
Features
✨ Include route in scope to allow middleware and other tools to extract its information. PR
## 4603
by
@tiangolo
.
0.74.0
Breaking Changes
✨ Update internal
AsyncExitStack
to fix context for dependencies with
yield
. PR
## 4575
by
@tiangolo
.
Dependencies with
yield
can now catch
HTTPException
and custom exceptions. For example:
async
def
get_database
():
with
Session
()
as
session
:
try
:
yield
session
except
HTTPException
:
session
.
rollback
()
raise
finally
:
session
.
close
()
After the dependency with
yield
handles the exception (or not) the exception is raised again. So that any exception handlers can catch it, or ultimately the default internal
ServerErrorMiddleware
.
If you depended on exceptions not being received by dependencies with
yield
, and receiving an exception breaks the code after
yield
, you can use a block with
try
and
finally
:
async
def
do_something
():
try
:
yield
something
finally
:
some_cleanup
()
...that way the
finally
block is run regardless of any exception that might happen.
Features
The same PR
## 4575
from above also fixes the
contextvars
context for the code before and after
yield
. This was the main objective of that PR.
This means that now, if you set a value in a context variable before
yield
, the value would still be available after
yield
(as you would intuitively expect). And it also means that you can reset the context variable with a token afterwards.
For example, this works correctly now:
from
contextvars
import
ContextVar
from
typing
import
Any
,
Dict
,
Optional
legacy_request_state_context_var
:
ContextVar
[
Optional
[
Dict
[
str
,
Any
]]]
=
ContextVar
(
"legacy_request_state_context_var"
,
default
=
None
)
async
def
set_up_request_state_dependency
():
request_state
=
{
"user"
:
"deadpond"
}
contextvar_token
=
legacy_request_state_context_var
.
set
(
request_state
)
yield
request_state
legacy_request_state_context_var
.
reset
(
contextvar_token
)
...before this change it would raise an error when resetting the context variable, because the
contextvars
context was different, because of the way it was implemented.
Note
: You probably don't need
contextvars
, and you should probably avoid using them. But they are powerful and useful in some advanced scenarios, for example, migrating from code that used Flask's
g
semi-global variable.
Technical Details
: If you want to know more of the technical details you can check out the PR description
## 4575
.
Internal
🔧 Add Striveworks sponsor. PR
## 4596
by
@tiangolo
.
💚 Only build docs on push when on master to avoid duplicate runs from PRs. PR
## 4564
by
@tiangolo
.
👥 Update FastAPI People. PR
## 4502
by
@github-actions[bot]
.
0.73.0
Features
✨ Add support for declaring
UploadFile
parameters without explicit
File()
. PR
## 4469
by
@tiangolo
. New docs:
Request Files - File Parameters with UploadFile
.
✨ Add support for tags with Enums. PR
## 4468
by
@tiangolo
. New docs:
Path Operation Configuration - Tags with Enums
.
✨ Allow hiding from OpenAPI (and Swagger UI)
Query
,
Cookie
,
Header
, and
Path
parameters. PR
## 3144
by
@astraldawn
. New docs:
Query Parameters and String Validations - Exclude from OpenAPI
.
Docs
📝 Tweak and improve docs for Request Files. PR
## 4470
by
@tiangolo
.
Fixes
🐛 Fix bug preventing to use OpenAPI when using tuples. PR
## 3874
by
@victorbenichoux
.
🐛 Prefer custom encoder over defaults if specified in
jsonable_encoder
. PR
## 2061
by
@viveksunder
.
💚 Duplicate PR to trigger CI. PR
## 4467
by
@tiangolo
.
Internal
🐛 Fix docs dependencies cache, to get the latest Material for MkDocs. PR
## 4466
by
@tiangolo
.
🔧 Add sponsor Dropbase. PR
## 4465
by
@tiangolo
.
0.72.0
Features
✨ Enable configuring Swagger UI parameters. Original PR
## 2568
by
@jmriebold
. Here are the new docs:
Configuring Swagger UI
.
Docs
📝 Update Python Types docs, add missing 3.6 / 3.9 example. PR
## 4434
by
@tiangolo
.
Translations
🌐 Update Chinese translation for
docs/help-fastapi.md
. PR
## 3847
by
@jaystone776
.
🌐 Fix Korean translation for
docs/ko/docs/index.md
. PR
## 4195
by
@kty4119
.
🌐 Add Polish translation for
docs/pl/docs/index.md
. PR
## 4245
by
@MicroPanda123
.
🌐 Add Chinese translation for
docs\tutorial\path-operation-configuration.md
. PR
## 3312
by
@jaystone776
.
Internal
🔧 Enable MkDocs Material Insiders'
content.tabs.link
. PR
## 4399
by
@tiangolo
.
0.71.0
Features
✨ Add docs and tests for Python 3.9 and Python 3.10. PR
## 3712
by
@tiangolo
.
You can start with
Python Types Intro
, it explains what changes between different Python versions, in Python 3.9 and in Python 3.10.
All the FastAPI docs are updated. Each code example in the docs that could use different syntax in Python 3.9 or Python 3.10 now has all the alternatives in tabs.
⬆️ Upgrade Starlette to 0.17.1. PR
## 4145
by
@simondale00
.
Internal
👥 Update FastAPI People. PR
## 4354
by
@github-actions[bot]
.
🔧 Add FastAPI Trove Classifier for PyPI as now there's one 🤷😁. PR
## 4386
by
@tiangolo
.
⬆ Upgrade MkDocs Material and configs. PR
## 4385
by
@tiangolo
.
0.70.1
There's nothing interesting in this particular FastAPI release. It is mainly to enable/unblock the release of the next version of Pydantic that comes packed with features and improvements. 🤩
Fixes
🐛 Fix JSON Schema for dataclasses, supporting the fixes in Pydantic 1.9. PR
## 4272
by
@PrettyWood
.
Translations
🌐 Add Korean translation for
docs/tutorial/request-forms-and-files.md
. PR
## 3744
by
@NinaHwang
.
🌐 Add Korean translation for
docs/tutorial/request-files.md
. PR
## 3743
by
@NinaHwang
.
🌐 Add portuguese translation for
docs/tutorial/query-params-str-validations.md
. PR
## 3965
by
@leandrodesouzadev
.
🌐 Add Korean translation for
docs/tutorial/response-status-code.md
. PR
## 3742
by
@NinaHwang
.
🌐 Add Korean translation for Tutorial - JSON Compatible Encoder. PR
## 3152
by
@NEONKID
.
🌐 Add Korean translation for Tutorial - Path Parameters and Numeric Validations. PR
## 2432
by
@hard-coders
.
🌐 Add Korean translation for
docs/ko/docs/deployment/versions.md
. PR
## 4121
by
@DevDae
.
🌐 Fix Korean translation for
docs/ko/docs/tutorial/index.md
. PR
## 4193
by
@kimjaeyoonn
.
🔧 Add CryptAPI sponsor. PR
## 4264
by
@tiangolo
.
📝 Update
docs/tutorial/dependencies/classes-as-dependencies
: Add type of query parameters in a description of
Classes as dependencies
. PR
## 4015
by
@0417taehyun
.
🌐 Add French translation for Tutorial - First steps. PR
## 3455
by
@Smlep
.
🌐 Add French translation for
docs/tutorial/path-params.md
. PR
## 3548
by
@Smlep
.
🌐 Add French translation for
docs/tutorial/query-params.md
. PR
## 3556
by
@Smlep
.
🌐 Add Turkish translation for
docs/python-types.md
. PR
## 3926
by
@BilalAlpaslan
.
Internal
👥 Update FastAPI People. PR
## 4274
by
@github-actions[bot]
.
0.70.0
This release just upgrades Starlette to the latest version,
0.16.0
, which includes several bug fixes and some small breaking changes.
These last
three consecutive releases
are independent so that you can
migrate gradually
:
First to FastAPI
0.68.2
, with no breaking changes, but upgrading all the sub-dependencies.
Next to FastAPI
0.69.0
, which upgrades Starlette to
0.15.0
, with AnyIO support, and a higher chance of having breaking changes in your code.
Finally to FastAPI
0.70.0
, just upgrading Starlette to the latest version
0.16.0
with additional bug fixes.
This way, in case there was a breaking change for your code in one of the releases, you can still benefit from the previous upgrades. ✨
Breaking Changes - Upgrade
⬆️ Upgrade Starlette to 0.16.0. PR
## 4016
by
@tiangolo
.
Also upgrades the ranges of optional dependencies:
"jinja2 >=2.11.2,<4.0.0"
"itsdangerous >=1.1.0,<3.0.0"
0.69.0
Breaking Changes - Upgrade
This release adds support for
Trio
. ✨
It upgrades the version of Starlette to
0.15.0
, now based on
AnyIO
, and the internal async components in
FastAPI
are now based on AnyIO as well, making it compatible with both
asyncio
and
Trio
.
You can read the docs about running
FastAPI with Trio using Hypercorn
.
This release also removes
graphene
as an optional dependency for GraphQL. If you need to work with GraphQL, the recommended library now is
Strawberry
. You can read the new
FastAPI with GraphQL docs
.
Features
✨ Add support for Trio via AnyIO, upgrading Starlette to
0.15.0
. PR
## 3372
by
@graingert
.
➖ Remove
graphene
as an optional dependency. PR
## 4007
by
@tiangolo
.
Docs
📝 Add docs for using Trio with Hypercorn. PR
## 4014
by
@tiangolo
.
✏ Fix typos in Deployment Guide. PR
## 3975
by
@ghandic
.
📝 Update docs with pip install calls when using extras with brackets, use quotes for compatibility with Zsh. PR
## 3131
by
@tomwei7
.
📝 Add external link to article: Deploying ML Models as API Using FastAPI and Heroku. PR
## 3904
by
@kaustubhgupta
.
✏ Fix typo in file paths in
docs/en/docs/contributing.md
. PR
## 3752
by
@NinaHwang
.
✏ Fix a typo in
docs/en/docs/advanced/path-operation-advanced-configuration.md
and
docs/en/docs/release-notes.md
. PR
## 3750
by
@saintmalik
.
✏️ Add a missing comma in the security tutorial. PR
## 3564
by
@jalvaradosegura
.
✏ Fix typo in
docs/en/docs/help-fastapi.md
. PR
## 3760
by
@jaystone776
.
✏ Fix typo about file path in
docs/en/docs/tutorial/bigger-applications.md
. PR
## 3285
by
@HolyDorus
.
✏ Re-word to clarify test client in
docs/en/docs/tutorial/testing.md
. PR
## 3382
by
@Bharat123rox
.
📝 Fix incorrect highlighted code. PR
## 3325
by
@paxcodes
.
📝 Add external link to article: How-to deploy FastAPI app to Heroku. PR
## 3241
by
@Jarmos-san
.
✏ Fix typo (mistranslation) in
docs/en/docs/advanced/templates.md
. PR
## 3211
by
@oerpli
.
📝 Remove note about (now supported) feature from Swagger UI in
docs/en/docs/tutorial/request-files.md
. PR
## 2803
by
@gsganden
.
✏ Fix typo re-word in
docs/tutorial/handling-errors.md
. PR
## 2700
by
@graue70
.
Translations
🌐 Initialize Azerbaijani translations. PR
## 3941
by
@madatbay
.
🌐 Add Turkish translation for
docs/fastapi-people.md
. PR
## 3848
by
@BilalAlpaslan
.
Internal
📝 Add supported Python versions badge. PR
## 2794
by
@hramezani
.
✏ Fix link in Japanese docs for
docs/ja/docs/deployment/docker.md
. PR
## 3245
by
@utamori
.
🔧 Correct DeprecationWarning config and comment in pytest settings. PR
## 4008
by
@graingert
.
🔧 Swap light/dark theme button icon. PR
## 3246
by
@eddsalkield
.
🔧 Lint only in Python 3.7 and above. PR
## 4006
by
@tiangolo
.
🔧 Add GitHub Action notify-translations config for Azerbaijani. PR
## 3995
by
@tiangolo
.
0.68.2
This release has
no breaking changes
. 🎉
It upgrades the version ranges of sub-dependencies to allow applications using FastAPI to easily upgrade them.
Soon there will be a new FastAPI release upgrading Starlette to take advantage of recent improvements, but as that has a higher chance of having breaking changes, it will be in a separate release.
Features
⬆Increase supported version of aiofiles to suppress warnings. PR
## 2899
by
@SnkSynthesis
.
➖ Do not require backports in Python >= 3.7. PR
## 1880
by
@FFY00
.
⬆ Upgrade required Python version to >= 3.6.1, needed by typing.Deque, used by Pydantic. PR
## 2733
by
@hukkin
.
⬆️ Bump Uvicorn max range to 0.15.0. PR
## 3345
by
@Kludex
.
Docs
📝 Update GraphQL docs, recommend Strawberry. PR
## 3981
by
@tiangolo
.
📝 Re-write and extend Deployment guide: Concepts, Uvicorn, Gunicorn, Docker, Containers, Kubernetes. PR
## 3974
by
@tiangolo
.
📝 Upgrade HTTPS guide with more explanations and diagrams. PR
## 3950
by
@tiangolo
.
Translations
🌐 Add Turkish translation for
docs/features.md
. PR
## 1950
by
@ycd
.
🌐 Add Turkish translation for
docs/benchmarks.md
. PR
## 2729
by
@Telomeraz
.
🌐 Add Turkish translation for
docs/index.md
. PR
## 1908
by
@ycd
.
🌐 Add French translation for
docs/tutorial/body.md
. PR
## 3671
by
@Smlep
.
🌐 Add French translation for
deployment/docker.md
. PR
## 3694
by
@rjNemo
.
🌐 Add Portuguese translation for
docs/tutorial/path-params.md
. PR
## 3664
by
@FelipeSilva93
.
🌐 Add Portuguese translation for
docs/deployment/https.md
. PR
## 3754
by
@lsglucas
.
🌐 Add German translation for
docs/features.md
. PR
## 3699
by
@mawassk
.
Internal
✨ Update GitHub Action: notify-translations, to avoid a race conditions. PR
## 3989
by
@tiangolo
.
⬆️ Upgrade development
autoflake
, supporting multi-line imports. PR
## 3988
by
@tiangolo
.
⬆️ Increase dependency ranges for tests and docs: pytest-cov, pytest-asyncio, black, httpx, sqlalchemy, databases, mkdocs-markdownextradata-plugin. PR
## 3987
by
@tiangolo
.
👥 Update FastAPI People. PR
## 3986
by
@github-actions[bot]
.
💚 Fix badges in README and main page. PR
## 3979
by
@ghandic
.
⬆ Upgrade internal testing dependencies: mypy to version 0.910, add newly needed type packages. PR
## 3350
by
@ArcLightSlavik
.
✨ Add Deepset Sponsorship. PR
## 3976
by
@tiangolo
.
🎨 Tweak CSS styles for shell animations. PR
## 3888
by
@tiangolo
.
🔧 Add new Sponsor Calmcode.io. PR
## 3777
by
@tiangolo
.
0.68.1
✨ Add support for
read_with_orm_mode
, to support
SQLModel
relationship attributes. PR
## 3757
by
@tiangolo
.
Translations
🌐 Add Portuguese translation of
docs/fastapi-people.md
. PR
## 3461
by
@ComicShrimp
.
🌐 Add Chinese translation for
docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 3492
by
@jaystone776
.
🔧 Add new Translation tracking issues for German and Indonesian. PR
## 3718
by
@tiangolo
.
🌐 Add Chinese translation for
docs/tutorial/dependencies/sub-dependencies.md
. PR
## 3491
by
@jaystone776
.
🌐 Add Portuguese translation for
docs/advanced/index.md
. PR
## 3460
by
@ComicShrimp
.
🌐 Portuguese translation of
docs/async.md
. PR
## 1330
by
@Serrones
.
🌐 Add French translation for
docs/async.md
. PR
## 3416
by
@Smlep
.
Internal
✨ Add GitHub Action: Notify Translations. PR
## 3715
by
@tiangolo
.
✨ Update computation of FastAPI People and sponsors. PR
## 3714
by
@tiangolo
.
✨ Enable recent Material for MkDocs Insiders features. PR
## 3710
by
@tiangolo
.
🔥 Remove/clean extra imports from examples in docs for features. PR
## 3709
by
@tiangolo
.
➕ Update docs library to include sources in Markdown. PR
## 3648
by
@tiangolo
.
⬆ Enable tests for Python 3.9. PR
## 2298
by
@Kludex
.
👥 Update FastAPI People. PR
## 3642
by
@github-actions[bot]
.
0.68.0
Features
✨ Add support for extensions and updates to the OpenAPI schema in each
path operation
. New docs:
FastAPI Path Operation Advanced Configuration - OpenAPI Extra
. Initial PR
## 1922
by
@edouardlp
.
✨ Add additional OpenAPI metadata parameters to
FastAPI
class, shown on the automatic API docs UI. New docs:
Metadata and Docs URLs
. Initial PR
## 1812
by
@dkreeft
.
✨ Add
description
parameter to all the security scheme classes, e.g.
APIKeyQuery(name="key", description="A very cool API key")
. PR
## 1757
by
@hylkepostma
.
✨ Update OpenAPI models, supporting recursive models and extensions. PR
## 3628
by
@tiangolo
.
✨ Import and re-export data structures from Starlette, used by Request properties, on
fastapi.datastructures
. Initial PR
## 1872
by
@jamescurtin
.
Docs
📝 Update docs about async and response-model with more gender neutral language. PR
## 1869
by
@Edward-Knight
.
Translations
🌐 Add Russian translation for
docs/python-types.md
. PR
## 3039
by
@dukkee
.
🌐 Add Chinese translation for
docs/tutorial/dependencies/index.md
. PR
## 3489
by
@jaystone776
.
🌐 Add Russian translation for
docs/external-links.md
. PR
## 3036
by
@dukkee
.
🌐 Add Chinese translation for
docs/tutorial/dependencies/global-dependencies.md
. PR
## 3493
by
@jaystone776
.
🌐 Add Portuguese translation for
docs/deployment/versions.md
. PR
## 3618
by
@lsglucas
.
🌐 Add Japanese translation for
docs/tutorial/security/oauth2-jwt.md
. PR
## 3526
by
@sattosan
.
Internal
✅ Add the
docs_src
directory to test coverage and update tests. Initial PR
## 1904
by
@Kludex
.
🔧 Add new GitHub templates with forms for new issues. PR
## 3612
by
@tiangolo
.
📝 Add official FastAPI Twitter to docs:
@fastapi
. PR
## 3578
by
@tiangolo
.
0.67.0
Features
✨ Add support for
dataclasses
in request bodies and
response_model
. New documentation:
Advanced User Guide - Using Dataclasses
. PR
## 3577
by
@tiangolo
.
✨ Support
dataclasses
in responses. PR
## 3576
by
@tiangolo
, continuation from initial PR
## 2722
by
@amitlissack
.
Docs
📝 Add external link: How to Create A Fake Certificate Authority And Generate TLS Certs for FastAPI. PR
## 2839
by
@aitoehigie
.
✏ Fix code highlighted line in:
body-nested-models.md
. PR
## 3463
by
@jaystone776
.
✏ Fix typo in
body-nested-models.md
. PR
## 3462
by
@jaystone776
.
✏ Fix typo "might me" -> "might be" in
docs/en/docs/tutorial/schema-extra-example.md
. PR
## 3362
by
@dbrakman
.
📝 Add external link: Building simple E-Commerce with NuxtJS and FastAPI. PR
## 3271
by
@ShahriyarR
.
📝 Add external link: Serve a machine learning model using Sklearn, FastAPI and Docker. PR
## 2974
by
@rodrigo-arenas
.
✏️ Fix typo on docstring in datastructures file. PR
## 2887
by
@Kludex
.
📝 Add External Link: Deploy FastAPI on Ubuntu and Serve using Caddy 2 Web Server. PR
## 3572
by
@tiangolo
.
📝 Add External Link, replaces #1898. PR
## 3571
by
@tiangolo
.
Internal
🎨 Improve style for sponsors, add radius border. PR
## 2388
by
@Kludex
.
👷 Update GitHub Action latest-changes. PR
## 3574
by
@tiangolo
.
👷 Update GitHub Action latest-changes. PR
## 3573
by
@tiangolo
.
👷 Rename and clarify CI workflow job names. PR
## 3570
by
@tiangolo
.
👷 Update GitHub Action latest-changes, strike 2 ⚾. PR
## 3575
by
@tiangolo
.
🔧 Sort external links in docs to have the most recent at the top. PR
## 3568
by
@tiangolo
.
0.66.1
Translations
🌐 Add basic setup for German translations. PR
## 3522
by
@0x4Dark
.
🌐 Add Portuguese translation for
docs/tutorial/security/index.md
. PR
## 3507
by
@oandersonmagalhaes
.
🌐 Add Portuguese translation for
docs/deployment/index.md
. PR
## 3337
by
@lsglucas
.
Internal
🔧 Configure strict pytest options and update/refactor tests. Upgrade pytest to
>=6.2.4,<7.0.0
and pytest-cov to
>=2.12.0,<3.0.0
. Initial PR
## 2790
by
@graingert
.
⬆️ Upgrade python-jose dependency to
>=3.3.0,<4.0.0
for tests. PR
## 3468
by
@tiangolo
.
0.66.0
Features
✨ Allow setting the
response_class
to
RedirectResponse
or
FileResponse
and returning the URL from the function. New and updated docs are in the tutorial section
Custom Response - HTML, Stream, File, others
, in
RedirectResponse
and in
FileResponse
. PR
## 3457
by
@tiangolo
.
Fixes
🐛 Fix include/exclude for dicts in
jsonable_encoder
. PR
## 2016
by
@Rubikoid
.
🐛 Support custom OpenAPI / JSON Schema fields in the generated output OpenAPI. PR
## 1429
by
@jmagnusson
.
Translations
🌐 Add Spanish translation for
tutorial/query-params.md
. PR
## 2243
by
@mariacamilagl
.
🌐 Add Spanish translation for
advanced/response-directly.md
. PR
## 1253
by
@jfunez
.
🌐 Add Spanish translation for
advanced/additional-status-codes.md
. PR
## 1252
by
@jfunez
.
🌐 Add Spanish translation for
advanced/path-operation-advanced-configuration.md
. PR
## 1251
by
@jfunez
.
0.65.3
Fixes
♻ Assume request bodies contain JSON when no Content-Type header is provided. This fixes a breaking change introduced by
0.65.2 with PR #2118
. It should allow upgrading FastAPI applications with clients that send JSON data without a
Content-Type
header. And there's still protection against CSRFs. PR
## 3456
by
@tiangolo
.
Translations
🌐 Initialize Indonesian translations. PR
## 3014
by
@pace-noge
.
🌐 Add Spanish translation of Tutorial - Path Parameters. PR
## 2219
by
@mariacamilagl
.
🌐 Add Spanish translation of Tutorial - First Steps. PR
## 2208
by
@mariacamilagl
.
🌐 Portuguese translation of Tutorial - Body - Fields. PR
## 3420
by
@ComicShrimp
.
🌐 Add Chinese translation for Tutorial - Request - Forms - and - Files. PR
## 3249
by
@jaystone776
.
🌐 Add Chinese translation for Tutorial - Handling - Errors. PR
## 3299
by
@jaystone776
.
🌐 Add Chinese translation for Tutorial - Form - Data. PR
## 3248
by
@jaystone776
.
🌐 Add Chinese translation for Tutorial - Body - Updates. PR
## 3237
by
@jaystone776
.
🌐 Add Chinese translation for FastAPI People. PR
## 3112
by
@hareru
.
🌐 Add French translation for Project Generation. PR
## 3197
by
@Smlep
.
🌐 Add French translation for Python Types Intro. PR
## 3185
by
@Smlep
.
🌐 Add French translation for External Links. PR
## 3103
by
@Smlep
.
🌐 Add French translation for Alternatives, Inspiration and Comparisons. PR
## 3020
by
@rjNemo
.
🌐 Fix Chinese translation code snippet mismatch in Tutorial - Python Types Intro. PR
## 2573
by
@BoYanZh
.
🌐 Add Portuguese translation for Development Contributing. PR
## 1364
by
@Serrones
.
🌐 Add Chinese translation for Tutorial - Request - Files. PR
## 3244
by
@jaystone776
.
Internal
👥 Update FastAPI People. PR
## 3450
by
@github-actions[bot]
.
👥 Update FastAPI People. PR
## 3319
by
@github-actions[bot]
.
⬆ Upgrade docs development dependency on
typer-cli
to >=0.0.12 to fix conflicts. PR
## 3429
by
@tiangolo
.
0.65.2
Security fixes
🔒 Check Content-Type request header before assuming JSON. Initial PR
## 2118
by
@patrickkwang
.
This change fixes a
CSRF
security vulnerability when using cookies for authentication in path operations with JSON payloads sent by browsers.
In versions lower than
0.65.2
, FastAPI would try to read the request payload as JSON even if the
content-type
header sent was not set to
application/json
or a compatible JSON media type (e.g.
application/geo+json
).
So, a request with a content type of
text/plain
containing JSON data would be accepted and the JSON data would be extracted.
But requests with content type
text/plain
are exempt from
CORS
preflights, for being considered
Simple requests
. So, the browser would execute them right away including cookies, and the text content could be a JSON string that would be parsed and accepted by the FastAPI application.
See
CVE-2021-32677
for more details.
Thanks to
Dima Boger
for the security report! 🙇🔒
Internal
🔧 Update sponsors badge, course bundle. PR
## 3340
by
@tiangolo
.
🔧 Add new gold sponsor Jina 🎉. PR
## 3291
by
@tiangolo
.
🔧 Add new banner sponsor badge for FastAPI courses bundle. PR
## 3288
by
@tiangolo
.
👷 Upgrade Issue Manager GitHub Action. PR
## 3236
by
@tiangolo
.
0.65.1
Security fixes
📌 Upgrade pydantic pin, to handle security vulnerability
CVE-2021-29510
. PR
## 3213
by
@tiangolo
.
0.65.0
Breaking Changes - Upgrade
⬆️ Upgrade Starlette to
0.14.2
, including internal
UJSONResponse
migrated from Starlette. This includes several bug fixes and features from Starlette. PR
## 2335
by
@hanneskuettner
.
Translations
🌐 Initialize new language Polish for translations. PR
## 3170
by
@neternefer
.
Internal
👷 Add GitHub Action cache to speed up CI installs. PR
## 3204
by
@tiangolo
.
⬆️ Upgrade setup-python GitHub Action to v2. PR
## 3203
by
@tiangolo
.
🐛 Fix docs script to generate a new translation language with
overrides
boilerplate. PR
## 3202
by
@tiangolo
.
✨ Add new Deta banner badge with new sponsorship tier 🙇. PR
## 3194
by
@tiangolo
.
👥 Update FastAPI People. PR
## 3189
by
@github-actions[bot]
.
🔊 Update FastAPI People to allow better debugging. PR
## 3188
by
@tiangolo
.
0.64.0
Features
✨ Add support for adding multiple
examples
in request bodies and path, query, cookie, and header params. New docs:
Declare Request Example Data
. Initial PR
## 1267
by
@austinorr
.
Fixes
📌 Pin SQLAlchemy range for tests, as it doesn't use SemVer. PR
## 3001
by
@tiangolo
.
🎨 Add newly required type annotations for mypy. PR
## 2882
by
@tiangolo
.
🎨 Remove internal "type: ignore", now unnecessary. PR
## 2424
by
@AsakuraMizu
.
Docs
📝 Add link to article in Russian "FastAPI: знакомимся с фреймворком". PR
## 2564
by
@trkohler
.
📝 Add external link to blog post "Authenticate Your FastAPI App with Auth0". PR
## 2172
by
@dompatmore
.
📝 Fix broken link to article: Machine learning model serving in Python using FastAPI and Streamlit. PR
## 2557
by
@davidefiocco
.
📝 Add FastAPI Medium Article: Deploy a dockerized FastAPI application to AWS. PR
## 2515
by
@vjanz
.
✏ Fix typo in Tutorial - Handling Errors. PR
## 2486
by
@johnthagen
.
✏ Fix typo in Security OAuth2 scopes. PR
## 2407
by
@jugmac00
.
✏ Fix typo/clarify docs for SQL (Relational) Databases. PR
## 2393
by
@kangni
.
📝 Add external link to "FastAPI for Flask Users". PR
## 2280
by
@amitness
.
Translations
🌐 Fix Chinese translation of Tutorial - Query Parameters, remove obsolete content. PR
## 3051
by
@louis70109
.
🌐 Add French translation for Tutorial - Background Tasks. PR
## 3098
by
@Smlep
.
🌐 Fix Korean translation for docs/ko/docs/index.md. PR
## 3159
by
@SueNaEunYang
.
🌐 Add Korean translation for Tutorial - Query Parameters. PR
## 2390
by
@hard-coders
.
🌐 Add French translation for FastAPI People. PR
## 2232
by
@JulianMaurin
.
🌐 Add Korean translation for Tutorial - Path Parameters. PR
## 2355
by
@hard-coders
.
🌐 Add French translation for Features. PR
## 2157
by
@Jefidev
.
👥 Update FastAPI People. PR
## 3031
by
@github-actions[bot]
.
🌐 Add Chinese translation for Tutorial - Debugging. PR
## 2737
by
@blt232018
.
🌐 Add Chinese translation for Tutorial - Security - OAuth2 with Password (and hashing), Bearer with JWT tokens. PR
## 2642
by
@waynerv
.
🌐 Add Korean translation for Tutorial - Header Parameters. PR
## 2589
by
@mode9
.
🌐 Add Chinese translation for Tutorial - Metadata and Docs URLs. PR
## 2559
by
@blt232018
.
🌐 Add Korean translation for Tutorial - First Steps. PR
## 2323
by
@hard-coders
.
🌐 Add Chinese translation for Tutorial - CORS (Cross-Origin Resource Sharing). PR
## 2540
by
@blt232018
.
🌐 Add Chinese translation for Tutorial - Middleware. PR
## 2334
by
@lpdswing
.
🌐 Add Korean translation for Tutorial - Intro. PR
## 2317
by
@hard-coders
.
🌐 Add Chinese translation for Tutorial - Bigger Applications - Multiple Files. PR
## 2453
by
@waynerv
.
🌐 Add Chinese translation for Tutorial - Security - Security Intro. PR
## 2443
by
@waynerv
.
🌐 Add Chinese translation for Tutorial - Header Parameters. PR
## 2412
by
@maoyibo
.
🌐 Add Chinese translation for Tutorial - Extra Data Types. PR
## 2410
by
@maoyibo
.
🌐 Add Japanese translation for Deployment - Docker. PR
## 2312
by
@tokusumi
.
🌐 Add Japanese translation for Deployment - Versions. PR
## 2310
by
@tokusumi
.
🌐 Add Chinese translation for Tutorial - Cookie Parameters. PR
## 2261
by
@alicrazy1947
.
🌐 Add Japanese translation for Tutorial - Static files. PR
## 2260
by
@tokusumi
.
🌐 Add Japanese translation for Tutorial - Testing. PR
## 2259
by
@tokusumi
.
🌐 Add Japanese translation for Tutorial - Debugging. PR
## 2256
by
@tokusumi
.
🌐 Add Japanese translation for Tutorial - Middleware. PR
## 2255
by
@tokusumi
.
🌐 Add Japanese translation for Concurrency and async / await. PR
## 2058
by
@tokusumi
.
🌐 Add Chinese translation for Tutorial - Security - Simple OAuth2 with Password and Bearer. PR
## 2514
by
@waynerv
.
🌐 Add Japanese translation for Deployment - Deta. PR
## 2314
by
@tokusumi
.
🌐 Add Chinese translation for Tutorial - Security - Get Current User. PR
## 2474
by
@waynerv
.
🌐 Add Japanese translation for Deployment - Manually. PR
## 2313
by
@tokusumi
.
🌐 Add Japanese translation for Deployment - Intro. PR
## 2309
by
@tokusumi
.
🌐 Add Japanese translation for FastAPI People. PR
## 2254
by
@tokusumi
.
🌐 Add Japanese translation for Advanced - Path Operation Advanced Configuration. PR
## 2124
by
@Attsun1031
.
🌐 Add Japanese translation for External Links. PR
## 2070
by
@tokusumi
.
🌐 Add Japanese translation for Tutorial - Body - Updates. PR
## 1956
by
@SwftAlpc
.
🌐 Add Japanese translation for Tutorial - Form Data. PR
## 1943
by
@SwftAlpc
.
🌐 Add Japanese translation for Tutorial - Cookie Parameters. PR
## 1933
by
@SwftAlpc
.
Internal
🔧 Update top banner, point to newsletter. PR
## 3003
by
@tiangolo
.
🔧 Disable sponsor WeTransfer. PR
## 3002
by
@tiangolo
.
👥 Update FastAPI People. PR
## 2880
by
@github-actions[bot]
.
👥 Update FastAPI People. PR
## 2739
by
@github-actions[bot]
.
🔧 Add new Gold Sponsor Talk Python 🎉. PR
## 2673
by
@tiangolo
.
🔧 Add new Gold Sponsor vim.so 🎉. PR
## 2669
by
@tiangolo
.
🔧 Add FastAPI user survey banner. PR
## 2623
by
@tiangolo
.
🔧 Add new Bronze Sponsor(s) 🥉🎉. PR
## 2622
by
@tiangolo
.
📝 Update social links: add Discord, fix GitHub. PR
## 2621
by
@tiangolo
.
🔧 Update FastAPI People GitHub Sponsors order. PR
## 2620
by
@tiangolo
.
🔧 Update InvestSuite sponsor data. PR
## 2608
by
@tiangolo
.
👥 Update FastAPI People. PR
## 2590
by
@github-actions[bot]
.
0.63.0
Features
✨ Improve type annotations, add support for mypy --strict, internally and for external packages. PR
## 2547
by
@tiangolo
.
Breaking changes
⬆️ Upgrade Uvicorn when installing
fastapi[all]
to the latest version including
uvloop
, the new range is
uvicorn[standard] >=0.12.0,<0.14.0
. PR
## 2548
by
@tiangolo
.
Fixes
🐛 PR
## 2547
(read above) also fixes some false-positive mypy errors with
callbacks
parameters and when using the
OAuth2
class.
Docs
📝 Update Uvicorn installation instructions to use uvicorn[standard] (includes uvloop). PR
## 2543
by
@tiangolo
.
📝 Update title for Deta tutorial. PR
## 2466
by
@tiangolo
.
👥 Update FastAPI People. PR
## 2454
by
@github-actions[bot]
.
Translations
🌐 Add docs lang selector widget. PR
## 2542
by
@tiangolo
.
🌐 Add Chinese translation for Tutorial - Response Status Code. PR
## 2442
by
@waynerv
.
🌐 Start translation of the documentation for the Albanian language. PR
## 2516
by
@vjanz
.
🌐 Add Chinese translation for Tutorial - Extra Models. PR
## 2416
by
@waynerv
.
🌐 Add Chinese translation for Tutorial - Response Model. PR
## 2414
by
@waynerv
.
🌐 Add Chinese translation for Tutorial - Schema Extra Example. PR
## 2411
by
@maoyibo
.
🌐 Add Korean translation for Index. PR
## 2192
by
@hard-coders
.
🌐 Add Japanese translation for Advanced User Guide - Additional Status Codes. PR
## 2145
by
@Attsun1031
.
Internal
🐛 Fix docs overrides directory for translations. PR
## 2541
by
@tiangolo
.
➖ Remove Typer as a docs building dependency (covered by typer-cli) to fix pip resolver conflicts. PR
## 2539
by
@tiangolo
.
✨ Add newsletter: FastAPI and friends. PR
## 2509
by
@tiangolo
.
✨ Add new Gold Sponsor: InvestSuite 🎉. PR
## 2508
by
@tiangolo
.
🔧 Add issue template configs. PR
## 2476
by
@tiangolo
.
0.62.0
Features
✨ Add support for shared/top-level parameters (dependencies, tags, etc). PR
## 2434
by
@tiangolo
.
Up to now, for several options, the only way to apply them to a group of
path operations
was in
include_router
. That works well, but the call to
app.include_router()
or
router.include_router()
is normally done in another file.
That means that, for example, to apply authentication to all the
path operations
in a router it would end up being done in a different file, instead of keeping related logic together.
Setting options in
include_router
still makes sense in some cases, for example, to override or increase configurations from a third party router included in an app. But in a router that is part of a bigger application, it would probably make more sense to add those settings when creating the
APIRouter
.
In
FastAPI
This allows setting the (mostly new) parameters (additionally to the already existing parameters):
default_response_class
: updated to handle defaults in
APIRouter
and
include_router
.
dependencies
: to include ✨ top-level dependencies ✨ that apply to the whole application. E.g. to add global authentication.
callbacks
: OpenAPI callbacks that apply to all the
path operations
.
deprecated
: to mark all the
path operations
as deprecated. 🤷
include_in_schema
: to allow excluding all the
path operations
from the OpenAPI schema.
responses
: OpenAPI responses that apply to all the
path operations
.
For example:
from
fastapi
import
FastAPI
,
Depends
async
def
some_dependency
():
return
app
=
FastAPI
(
dependencies
=
[
Depends
(
some_dependency
)])
In
APIRouter
This allows setting the (mostly new) parameters (additionally to the already existing parameters):
default_response_class
: updated to handle defaults in
APIRouter
and
include_router
. For example, it's not needed to set it explicitly when
creating callbacks
.
dependencies
: to include ✨ router-level dependencies ✨ that apply to all the
path operations
in a router. Up to now, this was only possible with
include_router
.
callbacks
: OpenAPI callbacks that apply to all the
path operations
in this router.
deprecated
: to mark all the
path operations
in a router as deprecated.
include_in_schema
: to allow excluding all the
path operations
in a router from the OpenAPI schema.
responses
: OpenAPI responses that apply to all the
path operations
in a router.
prefix
: to set the path prefix for a router. Up to now, this was only possible when calling
include_router
.
tags
: OpenAPI tags to apply to all the
path operations
in this router.
For example:
from
fastapi
import
APIRouter
,
Depends
async
def
some_dependency
():
return
router
=
APIRouter
(
prefix
=
"/users"
,
dependencies
=
[
Depends
(
some_dependency
)])
In
include_router
Most of these settings are now supported in
APIRouter
, which normally lives closer to the related code, so it is recommended to use
APIRouter
when possible.
But
include_router
is still useful to, for example, adding options (like
dependencies
,
prefix
, and
tags
) when including a third party router, or a generic router that is shared between several projects.
This PR allows setting the (mostly new) parameters (additionally to the already existing parameters):
default_response_class
: updated to handle defaults in
APIRouter
and
FastAPI
.
deprecated
: to mark all the
path operations
in a router as deprecated in OpenAPI.
include_in_schema
: to allow disabling all the
path operations
from showing in the OpenAPI schema.
callbacks
: OpenAPI callbacks that apply to all the
path operations
in this router.
Note: all the previous parameters are still there, so it's still possible to declare
dependencies
in
include_router
.
Breaking Changes
PR
## 2434
includes several improvements that shouldn't affect normal use cases, but could affect in advanced scenarios:
If you are testing the generated OpenAPI (you shouldn't, FastAPI already tests it extensively for you): the order for
tags
in
include_router
and
path operations
was updated for consistency, but it's a simple order change.
If you have advanced custom logic to access each route's
route.response_class
, or the
router.default_response_class
, or the
app.default_response_class
: the default value for
response_class
in
APIRoute
and for
default_response_class
in
APIRouter
and
FastAPI
is now a
DefaultPlaceholder
used internally to handle and solve default values and overrides. The actual response class inside the
DefaultPlaceholder
is available at
route.response_class.value
.
Docs
PR
## 2434
(above) includes new or updated docs:
Advanced User Guide - OpenAPI Callbacks
.
Tutorial - Bigger Applications
.
Tutorial - Dependencies - Dependencies in path operation decorators
.
Tutorial - Dependencies - Global Dependencies
.
📝 Add FastAPI monitoring blog post to External Links. PR
## 2324
by
@louisguitton
.
✏️ Fix typo in Deta tutorial. PR
## 2320
by
@tiangolo
.
✨ Add Discord chat. PR
## 2322
by
@tiangolo
.
📝 Fix image links for sponsors. PR
## 2304
by
@tiangolo
.
Translations
🌐 Add Japanese translation for Advanced - Custom Response. PR
## 2193
by
@Attsun1031
.
🌐 Add Chinese translation for Benchmarks. PR
## 2119
by
@spaceack
.
🌐 Add Chinese translation for Tutorial - Body - Nested Models. PR
## 1609
by
@waynerv
.
🌐 Add Chinese translation for Advanced - Custom Response. PR
## 1459
by
@RunningIkkyu
.
🌐 Add Chinese translation for Advanced - Return a Response Directly. PR
## 1452
by
@RunningIkkyu
.
🌐 Add Chinese translation for Advanced - Additional Status Codes. PR
## 1451
by
@RunningIkkyu
.
🌐 Add Chinese translation for Advanced - Path Operation Advanced Configuration. PR
## 1447
by
@RunningIkkyu
.
🌐 Add Chinese translation for Advanced User Guide - Intro. PR
## 1445
by
@RunningIkkyu
.
Internal
🔧 Update TestDriven link to course in sponsors section. PR
## 2435
by
@tiangolo
.
🍱 Update sponsor logos. PR
## 2418
by
@tiangolo
.
💚 Fix disabling install of Material for MkDocs Insiders in forks, strike 1 ⚾. PR
## 2340
by
@tiangolo
.
🐛 Fix disabling Material for MkDocs Insiders install in forks. PR
## 2339
by
@tiangolo
.
✨ Add silver sponsor WeTransfer. PR
## 2338
by
@tiangolo
.
✨ Set up and enable Material for MkDocs Insiders for the docs. PR
## 2325
by
@tiangolo
.
0.61.2
Fixes
📌 Relax Swagger UI version pin. PR
## 2089
by
@jmriebold
.
🐛 Fix bug overriding custom HTTPException and RequestValidationError from exception_handlers. PR
## 1924
by
@uriyyo
.
✏️ Fix typo on dependencies utils and cleanup unused variable. PR
## 1912
by
@Kludex
.
Docs
✏️ Fix typo in Tutorial - Path Parameters. PR
## 2231
by
@mariacamilagl
.
✏ Fix a stylistic error in docs. PR
## 2206
by
@ddobrinskiy
.
✏ Fix capitalizaiton typo in docs. PR
## 2204
by
@imba-tjd
.
✏ Fix typo in docs. PR
## 2179
by
@ammarasmro
.
📝 Update/fix links in docs to use HTTPS. PR
## 2165
by
@imba-tjd
.
✏ Fix typos and add rewording in docs. PR
## 2159
by
@nukopy
.
📝 Fix code consistency in examples for Tutorial - User Guide - Path Parameters. PR
## 2158
by
@nukopy
.
📝 Fix renamed parameter
content_type
typo. PR
## 2135
by
@TeoZosa
.
✏ Fix minor typos in docs. PR
## 2122
by
@TeoZosa
.
✏ Fix typos in docs and source examples. PR
## 2102
by
@AdrianDeAnda
.
✏ Fix incorrect Celery URLs in docs. PR
## 2100
by
@CircleOnCircles
.
📝 Simplify intro to Python Types, all currently supported Python versions include type hints 🎉. PR
## 2085
by
@ninjaaron
.
📝 Fix example code with sets in Tutorial - Body - Nested Models 3. PR
## 2054
by
@hitrust
.
📝 Fix example code with sets in Tutorial - Body - Nested Models 2. PR
## 2053
by
@hitrust
.
📝 Fix example code with sets in Tutorial - Body - Nested Models. PR
## 2052
by
@hitrust
.
✏ Fix typo in Benchmarks. PR
## 1995
by
@AlejoAsd
.
📝 Add note in CORS tutorial about allow_origins with ["*"] and allow_credentials. PR
## 1895
by
@dsmurrell
.
📝 Add deployment to Deta, the first gold sponsor 🎉. PR
## 2303
by
@tiangolo
.
👥 Update FastAPI People. PR
## 2282
by
@github-actions[bot]
.
✏️ Fix uppercase in Tutorial - Query parameters. PR
## 2245
by
@mariacamilagl
.
📝 Add articles to External Links. PR
## 2247
by
@tiangolo
.
✏ Fix typo in Spanish tutorial index. PR
## 2020
by
@aviloncho
.
Translations
🌐 Add Japanese translation for Advanced Tutorial - Response Directly. PR
## 2191
by
@Attsun1031
.
📝 Add Japanese translation for Tutorial - Security - First Steps. PR
## 2153
by
@komtaki
.
🌐 Add Japanese translation for Tutorial - Query Parameters and String Validations. PR
## 1901
by
@SwftAlpc
.
🌐 Add Portuguese translation for External Links. PR
## 1443
by
@Serrones
.
🌐 Add Japanese translation for Tutorial - CORS. PR
## 2125
by
@tokusumi
.
🌐 Add Japanese translation for Contributing. PR
## 2067
by
@komtaki
.
🌐 Add Japanese translation for Project Generation. PR
## 2050
by
@tokusumi
.
🌐 Add Japanese translation for Alternatives. PR
## 2043
by
@Attsun1031
.
🌐 Add Japanese translation for History Design and Future. PR
## 2002
by
@komtaki
.
🌐 Add Japanese translation for Benchmarks. PR
## 1992
by
@komtaki
.
🌐 Add Japanese translation for Tutorial - Header Parameters. PR
## 1935
by
@SwftAlpc
.
🌐 Add Portuguese translation for Tutorial - First Steps. PR
## 1861
by
@jessicapaz
.
🌐 Add Portuguese translation for Python Types. PR
## 1796
by
@izaguerreiro
.
🌐 Add Japanese translation for Help FastAPI. PR
## 1692
by
@tokusumi
.
🌐 Add Japanese translation for Tutorial - Body. PR
## 1683
by
@tokusumi
.
🌐 Add Japanese translation for Tutorial - Query Params. PR
## 1674
by
@tokusumi
.
🌐 Add Japanese translation for tutorial/path-params.md. PR
## 1671
by
@tokusumi
.
🌐 Add Japanese translation for tutorial/first-steps.md. PR
## 1658
by
@tokusumi
.
🌐 Add Japanese translation for tutorial/index.md. PR
## 1656
by
@tokusumi
.
🌐 Add translation to Portuguese for Project Generation. PR
## 1602
by
@Serrones
.
🌐 Add Japanese translation for Features. PR
## 1625
by
@tokusumi
.
🌐 Initialize new language Korean for translations. PR
## 2018
by
@hard-coders
.
🌐 Add Portuguese translation of Deployment. PR
## 1374
by
@Serrones
.
Internal
🔥 Cleanup after upgrade for Docs Previews GitHub Action. PR
## 2248
by
@tiangolo
.
🐛 Fix CI docs preview, unzip docs. PR
## 2246
by
@tiangolo
.
✨ Add instant docs deploy previews for PRs from forks. PR
## 2244
by
@tiangolo
.
⚡️ Build docs for languages in parallel in subprocesses to speed up CI. PR
## 2242
by
@tiangolo
.
🐛 Fix docs order generation for partial translations. PR
## 2238
by
@tiangolo
.
👥 Update FastAPI People. PR
## 2202
by
@github-actions[bot]
.
♻️ Update FastAPI People GitHub Action to send the PR as github-actions. PR
## 2201
by
@tiangolo
.
🔧 Update FastAPI People GitHub Action config, run monthly. PR
## 2199
by
@tiangolo
.
🐛 Fix FastAPI People GitHub Action Docker dependency, strike 1 ⚾. PR
## 2198
by
@tiangolo
.
🐛 Fix FastAPI People GitHub Action Docker dependencies. PR
## 2197
by
@tiangolo
.
🐛 Fix FastAPI People GitHub Action when there's nothing to change. PR
## 2196
by
@tiangolo
.
👥 Add new section FastAPI People. PR
## 2195
by
@tiangolo
.
⬆️ Upgrade GitHub Action Latest Changes. PR
## 2190
by
@tiangolo
.
⬆️ Upgrade GitHub Action Label Approved. PR
## 2189
by
@tiangolo
.
🔧 Update GitHub Action Label Approved, run at 12:00. PR
## 2185
by
@tiangolo
.
👷 Upgrade GitHub Action Latest Changes. PR
## 2184
by
@tiangolo
.
👷 Set GitHub Action Label Approved to run daily, not every minute. PR
## 2163
by
@tiangolo
.
🔥 Remove pr-approvals GitHub Action as it's not compatible with forks. Use the new one. PR
## 2162
by
@tiangolo
.
👷 Add GitHub Action Latest Changes. PR
## 2160
.
👷 Add GitHub Action Label Approved. PR
## 2161
.
0.61.1
Fixes
Fix issues using
jsonable_encoder
with SQLAlchemy models directly. PR
## 1987
.
Docs
Fix typo in NoSQL docs. PR
## 1980
by
@facundojmaero
.
Translations
Add translation for
main page to Japanese
PR
## 1571
by
@ryuckel
.
Initialize French translations. PR
## 1975
by
@JulianMaurin-BM
.
Initialize Turkish translations. PR
## 1905
by
@ycd
.
Internal
Improve docs maintainability by updating
hl_lines
syntax to use ranges. PR
## 1863
by
@la-mar
.
0.61.0
Features
Add support for injecting
HTTPConnection
(as
Request
and
WebSocket
). Useful for sharing app state in dependencies. PR
## 1827
by
@nsidnev
.
Export
WebSocketDisconnect
and add example handling WebSocket disconnections to docs. PR
## 1822
by
@rkbeatss
.
Breaking Changes
Require Pydantic >
1.0.0
.
Remove support for deprecated Pydantic
0.32.2
. This improves maintainability and allows new features.
In
FastAPI
and
APIRouter
:
Remove
path operation decorators
related/deprecated parameter
response_model_skip_defaults
(use
response_model_exclude_unset
instead).
Change
path operation decorators
parameter default for
response_model_exclude
from
set()
to
None
(as is in Pydantic).
In
encoders.jsonable_encoder
:
Remove deprecated
skip_defaults
, use instead
exclude_unset
.
Set default of
exclude
from
set()
to
None
(as is in Pydantic).
PR
## 1862
.
In
encoders.jsonable_encoder
remove parameter
sqlalchemy_safe
.
It was an early hack to allow returning SQLAlchemy models, but it was never documented, and the recommended way is using Pydantic's
orm_mode
as described in the tutorial:
SQL (Relational) Databases
.
PR
## 1864
.
Docs
Add link to the course by TestDriven.io:
Test-Driven Development with FastAPI and Docker
. PR
## 1860
.
Fix empty log message in docs example about handling errors. PR
## 1815
by
@manlix
.
Reword text to reduce ambiguity while not being gender-specific. PR
## 1824
by
@Mause
.
Internal
Add Flake8 linting. Original PR
## 1774
by
@MashhadiNima
.
Disable Gitter bot, as it's currently broken, and Gitter's response doesn't show the problem. PR
## 1853
.
0.60.2
Fix typo in docs for query parameters. PR
## 1832
by
@ycd
.
Add docs about
Async Tests
. PR
## 1619
by
@empicano
.
Raise an exception when using form data (
Form
,
File
) without having
python-multipart
installed.
Up to now the application would run, and raise an exception only when receiving a request with form data, the new behavior, raising early, will prevent from deploying applications with broken dependencies.
It also detects if the correct package
python-multipart
is installed instead of the incorrect
multipart
(both importable as
multipart
).
PR
## 1851
based on original PR
## 1627
by
@chrisngyn
,
@YKo20010
,
@kx-chen
.
Re-enable Gitter releases bot. PR
## 1831
.
Add link to async SQL databases tutorial from main SQL tutorial. PR
## 1813
by
@short2strings
.
Fix typo in tutorial about behind a proxy. PR
## 1807
by
@toidi
.
Fix typo in Portuguese docs. PR
## 1795
by
@izaguerreiro
.
Add translations setup for Ukrainian. PR
## 1830
.
Add external link
Build And Host Fast Data Science Applications Using FastAPI
. PR
## 1786
by
@Kludex
.
Fix encoding of Pydantic models that inherit from others models with custom
json_encoders
. PR
## 1769
by
@henrybetts
.
Simplify and improve
jsonable_encoder
. PR
## 1754
by
@MashhadiNima
.
Simplify internal code syntax in several points. PR
## 1753
by
@uriyyo
.
Improve internal typing, declare
Optional
parameters. PR
## 1731
by
@MashhadiNima
.
Add external link
Deploy FastAPI on Azure App Service
to docs. PR
## 1726
by
@windson
.
Add link to Starlette docs about WebSocket testing. PR
## 1717
by
@hellocoldworld
.
Refactor generating dependant, merge for loops. PR
## 1714
by
@Bloodielie
.
Update example for templates with Jinja to include HTML media type. PR
## 1690
by
@frafra
.
Fix typos in docs for security. PR
## 1678
by
@nilslindemann
.
Fix typos in docs for dependencies. PR
## 1675
by
@nilslindemann
.
Fix type annotation for
**extra
parameters in
FastAPI
. PR
## 1659
by
@bharel
.
Bump MkDocs Material to fix docs in browsers with dark mode. PR
## 1789
by
@adriencaccia
.
Remove docs preview comment from each commit. PR
## 1826
.
Update GitHub context extraction for Gitter notification bot. PR
## 1766
.
0.60.1
Add debugging logs for GitHub actions to introspect GitHub hidden context. PR
## 1764
.
Use OS preference theme for online docs. PR
## 1760
by
@adriencaccia
.
Upgrade Starlette to version
0.13.6
to handle a vulnerability when using static files in Windows. PR
## 1759
by
@jamesag26
.
Pin Swagger UI temporarily, waiting for a fix for
swagger-api/swagger-ui#6249
. PR
## 1763
.
Update GitHub Actions, use commit from PR for docs preview, not commit from pre-merge. PR
## 1761
.
Update GitHub Actions, refactor Gitter bot. PR
## 1746
.
0.60.0
Add GitHub Action to watch for missing preview docs and trigger a preview deploy. PR
## 1740
.
Add custom GitHub Action to get artifact with docs preview. PR
## 1739
.
Add new GitHub Actions to preview docs from PRs. PR
## 1738
.
Add XML test coverage to support GitHub Actions. PR
## 1737
.
Update badges and remove Travis now that GitHub Actions is the main CI. PR
## 1736
.
Add GitHub Actions for CI, move from Travis. PR
## 1735
.
Add support for adding OpenAPI schema for GET requests with a body. PR
## 1626
by
@victorphoenix3
.
0.59.0
Fix typo in docstring for OAuth2 utils. PR
## 1621
by
@tomarv2
.
Update JWT docs to use Python-jose instead of PyJWT. Initial PR
## 1610
by
@asheux
.
Fix/re-enable search bar in docs. PR
## 1703
.
Auto-generate a "server" in OpenAPI
servers
when there's a
root_path
instead of prefixing all the
paths
:
Add a new parameter for
FastAPI
classes:
root_path_in_servers
to disable the auto-generation of
servers
.
New docs about
root_path
and
servers
in
Additional Servers
.
Update OAuth2 examples to use a relative URL for
tokenUrl="token"
to make sure those examples keep working as-is even when behind a reverse proxy.
Initial PR
## 1596
by
@rkbeatss
.
Fix typo/link in External Links. PR
## 1702
.
Update handling of
External Links
to use a data file and allow translating the headers without becoming obsolete quickly when new links are added. PR
## https://github.com/tiangolo/fastapi/pull/1701
.
Add external link
Machine learning model serving in Python using FastAPI and Streamlit
to docs. PR
## 1669
by
@davidefiocco
.
Add note in docs on order in Pydantic Unions. PR
## 1591
by
@kbanc
.
Improve support for tests in editor. PR
## 1699
.
Pin dependencies. PR
## 1697
.
Update isort to version 5.x.x. PR
## 1670
by
@asheux
.
0.58.1
Add link in docs to Pydantic data types. PR
## 1612
by
@tayoogunbiyi
.
Fix link in warning logs for
openapi_prefix
. PR
## 1611
by
@bavaria95
.
Fix bad link in docs. PR
## 1603
by
@molto0504
.
Add Vim temporary files to
.gitignore
for contributors using Vim. PR
## 1590
by
@asheux
.
Fix typo in docs for sub-applications. PR
## 1578
by
@schlpbch
.
Use
Optional
in all the examples in the docs. Original PR
## 1574
by
@chrisngyn
,
@kx-chen
,
@YKo20010
. Updated and merged PR
## 1644
.
Update tests and handling of
response_model_by_alias
. PR
## 1642
.
Add translation to Chinese for
Body - Fields - 请求体 - 字段
. PR
## 1569
by
@waynerv
.
Update Chinese translation of main page. PR
## 1564
by
@waynerv
.
Add translation to Chinese for
Body - Multiple Parameters - 请求体 - 多个参数
. PR
## 1532
by
@waynerv
.
Add translation to Chinese for
Path Parameters and Numeric Validations - 路径参数和数值校验
. PR
## 1506
by
@waynerv
.
Add GitHub action to auto-label approved PRs (mainly for translations). PR
## 1638
.
0.58.0
Deep merge OpenAPI responses to preserve all the additional metadata. PR
## 1577
.
Mention in docs that only main app events are run (not sub-apps). PR
## 1554
by
@amacfie
.
Fix body validation error response, do not include body variable when it is not embedded. PR
## 1553
by
@amacfie
.
Fix testing OAuth2 security scopes when using dependency overrides. PR
## 1549
by
@amacfie
.
Fix Model for JSON Schema keyword
not
as a JSON Schema instead of a list. PR
## 1548
by
@v-do
.
Add support for OpenAPI
servers
. PR
## 1547
by
@mikaello
.
0.57.0
Remove broken link from "External Links". PR
## 1565
by
@victorphoenix3
.
Update/fix docs for
WebSockets with dependencies
. Original PR
## 1540
by
@ChihSeanHsu
.
Add support for Python's
http.HTTPStatus
in
status_code
parameters. PR
## 1534
by
@retnikt
.
When using Pydantic models with
__root__
, use the internal value in
jsonable_encoder
. PR
## 1524
by
@patrickkwang
.
Update docs for path parameters. PR
## 1521
by
@yankeexe
.
Update docs for first steps, links and rewording. PR
## 1518
by
@yankeexe
.
Enable
showCommonExtensions
in Swagger UI to show additional validations like
maxLength
, etc. PR
## 1466
by
@TiewKH
.
Make
OAuth2PasswordRequestFormStrict
importable directly from
fastapi.security
. PR
## 1462
by
@RichardHoekstra
.
Add docs about
Default response class
. PR
## 1455
by
@TezRomacH
.
Add note in docs about additional parameters
response_model_exclude_defaults
and
response_model_exclude_none
in
Response Model
. PR
## 1427
by
@wshayes
.
Add note about
PyCharm Pydantic plugin
to docs. PR
## 1420
by
@koxudaxi
.
Update and clarify testing function name. PR
## 1395
by
@chenl
.
Fix duplicated headers created by indirect dependencies that use the request directly. PR
## 1386
by
@obataku
from tests by
@scottsmith2gmail
.
Upgrade Starlette version to
0.13.4
. PR
## 1361
by
@rushton
.
Improve error handling and feedback for requests with invalid JSON. PR
## 1354
by
@aviramha
.
Add support for declaring metadata for tags in OpenAPI. New docs at
Tutorial - Metadata and Docs URLs - Metadata for tags
. PR
## 1348
by
@thomas-maschler
.
Add basic setup for Russian translations. PR
## 1566
.
Remove obsolete Chinese articles after adding official community translations. PR
## 1510
by
@waynerv
.
Add
__repr__
for
path operation function
parameter helpers (like
Query
,
Depends
, etc) to simplify debugging. PR
## 1560
by
@rkbeatss
and
@victorphoenix3
.
0.56.1
Add link to advanced docs from tutorial. PR
## 1512
by
@kx-chen
.
Remove internal unnecessary f-strings. PR
## 1526
by
@kotamatsuoka
.
Add translation to Chinese for
Query Parameters and String Validations - 查询参数和字符串校验
. PR
## 1500
by
@waynerv
.
Add translation to Chinese for
Request Body - 请求体
. PR
## 1492
by
@waynerv
.
Add translation to Chinese for
Help FastAPI - Get Help - 帮助 FastAPI - 获取帮助
. PR
## 1465
by
@waynerv
.
Add translation to Chinese for
Query Parameters - 查询参数
. PR
## 1454
by
@waynerv
.
Add translation to Chinese for
Contributing - 开发 - 贡献
. PR
## 1460
by
@waynerv
.
Add translation to Chinese for
Path Parameters - 路径参数
. PR
## 1453
by
@waynerv
.
Add official Microsoft project generator for
serving spaCy with FastAPI and Azure Cognitive Skills
to
Project Generators
. PR
## 1390
by
@kabirkhan
.
Update docs in
Python Types Intro
to include info about
Optional
. Original PR
## 1377
by
@yaegassy
.
Fix support for callable class dependencies with
yield
. PR
## 1365
by
@mrosales
.
Fix/remove incorrect error logging when a client sends invalid payloads. PR
## 1351
by
@dbanty
.
Add translation to Chinese for
First Steps - 第一步
. PR
## 1323
by
@waynerv
.
Fix generating OpenAPI for apps using callbacks with routers including Pydantic models. PR
## 1322
by
@nsidnev
.
Optimize internal regex performance in
get_path_param_names()
. PR
## 1243
by
@heckad
.
Remove
*,
from functions in docs where it's not needed. PR
## 1239
by
@pankaj-giri
.
Start translations for Italian. PR
## 1557
by
@csr
.
0.56.0
Add support for ASGI
root_path
:
Use
root_path
internally for mounted applications, so that OpenAPI and the docs UI works automatically without extra configurations and parameters.
Add new
root_path
parameter for
FastAPI
applications to provide it in cases where it can be set with the command line (e.g. for Uvicorn and Hypercorn, with the parameter
--root-path
).
Deprecate
openapi_prefix
parameter in favor of the new
root_path
parameter.
Add new/updated docs for
Sub Applications - Mounts
, without
openapi_prefix
(as it is now handled automatically).
Add new/updated docs for
Behind a Proxy
, including how to setup a local testing proxy with Traefik and using
root_path
.
Update docs for
Extending OpenAPI
with the new
openapi_prefix
parameter passed (internally generated from
root_path
).
Original PR
## 1199
by
@iksteen
.
Update new issue templates and docs:
Help FastAPI - Get Help
. PR
## 1531
.
Update GitHub action issue-manager. PR
## 1520
.
Add new links:
English articles
:
Real-time Notifications with Python and Postgres
by
Guillermo Cruz
.
Microservice in Python using FastAPI
by
Paurakh Sharma Humagain
.
Build simple API service with Python FastAPI — Part 1
by
cuongld2
.
FastAPI + Zeit.co = 🚀
by
Paul Sec
.
Build a web API from scratch with FastAPI - the workshop
by
Sebastián Ramírez (tiangolo)
.
Build a Secure Twilio Webhook with Python and FastAPI
by
Twilio
.
Using FastAPI with Django
by
Stavros Korokithakis
.
Introducing Dispatch
by
Netflix
.
Podcasts
:
Build The Next Generation Of Python Web Applications With FastAPI - Episode 259 - interview to Sebastían Ramírez (tiangolo)
by
Podcast.
__init__
.
Talks
:
PyConBY 2020: Serve ML models easily with FastAPI
by
Sebastián Ramírez (tiangolo)
.
[VIRTUAL] Py.Amsterdam's flying Software Circus: Intro to FastAPI
by
Sebastián Ramírez (tiangolo)
.
PR
## 1467
.
Add translation to Chinese for
Python Types Intro - Python 类型提示简介
. PR
## 1197
by
@waynerv
.
0.55.1
Fix handling of enums with their own schema in path parameters. To support
pydantic/pydantic#1432
in FastAPI. PR
## 1463
.
0.55.0
Allow enums to allow them to have their own schemas in OpenAPI. To support
pydantic/pydantic#1432
in FastAPI. PR
## 1461
.
Add links for funding through
GitHub sponsors
. PR
## 1425
.
Update issue template for for questions. PR
## 1344
by
@retnikt
.
Update warning about storing passwords in docs. PR
## 1336
by
@skorokithakis
.
Fix typo. PR
## 1326
by
@chenl
.
Add translation to Portuguese for
Alternatives, Inspiration and Comparisons - Alternativas, Inspiração e Comparações
. PR
## 1325
by
@Serrones
.
Fix 2 typos in docs. PR
## 1324
by
@waynerv
.
Update CORS docs, fix correct default of
max_age=600
. PR
## 1301
by
@derekbekoe
.
Add translation of
main page to Portuguese
. PR
## 1300
by
@Serrones
.
Re-word and clarify docs for extra info in fields. PR
## 1299
by
@chris-allnutt
.
Make sure the
*
in short features in the docs is consistent (after
.
) in all languages. PR
## 1424
.
Update order of execution for
get_db
in SQLAlchemy tutorial. PR
## 1293
by
@bcb
.
Fix typos in Async docs. PR
## 1423
.
0.54.2
Add translation to Spanish for
Concurrency and async / await - Concurrencia y async / await
. PR
## 1290
by
@alvaropernas
.
Remove obsolete vote link. PR
## 1289
by
@donhui
.
Allow disabling docs UIs by just disabling OpenAPI with
openapi_url=None
. New example in docs:
Advanced: Conditional OpenAPI
. PR
## 1421
.
Add translation to Portuguese for
Benchmarks - Comparações
. PR
## 1274
by
@Serrones
.
Add translation to Portuguese for
Tutorial - User Guide - Intro - Tutorial - Guia de Usuário - Introdução
. PR
## 1259
by
@marcosmmb
.
Allow using Unicode in MkDocs for translations. PR
## 1419
.
Add translation to Spanish for
Advanced User Guide - Intro - Guía de Usuario Avanzada - Introducción
. PR
## 1250
by
@jfunez
.
Add translation to Portuguese for
History, Design and Future - História, Design e Futuro
. PR
## 1249
by
@marcosmmb
.
Add translation to Portuguese for
Features - Recursos
. PR
## 1248
by
@marcosmmb
.
Add translation to Spanish for
Tutorial - User Guide - Intro - Tutorial - Guía de Usuario - Introducción
. PR
## 1244
by
@MartinEliasQ
.
Add translation to Chinese for
Deployment - 部署
. PR
## 1203
by
@RunningIkkyu
.
Add translation to Chinese for
Tutorial - User Guide - Intro - 教程 - 用户指南 - 简介
. PR
## 1202
by
@waynerv
.
Add translation to Chinese for
Features - 特性
. PR
## 1192
by
@Dustyposa
.
Add translation for
main page to Chinese
PR
## 1191
by
@waynerv
.
Update docs for project generation. PR
## 1287
.
Add Spanish translation for
Introducción a los Tipos de Python (Python Types Intro)
. PR
## 1237
by
@mariacamilagl
.
Add Spanish translation for
Características (Features)
. PR
## 1220
by
@mariacamilagl
.
0.54.1
Update database test setup. PR
## 1226
.
Improve test debugging by showing response text in failing tests. PR
## 1222
by
@samuelcolvin
.
0.54.0
Fix grammatical mistakes in async docs. PR
## 1188
by
@mickeypash
.
Add support for
response_model_exclude_defaults
and
response_model_exclude_none
:
Deprecate the parameter
include_none
in
jsonable_encoder
and add the inverted
exclude_none
, to keep in sync with Pydantic.
PR
## 1166
by
@voegtlel
.
Add example about
Testing a Database
. Initial PR
## 1144
by
@duganchen
.
Update docs for
Development - Contributing: Translations
including note about reviewing translation PRs.
## 1215
.
Update log style in README.md for GitHub Markdown compatibility. PR
## 1200
by
## geekgao
.
Add Python venv
env
to
.gitignore
. PR
## 1212
by
@cassiobotaro
.
Start Portuguese translations. PR
## 1210
by
@cassiobotaro
.
Update docs for Pydantic's
Settings
using a dependency with
@lru_cache()
. PR
## 1214
.
Add first translation to Spanish
FastAPI
. PR
## 1201
by
@mariacamilagl
.
Add docs about
Settings and Environment Variables
. Initial PR
1118
by
@alexmitelman
.
0.53.2
Fix automatic embedding of body fields for dependencies and sub-dependencies. Original PR
## 1079
by
@Toad2186
.
Fix dependency overrides in WebSocket testing. PR
## 1122
by
@amitlissack
.
Fix docs script to ensure languages are always sorted. PR
## 1189
.
Start translations for Chinese. PR
## 1187
by
@RunningIkkyu
.
Add docs for
Schema Extra - Example
. PR
## 1185
.
0.53.1
Fix included example after translations refactor. PR
## 1182
.
Add docs example for
example
in
Field
. Docs at
Body - Fields: JSON Schema extras
. PR
## 1106
by
@JohnPaton
.
Fix using recursive models in
response_model
. PR
## 1164
by
@voegtlel
.
Add docs for
Pycharm Debugging
. PR
## 1096
by
@youngquan
.
Fix typo in docs. PR
## 1148
by
@PLNech
.
Update Windows development environment instructions. PR
## 1179
.
0.53.0
Update test coverage badge. PR
## 1175
.
Add
orjson
to
pip install fastapi[all]
. PR
## 1161
by
@michael0liver
.
Fix included example for
GZipMiddleware
. PR
## 1138
by
@arimbr
.
Fix class name in docstring for
OAuth2PasswordRequestFormStrict
. PR
## 1126
by
@adg-mh
.
Clarify function name in example in docs. PR
## 1121
by
@tmsick
.
Add external link
Apache Kafka producer and consumer with FastAPI and aiokafka
to docs. PR
## 1112
by
@iwpnd
.
Fix serialization when using
by_alias
or
exclude_unset
and returning data with Pydantic models. PR
## 1074
by
@juhovh-aiven
.
Add Gitter chat to docs. PR
## 1061
by
@aakashnand
.
Update and simplify translations docs. PR
## 1171
.
Update development of FastAPI docs, set address to
127.0.0.1
to improve Windows support. PR
## 1169
by
@mariacamilagl
.
Add support for docs translations. New docs:
Development - Contributing: Docs: Translations
. PR
## 1168
.
Update terminal styles in docs and add note about
Typer
, the FastAPI of CLIs
. PR
## 1139
.
0.52.0
Add new high-performance JSON response class using
orjson
. New docs:
Custom Response - HTML, Stream, File, others:
ORJSONResponse
. PR
## 1065
.
0.51.0
Re-export utils from Starlette:
This allows using things like
from fastapi.responses import JSONResponse
instead of
from starlette.responses import JSONResponse
.
It's mainly syntax sugar, a convenience for developer experience.
Now
Request
,
Response
,
WebSocket
,
status
can be imported directly from
fastapi
as in
from fastapi import Response
. This is because those are frequently used, to use the request directly, to set headers and cookies, to get status codes, etc.
Documentation changes in many places, but new docs and noticeable improvements:
Custom Response - HTML, Stream, File, others
.
Advanced Middleware
.
Including WSGI - Flask, Django, others
.
PR
## 1064
.
0.50.0
Add link to Release Notes from docs about pinning versions for deployment. PR
## 1058
.
Upgrade code to use the latest version of Starlette, including:
Several bug fixes.
Optional redirects of slashes, with or without ending in
/
.
Events for routers,
"startup"
, and
"shutdown"
.
PR
## 1057
.
Add docs about pinning FastAPI versions for deployment:
Deployment: FastAPI versions
. PR
## 1056
.
0.49.2
Fix links in release notes. PR
## 1052
by
@sattosan
.
Fix typo in release notes. PR
## 1051
by
@sattosan
.
Refactor/clarify
serialize_response
parameter name to avoid confusion. PR
## 1031
by
@patrickmckenna
.
Refactor calling each a path operation's handler function in an isolated function, to simplify profiling. PR
## 1027
by
@sm-Fifteen
.
Add missing dependencies for testing. PR
## 1026
by
@sm-Fifteen
.
Fix accepting valid types for response models, including Python types like
List[int]
. PR
## 1017
by
@patrickmckenna
.
Fix format in SQL tutorial. PR
## 1015
by
@vegarsti
.
0.49.1
Fix path operation duplicated parameters when used in dependencies and the path operation function. PR
## 994
by
@merowinger92
.
Update Netlify previews deployment GitHub action as the fix is already merged and there's a new release. PR
## 1047
.
Move mypy configurations to config file. PR
## 987
by
@hukkinj1
.
Temporary fix to Netlify previews not deployable from PRs from forks. PR
## 1046
by
@mariacamilagl
.
0.49.0
Fix encoding of
pathlib
paths in
jsonable_encoder
. PR
## 978
by
@patrickmckenna
.
Add articles to
External Links
:
PythonのWeb frameworkのパフォーマンス比較 (Django, Flask, responder, FastAPI, japronto)
and
[FastAPI] Python製のASGI Web フレームワーク FastAPIに入門する
. PR
## 974
by
@tokusumi
.
Fix broken links in docs. PR
## 949
by
@tsotnikov
.
Fix small typos. PR
## 941
by
@NikitaKolesov
.
Update and clarify docs for dependencies with
yield
. PR
## 986
.
Add Mermaid JS support for diagrams in docs. Add first diagrams to
Dependencies: First Steps
and
Dependencies with
yield
and
HTTPException
. PR
## 985
.
Update CI to run docs deployment in GitHub actions. PR
## 983
.
Allow
callable
s in
path operation functions
, like functions modified with
functools.partial
. PR
## 977
.
0.48.0
Run linters first in tests to error out faster. PR
## 948
.
Log warning about
email-validator
only when used. PR
## 946
.
Simplify
Peewee docs
with double dependency with
yield
. PR
## 947
.
Add article
External Links
:
Create and Deploy FastAPI app to Heroku
. PR
## 942
by
@windson
.
Update description of Sanic, as it is now ASGI too. PR
## 932
by
@raphaelauv
.
Fix typo in main page. PR
## 920
by
@mMarzeta
.
Fix parsing of possibly invalid bodies. PR
## 918
by
@dmontagu
.
Fix typo
## 916
by
@adursun
.
Allow
Any
type for enums in OpenAPI. PR
## 906
by
@songzhi
.
Add article to
External Links
:
How to continuously deploy a FastAPI to AWS Lambda with AWS SAM
. PR
## 901
by
@iwpnd
.
Add note about using Body parameters without Pydantic. PR
## 900
by
@pawamoy
.
Fix Pydantic field clone logic. PR
## 899
by
@deuce2367
.
Fix link in middleware docs. PR
## 893
by
@linchiwei123
.
Rename default API title from "Fast API" to "FastAPI" for consistency. PR
## 890
.
0.47.1
Fix model filtering in
response_model
, cloning sub-models. PR
## 889
.
Fix FastAPI serialization of Pydantic models using ORM mode blocking the event loop. PR
## 888
.
0.47.0
Refactor documentation to make a simpler and shorter
Tutorial - User Guide
and an additional
Advanced User Guide
with all the additional docs. PR
## 887
.
Tweak external links, Markdown format, typos. PR
## 881
.
Fix bug in tutorial handling HTTP Basic Auth
username
and
password
. PR
## 865
by
@isaevpd
.
Fix handling form
path operation
parameters declared with pure classes like
list
,
tuple
, etc. PR
## 856
by
@nsidnev
.
Add request
body
to
RequestValidationError
, new docs:
Use the
RequestValidationError
body
. Initial PR
## 853
by
@aviramha
.
Update
External Links
with new links and dynamic GitHub projects with
fastapi
topic. PR
## 850
.
Fix Peewee
contextvars
handling in docs:
SQL (Relational) Databases with Peewee
. PR
## 879
.
Setup development environment with Python's Venv and Flit, instead of requiring the extra Pipenv duplicating dependencies. Updated docs:
Development - Contributing
. PR
## 877
.
Update docs for
HTTP Basic Auth
to improve security against timing attacks. Initial PR
## 807
by
@zwass
.
0.46.0
Fix typos and tweak configs. PR
## 837
.
Add link to Chinese article in
External Links
. PR
810
by
@wxq0309
.
Implement
OAuth2AuthorizationCodeBearer
class. PR
## 797
by
@kuwv
.
Update example upgrade in docs main page. PR
## 795
by
@cdeil
.
Fix callback handling for sub-routers. PR
## 792
by
@jekirl
.
Fix typos. PR
## 784
by
@kkinder
.
Add 4 Japanese articles to
External Links
. PR
## 783
by
@HymanZHAN
.
Add support for subtypes of main types in
jsonable_encoder
, e.g. asyncpg's UUIDs. PR
## 756
by
@RmStorm
.
Fix usage of Pydantic's
HttpUrl
in docs. PR
## 832
by
@Dustyposa
.
Fix Twitter links in docs. PR
## 813
by
@justindujardin
.
Add docs for correctly
using FastAPI with Peewee ORM
. Including how to overwrite parts of Peewee to correctly handle async threads. PR
## 789
.
0.45.0
Add support for OpenAPI Callbacks:
New docs:
OpenAPI Callbacks
.
Refactor generation of
operationId
s to be valid Python names (also valid variables in most languages).
Add
default_response_class
parameter to
APIRouter
.
Original PR
## 722
by
@booooh
.
Refactor logging to use the same logger everywhere, update log strings and levels. PR
## 781
.
Add article to
External Links
:
Почему Вы должны попробовать FastAPI?
. PR
## 766
by
@prostomarkeloff
.
Remove gender bias in docs for handling errors. PR
## 780
. Original idea in PR
## 761
by
@classywhetten
.
Rename docs and references to
body-schema
to
body-fields
to keep in line with Pydantic. PR
## 746
by
@prostomarkeloff
.
0.44.1
Add GitHub social preview images to git. PR
## 752
.
Update PyPI "trove classifiers". PR
## 751
.
Add full support for Python 3.8. Enable Python 3.8 in full in Travis. PR
749
.
Update "new issue" templates. PR
## 749
.
Fix serialization of errors for exotic Pydantic types. PR
## 748
by
@dmontagu
.
0.44.0
Add GitHub action
Issue Manager
. PR
## 742
.
Fix typos in docs. PR
734
by
@bundabrg
.
Fix usage of
custom_encoder
in
jsonable_encoder
. PR
## 715
by
@matrixise
.
Fix invalid XML example. PR
710
by
@OcasoProtal
.
Fix typos and update wording in deployment docs. PR
## 700
by
@marier-nico
.
Add note about dependencies in
APIRouter
docs. PR
## 698
by
@marier-nico
.
Add support for async class methods as dependencies
## 681
by
@frankie567
.
Add FastAPI with Swagger UI cheatsheet to external links. PR
## 671
by
@euri10
.
Fix typo in HTTP protocol in CORS example. PR
## 647
by
@forestmonster
.
Add support for Pydantic versions
1.0.0
and above, with temporary (deprecated) backwards compatibility for Pydantic
0.32.2
. PR
## 646
by
@dmontagu
.
0.43.0
Update docs to reduce gender bias. PR
## 645
by
@ticosax
.
Add docs about
overriding the
operationId
for all the
path operations
based on their function name. PR
## 642
by
@SKalt
.
Fix validators in models generating an incorrect key order. PR
## 637
by
@jaddison
.
Generate correct OpenAPI docs for responses with no content. PR
## 621
by
@brotskydotcom
.
Remove
$
from Bash code blocks in docs for consistency. PR
## 613
by
@nstapelbroek
.
Add docs for
self-serving docs' (Swagger UI) static assets
, e.g. to use the docs offline, or without Internet. Initial PR
## 557
by
@svalouch
.
Fix
black
linting after upgrade. PR
## 682
by
@frankie567
.
0.42.0
Add dependencies with
yield
, a.k.a. exit steps, context managers, cleanup, teardown, ...
This allows adding extra code after a dependency is done. It can be used, for example, to close database connections.
Dependencies with
yield
can be normal or
async
,
FastAPI
will run normal dependencies in a threadpool.
They can be combined with normal dependencies.
It's possible to have arbitrary trees/levels of dependencies with
yield
and exit steps are handled in the correct order automatically.
It works by default in Python 3.7 or above. For Python 3.6, it requires the extra backport dependencies:
async-exit-stack
async-generator
New docs at
Dependencies with
yield
.
Updated database docs
SQL (Relational) Databases: Main
FastAPI
app
.
PR
## 595
.
Fix
sitemap.xml
in website. PR
## 598
by
@samuelcolvin
.
0.41.0
Upgrade required Starlette to
0.12.9
, the new range is
>=0.12.9,<=0.12.9
.
Add
State
to FastAPI apps at
app.state
.
PR
## 593
.
Improve handling of custom classes for
Request
s and
APIRoute
s.
This helps to more easily solve use cases like:
Reading a body before and/or after a request (equivalent to a middleware).
Run middleware-like code only for a subset of
path operations
.
Process a request before passing it to a
path operation function
. E.g. decompressing, deserializing, etc.
Processing a response after being generated by
path operation functions
but before returning it. E.g. adding custom headers, logging, adding extra metadata.
New docs section:
Custom Request and APIRoute class
.
PR
## 589
by
@dmontagu
.
Fix preserving custom route class in routers when including other sub-routers. PR
## 538
by
@dmontagu
.
0.40.0
Add notes to docs about installing
python-multipart
when using forms. PR
## 574
by
@sliptonic
.
Generate OpenAPI schemas in alphabetical order. PR
## 554
by
@dmontagu
.
Add support for truncating docstrings from
path operation functions
.
New docs at
Advanced description from docstring
.
PR
## 556
by
@svalouch
.
Fix
DOCTYPE
in HTML files generated for Swagger UI and ReDoc. PR
## 537
by
@Trim21
.
Fix handling
4XX
responses overriding default
422
validation error responses. PR
## 517
by
@tsouvarev
.
Fix typo in documentation for
Simple HTTP Basic Auth
. PR
## 514
by
@prostomarkeloff
.
Fix incorrect documentation example in
first steps
. PR
## 511
by
@IgnatovFedor
.
Add support for Swagger UI
initOauth
settings with the parameter
swagger_ui_init_oauth
. PR
## 499
by
@zamiramir
.
0.39.0
Allow path parameters to have default values (e.g.
None
) and discard them instead of raising an error.
This allows declaring a parameter like
user_id: str = None
that can be taken from a query parameter, but the same
path operation
can be included in a router with a path
/users/{user_id}
, in which case will be taken from the path and will be required.
PR
## 464
by
@jonathanunderwood
.
Add support for setting a
default_response_class
in the
FastAPI
instance or in
include_router
. Initial PR
## 467
by
@toppk
.
Add support for type annotations using strings and
from __future__ import annotations
. PR
## 451
by
@dmontagu
.
0.38.1
Fix incorrect
Request
class import. PR
## 493
by
@kamalgill
.
0.38.0
Add recent articles to
External Links
and recent opinions. PR
## 490
.
Upgrade support range for Starlette to include
0.12.8
. The new range is
>=0.11.1,<=0.12.8"
. PR
## 477
by
@dmontagu
.
Upgrade support to Pydantic version 0.32.2 and update internal code to use it (breaking change). PR
## 463
by
@dmontagu
.
0.37.0
Add support for custom route classes for advanced use cases. PR
## 468
by
@dmontagu
.
Allow disabling Google fonts in ReDoc. PR
## 481
by
@b1-luettje
.
Fix security issue: when returning a sub-class of a response model and using
skip_defaults
it could leak information. PR
## 485
by
@dmontagu
.
Enable tests for Python 3.8-dev. PR
## 465
by
@Jamim
.
Add support and tests for Pydantic dataclasses in
response_model
. PR
## 454
by
@dconathan
.
Fix typo in OAuth2 JWT tutorial. PR
## 447
by
@pablogamboa
.
Use the
media_type
parameter in
Body()
params to set the media type in OpenAPI for
requestBody
. PR
## 439
by
@divums
.
Add article
Deploying a scikit-learn model with ONNX and FastAPI
by
Nico Axtmann
. PR
## 438
by
@naxty
.
Allow setting custom
422
(validation error) response/schema in OpenAPI.
And use media type from response class instead of fixed
application/json
(the default).
PR
## 437
by
@divums
.
Fix using
"default"
extra response with status codes at the same time. PR
## 489
.
Allow additional responses to use status code ranges (like
5XX
and
4XX
) and
"default"
. PR
## 435
by
@divums
.
0.36.0
Fix implementation for
skip_defaults
when returning a Pydantic model. PR
## 422
by
@dmontagu
.
Fix OpenAPI generation when using the same dependency in multiple places for the same
path operation
. PR
## 417
by
@dmontagu
.
Allow having empty paths in
path operations
used with
include_router
and a
prefix
.
This allows having a router for
/cats
and all its
path operations
, while having one of them for
/cats
.
Now it doesn't have to be only
/cats/
(with a trailing slash).
To use it, declare the path in the
path operation
as the empty string (
""
).
PR
## 415
by
@vitalik
.
Fix mypy error after merging PR #415. PR
## 462
.
0.35.0
Fix typo in routing
assert
. PR
## 419
by
@pablogamboa
.
Fix typo in docs. PR
## 411
by
@bronsen
.
Fix parsing a body type declared with
Union
. PR
## 400
by
@koxudaxi
.
0.34.0
Upgrade Starlette supported range to include the latest
0.12.7
. The new range is
0.11.1,<=0.12.7
. PR
## 367
by
@dedsm
.
Add test for OpenAPI schema with duplicate models from PR
## 333
by
@dmontagu
. PR
## 385
.
0.33.0
Upgrade Pydantic version to
0.30.0
. PR
## 384
by
@jekirl
.
0.32.0
Fix typo in docs for features. PR
## 380
by
@MartinoMensio
.
Fix source code
limit
for example in
Query Parameters
. PR
## 366
by
@Smashman
.
Update wording in docs about
OAuth2 scopes
. PR
## 371
by
@cjw296
.
Update docs for
Enum
s to inherit from
str
and improve Swagger UI rendering. PR
## 351
.
Fix regression, add Swagger UI deep linking again. PR
## 350
.
Add test for having path templates in
prefix
of
.include_router
. PR
## 349
.
Add note to docs:
Include the same router multiple times with different
prefix
. PR
## 348
.
Fix OpenAPI/JSON Schema generation for two functions with the same name (in different modules) with the same composite bodies.
Composite bodies' IDs are now based on path, not only on route name, as the auto-generated name uses the function names, that can be duplicated in different modules.
The same new ID generation applies to response models.
This also changes the generated title for those models.
Only composite bodies and response models are affected because those are generated dynamically, they don't have a module (a Python file).
This also adds the possibility of using
.include_router()
with the same
APIRouter
multiple
times, with different prefixes, e.g.
/api/v2
and
/api/latest
, and it will now work correctly.
PR
## 347
.
0.31.0
Upgrade Pydantic supported version to
0.29.0
.
New supported version range is
"pydantic >=0.28,<=0.29.0"
.
This adds support for Pydantic
Generic Models
, kudos to
@dmontagu
.
PR
## 344
.
0.30.1
Add section in docs about
External Links and Articles
. PR
## 341
.
Remove
Pipfile.lock
from the repository as it is only used by FastAPI contributors (developers of FastAPI itself). See the PR for more details. PR
## 340
.
Update section about
Help FastAPI - Get Help
. PR
## 339
.
Refine internal type declarations to improve/remove Mypy errors in users' code. PR
## 338
.
Update and clarify
SQL tutorial with SQLAlchemy
. PR
## 331
by
@mariacamilagl
.
Add SQLite
online viewers to the docs
. PR
## 330
by
@cyrilbois
.
0.30.0
Add support for Pydantic's ORM mode:
Updated documentation about SQL with SQLAlchemy, using Pydantic models with ORM mode, SQLAlchemy models with relations, separation of files, simplification of code and other changes. New docs:
SQL (Relational) Databases
.
The new support for ORM mode fixes issues/adds features related to ORMs with lazy-loading, hybrid properties, dynamic/getters (using
@property
decorators) and several other use cases.
This applies to ORMs like SQLAlchemy, Peewee, Tortoise ORM, GINO ORM and virtually any other.
If your
path operations
return an arbitrary object with attributes (e.g.
my_item.name
instead of
my_item["name"]
) AND you use a
response_model
, make sure to update the Pydantic models with
orm_mode = True
as described in the docs (link above).
New documentation about receiving plain
dict
s as request bodies:
Bodies of arbitrary
dict
s
.
New documentation about returning arbitrary
dict
s in responses:
Response with arbitrary
dict
.
Technical Details
:
When declaring a
response_model
it is used directly to generate the response content, from whatever was returned from the
path operation function
.
Before this, the return content was first passed through
jsonable_encoder
to ensure it was a "jsonable" object, like a
dict
, instead of an arbitrary object with attributes (like an ORM model). That's why you should make sure to update your Pydantic models for objects with attributes to use
orm_mode = True
.
If you don't have a
response_model
, the return object will still be passed through
jsonable_encoder
first.
When a
response_model
is declared, the same
response_model
type declaration won't be used as is, it will be "cloned" to create an new one (a cloned Pydantic
Field
with all the submodels cloned as well).
This avoids/fixes a potential security issue: as the returned object is passed directly to Pydantic, if the returned object was a subclass of the
response_model
(e.g. you return a
UserInDB
that inherits from
User
but contains extra fields, like
hashed_password
, and
User
is used in the
response_model
), it would still pass the validation (because
UserInDB
is a subclass of
User
) and the object would be returned as-is, including the
hashed_password
. To fix this, the declared
response_model
is cloned, if it is a Pydantic model class (or contains Pydantic model classes in it, e.g. in a
List[Item]
), the Pydantic model class(es) will be a different one (the "cloned" one). So, an object that is a subclass won't simply pass the validation and returned as-is, because it is no longer a sub-class of the cloned
response_model
. Instead, a new Pydantic model object will be created with the contents of the returned object. So, it will be a new object (made with the data from the returned one), and will be filtered by the cloned
response_model
, containing only the declared fields as normally.
PR
## 322
.
Remove/clean unused RegEx code in routing. PR
## 314
by
@dmontagu
.
Use default response status code descriptions for additional responses. PR
## 313
by
@duxiaoyao
.
Upgrade Pydantic support to
0.28
. PR
## 320
by
@jekirl
.
0.29.1
Fix handling an empty-body request with a required body param. PR
## 311
.
Fix broken link in docs:
Return a Response directly
. PR
## 306
by
@dmontagu
.
Fix docs discrepancy in docs for
Response Model
. PR
## 288
by
@awiddersheim
.
0.29.0
Add support for declaring a
Response
parameter:
This allows declaring:
Response Cookies
.
Response Headers
.
An HTTP Status Code different than the default:
Response - Change Status Code
.
All of this while still being able to return arbitrary objects (
dict
, DB model, etc).
Update attribution to Hug, for inspiring the
response
parameter pattern.
PR
## 294
.
0.28.0
Implement dependency cache per request.
This avoids calling each dependency multiple times for the same request.
This is useful while calling external services, performing costly computation, etc.
This also means that if a dependency was declared as a
path operation decorator
dependency, possibly at the router level (with
.include_router()
) and then it is declared again in a specific
path operation
, the dependency will be called only once.
The cache can be disabled per dependency declaration, using
use_cache=False
as in
Depends(your_dependency, use_cache=False)
.
Updated docs at:
Using the same dependency multiple times
.
PR
## 292
.
Implement dependency overrides for testing.
This allows using overrides/mocks of dependencies during tests.
New docs:
Testing Dependencies with Overrides
.
PR
## 291
.
0.27.2
Fix path and query parameters receiving
dict
as a valid type. It should be mapped to a body payload. PR
## 287
. Updated docs at:
Query parameter list / multiple values with defaults: Using
list
.
0.27.1
Fix
auto_error=False
handling in
HTTPBearer
security scheme. Do not
raise
when there's an incorrect
Authorization
header if
auto_error=False
. PR
## 282
.
Fix type declaration of
HTTPException
. PR
## 279
.
0.27.0
Fix broken link in docs about OAuth 2.0 with scopes. PR
## 275
by
@dmontagu
.
Refactor param extraction using Pydantic
Field
:
Large refactor, improvement, and simplification of param extraction from
path operations
.
Fix/add support for list
query parameters
with list defaults. New documentation:
Query parameter list / multiple values with defaults
.
Add support for enumerations in
path operation
parameters. New documentation:
Path Parameters: Predefined values
.
Add support for type annotations using
Optional
as in
param: Optional[str] = None
. New documentation:
Optional type declarations
.
PR
## 278
.
0.26.0
Separate error handling for validation errors.
This will allow developers to customize the exception handlers.
Document better how to handle exceptions and use error handlers.
Include
RequestValidationError
and
WebSocketRequestValidationError
(this last one will be useful once
encode/starlette#527
or equivalent is merged).
New documentation about exceptions handlers:
Install custom exception handlers
.
Override the default exception handlers
.
Reuse
FastAPI's
exception handlers
.
PR
## 273
.
Fix support for
paths
in
path parameters
without needing explicit
Path(...)
.
PR
## 256
.
Documented in PR
## 272
by
@wshayes
.
New documentation at:
Path Parameters containing paths
.
Update docs for testing FastAPI. Include using
POST
, sending JSON, testing headers, etc. New documentation:
Testing
. PR
## 271
.
Fix type declaration of
response_model
to allow generic Python types as
List[Model]
. Mainly to fix
mypy
for users. PR
## 266
.
0.25.0
Add support for Pydantic's
include
,
exclude
,
by_alias
.
Update documentation:
Response Model
.
Add docs for:
Body - updates
, using Pydantic's
skip_defaults
.
Add method consistency tests.
PR
## 264
.
Add
CONTRIBUTING.md
file to GitHub, to help new contributors. PR
## 255
by
@wshayes
.
Add support for Pydantic's
skip_defaults
:
There's a new
path operation decorator
parameter
response_model_skip_defaults
.
The name of the parameter will most probably change in a future version to
response_skip_defaults
,
model_skip_defaults
or something similar.
New
documentation section about using
response_model_skip_defaults
.
PR
## 248
by
@wshayes
.
0.24.0
Add support for WebSockets with dependencies and parameters.
Support included for:
Depends
Security
Cookie
Header
Path
Query
...as these are compatible with the WebSockets protocol (e.g.
Body
is not).
Updated documentation for WebSockets
.
PR
## 178
by
@jekirl
.
Upgrade the compatible version of Pydantic to
0.26.0
.
This includes JSON Schema support for IP address and network objects, bug fixes, and other features.
PR
## 247
by
@euri10
.
0.23.0
Upgrade the compatible version of Starlette to
0.12.0
.
This includes support for ASGI 3 (the latest version of the standard).
It's now possible to use
Starlette's
StreamingResponse
with iterators, like
file-like
objects (as those returned by
open()
).
It's now possible to use the low level utility
iterate_in_threadpool
from
starlette.concurrency
(for advanced scenarios).
PR
## 243
.
Add OAuth2 redirect page for Swagger UI. This allows having delegated authentication in the Swagger UI docs. For this to work, you need to add
{your_origin}/docs/oauth2-redirect
to the allowed callbacks in your OAuth2 provider (in Auth0, Facebook, Google, etc).
For example, during development, it could be
http://localhost:8000/docs/oauth2-redirect
.
Keep in mind that this callback URL is independent of whichever one is used by your frontend. You might also have another callback at
https://yourdomain.com/login/callback
.
This is only to allow delegated authentication in the API docs with Swagger UI.
PR
## 198
by
@steinitzu
.
Make Swagger UI and ReDoc route handlers (
path operations
) be
async
functions instead of lambdas to improve performance. PR
## 241
by
@Trim21
.
Make Swagger UI and ReDoc URLs parameterizable, allowing to host and serve local versions of them and have offline docs. PR
## 112
by
@euri10
.
0.22.0
Add support for
dependencies
parameter:
A parameter in
path operation decorators
, for dependencies that should be executed but the return value is not important or not used in the
path operation function
.
A parameter in the
.include_router()
method of FastAPI applications and routers, to include dependencies that should be executed in each
path operation
in a router.
This is useful, for example, to require authentication or permissions in specific group of
path operations
.
Different
dependencies
can be applied to different routers.
These
dependencies
are run before the normal parameter dependencies. And normal dependencies are run too. They can be combined.
Dependencies declared in a router are executed first, then the ones defined in
path operation decorators
, and then the ones declared in normal parameters. They are all combined and executed.
All this also supports using
Security
with
scopes
in those
dependencies
parameters, for more advanced OAuth 2.0 security scenarios with scopes.
New documentation about
dependencies in
path operation decorators
.
New documentation about
dependencies in the
include_router()
method
.
PR
## 235
.
Fix OpenAPI documentation of Starlette URL convertors. Specially useful when using
path
convertors, to take a whole path as a parameter, like
/some/url/{p:path}
. PR
## 234
by
@euri10
.
Make default parameter utilities exported from
fastapi
be functions instead of classes (the new functions return instances of those classes). To be able to override the return types and fix
mypy
errors in FastAPI's users' code. Applies to
Path
,
Query
,
Header
,
Cookie
,
Body
,
Form
,
File
,
Depends
, and
Security
. PR
## 226
and PR
## 231
.
Separate development scripts
test.sh
,
lint.sh
, and
format.sh
. PR
## 232
.
Re-enable
black
formatting checks for Python 3.7. PR
## 229
by
@zamiramir
.
0.21.0
On body parsing errors, raise
from
previous exception, to allow better introspection in logging code. PR
## 192
by
@ricardomomm
.
Use Python logger named "
fastapi
" instead of root logger. PR
## 222
by
@euri10
.
Upgrade Pydantic to version 0.25. PR
## 225
by
@euri10
.
Fix typo in routing. PR
## 221
by
@djlambert
.
0.20.1
Add typing information to package including file
py.typed
. PR
## 209
by
@meadsteve
.
Add FastAPI bot for Gitter. To automatically announce new releases. PR
## 189
.
0.20.0
Upgrade OAuth2:
Upgrade Password flow using Bearer tokens to use the correct HTTP status code 401
UNAUTHORIZED
, with
WWW-Authenticate
headers.
Update, simplify, and improve all the
security docs
.
Add new
scope_str
to
SecurityScopes
and update docs:
OAuth2 scopes
.
Update docs, images, tests.
PR
## 188
.
Include
Hypercorn
as an alternative ASGI server in the docs. PR
## 187
.
Add docs for
Static Files
and
Templates
. PR
## 186
.
Add docs for handling
Response Cookies
and
Response Headers
. PR
## 185
.
Fix typos in docs. PR
## 176
by
@chdsbd
.
0.19.0
Rename
path operation decorator
parameter
content_type
to
response_class
. PR
## 183
.
Add docs:
How to use the
jsonable_encoder
in
JSON compatible encoder
.
How to
Return a Response directly
.
Update how to use a
Custom Response Class
.
PR
## 184
.
0.18.0
Add docs for
HTTP Basic Auth
. PR
## 177
.
Upgrade HTTP Basic Auth handling with automatic headers (automatic browser login prompt). PR
## 175
.
Update dependencies for security. PR
## 174
.
Add docs for
Middleware
. PR
## 173
.
0.17.0
Make Flit publish from CI. PR
## 170
.
Add documentation about handling
CORS (Cross-Origin Resource Sharing)
. PR
## 169
.
By default, encode by alias. This allows using Pydantic
alias
parameters working by default. PR
## 168
.
0.16.0
Upgrade
path operation
docstring
parsing to support proper Markdown descriptions. New documentation at
Path Operation Configuration
. PR
## 163
.
Refactor internal usage of Pydantic to use correct data types. PR
## 164
.
Upgrade Pydantic to version
0.23
. PR
## 160
by
@euri10
.
Fix typo in Tutorial about Extra Models. PR
## 159
by
@danielmichaels
.
Fix
Query Parameters
URL examples in docs. PR
## 157
by
@hayata-yamamoto
.
0.15.0
Add support for multiple file uploads (as a single form field). New docs at:
Multiple file uploads
. PR
## 158
.
Add docs for:
Additional Status Codes
. PR
## 156
.
0.14.0
Improve automatically generated names of
path operations
in OpenAPI (in API docs). A function
read_items
instead of having a generated name "Read Items Get" will have "Read Items". PR
## 155
.
Add docs for:
Testing
FastAPI
. PR
## 151
.
Update
/docs
Swagger UI to enable deep linking. This allows sharing the URL pointing directly to the
path operation
documentation in the docs. PR
## 148
by
@wshayes
.
Update development dependencies,
Pipfile.lock
. PR
## 150
.
Include Falcon and Hug in:
Alternatives, Inspiration and Comparisons
.
0.13.0
Improve/upgrade OAuth2 scopes support with
SecurityScopes
:
SecurityScopes
can be declared as a parameter like
Request
, to get the scopes of all super-dependencies/dependants.
Improve
Security
handling, merging scopes when declaring
SecurityScopes
.
Allow using
SecurityBase
(like
OAuth2
) classes with
Depends
and still document them.
Security
now is needed only to declare
scopes
.
Updated docs about:
OAuth2 with Password (and hashing), Bearer with JWT tokens
.
New docs about:
OAuth2 scopes
.
PR
## 141
.
0.12.1
Fix bug: handling additional
responses
in
APIRouter.include_router()
. PR
## 140
.
Fix typo in SQL tutorial. PR
## 138
by
@mostaphaRoudsari
.
Fix typos in section about nested models and OAuth2 with JWT. PR
## 127
by
@mmcloud
.
0.12.0
Add additional
responses
parameter to
path operation decorators
to extend responses in OpenAPI (and API docs).
It also allows extending existing responses generated from
response_model
, declare other media types (like images), etc.
The new documentation is here:
Additional Responses
.
responses
can also be added to
.include_router()
, the updated docs are here:
Bigger Applications
.
PR
## 97
originally initiated by
@barsi
.
Update
scripts/test-cov-html.sh
to allow passing extra parameters like
-vv
, for development.
0.11.0
Add
auto_error
parameter to security utility functions. Allowing them to be optional. Also allowing to have multiple alternative security schemes that are then checked in a single dependency instead of each one verifying and returning the error to the client automatically when not satisfied. PR
## 134
.
Update
SQL Tutorial
to close database sessions even when there are exceptions. PR
## 89
by
@alexiri
.
Fix duplicate dependency in
pyproject.toml
. PR
## 128
by
@zxalif
.
0.10.3
Add Gitter chat, badge, links, etc.
https://gitter.im/tiangolo/fastapi
. PR
## 117
.
Add docs about
Extending OpenAPI
. PR
## 126
.
Make Travis run Ubuntu Xenial (newer version) and Python 3.7 instead of Python 3.7-dev. PR
## 92
by
@blueyed
.
Fix duplicated param variable creation. PR
## 123
by
@yihuang
.
Add note in
Response Model docs
about why using a function parameter instead of a function return type annotation. PR
## 109
by
@JHSaunders
.
Fix event docs (startup/shutdown) function name. PR
## 105
by
@stratosgear
.
0.10.2
Fix OpenAPI (JSON Schema) for declarations of Python
Union
(JSON Schema
additionalProperties
). PR
## 121
.
Update
Background Tasks
with a note on Celery.
Document response models using unions and lists, updated at:
Extra Models
. PR
## 108
.
0.10.1
Add docs and tests for
encode/databases
. New docs at:
Async SQL (Relational) Databases
. PR
## 107
.
0.10.0
Add support for Background Tasks in
path operation functions
and dependencies. New documentation about
Background Tasks is here
. PR
## 103
.
Add support for
.websocket_route()
in
APIRouter
. PR
## 100
by
@euri10
.
New docs section about
Events: startup - shutdown
. PR
## 99
.
0.9.1
Document receiving
Multiple values with the same query parameter
and
Duplicate headers
. PR
## 95
.
0.9.0
Upgrade compatible Pydantic version to
0.21.0
. PR
## 90
.
Add documentation for:
Application Configuration
.
Fix typo in docs. PR
## 76
by
@matthewhegarty
.
Fix link in "Deployment" to "Bigger Applications".
0.8.0
Make development scripts executable. PR
## 76
by
@euri10
.
Add support for adding
tags
in
app.include_router()
. PR
## 55
by
@euri10
. Documentation updated in the section:
Bigger Applications
.
Update docs related to Uvicorn to use new
--reload
option from version
0.5.x
. PR
## 74
.
Update
isort
imports and scripts to be compatible with newer versions. PR
## 75
.
0.7.1
Update
technical details about
async def
handling
with respect to previous frameworks. PR
## 64
by
@haizaar
.
Add
deployment documentation for Docker in Raspberry Pi
and other architectures.
Trigger Docker images build on Travis CI automatically. PR
## 65
.
0.7.0
Add support for
UploadFile
in
File
parameter annotations.
This includes a file-like interface.
Here's the updated documentation for declaring
File
parameters with
UploadFile
.
And here's the updated documentation for using
Form
parameters mixed with
File
parameters, supporting
bytes
and
UploadFile
at the same time.
PR
## 63
.
0.6.4
Add
technical details about
async def
handling to docs
. PR
## 61
.
Add docs for
Debugging FastAPI applications in editors
.
Clarify
Bigger Applications deployed with Docker
.
Fix typos in docs.
Add section about
History, Design and Future
.
Add docs for using
WebSockets with
FastAPI
. PR
## 62
.
0.6.3
Add Favicons to docs. PR
## 53
.
0.6.2
Introduce new project generator based on FastAPI and PostgreSQL:
https://github.com/tiangolo/full-stack-fastapi-postgresql
. PR
## 52
.
Update
SQL tutorial with SQLAlchemy, using
Depends
to improve editor support and reduce code repetition
. PR
## 52
.
Improve middleware naming in tutorial for SQL with SQLAlchemy
https://fastapi.tiangolo.com/tutorial/sql-databases/
.
0.6.1
Add docs for GraphQL:
https://fastapi.tiangolo.com/advanced/graphql/
. PR
## 48
.
0.6.0
Update SQL with SQLAlchemy tutorial at
https://fastapi.tiangolo.com/tutorial/sql-databases/
using the new official
request.state
. PR
## 45
.
Upgrade Starlette to version
0.11.1
and add required compatibility changes. PR
## 44
.
0.5.1
Add section about
helping and getting help with
FastAPI
.
Add note about
path operations order in docs
.
Update
section about error handling
with more information and make relation with Starlette error handling utilities more explicit. PR
## 41
.
Add
Development - Contributing section to the docs
. PR
## 42
.
0.5.0
Add new
HTTPException
with support for custom headers. With new documentation for handling errors at:
https://fastapi.tiangolo.com/tutorial/handling-errors/
. PR
## 35
.
Add
documentation to use Starlette
Request
object
directly. Check
## 25
by
@euri10
.
Add issue templates to simplify reporting bugs, getting help, etc:
## 34
.
Update example for the SQLAlchemy tutorial at
https://fastapi.tiangolo.com/tutorial/sql-databases/
using middleware and database session attached to request.
0.4.0
Add
openapi_prefix
, support for reverse proxy and mounting sub-applications. See the docs at
https://fastapi.tiangolo.com/advanced/sub-applications-proxy/
:
## 26
by
@kabirkhan
.
Update
docs/tutorial for SQLAlchemy
including note about
DB Browser for SQLite
.
0.3.0
Fix/add SQLAlchemy support, including ORM, and update
docs for SQLAlchemy
:
## 30
.
0.2.1
Fix
jsonable_encoder
for Pydantic models with
Config
but without
json_encoders
:
## 29
.
0.2.0
Fix typos in Security section:
## 24
by
@kkinder
.
Add support for Pydantic custom JSON encoders:
## 21
by
@euri10
.
0.1.19
Upgrade Starlette version to the current latest
0.10.1
:
## 17
by
@euri10
.

## 106_RU
FastAPI¶
---

FastAPI
Готовый к внедрению высокопроизводительный фреймворк, простой в изучении и разработке.
Документация
:
https://fastapi.tiangolo.com
Исходный код
:
https://github.com/fastapi/fastapi
FastAPI — это современный, быстрый (высокопроизводительный) веб-фреймворк для создания API используя Python, в основе которого лежит стандартная аннотация типов Python.
Ключевые особенности:
Скорость
: Очень высокая производительность, на уровне
NodeJS
и
Go
(благодаря Starlette и Pydantic).
Один из самых быстрых фреймворков Python
.
Быстрота разработки
: Увеличьте скорость разработки примерно на 200–300%. *
Меньше ошибок
: Сократите примерно на 40% количество ошибок, вызванных человеком (разработчиком). *
Интуитивно понятный
: Отличная поддержка редактора.
Автозавершение
везде. Меньше времени на отладку.
Лёгкость
: Разработан так, чтобы его было легко использовать и осваивать. Меньше времени на чтение документации.
Краткость
: Сведите к минимуму дублирование кода. Каждый объявленный параметр - определяет несколько функций. Меньше ошибок.
Надежность
: Получите готовый к работе код. С автоматической интерактивной документацией.
На основе стандартов
: Основан на открытых стандартах API и полностью совместим с ними:
OpenAPI
(ранее известном как Swagger) и
JSON Schema
.
* оценка на основе тестов внутренней команды разработчиков, создающих производственные приложения.
Спонсоры
Другие спонсоры
Отзывы
"
В последнее время я много где использую
FastAPI
. [...] На самом деле я планирую использовать его для всех
сервисов машинного обучения моей команды в Microsoft
. Некоторые из них интегрируются в основной продукт
Windows
, а некоторые — в продукты
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
Мы использовали библиотеку
FastAPI
для создания сервера
REST
, к которому можно делать запросы для получения
прогнозов
. [для Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
рада объявить о выпуске опенсорсного фреймворка для оркестровки
антикризисного управления
:
Dispatch
! [создана с помощью
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Я в полном восторге от
FastAPI
. Это так весело!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Честно говоря, то, что вы создали, выглядит очень солидно и отполировано. Во многих смыслах я хотел, чтобы
Hug
был именно таким — это действительно вдохновляет, когда кто-то создаёт такое.
"
Timothy Crosley -
Hug
creator
(ref)
"
Если вы хотите изучить какой-нибудь
современный фреймворк
для создания REST API, ознакомьтесь с
FastAPI
[...] Он быстрый, лёгкий и простой в изучении [...]
"
"
Мы перешли на
FastAPI
для наших
API
[...] Я думаю, вам тоже понравится [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, интерфейс командной строки для FastAPI
Если вы создаете приложение
CLI
для использования в терминале вместо веб-API, ознакомьтесь с
Typer
.
Typer
— младший брат FastAPI. И он предназначен для использования в качестве
интерфейса командной строки для FastAPI
. ⌨️ 🚀
Зависимости
FastAPI стоит на плечах гигантов:
Starlette
для части связанной с вебом.
Pydantic
для части связанной с данными.
Установка
fast →
pip install fastapi
restart ↻
Вам также понадобится сервер ASGI для производства, такой как
Uvicorn
или
Hypercorn
.
fast →
pip install "uvicorn[standard]"
restart ↻
Пример
Создание
Создайте файл
main.py
со следующим содержимым:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Или используйте
async def
...
Если ваш код использует
async
/
await
, используйте
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Примечание
:
Если вы не знаете, проверьте раздел
"Торопитесь?"
в документации об
async
и
await
.
Запуск
Запустите сервер с помощью:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
О команде
uvicorn main:app --reload
...
Команда
uvicorn main:app
относится к:
main
: файл
main.py
(модуль Python).
app
: объект, созданный внутри
main.py
с помощью строки
app = FastAPI()
.
--reload
: перезапуск сервера после изменения кода. Делайте это только во время разработки.
Проверка
Откройте браузер на
http://127.0.0.1:8000/items/5?q=somequery
.
Вы увидите следующий JSON ответ:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Вы уже создали API, который:
Получает HTTP-запросы по
путям
/
и
/items/{item_id}
.
И первый и второй
путь
используют
GET
операции
(также известные как HTTP
методы
).
путь
/items/{item_id}
имеет
параметр пути
item_id
, который должен быть
int
.
путь
/items/{item_id}
имеет необязательный
str
параметр запроса
q
.
Интерактивная документация по API
Перейдите на
http://127.0.0.1:8000/docs
.
Вы увидите автоматическую интерактивную документацию API (предоставленную
Swagger UI
):
Альтернативная документация по API
А теперь перейдите на
http://127.0.0.1:8000/redoc
.
Вы увидите альтернативную автоматическую документацию (предоставленную
ReDoc
):
Пример обновления
Теперь измените файл
main.py
, чтобы получить тело ответа из
PUT
запроса.
Объявите тело, используя стандартную типизацию Python, спасибо Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Сервер должен перезагрузиться автоматически (потому что вы добавили
--reload
к команде
uvicorn
выше).
Интерактивное обновление документации API
Перейдите на
http://127.0.0.1:8000/docs
.
Интерактивная документация API будет автоматически обновляться, включая новое тело:
Нажмите на кнопку "Try it out", это позволит вам заполнить параметры и напрямую взаимодействовать с API:
Затем нажмите кнопку "Execute", пользовательский интерфейс свяжется с вашим API, отправит параметры, получит результаты и отобразит их на экране:
Альтернативное обновление документации API
А теперь перейдите на
http://127.0.0.1:8000/redoc
.
Альтернативная документация также будет отражать новый параметр и тело запроса:
Подведём итоги
Таким образом, вы объявляете
один раз
типы параметров, тело и т. д. в качестве параметров функции.
Вы делаете это используя стандартную современную типизацию Python.
Вам не нужно изучать новый синтаксис, методы или классы конкретной библиотеки и т. д.
Только стандартный
Python
.
Например, для
int
:
item_id
:
int
или для более сложной модели
Item
:
item
:
Item
... и с этим единственным объявлением вы получаете:
Поддержка редактора, в том числе:
Автозавершение.
Проверка типов.
Валидация данных:
Автоматические и четкие ошибки, когда данные недействительны.
Проверка даже для глубоко вложенных объектов JSON.
Преобразование
входных данных: поступающие из сети в объекты Python с соблюдением типов. Чтение из:
JSON.
Параметров пути.
Параметров запроса.
Cookies.
Заголовков.
Форм.
Файлов.
Преобразование
выходных данных: преобразование объектов Python в данные передаваемые по сети интернет (такие как JSON):
Преобразование типов Python (
str
,
int
,
float
,
bool
,
list
, и т.д.).
Объекты
datetime
.
Объекты
UUID
.
Модели баз данных.
...и многое другое.
Автоматическая интерактивная документация по API, включая 2 альтернативных пользовательских интерфейса:
Swagger UI.
ReDoc.
Возвращаясь к предыдущему примеру кода,
FastAPI
будет:
Проверять наличие
item_id
в пути для запросов
GET
и
PUT
.
Проверять, что
item_id
имеет тип
int
для запросов
GET
и
PUT
.
Если это не так, клиент увидит полезную чёткую ошибку.
Проверять, есть ли необязательный параметр запроса с именем
q
(например,
http://127.0.0.1:8000/items/foo?q=somequery
) для
GET
запросов.
Поскольку параметр
q
объявлен с
= None
, он является необязательным.
Без
None
он был бы необходим (как тело в случае с
PUT
).
Для
PUT
запросов к
/items/{item_id}
читать тело как JSON:
Проверять, что у него есть обязательный атрибут
name
, который должен быть
str
.
Проверять, что у него есть обязательный атрибут
price
, который должен быть
float
.
Проверять, что у него есть необязательный атрибут
is_offer
, который должен быть
bool
, если он присутствует.
Все это также будет работать для глубоко вложенных объектов JSON.
Преобразовывать из и в JSON автоматически.
Документировать с помощью OpenAPI все, что может быть использовано:
Системы интерактивной документации.
Системы автоматической генерации клиентского кода для многих языков.
Обеспечит 2 интерактивных веб-интерфейса документации напрямую.
Мы только немного копнули поверхность, но вы уже поняли, как все это работает.
Попробуйте изменить строку с помощью:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...из:
...
"item_name"
:
item
.
name
...
...в:
...
"item_price"
:
item
.
price
...
... и посмотрите, как ваш редактор будет автоматически заполнять атрибуты и узнавать их типы:
Более полный пример с дополнительными функциями см. в
Учебное руководство - Руководство пользователя
.
Осторожно, спойлер
: руководство пользователя включает в себя:
Объявление
параметров
из других мест, таких как:
заголовки
,
cookies
,
поля формы
и
файлы
.
Как установить
ограничительные проверки
такие как
maximum_length
или
regex
.
Очень мощная и простая в использовании система
внедрения зависимостей
.
Безопасность и аутентификация, включая поддержку
OAuth2
с
токенами JWT
и
HTTP Basic
аутентификацию.
Более продвинутые (но столь же простые) методы объявления
глубоко вложенных моделей JSON
(спасибо Pydantic).
GraphQL
интеграция с
Strawberry
и другими библиотеками.
Множество дополнительных функций (благодаря Starlette), таких как:
Веб-сокеты
очень простые тесты на основе HTTPX и
pytest
CORS
Cookie сеансы(сессии)
...и многое другое.
Производительность
Независимые тесты TechEmpower показывают приложения
FastAPI
, работающие под управлением Uvicorn, как
один из самых быстрых доступных фреймворков Python
, уступающий только самим Starlette и Uvicorn (используемых внутри FastAPI). (*)
Чтобы узнать больше об этом, см. раздел
Тесты производительности
.
Необязательные зависимости
Используется Pydantic:
email-validator
- для проверки электронной почты.
Используется Starlette:
HTTPX
- Обязательно, если вы хотите использовать
TestClient
.
jinja2
- Обязательно, если вы хотите использовать конфигурацию шаблона по умолчанию.
python-multipart
- Обязательно, если вы хотите поддерживать форму
"парсинга"
с помощью
request.form()
.
itsdangerous
- Обязательно, для поддержки
SessionMiddleware
.
pyyaml
- Обязательно, для поддержки
SchemaGenerator
Starlette (возможно, вам это не нужно с FastAPI).
Используется FastAPI / Starlette:
uvicorn
- сервер, который загружает и обслуживает ваше приложение.
orjson
- Обязательно, если вы хотите использовать
ORJSONResponse
.
ujson
- Обязательно, если вы хотите использовать
UJSONResponse
.
Вы можете установить все это с помощью
pip install "fastapi[all]"
.
Лицензия
Этот проект распространяется на условиях лицензии MIT.

## 107_TR
FastAPI¶
---

FastAPI
FastAPI framework, yüksek performanslı, öğrenmesi oldukça kolay, kodlaması hızlı, kullanıma hazır
Dokümantasyon
:
https://fastapi.tiangolo.com
Kaynak Kod
:
https://github.com/fastapi/fastapi
FastAPI, Python 'nin standart
tip belirteçleri
ne dayalı, modern ve hızlı (yüksek performanslı) API'lar oluşturmak için kullanılabilecek web framework'tür.
Temel özellikleri şunlardır:
Hızlı
: Çok yüksek performanslı,
NodeJS
ve
Go
ile eşit düzeyde (Starlette ve Pydantic sayesinde).
En hızlı Python framework'lerinden bir tanesidir
.
Kodlaması Hızlı
: Geliştirme hızını yaklaşık %200 ile %300 aralığında arttırır. *
Daha az hata
: İnsan (geliştirici) kaynaklı hataları yaklaşık %40 azaltır. *
Sezgisel
: Muhteşem bir editör desteği. Her yerde
otomatik tamamlama
. Hata ayıklama ile daha az zaman harcayacaksınız.
Kolay
: Öğrenmesi ve kullanması kolay olacak şekilde tasarlandı. Doküman okuma ile daha az zaman harcayacaksınız.
Kısa
: Kod tekrarı minimize edildi. Her parametre tanımlamasında birden fazla özellik ve daha az hatayla karşılaşacaksınız.
Güçlü
: Otomatik ve etkileşimli dokümantasyon ile birlikte, kullanıma hazır kod elde edebilirsiniz.
Standard öncelikli
: API'lar için açık standartlara dayalı (ve tamamen uyumlu);
OpenAPI
(eski adıyla Swagger) ve
JSON Schema
.
* ilgili kanılar, dahili geliştirme ekibinin geliştirdikleri ürünlere yaptıkları testlere dayanmaktadır.
Sponsorlar
Diğer Sponsorlar
Görüşler
"
[...] Bugünlerde
FastAPI
'ı çok fazla kullanıyorum. [...] Aslında bunu ekibimin
Microsoft'taki Machine Learning servislerinin
tamamında kullanmayı planlıyorum. Bunlardan bazıları
Windows
'un ana ürünlerine ve
Office
ürünlerine entegre ediliyor.
"
Kabir Khan -
Microsoft
(ref)
"
FastAPI
'ı
tahminlerimiz
'i sorgulanabilir hale getirecek bir
REST
sunucu oluşturmak için benimsedik/kullanmaya başladık.
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
,
kriz yönetiminde
orkestrasyon yapabilmek için geliştirdiği yeni framework'ü
Dispatch
'in, açık kaynak sürümünü paylaşmaktan gurur duyuyor. [
FastAPI
ile yapıldı.]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
FastAPI
için ayın üzerindeymişcesine heyecanlıyım. Çok eğlenceli!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Dürüst olmak gerekirse, inşa ettiğiniz şey gerçekten sağlam ve profesyonel görünüyor. Birçok açıdan
Hug
'ın olmasını istediğim şey tam da bu - böyle bir şeyi inşa eden birini görmek gerçekten ilham verici.
"
Timothy Crosley -
Hug
'ın Yaratıcısı
(ref)
"
Eğer REST API geliştirmek için
modern bir framework
öğrenme arayışında isen,
FastAPI
'a bir göz at [...] Hızlı, kullanımı ve öğrenmesi kolay. [...]
"
"
API
servislerimizi
FastAPI
'a taşıdık [...] Sizin de beğeneceğinizi düşünüyoruz. [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
kurucuları -
spaCy
yaratıcıları
(ref)
-
(ref)
"
Python ile kullanıma hazır bir API oluşturmak isteyen herhangi biri için,
FastAPI
'ı şiddetle tavsiye ederim.
Harika tasarlanmış
,
kullanımı kolay
ve
yüksek ölçeklenebilir
, API odaklı geliştirme stratejimizin
ana bileşeni
haline geldi ve Virtual TAC Engineer gibi birçok otomasyon ve servisi yönetiyor.
"
Deon Pillsbury -
Cisco
(ref)
Komut Satırı Uygulamalarının FastAPI'ı:
Typer
Eğer API yerine, terminalde kullanılmak üzere bir
komut satırı uygulaması
geliştiriyorsanız
Typer
'a göz atabilirsiniz.
Typer
kısaca FastAPI'ın küçük kardeşi. Ve hedefi komut satırı uygulamalarının
FastAPI'ı
olmak. ⌨️ 🚀
Gereksinimler
FastAPI iki devin omuzları üstünde duruyor:
Web tarafı için
Starlette
.
Data tarafı için
Pydantic
.
Kurulum
fast →
pip install fastapi
restart ↻
Uygulamamızı kullanılabilir hale getirmek için
Uvicorn
ya da
Hypercorn
gibi bir ASGI sunucusuna ihtiyacımız olacak.
fast →
pip install "uvicorn[standard]"
restart ↻
Örnek
Kodu Oluşturalım
main.py
adında bir dosya oluşturup içine şu kodu yapıştıralım:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Ya da
async def
...
Eğer kodunuzda
async
/
await
varsa,
async def
kullanalım:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Not
:
Eğer bu konu hakkında bilginiz yoksa
async
ve
await
dokümantasyonundaki
"Aceleniz mi var?"
kısmını kontrol edebilirsiniz.
Kodu Çalıştıralım
Sunucuyu aşağıdaki komutla çalıştıralım:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
uvicorn main:app --reload
komutuyla ilgili...
uvicorn main:app
komutunu şu şekilde açıklayabiliriz:
main
: dosya olan
main.py
(yani Python "modülü").
app
: ise
main.py
dosyasının içerisinde
app = FastAPI()
satırında oluşturduğumuz
FastAPI
nesnesi.
--reload
: kod değişikliklerinin ardından sunucuyu otomatik olarak yeniden başlatır. Bu parameteyi sadece geliştirme aşamasında kullanmalıyız.
Şimdi de Kontrol Edelim
Tarayıcımızda şu bağlantıyı açalım
http://127.0.0.1:8000/items/5?q=somequery
.
Aşağıdaki gibi bir JSON yanıtıyla karşılaşacağız:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Az önce oluşturduğumuz API:
/
ve
/items/{item_id}
yollarına
HTTP isteği alabilir.
İki
yolda
GET
operasyonlarını
(HTTP
metodları
olarak da bilinen) kabul ediyor.
/items/{item_id}
yolu
item_id
adında bir
yol parametresine
sahip ve bu parametre
int
değer almak zorundadır.
/items/{item_id}
yolu
q
adında bir
yol parametresine
sahip ve bu parametre opsiyonel olmakla birlikte,
str
değer almak zorundadır.
Etkileşimli API Dokümantasyonu
Şimdi
http://127.0.0.1:8000/docs
bağlantısını açalım.
Swagger UI
tarafından sağlanan otomatik etkileşimli bir API dokümantasyonu göreceğiz:
Alternatif API Dokümantasyonu
Şimdi
http://127.0.0.1:8000/redoc
bağlantısını açalım.
ReDoc
tarafından sağlanan otomatik dokümantasyonu göreceğiz:
Örneği Güncelleyelim
Şimdi
main.py
dosyasını,
PUT
isteğiyle birlikte bir gövde alacak şekilde değiştirelim.
Gövde
yi Pydantic sayesinde standart python tiplerini kullanarak tanımlayalım.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Sunucu otomatik olarak yeniden başlamış olmalı (çünkü yukarıda
uvicorn
komutuyla birlikte
--reload
parametresini kullandık).
Etkileşimli API Dokümantasyonundaki Değişimi Görelim
Şimdi
http://127.0.0.1:8000/docs
bağlantısına tekrar gidelim.
Etkileşimli API dokümantasyonu, yeni gövdede dahil olmak üzere otomatik olarak güncellenmiş olacak:
"Try it out" butonuna tıklayalım, bu işlem API parametleri üzerinde değişiklik yapmamıza ve doğrudan API ile etkileşime geçmemize imkan sağlayacak:
Şimdi "Execute" butonuna tıklayalım, kullanıcı arayüzü API'ımız ile bağlantı kurup parametreleri gönderecek ve sonucu ekranımıza getirecek:
Alternatif API Dokümantasyonundaki Değişimi Görelim
Şimdi ise
http://127.0.0.1:8000/redoc
bağlantısına tekrar gidelim.
Alternatif dokümantasyonda yaptığımız değişiklikler ile birlikte yeni sorgu parametresi ve gövde bilgisi ile güncelemiş olacak:
Özet
Özetlemek gerekirse, parametrelerin, gövdenin, vb. veri tiplerini fonksiyon parametreleri olarak
bir kere
tanımlıyoruz.
Bu işlemi standart modern Python tipleriyle yapıyoruz.
Yeni bir sözdizimi yapısını, bir kütüphane özel metod veya sınıfları öğrenmeye gerek yoktur.
Hepsi sadece
Python
standartlarına dayalıdır.
Örnek olarak,
int
tanımlamak için:
item_id
:
int
ya da daha kompleks herhangi bir python modelini tanımlayabiliriz, örneğin
Item
modeli için:
item
:
Item
...ve sadece kısa bir parametre tipi belirterek elde ettiklerimiz:
Editör desteğiyle birlikte:
Otomatik tamamlama.
Tip kontrolü.
Veri Doğrulama:
Veri geçerli değilse, otomatik olarak açıklayıcı hatalar gösterir.
Çok
derin
JSON nesnelerinde bile doğrulama yapar.
Gelen verinin
dönüşümünü
aşağıdaki veri tiplerini kullanarak gerçekleştirir:
JSON.
Yol parametreleri.
Sorgu parametreleri.
Çerezler.
Headers.
Formlar.
Dosyalar.
Giden verinin
dönüşümünü
aşağıdaki veri tiplerini kullanarak gerçekleştirir (JSON olarak):
Python tiplerinin (
str
,
int
,
float
,
bool
,
list
, vb) dönüşümü.
datetime
nesnesi.
UUID
nesnesi.
Veritabanı modelleri.
ve çok daha fazlası...
2 alternatif kullanıcı arayüzü dahil olmak üzere, otomatik etkileşimli API dokümantasyonu sağlar:
Swagger UI.
ReDoc.
Az önceki örneğe geri dönelim,
FastAPI
'ın yapacaklarına bir bakış atalım:
item_id
'nin
GET
ve
PUT
istekleri için, yolda olup olmadığının kontol edecek.
item_id
'nin
GET
ve
PUT
istekleri için, tipinin
int
olduğunu doğrulayacak.
Eğer değilse, sebebini belirten bir hata mesajı gösterecek.
Opsiyonel bir
q
parametresinin
GET
isteği içinde (
http://127.0.0.1:8000/items/foo?q=somequery
gibi) olup olmadığını kontrol edecek
q
parametresini
= None
ile oluşturduğumuz için, opsiyonel bir parametre olacak.
Eğer
None
olmasa zorunlu bir parametre olacaktı (
PUT
metodunun gövdesinde olduğu gibi).
PUT
isteği için
/items/{item_id}
'nin gövdesini, JSON olarak doğrulayıp okuyacak:
name
adında zorunlu bir parametre olup olmadığını ve varsa tipinin
str
olup olmadığını kontol edecek.
price
adında zorunlu bir parametre olup olmadığını ve varsa tipinin
float
olup olmadığını kontol edecek.
is_offer
adında opsiyonel bir parametre olup olmadığını ve varsa tipinin
float
olup olmadığını kontol edecek.
Bunların hepsi en derin JSON nesnelerinde bile çalışacak.
Verilerin JSON'a ve JSON'ın python nesnesine dönüşümü otomatik olarak yapılacak.
Her şeyi OpenAPI ile uyumlu bir şekilde otomatik olarak dokümanlayacak ve bunlarda aşağıdaki gibi kullanılabilecek:
Etkileşimli dokümantasyon sistemleri.
Bir çok programlama dili için otomatik istemci kodu üretim sistemleri.
İki ayrı etkileşimli dokümantasyon arayüzünü doğrudan sağlayacak.
Daha yeni başladık ama çalışma mantığını çoktan anlamış oldunuz.
Şimdi aşağıdaki satırı değiştirmeyi deneyin:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...bundan:
...
"item_name"
:
item
.
name
...
...buna:
...
"item_price"
:
item
.
price
...
...ve editörünün veri tiplerini bildiğini ve otomatik tamamladığını göreceksiniz:
Daha fazal özellik içeren, daha eksiksiz bir örnek için
Öğretici - Kullanıcı Rehberi
sayfasını ziyaret edebilirsin.
Spoiler
: Öğretici - Kullanıcı rehberi şunları içerir:
Parameterlerin
,
headers
,
çerezler
,
form alanları
ve
dosyalar
olarak tanımlanması.
maximum_length
ya da
regex
gibi
doğrulama kısıtlamalarının
nasıl yapılabileceği.
Çok güçlü ve kullanımı kolay
Bağımlılık Enjeksiyonu
sistemi oluşturmayı.
Güvenlik ve kimlik doğrulama,
JWT tokenleri
ile
OAuth2
desteği, ve
HTTP Basic
doğrulaması.
İleri seviye fakat bir o kadarda basit olan
çok derin JSON modelleri
(Pydantic sayesinde).
GraphQL
entegrasyonu:
Strawberry
ve diğer kütüphaneleri kullanarak.
Diğer ekstra özellikler (Starlette sayesinde):
WebSocketler
HTTPX ve
pytest
sayesinde aşırı kolay testler.
CORS
Cookie Sessions
...ve daha fazlası.
Performans
Bağımsız TechEmpower kıyaslamaları gösteriyor ki, Uvicorn ile çalıştırılan
FastAPI
uygulamaları
en hızlı Python framework'lerinden birisi
, sadece Starlette ve Uvicorn'dan yavaş, ki FastAPI bunların üzerine kurulu bir kütüphanedir.
Daha fazla bilgi için, bu bölüme bir göz at
Kıyaslamalar
.
Opsiyonel Gereksinimler
Pydantic tarafında kullanılan:
email-validator
- email doğrulaması için.
pydantic-settings
- ayar yönetimi için.
pydantic-extra-types
- Pydantic ile birlikte kullanılabilecek ek tipler için.
Starlette tarafında kullanılan:
httpx
- Eğer
TestClient
yapısını kullanacaksanız gereklidir.
jinja2
- Eğer varsayılan template konfigürasyonunu kullanacaksanız gereklidir.
python-multipart
- Eğer
request.form()
ile form
dönüşümü
desteğini kullanacaksanız gereklidir.
itsdangerous
-
SessionMiddleware
desteği için gerekli.
pyyaml
-
SchemaGenerator
desteği için gerekli (Muhtemelen FastAPI kullanırken ihtiyacınız olmaz).
Hem FastAPI hem de Starlette tarafından kullanılan:
uvicorn
- oluşturduğumuz uygulamayı servis edecek web sunucusu görevini üstlenir.
orjson
-
ORJSONResponse
kullanacaksanız gereklidir.
ujson
-
UJSONResponse
kullanacaksanız gerekli.
Bunların hepsini
pip install fastapi[all]
ile yükleyebilirsin.
Lisans
Bu proje, MIT lisansı şartları altında lisanslanmıştır.

## 108_TUTORIAL
Tutorial - User Guide¶
---

Tutorial - User Guide
This tutorial shows you how to use
FastAPI
with most of its features, step by step.
Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific API needs.
It is also built to work as a future reference so you can come back and see exactly what you need.
Run the code
All the code blocks can be copied and used directly (they are actually tested Python files).
To run any of the examples, copy the code to a file
main.py
, and start
fastapi dev
with:
fast →
fastapi dev main.py
FastAPI
Starting development server 🚀
Searching for package file structure from directories
with
__init__.py
files
Importing from
/home/user/code/
awesomeapp
module
🐍 main.py
code
Importing the FastAPI app object from the module with
the following code:
from
main
import
app
app
Using import string:
main:app
server
Server started at
http://127.0.0.1:8000
server
Documentation at
http://127.0.0.1:8000/docs
tip
Running in development mode, for production use:
fastapi run
Logs:
INFO
Will watch for changes in these directories:
[
'/home/user/code/awesomeapp'
]
INFO
Uvicorn running on
http://127.0.0.1:8000
(
Press CTRL+C
to quit
)
INFO
Started reloader process
[
383138
]
using WatchFiles
INFO
Started server process
[
383153
]
INFO
Waiting for application startup.
INFO
Application startup complete.
It is
HIGHLY encouraged
that you write or copy the code, edit it and run it locally.
Using it in your editor is what really shows you the benefits of FastAPI, seeing how little code you have to write, all the type checks, autocompletion, etc.
Install FastAPI
The first step is to install FastAPI.
Make sure you create a
virtual environment
, activate it, and then
install FastAPI
:
fast →
pip install "fastapi[standard]"
restart ↻
Note
When you install with
pip install "fastapi[standard]"
it comes with some default optional standard dependencies.
If you don't want to have those optional dependencies, you can instead install
pip install fastapi
.
Advanced User Guide
There is also an
Advanced User Guide
that you can read later after this
Tutorial - User guide
.
The
Advanced User Guide
builds on this one, uses the same concepts, and teaches you some extra features.
But you should first read the
Tutorial - User Guide
(what you are reading right now).
It's designed so that you can build a complete application with just the
Tutorial - User Guide
, and then extend it in different ways, depending on your needs, using some of the additional ideas from the
Advanced User Guide
.

## 109_TUTORIAL_BACKGROUND_TASKS
Background Tasks¶
---

Background Tasks
You can define background tasks to be run
after
returning a response.
This is useful for operations that need to happen after a request, but that the client doesn't really have to be waiting for the operation to complete before receiving the response.
This includes, for example:
Email notifications sent after performing an action:
As connecting to an email server and sending an email tends to be "slow" (several seconds), you can return the response right away and send the email notification in the background.
Processing data:
For example, let's say you receive a file that must go through a slow process, you can return a response of "Accepted" (HTTP 202) and process the file in the background.
Using
BackgroundTasks
First, import
BackgroundTasks
and define a parameter in your
path operation function
with a type declaration of
BackgroundTasks
:
Python 3.8+
from
fastapi
import
BackgroundTasks
,
FastAPI
app
=
FastAPI
()
def
write_notification
(
email
:
str
,
message
=
""
):
with
open
(
"log.txt"
,
mode
=
"w"
)
as
email_file
:
content
=
f
"notification for
{
email
}
:
{
message
}
"
email_file
.
write
(
content
)
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
):
background_tasks
.
add_task
(
write_notification
,
email
,
message
=
"some notification"
)
return
{
"message"
:
"Notification sent in the background"
}
FastAPI
will create the object of type
BackgroundTasks
for you and pass it as that parameter.
Create a task function
Create a function to be run as the background task.
It is just a standard function that can receive parameters.
It can be an
async def
or normal
def
function,
FastAPI
will know how to handle it correctly.
In this case, the task function will write to a file (simulating sending an email).
And as the write operation doesn't use
async
and
await
, we define the function with normal
def
:
Python 3.8+
from
fastapi
import
BackgroundTasks
,
FastAPI
app
=
FastAPI
()
def
write_notification
(
email
:
str
,
message
=
""
):
with
open
(
"log.txt"
,
mode
=
"w"
)
as
email_file
:
content
=
f
"notification for
{
email
}
:
{
message
}
"
email_file
.
write
(
content
)
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
):
background_tasks
.
add_task
(
write_notification
,
email
,
message
=
"some notification"
)
return
{
"message"
:
"Notification sent in the background"
}
Add the background task
Inside of your
path operation function
, pass your task function to the
background tasks
object with the method
.add_task()
:
Python 3.8+
from
fastapi
import
BackgroundTasks
,
FastAPI
app
=
FastAPI
()
def
write_notification
(
email
:
str
,
message
=
""
):
with
open
(
"log.txt"
,
mode
=
"w"
)
as
email_file
:
content
=
f
"notification for
{
email
}
:
{
message
}
"
email_file
.
write
(
content
)
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
):
background_tasks
.
add_task
(
write_notification
,
email
,
message
=
"some notification"
)
return
{
"message"
:
"Notification sent in the background"
}
.add_task()
receives as arguments:
A task function to be run in the background (
write_notification
).
Any sequence of arguments that should be passed to the task function in order (
email
).
Any keyword arguments that should be passed to the task function (
message="some notification"
).
Dependency Injection
Using
BackgroundTasks
also works with the dependency injection system, you can declare a parameter of type
BackgroundTasks
at multiple levels: in a
path operation function
, in a dependency (dependable), in a sub-dependency, etc.
FastAPI
knows what to do in each case and how to reuse the same object, so that all the background tasks are merged together and are run in the background afterwards:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
BackgroundTasks
,
Depends
,
FastAPI
app
=
FastAPI
()
def
write_log
(
message
:
str
):
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
message
)
def
get_query
(
background_tasks
:
BackgroundTasks
,
q
:
str
|
None
=
None
):
if
q
:
message
=
f
"found query:
{
q
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
q
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
,
q
:
Annotated
[
str
,
Depends
(
get_query
)]
):
message
=
f
"message to
{
email
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
{
"message"
:
"Message sent"
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
BackgroundTasks
,
Depends
,
FastAPI
app
=
FastAPI
()
def
write_log
(
message
:
str
):
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
message
)
def
get_query
(
background_tasks
:
BackgroundTasks
,
q
:
Union
[
str
,
None
]
=
None
):
if
q
:
message
=
f
"found query:
{
q
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
q
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
,
q
:
Annotated
[
str
,
Depends
(
get_query
)]
):
message
=
f
"message to
{
email
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
{
"message"
:
"Message sent"
}
from
typing
import
Union
from
fastapi
import
BackgroundTasks
,
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
def
write_log
(
message
:
str
):
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
message
)
def
get_query
(
background_tasks
:
BackgroundTasks
,
q
:
Union
[
str
,
None
]
=
None
):
if
q
:
message
=
f
"found query:
{
q
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
q
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
,
q
:
Annotated
[
str
,
Depends
(
get_query
)]
):
message
=
f
"message to
{
email
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
{
"message"
:
"Message sent"
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
BackgroundTasks
,
Depends
,
FastAPI
app
=
FastAPI
()
def
write_log
(
message
:
str
):
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
message
)
def
get_query
(
background_tasks
:
BackgroundTasks
,
q
:
str
|
None
=
None
):
if
q
:
message
=
f
"found query:
{
q
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
q
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
,
q
:
str
=
Depends
(
get_query
)
):
message
=
f
"message to
{
email
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
{
"message"
:
"Message sent"
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
BackgroundTasks
,
Depends
,
FastAPI
app
=
FastAPI
()
def
write_log
(
message
:
str
):
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
message
)
def
get_query
(
background_tasks
:
BackgroundTasks
,
q
:
Union
[
str
,
None
]
=
None
):
if
q
:
message
=
f
"found query:
{
q
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
q
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
,
q
:
str
=
Depends
(
get_query
)
):
message
=
f
"message to
{
email
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
{
"message"
:
"Message sent"
}
In this example, the messages will be written to the
log.txt
file
after
the response is sent.
If there was a query in the request, it will be written to the log in a background task.
And then another background task generated at the
path operation function
will write a message using the
email
path parameter.
Technical Details
The class
BackgroundTasks
comes directly from
starlette.background
.
It is imported/included directly into FastAPI so that you can import it from
fastapi
and avoid accidentally importing the alternative
BackgroundTask
(without the
s
at the end) from
starlette.background
.
By only using
BackgroundTasks
(and not
BackgroundTask
), it's then possible to use it as a
path operation function
parameter and have
FastAPI
handle the rest for you, just like when using the
Request
object directly.
It's still possible to use
BackgroundTask
alone in FastAPI, but you have to create the object in your code and return a Starlette
Response
including it.
You can see more details in
Starlette's official docs for Background Tasks
.
Caveat
If you need to perform heavy background computation and you don't necessarily need it to be run by the same process (for example, you don't need to share memory, variables, etc), you might benefit from using other bigger tools like
Celery
.
They tend to require more complex configurations, a message/job queue manager, like RabbitMQ or Redis, but they allow you to run background tasks in multiple processes, and especially, in multiple servers.
But if you need to access variables and objects from the same
FastAPI
app, or you need to perform small background tasks (like sending an email notification), you can simply just use
BackgroundTasks
.
Recap
Import and use
BackgroundTasks
with parameters in
path operation functions
and dependencies to add background tasks.

## 110_TUTORIAL_BIGGER_APPLICATIONS
Bigger Applications - Multiple Files¶
---

Bigger Applications - Multiple Files
If you are building an application or a web API, it's rarely the case that you can put everything in a single file.
FastAPI
provides a convenience tool to structure your application while keeping all the flexibility.
Info
If you come from Flask, this would be the equivalent of Flask's Blueprints.
An example file structure
Let's say you have a file structure like this:
.
├── app
│   ├── __init__.py
│   ├── main.py
│   ├── dependencies.py
│   └── routers
│   │ ├── __init__.py
│   │ ├── items.py
│   │ └── users.py
│   └── internal
│   ├── __init__.py
│   └── admin.py
Tip
There are several
__init__.py
files: one in each directory or subdirectory.
This is what allows importing code from one file into another.
For example, in
app/main.py
you could have a line like:
from app.routers import items
The
app
directory contains everything. And it has an empty file
app/__init__.py
, so it is a "Python package" (a collection of "Python modules"):
app
.
It contains an
app/main.py
file. As it is inside a Python package (a directory with a file
__init__.py
), it is a "module" of that package:
app.main
.
There's also an
app/dependencies.py
file, just like
app/main.py
, it is a "module":
app.dependencies
.
There's a subdirectory
app/routers/
with another file
__init__.py
, so it's a "Python subpackage":
app.routers
.
The file
app/routers/items.py
is inside a package,
app/routers/
, so, it's a submodule:
app.routers.items
.
The same with
app/routers/users.py
, it's another submodule:
app.routers.users
.
There's also a subdirectory
app/internal/
with another file
__init__.py
, so it's another "Python subpackage":
app.internal
.
And the file
app/internal/admin.py
is another submodule:
app.internal.admin
.
The same file structure with comments:
.
├── app # "app" is a Python package
│   ├── __init__.py # this file makes "app" a "Python package"
│   ├── main.py # "main" module, e.g. import app.main
│   ├── dependencies.py # "dependencies" module, e.g. import app.dependencies
│   └── routers # "routers" is a "Python subpackage"
│   │ ├── __init__.py # makes "routers" a "Python subpackage"
│   │ ├── items.py # "items" submodule, e.g. import app.routers.items
│   │ └── users.py # "users" submodule, e.g. import app.routers.users
│   └── internal # "internal" is a "Python subpackage"
│   ├── __init__.py # makes "internal" a "Python subpackage"
│   └── admin.py # "admin" submodule, e.g. import app.internal.admin
APIRouter
Let's say the file dedicated to handling just users is the submodule at
/app/routers/users.py
.
You want to have the
path operations
related to your users separated from the rest of the code, to keep it organized.
But it's still part of the same
FastAPI
application/web API (it's part of the same "Python Package").
You can create the
path operations
for that module using
APIRouter
.
Import
APIRouter
You import it and create an "instance" the same way you would with the class
FastAPI
:
app/routers/users.py
from
fastapi
import
APIRouter
router
=
APIRouter
()
@router
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
@router
.
get
(
"/users/me"
,
tags
=
[
"users"
])
async
def
read_user_me
():
return
{
"username"
:
"fakecurrentuser"
}
@router
.
get
(
"/users/
{username}
"
,
tags
=
[
"users"
])
async
def
read_user
(
username
:
str
):
return
{
"username"
:
username
}
Path operations
with
APIRouter
And then you use it to declare your
path operations
.
Use it the same way you would use the
FastAPI
class:
app/routers/users.py
from
fastapi
import
APIRouter
router
=
APIRouter
()
@router
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
@router
.
get
(
"/users/me"
,
tags
=
[
"users"
])
async
def
read_user_me
():
return
{
"username"
:
"fakecurrentuser"
}
@router
.
get
(
"/users/
{username}
"
,
tags
=
[
"users"
])
async
def
read_user
(
username
:
str
):
return
{
"username"
:
username
}
You can think of
APIRouter
as a "mini
FastAPI
" class.
All the same options are supported.
All the same
parameters
,
responses
,
dependencies
,
tags
, etc.
Tip
In this example, the variable is called
router
, but you can name it however you want.
We are going to include this
APIRouter
in the main
FastAPI
app, but first, let's check the dependencies and another
APIRouter
.
Dependencies
We see that we are going to need some dependencies used in several places of the application.
So we put them in their own
dependencies
module (
app/dependencies.py
).
We will now use a simple dependency to read a custom
X-Token
header:
Python 3.9+
Python 3.8+
Python 3.8+ non-Annotated
app/dependencies.py
from
typing
import
Annotated
from
fastapi
import
Header
,
HTTPException
async
def
get_token_header
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
get_query_token
(
token
:
str
):
if
token
!=
"jessica"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"No Jessica token provided"
)
app/dependencies.py
from
fastapi
import
Header
,
HTTPException
from
typing_extensions
import
Annotated
async
def
get_token_header
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
get_query_token
(
token
:
str
):
if
token
!=
"jessica"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"No Jessica token provided"
)
Tip
Prefer to use the
Annotated
version if possible.
app/dependencies.py
from
fastapi
import
Header
,
HTTPException
async
def
get_token_header
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
get_query_token
(
token
:
str
):
if
token
!=
"jessica"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"No Jessica token provided"
)
Tip
We are using an invented header to simplify this example.
But in real cases you will get better results using the integrated
Security utilities
.
Another module with
APIRouter
Let's say you also have the endpoints dedicated to handling "items" from your application in the module at
app/routers/items.py
.
You have
path operations
for:
/items/
/items/{item_id}
It's all the same structure as with
app/routers/users.py
.
But we want to be smarter and simplify the code a bit.
We know all the
path operations
in this module have the same:
Path
prefix
:
/items
.
tags
: (just one tag:
items
).
Extra
responses
.
dependencies
: they all need that
X-Token
dependency we created.
So, instead of adding all that to each
path operation
, we can add it to the
APIRouter
.
app/routers/items.py
from
fastapi
import
APIRouter
,
Depends
,
HTTPException
from
..dependencies
import
get_token_header
router
=
APIRouter
(
prefix
=
"/items"
,
tags
=
[
"items"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
404
:
{
"description"
:
"Not found"
}},
)
fake_items_db
=
{
"plumbus"
:
{
"name"
:
"Plumbus"
},
"gun"
:
{
"name"
:
"Portal Gun"
}}
@router
.
get
(
"/"
)
async
def
read_items
():
return
fake_items_db
@router
.
get
(
"/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
fake_items_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"name"
:
fake_items_db
[
item_id
][
"name"
],
"item_id"
:
item_id
}
@router
.
put
(
"/
{item_id}
"
,
tags
=
[
"custom"
],
responses
=
{
403
:
{
"description"
:
"Operation forbidden"
}},
)
async
def
update_item
(
item_id
:
str
):
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
403
,
detail
=
"You can only update the item: plumbus"
)
return
{
"item_id"
:
item_id
,
"name"
:
"The great Plumbus"
}
As the path of each
path operation
has to start with
/
, like in:
@router
.
get
(
"/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
...
...the prefix must not include a final
/
.
So, the prefix in this case is
/items
.
We can also add a list of
tags
and extra
responses
that will be applied to all the
path operations
included in this router.
And we can add a list of
dependencies
that will be added to all the
path operations
in the router and will be executed/solved for each request made to them.
Tip
Note that, much like
dependencies in
path operation decorators
, no value will be passed to your
path operation function
.
The end result is that the item paths are now:
/items/
/items/{item_id}
...as we intended.
They will be marked with a list of tags that contain a single string
"items"
.
These "tags" are especially useful for the automatic interactive documentation systems (using OpenAPI).
All of them will include the predefined
responses
.
All these
path operations
will have the list of
dependencies
evaluated/executed before them.
If you also declare dependencies in a specific
path operation
,
they will be executed too
.
The router dependencies are executed first, then the
dependencies
in the decorator
, and then the normal parameter dependencies.
You can also add
Security
dependencies with
scopes
.
Tip
Having
dependencies
in the
APIRouter
can be used, for example, to require authentication for a whole group of
path operations
. Even if the dependencies are not added individually to each one of them.
Check
The
prefix
,
tags
,
responses
, and
dependencies
parameters are (as in many other cases) just a feature from
FastAPI
to help you avoid code duplication.
Import the dependencies
This code lives in the module
app.routers.items
, the file
app/routers/items.py
.
And we need to get the dependency function from the module
app.dependencies
, the file
app/dependencies.py
.
So we use a relative import with
..
for the dependencies:
app/routers/items.py
from
fastapi
import
APIRouter
,
Depends
,
HTTPException
from
..dependencies
import
get_token_header
router
=
APIRouter
(
prefix
=
"/items"
,
tags
=
[
"items"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
404
:
{
"description"
:
"Not found"
}},
)
fake_items_db
=
{
"plumbus"
:
{
"name"
:
"Plumbus"
},
"gun"
:
{
"name"
:
"Portal Gun"
}}
@router
.
get
(
"/"
)
async
def
read_items
():
return
fake_items_db
@router
.
get
(
"/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
fake_items_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"name"
:
fake_items_db
[
item_id
][
"name"
],
"item_id"
:
item_id
}
@router
.
put
(
"/
{item_id}
"
,
tags
=
[
"custom"
],
responses
=
{
403
:
{
"description"
:
"Operation forbidden"
}},
)
async
def
update_item
(
item_id
:
str
):
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
403
,
detail
=
"You can only update the item: plumbus"
)
return
{
"item_id"
:
item_id
,
"name"
:
"The great Plumbus"
}
How relative imports work
Tip
If you know perfectly how imports work, continue to the next section below.
A single dot
.
, like in:
from
.dependencies
import
get_token_header
would mean:
Starting in the same package that this module (the file
app/routers/items.py
) lives in (the directory
app/routers/
)...
find the module
dependencies
(an imaginary file at
app/routers/dependencies.py
)...
and from it, import the function
get_token_header
.
But that file doesn't exist, our dependencies are in a file at
app/dependencies.py
.
Remember how our app/file structure looks like:
The two dots
..
, like in:
from
..dependencies
import
get_token_header
mean:
Starting in the same package that this module (the file
app/routers/items.py
) lives in (the directory
app/routers/
)...
go to the parent package (the directory
app/
)...
and in there, find the module
dependencies
(the file at
app/dependencies.py
)...
and from it, import the function
get_token_header
.
That works correctly! 🎉
The same way, if we had used three dots
...
, like in:
from
...dependencies
import
get_token_header
that would mean:
Starting in the same package that this module (the file
app/routers/items.py
) lives in (the directory
app/routers/
)...
go to the parent package (the directory
app/
)...
then go to the parent of that package (there's no parent package,
app
is the top level 😱)...
and in there, find the module
dependencies
(the file at
app/dependencies.py
)...
and from it, import the function
get_token_header
.
That would refer to some package above
app/
, with its own file
__init__.py
, etc. But we don't have that. So, that would throw an error in our example. 🚨
But now you know how it works, so you can use relative imports in your own apps no matter how complex they are. 🤓
Add some custom
tags
,
responses
, and
dependencies
We are not adding the prefix
/items
nor the
tags=["items"]
to each
path operation
because we added them to the
APIRouter
.
But we can still add
more
tags
that will be applied to a specific
path operation
, and also some extra
responses
specific to that
path operation
:
app/routers/items.py
from
fastapi
import
APIRouter
,
Depends
,
HTTPException
from
..dependencies
import
get_token_header
router
=
APIRouter
(
prefix
=
"/items"
,
tags
=
[
"items"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
404
:
{
"description"
:
"Not found"
}},
)
fake_items_db
=
{
"plumbus"
:
{
"name"
:
"Plumbus"
},
"gun"
:
{
"name"
:
"Portal Gun"
}}
@router
.
get
(
"/"
)
async
def
read_items
():
return
fake_items_db
@router
.
get
(
"/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
fake_items_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"name"
:
fake_items_db
[
item_id
][
"name"
],
"item_id"
:
item_id
}
@router
.
put
(
"/
{item_id}
"
,
tags
=
[
"custom"
],
responses
=
{
403
:
{
"description"
:
"Operation forbidden"
}},
)
async
def
update_item
(
item_id
:
str
):
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
403
,
detail
=
"You can only update the item: plumbus"
)
return
{
"item_id"
:
item_id
,
"name"
:
"The great Plumbus"
}
Tip
This last path operation will have the combination of tags:
["items", "custom"]
.
And it will also have both responses in the documentation, one for
404
and one for
403
.
The main
FastAPI
Now, let's see the module at
app/main.py
.
Here's where you import and use the class
FastAPI
.
This will be the main file in your application that ties everything together.
And as most of your logic will now live in its own specific module, the main file will be quite simple.
Import
FastAPI
You import and create a
FastAPI
class as normally.
And we can even declare
global dependencies
that will be combined with the dependencies for each
APIRouter
:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
Import the
APIRouter
Now we import the other submodules that have
APIRouter
s:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
As the files
app/routers/users.py
and
app/routers/items.py
are submodules that are part of the same Python package
app
, we can use a single dot
.
to import them using "relative imports".
How the importing works
The section:
from
.routers
import
items
,
users
means:
Starting in the same package that this module (the file
app/main.py
) lives in (the directory
app/
)...
look for the subpackage
routers
(the directory at
app/routers/
)...
and from it, import the submodule
items
(the file at
app/routers/items.py
) and
users
(the file at
app/routers/users.py
)...
The module
items
will have a variable
router
(
items.router
). This is the same one we created in the file
app/routers/items.py
, it's an
APIRouter
object.
And then we do the same for the module
users
.
We could also import them like:
from
app.routers
import
items
,
users
Info
The first version is a "relative import":
from
.routers
import
items
,
users
The second version is an "absolute import":
from
app.routers
import
items
,
users
To learn more about Python Packages and Modules, read
the official Python documentation about Modules
.
Avoid name collisions
We are importing the submodule
items
directly, instead of importing just its variable
router
.
This is because we also have another variable named
router
in the submodule
users
.
If we had imported one after the other, like:
from
.routers.items
import
router
from
.routers.users
import
router
the
router
from
users
would overwrite the one from
items
and we wouldn't be able to use them at the same time.
So, to be able to use both of them in the same file, we import the submodules directly:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
Include the
APIRouter
s for
users
and
items
Now, let's include the
router
s from the submodules
users
and
items
:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
Info
users.router
contains the
APIRouter
inside of the file
app/routers/users.py
.
And
items.router
contains the
APIRouter
inside of the file
app/routers/items.py
.
With
app.include_router()
we can add each
APIRouter
to the main
FastAPI
application.
It will include all the routes from that router as part of it.
Technical Details
It will actually internally create a
path operation
for each
path operation
that was declared in the
APIRouter
.
So, behind the scenes, it will actually work as if everything was the same single app.
Check
You don't have to worry about performance when including routers.
This will take microseconds and will only happen at startup.
So it won't affect performance. ⚡
Include an
APIRouter
with a custom
prefix
,
tags
,
responses
, and
dependencies
Now, let's imagine your organization gave you the
app/internal/admin.py
file.
It contains an
APIRouter
with some admin
path operations
that your organization shares between several projects.
For this example it will be super simple. But let's say that because it is shared with other projects in the organization, we cannot modify it and add a
prefix
,
dependencies
,
tags
, etc. directly to the
APIRouter
:
app/internal/admin.py
from
fastapi
import
APIRouter
router
=
APIRouter
()
@router
.
post
(
"/"
)
async
def
update_admin
():
return
{
"message"
:
"Admin getting schwifty"
}
But we still want to set a custom
prefix
when including the
APIRouter
so that all its
path operations
start with
/admin
, we want to secure it with the
dependencies
we already have for this project, and we want to include
tags
and
responses
.
We can declare all that without having to modify the original
APIRouter
by passing those parameters to
app.include_router()
:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
That way, the original
APIRouter
will stay unmodified, so we can still share that same
app/internal/admin.py
file with other projects in the organization.
The result is that in our app, each of the
path operations
from the
admin
module will have:
The prefix
/admin
.
The tag
admin
.
The dependency
get_token_header
.
The response
418
. 🍵
But that will only affect that
APIRouter
in our app, not in any other code that uses it.
So, for example, other projects could use the same
APIRouter
with a different authentication method.
Include a
path operation
We can also add
path operations
directly to the
FastAPI
app.
Here we do it... just to show that we can 🤷:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
and it will work correctly, together with all the other
path operations
added with
app.include_router()
.
Very Technical Details
Note
: this is a very technical detail that you probably can
just skip
.
The
APIRouter
s are not "mounted", they are not isolated from the rest of the application.
This is because we want to include their
path operations
in the OpenAPI schema and the user interfaces.
As we cannot just isolate them and "mount" them independently of the rest, the
path operations
are "cloned" (re-created), not included directly.
Check the automatic API docs
Now, run your app:
fast →
fastapi dev app/main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
And open the docs at
http://127.0.0.1:8000/docs
.
You will see the automatic API docs, including the paths from all the submodules, using the correct paths (and prefixes) and the correct tags:
Include the same router multiple times with different
prefix
You can also use
.include_router()
multiple times with the
same
router using different prefixes.
This could be useful, for example, to expose the same API under different prefixes, e.g.
/api/v1
and
/api/latest
.
This is an advanced usage that you might not really need, but it's there in case you do.
Include an
APIRouter
in another
The same way you can include an
APIRouter
in a
FastAPI
application, you can include an
APIRouter
in another
APIRouter
using:
router
.
include_router
(
other_router
)
Make sure you do it before including
router
in the
FastAPI
app, so that the
path operations
from
other_router
are also included.

## 111_TUTORIAL_BODY_FIELDS
Body - Fields¶
---

Body - Fields
The same way you can declare additional validation and metadata in
path operation function
parameters with
Query
,
Path
and
Body
, you can declare validation and metadata inside of Pydantic models using Pydantic's
Field
.
Import
Field
First, you have to import it:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Warning
Notice that
Field
is imported directly from
pydantic
, not from
fastapi
as are all the rest (
Query
,
Path
,
Body
, etc).
Declare model attributes
You can then use
Field
with model attributes:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Field
works the same way as
Query
,
Path
and
Body
, it has all the same parameters, etc.
Technical Details
Actually,
Query
,
Path
and others you'll see next create objects of subclasses of a common
Param
class, which is itself a subclass of Pydantic's
FieldInfo
class.
And Pydantic's
Field
returns an instance of
FieldInfo
as well.
Body
also returns objects of a subclass of
FieldInfo
directly. And there are others you will see later that are subclasses of the
Body
class.
Remember that when you import
Query
,
Path
, and others from
fastapi
, those are actually functions that return special classes.
Tip
Notice how each model's attribute with a type, default value and
Field
has the same structure as a
path operation function's
parameter, with
Field
instead of
Path
,
Query
and
Body
.
Add extra information
You can declare extra information in
Field
,
Query
,
Body
, etc. And it will be included in the generated JSON Schema.
You will learn more about adding extra information later in the docs, when learning to declare examples.
Warning
Extra keys passed to
Field
will also be present in the resulting OpenAPI schema for your application.
As these keys may not necessarily be part of the OpenAPI specification, some OpenAPI tools, for example
the OpenAPI validator
, may not work with your generated schema.
Recap
You can use Pydantic's
Field
to declare extra validations and metadata for model attributes.
You can also use the extra keyword arguments to pass additional JSON Schema metadata.

## 112_TUTORIAL_BODY_MULTIPLE_PARAMS
Body - Multiple Parameters¶
---

Body - Multiple Parameters
Now that we have seen how to use
Path
and
Query
, let's see more advanced uses of request body declarations.
Mix
Path
,
Query
and body parameters
First, of course, you can mix
Path
,
Query
and request body parameter declarations freely and
FastAPI
will know what to do.
And you can also declare body parameters as optional, by setting the default to
None
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
)],
q
:
str
|
None
=
None
,
item
:
Item
|
None
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
item
:
results
.
update
({
"item"
:
item
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Path
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
)],
q
:
Union
[
str
,
None
]
=
None
,
item
:
Union
[
Item
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
item
:
results
.
update
({
"item"
:
item
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
)],
q
:
Union
[
str
,
None
]
=
None
,
item
:
Union
[
Item
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
item
:
results
.
update
({
"item"
:
item
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
),
q
:
str
|
None
=
None
,
item
:
Item
|
None
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
item
:
results
.
update
({
"item"
:
item
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
),
q
:
Union
[
str
,
None
]
=
None
,
item
:
Union
[
Item
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
item
:
results
.
update
({
"item"
:
item
})
return
results
Note
Notice that, in this case, the
item
that would be taken from the body is optional. As it has a
None
default value.
Multiple body parameters
In the previous example, the
path operations
would expect a JSON body with the attributes of an
Item
, like:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
}
But you can also declare multiple body parameters, e.g.
item
and
user
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
str
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
}
return
results
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
}
return
results
In this case,
FastAPI
will notice that there is more than one body parameter in the function (there are two parameters that are Pydantic models).
So, it will then use the parameter names as keys (field names) in the body, and expect a body like:
{
"item"
:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
},
"user"
:
{
"username"
:
"dave"
,
"full_name"
:
"Dave Grohl"
}
}
Note
Notice that even though the
item
was declared the same way as before, it is now expected to be inside of the body with a key
item
.
FastAPI
will do the automatic conversion from the request, so that the parameter
item
receives its specific content and the same for
user
.
It will perform the validation of the compound data, and will document it like that for the OpenAPI schema and automatic docs.
Singular values in body
The same way there is a
Query
and
Path
to define extra data for query and path parameters,
FastAPI
provides an equivalent
Body
.
For example, extending the previous model, you could decide that you want to have another key
importance
in the same body, besides the
item
and
user
.
If you declare it as is, because it is a singular value,
FastAPI
will assume that it is a query parameter.
But you can instruct
FastAPI
to treat it as another body key using
Body
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
str
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
()]
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
()]
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
()]
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
str
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
int
=
Body
()):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
int
=
Body
()):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
return
results
In this case,
FastAPI
will expect a body like:
{
"item"
:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
},
"user"
:
{
"username"
:
"dave"
,
"full_name"
:
"Dave Grohl"
},
"importance"
:
5
}
Again, it will convert the data types, validate, document, etc.
Multiple body params and query
Of course, you can also declare additional query parameters whenever you need, additional to any body parameters.
As, by default, singular values are interpreted as query parameters, you don't have to explicitly add a
Query
, you can just do:
q
:
Union
[
str
,
None
]
=
None
Or in Python 3.10 and above:
q
:
str
|
None
=
None
For example:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
str
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
(
gt
=
0
)],
q
:
str
|
None
=
None
,
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
(
gt
=
0
)],
q
:
Union
[
str
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
(
gt
=
0
)],
q
:
Union
[
str
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
str
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
int
=
Body
(
gt
=
0
),
q
:
str
|
None
=
None
,
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
int
=
Body
(
gt
=
0
),
q
:
Union
[
str
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Info
Body
also has all the same extra validation and metadata parameters as
Query
,
Path
and others you will see later.
Embed a single body parameter
Let's say you only have a single
item
body parameter from a Pydantic model
Item
.
By default,
FastAPI
will then expect its body directly.
But if you want it to expect a JSON with a key
item
and inside of it the model contents, as it does when you declare extra body parameters, you can use the special
Body
parameter
embed
:
item
:
Item
=
Body
(
embed
=
True
)
as in:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
In this case
FastAPI
will expect a body like:
{
"item"
:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
}
}
instead of:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
}
Recap
You can add multiple body parameters to your
path operation function
, even though a request can only have a single body.
But
FastAPI
will handle it, give you the correct data in your function, and validate and document the correct schema in the
path operation
.
You can also declare singular values to be received as part of the body.
And you can instruct
FastAPI
to embed the body in a key even when there is only a single parameter declared.

## 113_TUTORIAL_BODY_NESTED_MODELS
Body - Nested Models¶
---

Body - Nested Models
With
FastAPI
, you can define, validate, document, and use arbitrarily deeply nested models (thanks to Pydantic).
List fields
You can define an attribute to be a subtype. For example, a Python
list
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
list
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
list
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
This will make
tags
be a list, although it doesn't declare the type of the elements of the list.
List fields with type parameter
But Python has a specific way to declare lists with internal types, or "type parameters":
Import typing's
List
In Python 3.9 and above you can use the standard
list
to declare these type annotations as we'll see below. 💡
But in Python versions before 3.9 (3.6 and above), you first need to import
List
from standard Python's
typing
module:
Python 3.8+
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
List
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.10+
Python 3.9+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
list
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
list
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Declare a
list
with a type parameter
To declare types that have type parameters (internal types), like
list
,
dict
,
tuple
:
If you are in a Python version lower than 3.9, import their equivalent version from the
typing
module
Pass the internal type(s) as "type parameters" using square brackets:
[
and
]
In Python 3.9 it would be:
my_list
:
list
[
str
]
In versions of Python before 3.9, it would be:
from
typing
import
List
my_list
:
List
[
str
]
That's all standard Python syntax for type declarations.
Use that same standard syntax for model attributes with internal types.
So, in our example, we can make
tags
be specifically a "list of strings":
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
list
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
list
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
List
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Set types
But then we think about it, and realize that tags shouldn't repeat, they would probably be unique strings.
And Python has a special data type for sets of unique items, the
set
.
Then we can declare
tags
as a set of strings:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
With this, even if you receive a request with duplicate data, it will be converted to a set of unique items.
And whenever you output that data, even if the source had duplicates, it will be output as a set of unique items.
And it will be annotated / documented accordingly too.
Nested Models
Each attribute of a Pydantic model has a type.
But that type can itself be another Pydantic model.
So, you can declare deeply nested JSON "objects" with specific attribute names, types and validations.
All that, arbitrarily nested.
Define a submodel
For example, we can define an
Image
model:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
image
:
Image
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Use the submodel as a type
And then we can use it as the type of an attribute:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
image
:
Image
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
This would mean that
FastAPI
would expect a body similar to:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
,
"tags"
:
[
"rock"
,
"metal"
,
"bar"
],
"image"
:
{
"url"
:
"http://example.com/baz.jpg"
,
"name"
:
"The Foo live"
}
}
Again, doing just that declaration, with
FastAPI
you get:
Editor support (completion, etc.), even for nested models
Data conversion
Data validation
Automatic documentation
Special types and validation
Apart from normal singular types like
str
,
int
,
float
, etc. you can use more complex singular types that inherit from
str
.
To see all the options you have, checkout
Pydantic's Type Overview
. You will see some examples in the next chapter.
For example, as in the
Image
model we have a
url
field, we can declare it to be an instance of Pydantic's
HttpUrl
instead of a
str
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
image
:
Image
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
The string will be checked to be a valid URL, and documented in JSON Schema / OpenAPI as such.
Attributes with lists of submodels
You can also use Pydantic models as subtypes of
list
,
set
, etc.:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
images
:
list
[
Image
]
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
images
:
Union
[
list
[
Image
],
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
List
,
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
images
:
Union
[
List
[
Image
],
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
This will expect (convert, validate, document, etc.) a JSON body like:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
,
"tags"
:
[
"rock"
,
"metal"
,
"bar"
],
"images"
:
[
{
"url"
:
"http://example.com/baz.jpg"
,
"name"
:
"The Foo live"
},
{
"url"
:
"http://example.com/dave.jpg"
,
"name"
:
"The Baz"
}
]
}
Info
Notice how the
images
key now has a list of image objects.
Deeply nested models
You can define arbitrarily deeply nested models:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
images
:
list
[
Image
]
|
None
=
None
class
Offer
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
items
:
list
[
Item
]
@app
.
post
(
"/offers/"
)
async
def
create_offer
(
offer
:
Offer
):
return
offer
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
images
:
Union
[
list
[
Image
],
None
]
=
None
class
Offer
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
items
:
list
[
Item
]
@app
.
post
(
"/offers/"
)
async
def
create_offer
(
offer
:
Offer
):
return
offer
from
typing
import
List
,
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
images
:
Union
[
List
[
Image
],
None
]
=
None
class
Offer
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
items
:
List
[
Item
]
@app
.
post
(
"/offers/"
)
async
def
create_offer
(
offer
:
Offer
):
return
offer
Info
Notice how
Offer
has a list of
Item
s, which in turn have an optional list of
Image
s
Bodies of pure lists
If the top level value of the JSON body you expect is a JSON
array
(a Python
list
), you can declare the type in the parameter of the function, the same as in Pydantic models:
images
:
List
[
Image
]
or in Python 3.9 and above:
images
:
list
[
Image
]
as in:
Python 3.9+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
@app
.
post
(
"/images/multiple/"
)
async
def
create_multiple_images
(
images
:
list
[
Image
]):
return
images
🤓 Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
@app
.
post
(
"/images/multiple/"
)
async
def
create_multiple_images
(
images
:
List
[
Image
]):
return
images
Editor support everywhere
And you get editor support everywhere.
Even for items inside of lists:
You couldn't get this kind of editor support if you were working directly with
dict
instead of Pydantic models.
But you don't have to worry about them either, incoming dicts are converted automatically and your output is converted automatically to JSON too.
Bodies of arbitrary
dict
s
You can also declare a body as a
dict
with keys of some type and values of some other type.
This way, you don't have to know beforehand what the valid field/attribute names are (as would be the case with Pydantic models).
This would be useful if you want to receive keys that you don't already know.
Another useful case is when you want to have keys of another type (e.g.,
int
).
That's what we are going to see here.
In this case, you would accept any
dict
as long as it has
int
keys with
float
values:
Python 3.9+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
post
(
"/index-weights/"
)
async
def
create_index_weights
(
weights
:
dict
[
int
,
float
]):
return
weights
🤓 Other versions and variants
Python 3.8+
from
typing
import
Dict
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
post
(
"/index-weights/"
)
async
def
create_index_weights
(
weights
:
Dict
[
int
,
float
]):
return
weights
Tip
Keep in mind that JSON only supports
str
as keys.
But Pydantic has automatic data conversion.
This means that, even though your API clients can only send strings as keys, as long as those strings contain pure integers, Pydantic will convert them and validate them.
And the
dict
you receive as
weights
will actually have
int
keys and
float
values.
Recap
With
FastAPI
you have the maximum flexibility provided by Pydantic models, while keeping your code simple, short and elegant.
But with all the benefits:
Editor support (completion everywhere!)
Data conversion (a.k.a. parsing / serialization)
Data validation
Schema documentation
Automatic docs

## 114_TUTORIAL_BODY_UPDATES
Body - Updates¶
---

Body - Updates
Update replacing with
PUT
To update an item you can use the
HTTP
PUT
operation.
You can use the
jsonable_encoder
to convert the input data to data that can be stored as JSON (e.g. with a NoSQL database). For example, converting
datetime
to
str
.
Python 3.10+
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
|
None
=
None
description
:
str
|
None
=
None
price
:
float
|
None
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
put
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
update_item_encoded
=
jsonable_encoder
(
item
)
items
[
item_id
]
=
update_item_encoded
return
update_item_encoded
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
put
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
update_item_encoded
=
jsonable_encoder
(
item
)
items
[
item_id
]
=
update_item_encoded
return
update_item_encoded
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
put
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
update_item_encoded
=
jsonable_encoder
(
item
)
items
[
item_id
]
=
update_item_encoded
return
update_item_encoded
PUT
is used to receive data that should replace the existing data.
Warning about replacing
That means that if you want to update the item
bar
using
PUT
with a body containing:
{
"name"
:
"Barz"
,
"price"
:
3
,
"description"
:
None
,
}
because it doesn't include the already stored attribute
"tax": 20.2
, the input model would take the default value of
"tax": 10.5
.
And the data would be saved with that "new"
tax
of
10.5
.
Partial updates with
PATCH
You can also use the
HTTP
PATCH
operation to
partially
update data.
This means that you can send only the data that you want to update, leaving the rest intact.
Note
PATCH
is less commonly used and known than
PUT
.
And many teams use only
PUT
, even for partial updates.
You are
free
to use them however you want,
FastAPI
doesn't impose any restrictions.
But this guide shows you, more or less, how they are intended to be used.
Using Pydantic's
exclude_unset
parameter
If you want to receive partial updates, it's very useful to use the parameter
exclude_unset
in Pydantic's model's
.model_dump()
.
Like
item.model_dump(exclude_unset=True)
.
Info
In Pydantic v1 the method was called
.dict()
, it was deprecated (but still supported) in Pydantic v2, and renamed to
.model_dump()
.
The examples here use
.dict()
for compatibility with Pydantic v1, but you should use
.model_dump()
instead if you can use Pydantic v2.
That would generate a
dict
with only the data that was set when creating the
item
model, excluding default values.
Then you can use this to generate a
dict
with only the data that was set (sent in the request), omitting default values:
Python 3.10+
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
|
None
=
None
description
:
str
|
None
=
None
price
:
float
|
None
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
Using Pydantic's
update
parameter
Now, you can create a copy of the existing model using
.model_copy()
, and pass the
update
parameter with a
dict
containing the data to update.
Info
In Pydantic v1 the method was called
.copy()
, it was deprecated (but still supported) in Pydantic v2, and renamed to
.model_copy()
.
The examples here use
.copy()
for compatibility with Pydantic v1, but you should use
.model_copy()
instead if you can use Pydantic v2.
Like
stored_item_model.model_copy(update=update_data)
:
Python 3.10+
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
|
None
=
None
description
:
str
|
None
=
None
price
:
float
|
None
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
Partial updates recap
In summary, to apply partial updates you would:
(Optionally) use
PATCH
instead of
PUT
.
Retrieve the stored data.
Put that data in a Pydantic model.
Generate a
dict
without default values from the input model (using
exclude_unset
).
This way you can update only the values actually set by the user, instead of overriding values already stored with default values in your model.
Create a copy of the stored model, updating its attributes with the received partial updates (using the
update
parameter).
Convert the copied model to something that can be stored in your DB (for example, using the
jsonable_encoder
).
This is comparable to using the model's
.model_dump()
method again, but it makes sure (and converts) the values to data types that can be converted to JSON, for example,
datetime
to
str
.
Save the data to your DB.
Return the updated model.
Python 3.10+
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
|
None
=
None
description
:
str
|
None
=
None
price
:
float
|
None
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
Tip
You can actually use this same technique with an HTTP
PUT
operation.
But the example here uses
PATCH
because it was created for these use cases.
Note
Notice that the input model is still validated.
So, if you want to receive partial updates that can omit all the attributes, you need to have a model with all the attributes marked as optional (with default values or
None
).
To distinguish from the models with all optional values for
updates
and models with required values for
creation
, you can use the ideas described in
Extra Models
.

## 115_TUTORIAL_BODY
Request Body¶
---

Request Body
When you need to send data from a client (let's say, a browser) to your API, you send it as a
request body
.
A
request
body is data sent by the client to your API. A
response
body is the data your API sends to the client.
Your API almost always has to send a
response
body. But clients don't necessarily need to send
request bodies
all the time, sometimes they only request a path, maybe with some query parameters, but don't send a body.
To declare a
request
body, you use
Pydantic
models with all their power and benefits.
Info
To send data, you should use one of:
POST
(the more common),
PUT
,
DELETE
or
PATCH
.
Sending a body with a
GET
request has an undefined behavior in the specifications, nevertheless, it is supported by FastAPI, only for very complex/extreme use cases.
As it is discouraged, the interactive docs with Swagger UI won't show the documentation for the body when using
GET
, and proxies in the middle might not support it.
Import Pydantic's
BaseModel
First, you need to import
BaseModel
from
pydantic
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
Create your data model
Then you declare your data model as a class that inherits from
BaseModel
.
Use standard Python types for all the attributes:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
The same as when declaring query parameters, when a model attribute has a default value, it is not required. Otherwise, it is required. Use
None
to make it just optional.
For example, this model above declares a JSON "
object
" (or Python
dict
) like:
{
"name"
:
"Foo"
,
"description"
:
"An optional description"
,
"price"
:
45.2
,
"tax"
:
3.5
}
...as
description
and
tax
are optional (with a default value of
None
), this JSON "
object
" would also be valid:
{
"name"
:
"Foo"
,
"price"
:
45.2
}
Declare it as a parameter
To add it to your
path operation
, declare it the same way you declared path and query parameters:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
...and declare its type as the model you created,
Item
.
Results
With just that Python type declaration,
FastAPI
will:
Read the body of the request as JSON.
Convert the corresponding types (if needed).
Validate the data.
If the data is invalid, it will return a nice and clear error, indicating exactly where and what was the incorrect data.
Give you the received data in the parameter
item
.
As you declared it in the function to be of type
Item
, you will also have all the editor support (completion, etc) for all of the attributes and their types.
Generate
JSON Schema
definitions for your model, you can also use them anywhere else you like if it makes sense for your project.
Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation
UIs
.
Automatic docs
The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs:
And will also be used in the API docs inside each
path operation
that needs them:
Editor support
In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a
dict
instead of a Pydantic model):
You also get error checks for incorrect type operations:
This is not by chance, the whole framework was built around that design.
And it was thoroughly tested at the design phase, before any implementation, to ensure it would work with all the editors.
There were even some changes to Pydantic itself to support this.
The previous screenshots were taken with
Visual Studio Code
.
But you would get the same editor support with
PyCharm
and most of the other Python editors:
Tip
If you use
PyCharm
as your editor, you can use the
Pydantic PyCharm Plugin
.
It improves editor support for Pydantic models, with:
auto-completion
type checks
refactoring
searching
inspections
Use the model
Inside of the function, you can access all the attributes of the model object directly:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
item_dict
=
item
.
dict
()
if
item
.
tax
is
not
None
:
price_with_tax
=
item
.
price
+
item
.
tax
item_dict
.
update
({
"price_with_tax"
:
price_with_tax
})
return
item_dict
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
item_dict
=
item
.
dict
()
if
item
.
tax
is
not
None
:
price_with_tax
=
item
.
price
+
item
.
tax
item_dict
.
update
({
"price_with_tax"
:
price_with_tax
})
return
item_dict
Request body + path parameters
You can declare path parameters and request body at the same time.
FastAPI
will recognize that the function parameters that match path parameters should be
taken from the path
, and that function parameters that are declared to be Pydantic models should be
taken from the request body
.
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_id"
:
item_id
,
**
item
.
dict
()}
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_id"
:
item_id
,
**
item
.
dict
()}
Request body + path + query parameters
You can also declare
body
,
path
and
query
parameters, all at the same time.
FastAPI
will recognize each of them and take the data from the correct place.
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
q
:
str
|
None
=
None
):
result
=
{
"item_id"
:
item_id
,
**
item
.
dict
()}
if
q
:
result
.
update
({
"q"
:
q
})
return
result
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
q
:
Union
[
str
,
None
]
=
None
):
result
=
{
"item_id"
:
item_id
,
**
item
.
dict
()}
if
q
:
result
.
update
({
"q"
:
q
})
return
result
The function parameters will be recognized as follows:
If the parameter is also declared in the
path
, it will be used as a path parameter.
If the parameter is of a
singular type
(like
int
,
float
,
str
,
bool
, etc) it will be interpreted as a
query
parameter.
If the parameter is declared to be of the type of a
Pydantic model
, it will be interpreted as a request
body
.
Note
FastAPI will know that the value of
q
is not required because of the default value
= None
.
The
str | None
(Python 3.10+) or
Union
in
Union[str, None]
(Python 3.8+) is not used by FastAPI to determine that the value is not required, it will know it's not required because it has a default value of
= None
.
But adding the type annotations will allow your editor to give you better support and detect errors.
Without Pydantic
If you don't want to use Pydantic models, you can also use
Body
parameters. See the docs for
Body - Multiple Parameters: Singular values in body
.

## 116_TUTORIAL_COOKIE_PARAM_MODELS
Cookie Parameter Models¶
---

Cookie Parameter Models
If you have a group of
cookies
that are related, you can create a
Pydantic model
to declare them. 🍪
This would allow you to
re-use the model
in
multiple places
and also to declare validations and metadata for all the parameters at once. 😎
Note
This is supported since FastAPI version
0.115.0
. 🤓
Tip
This same technique applies to
Query
,
Cookie
, and
Header
. 😎
Cookies with a Pydantic Model
Declare the
cookie
parameters that you need in a
Pydantic model
, and then declare the parameter as
Cookie
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
str
|
None
=
None
googall_tracker
:
str
|
None
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
str
|
None
=
None
googall_tracker
:
str
|
None
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Cookies
=
Cookie
()):
return
cookies
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Cookies
=
Cookie
()):
return
cookies
FastAPI
will
extract
the data for
each field
from the
cookies
received in the request and give you the Pydantic model you defined.
Check the Docs
You can see the defined cookies in the docs UI at
/docs
:
Info
Have in mind that, as
browsers handle cookies
in special ways and behind the scenes, they
don't
easily allow
JavaScript
to touch them.
If you go to the
API docs UI
at
/docs
you will be able to see the
documentation
for cookies for your
path operations
.
But even if you
fill the data
and click "Execute", because the docs UI works with
JavaScript
, the cookies won't be sent, and you will see an
error
message as if you didn't write any values.
Forbid Extra Cookies
In some special use cases (probably not very common), you might want to
restrict
the cookies that you want to receive.
Your API now has the power to control its own
cookie consent
. 🤪🍪
You can use Pydantic's model configuration to
forbid
any
extra
fields:
Python 3.9+
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
🤓 Other versions and variants
Python 3.10+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
session_id
:
str
fatebook_tracker
:
str
|
None
=
None
googall_tracker
:
str
|
None
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
session_id
:
str
fatebook_tracker
:
str
|
None
=
None
googall_tracker
:
str
|
None
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Cookies
=
Cookie
()):
return
cookies
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Cookies
=
Cookie
()):
return
cookies
If a client tries to send some
extra cookies
, they will receive an
error
response.
Poor cookie banners with all their effort to get your consent for the
API to reject it
. 🍪
For example, if the client tries to send a
santa_tracker
cookie with a value of
good-list-please
, the client will receive an
error
response telling them that the
santa_tracker
cookie is not allowed
:
{
"detail"
:
[
{
"type"
:
"extra_forbidden"
,
"loc"
:
[
"cookie"
,
"santa_tracker"
],
"msg"
:
"Extra inputs are not permitted"
,
"input"
:
"good-list-please"
,
}
]
}
Summary
You can use
Pydantic models
to declare
cookies
in
FastAPI
. 😎

## 117_TUTORIAL_COOKIE_PARAMS
Cookie Parameters¶
---

Cookie Parameters
You can define Cookie parameters the same way you define
Query
and
Path
parameters.
Import
Cookie
First import
Cookie
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
str
|
None
=
Cookie
(
default
=
None
)):
return
{
"ads_id"
:
ads_id
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
)):
return
{
"ads_id"
:
ads_id
}
Declare
Cookie
parameters
Then declare the cookie parameters using the same structure as with
Path
and
Query
.
You can define the default value as well as all the extra validation or annotation parameters:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
str
|
None
=
Cookie
(
default
=
None
)):
return
{
"ads_id"
:
ads_id
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
)):
return
{
"ads_id"
:
ads_id
}
Technical Details
Cookie
is a "sister" class of
Path
and
Query
. It also inherits from the same common
Param
class.
But remember that when you import
Query
,
Path
,
Cookie
and others from
fastapi
, those are actually functions that return special classes.
Info
To declare cookies, you need to use
Cookie
, because otherwise the parameters would be interpreted as query parameters.
Recap
Declare cookies with
Cookie
, using the same common pattern as
Query
and
Path
.

## 118_TUTORIAL_CORS
CORS (Cross-Origin Resource Sharing)¶
---

CORS (Cross-Origin Resource Sharing)
CORS or "Cross-Origin Resource Sharing"
refers to the situations when a frontend running in a browser has JavaScript code that communicates with a backend, and the backend is in a different "origin" than the frontend.
Origin
An origin is the combination of protocol (
http
,
https
), domain (
myapp.com
,
localhost
,
localhost.tiangolo.com
), and port (
80
,
443
,
8080
).
So, all these are different origins:
http://localhost
https://localhost
http://localhost:8080
Even if they are all in
localhost
, they use different protocols or ports, so, they are different "origins".
Steps
So, let's say you have a frontend running in your browser at
http://localhost:8080
, and its JavaScript is trying to communicate with a backend running at
http://localhost
(because we don't specify a port, the browser will assume the default port
80
).
Then, the browser will send an HTTP
OPTIONS
request to the
:80
-backend, and if the backend sends the appropriate headers authorizing the communication from this different origin (
http://localhost:8080
) then the
:8080
-browser will let the JavaScript in the frontend send its request to the
:80
-backend.
To achieve this, the
:80
-backend must have a list of "allowed origins".
In this case, the list would have to include
http://localhost:8080
for the
:8080
-frontend to work correctly.
Wildcards
It's also possible to declare the list as
"*"
(a "wildcard") to say that all are allowed.
But that will only allow certain types of communication, excluding everything that involves credentials: Cookies, Authorization headers like those used with Bearer Tokens, etc.
So, for everything to work correctly, it's better to specify explicitly the allowed origins.
Use
CORSMiddleware
You can configure it in your
FastAPI
application using the
CORSMiddleware
.
Import
CORSMiddleware
.
Create a list of allowed origins (as strings).
Add it as a "middleware" to your
FastAPI
application.
You can also specify whether your backend allows:
Credentials (Authorization headers, Cookies, etc).
Specific HTTP methods (
POST
,
PUT
) or all of them with the wildcard
"*"
.
Specific HTTP headers or all of them with the wildcard
"*"
.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.middleware.cors
import
CORSMiddleware
app
=
FastAPI
()
origins
=
[
"http://localhost.tiangolo.com"
,
"https://localhost.tiangolo.com"
,
"http://localhost"
,
"http://localhost:8080"
,
]
app
.
add_middleware
(
CORSMiddleware
,
allow_origins
=
origins
,
allow_credentials
=
True
,
allow_methods
=
[
"*"
],
allow_headers
=
[
"*"
],
)
@app
.
get
(
"/"
)
async
def
main
():
return
{
"message"
:
"Hello World"
}
The default parameters used by the
CORSMiddleware
implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context.
The following arguments are supported:
allow_origins
- A list of origins that should be permitted to make cross-origin requests. E.g.
['https://example.org', 'https://www.example.org']
. You can use
['*']
to allow any origin.
allow_origin_regex
- A regex string to match against origins that should be permitted to make cross-origin requests. e.g.
'https://.*\.example\.org'
.
allow_methods
- A list of HTTP methods that should be allowed for cross-origin requests. Defaults to
['GET']
. You can use
['*']
to allow all standard methods.
allow_headers
- A list of HTTP request headers that should be supported for cross-origin requests. Defaults to
[]
. You can use
['*']
to allow all headers. The
Accept
,
Accept-Language
,
Content-Language
and
Content-Type
headers are always allowed for
simple CORS requests
.
allow_credentials
- Indicate that cookies should be supported for cross-origin requests. Defaults to
False
.
None of
allow_origins
,
allow_methods
and
allow_headers
can be set to
['*']
if
allow_credentials
is set to
True
. All of them must be
explicitly specified
.
expose_headers
- Indicate any response headers that should be made accessible to the browser. Defaults to
[]
.
max_age
- Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to
600
.
The middleware responds to two particular types of HTTP request...
CORS preflight requests
These are any
OPTIONS
request with
Origin
and
Access-Control-Request-Method
headers.
In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a
200
or
400
response for informational purposes.
Simple requests
Any request with an
Origin
header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.
More info
For more info about
CORS
, check the
Mozilla CORS documentation
.
Technical Details
You could also use
from starlette.middleware.cors import CORSMiddleware
.
FastAPI
provides several middlewares in
fastapi.middleware
just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette.

## 119_TUTORIAL_DEBUGGING
Debugging¶
---

Debugging
You can connect the debugger in your editor, for example with Visual Studio Code or PyCharm.
Call
uvicorn
In your FastAPI application, import and run
uvicorn
directly:
Python 3.8+
import
uvicorn
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
root
():
a
=
"a"
b
=
"b"
+
a
return
{
"hello world"
:
b
}
if
__name__
==
"__main__"
:
uvicorn
.
run
(
app
,
host
=
"0.0.0.0"
,
port
=
8000
)
About
__name__ == "__main__"
The main purpose of the
__name__ == "__main__"
is to have some code that is executed when your file is called with:
fast →
python myapp.py
restart ↻
but is not called when another file imports it, like in:
from
myapp
import
app
More details
Let's say your file is named
myapp.py
.
If you run it with:
fast →
python myapp.py
restart ↻
then the internal variable
__name__
in your file, created automatically by Python, will have as value the string
"__main__"
.
So, the section:
uvicorn
.
run
(
app
,
host
=
"0.0.0.0"
,
port
=
8000
)
will run.
This won't happen if you import that module (file).
So, if you have another file
importer.py
with:
from
myapp
import
app
## Some more code
in that case, the automatically created variable inside of
myapp.py
will not have the variable
__name__
with a value of
"__main__"
.
So, the line:
uvicorn
.
run
(
app
,
host
=
"0.0.0.0"
,
port
=
8000
)
will not be executed.
Info
For more information, check
the official Python docs
.
Run your code with your debugger
Because you are running the Uvicorn server directly from your code, you can call your Python program (your FastAPI application) directly from the debugger.
For example, in Visual Studio Code, you can:
Go to the "Debug" panel.
"Add configuration...".
Select "Python"
Run the debugger with the option "
Python: Current File (Integrated Terminal)
".
It will then start the server with your
FastAPI
code, stop at your breakpoints, etc.
Here's how it might look:
If you use Pycharm, you can:
Open the "Run" menu.
Select the option "Debug...".
Then a context menu shows up.
Select the file to debug (in this case,
main.py
).
It will then start the server with your
FastAPI
code, stop at your breakpoints, etc.
Here's how it might look:

## 120_TUTORIAL_DEPENDENCIES
Dependencies¶
---

Dependencies
FastAPI
has a very powerful but intuitive
Dependency Injection
system.
It is designed to be very simple to use, and to make it very easy for any developer to integrate other components with
FastAPI
.
What is "Dependency Injection"
"Dependency Injection"
means, in programming, that there is a way for your code (in this case, your
path operation functions
) to declare things that it requires to work and use: "dependencies".
And then, that system (in this case
FastAPI
) will take care of doing whatever is needed to provide your code with those needed dependencies ("inject" the dependencies).
This is very useful when you need to:
Have shared logic (the same code logic again and again).
Share database connections.
Enforce security, authentication, role requirements, etc.
And many other things...
All these, while minimizing code repetition.
First Steps
Let's see a very simple example. It will be so simple that it is not very useful, for now.
But this way we can focus on how the
Dependency Injection
system works.
Create a dependency, or "dependable"
Let's first focus on the dependency.
It is just a function that can take all the same parameters that a
path operation function
can take:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
That's it.
2 lines
.
And it has the same shape and structure that all your
path operation functions
have.
You can think of it as a
path operation function
without the "decorator" (without the
@app.get("/some-path")
).
And it can return anything you want.
In this case, this dependency expects:
An optional query parameter
q
that is a
str
.
An optional query parameter
skip
that is an
int
, and by default is
0
.
An optional query parameter
limit
that is an
int
, and by default is
100
.
And then it just returns a
dict
containing those values.
Info
FastAPI added support for
Annotated
(and started recommending it) in version 0.95.0.
If you have an older version, you would get errors when trying to use
Annotated
.
Make sure you
Upgrade the FastAPI version
to at least 0.95.1 before using
Annotated
.
Import
Depends
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Declare the dependency, in the "dependant"
The same way you use
Body
,
Query
, etc. with your
path operation function
parameters, use
Depends
with a new parameter:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Although you use
Depends
in the parameters of your function the same way you use
Body
,
Query
, etc,
Depends
works a bit differently.
You only give
Depends
a single parameter.
This parameter must be something like a function.
You
don't call it
directly (don't add the parenthesis at the end), you just pass it as a parameter to
Depends()
.
And that function takes parameters in the same way that
path operation functions
do.
Tip
You'll see what other "things", apart from functions, can be used as dependencies in the next chapter.
Whenever a new request arrives,
FastAPI
will take care of:
Calling your dependency ("dependable") function with the correct parameters.
Get the result from your function.
Assign that result to the parameter in your
path operation function
.
This way you write shared code once and
FastAPI
takes care of calling it for your
path operations
.
Check
Notice that you don't have to create a special class and pass it somewhere to
FastAPI
to "register" it or anything similar.
You just pass it to
Depends
and
FastAPI
knows how to do the rest.
Share
Annotated
dependencies
In the examples above, you see that there's a tiny bit of
code duplication
.
When you need to use the
common_parameters()
dependency, you have to write the whole parameter with the type annotation and
Depends()
:
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]
But because we are using
Annotated
, we can store that
Annotated
value in a variable and use it in multiple places:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
CommonsDep
=
Annotated
[
dict
,
Depends
(
common_parameters
)]
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonsDep
):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
CommonsDep
):
return
commons
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
CommonsDep
=
Annotated
[
dict
,
Depends
(
common_parameters
)]
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonsDep
):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
CommonsDep
):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
CommonsDep
=
Annotated
[
dict
,
Depends
(
common_parameters
)]
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonsDep
):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
CommonsDep
):
return
commons
Tip
This is just standard Python, it's called a "type alias", it's actually not specific to
FastAPI
.
But because
FastAPI
is based on the Python standards, including
Annotated
, you can use this trick in your code. 😎
The dependencies will keep working as expected, and the
best part
is that the
type information will be preserved
, which means that your editor will be able to keep providing you with
autocompletion
,
inline errors
, etc. The same for other tools like
mypy
.
This will be especially useful when you use it in a
large code base
where you use
the same dependencies
over and over again in
many
path operations
.
To
async
or not to
async
As dependencies will also be called by
FastAPI
(the same as your
path operation functions
), the same rules apply while defining your functions.
You can use
async def
or normal
def
.
And you can declare dependencies with
async def
inside of normal
def
path operation functions
, or
def
dependencies inside of
async def
path operation functions
, etc.
It doesn't matter.
FastAPI
will know what to do.
Note
If you don't know, check the
Async:
"In a hurry?"
section about
async
and
await
in the docs.
Integrated with OpenAPI
All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema.
So, the interactive docs will have all the information from these dependencies too:
Simple usage
If you look at it,
path operation functions
are declared to be used whenever a
path
and
operation
matches, and then
FastAPI
takes care of calling the function with the correct parameters, extracting the data from the request.
Actually, all (or most) of the web frameworks work in this same way.
You never call those functions directly. They are called by your framework (in this case,
FastAPI
).
With the Dependency Injection system, you can also tell
FastAPI
that your
path operation function
also "depends" on something else that should be executed before your
path operation function
, and
FastAPI
will take care of executing it and "injecting" the results.
Other common terms for this same idea of "dependency injection" are:
resources
providers
services
injectables
components
FastAPI
plug-ins
Integrations and "plug-ins" can be built using the
Dependency Injection
system. But in fact, there is actually
no need to create "plug-ins"
, as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your
path operation functions
.
And dependencies can be created in a very simple and intuitive way that allows you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code,
literally
.
You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc.
FastAPI
compatibility
The simplicity of the dependency injection system makes
FastAPI
compatible with:
all the relational databases
NoSQL databases
external packages
external APIs
authentication and authorization systems
API usage monitoring systems
response data injection systems
etc.
Simple and Powerful
Although the hierarchical dependency injection system is very simple to define and use, it's still very powerful.
You can define dependencies that in turn can define dependencies themselves.
In the end, a hierarchical tree of dependencies is built, and the
Dependency Injection
system takes care of solving all these dependencies for you (and their sub-dependencies) and providing (injecting) the results at each step.
For example, let's say you have 4 API endpoints (
path operations
):
/items/public/
/items/private/
/users/{user_id}/activate
/items/pro/
then you could add different permission requirements for each of them just with dependencies and sub-dependencies:
Integrated with
OpenAPI
All these dependencies, while declaring their requirements, also add parameters, validations, etc. to your
path operations
.
FastAPI
will take care of adding it all to the OpenAPI schema, so that it is shown in the interactive documentation systems.

## 121_TUTORIAL_DEPENDENCIES_CLASSES_AS_DEPENDENCIES
Classes as Dependencies¶
---

Classes as Dependencies
Before diving deeper into the
Dependency Injection
system, let's upgrade the previous example.
A
dict
from the previous example
In the previous example, we were returning a
dict
from our dependency ("dependable"):
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
But then we get a
dict
in the parameter
commons
of the
path operation function
.
And we know that editors can't provide a lot of support (like completion) for
dict
s, because they can't know their keys and value types.
We can do better...
What makes a dependency
Up to now you have seen dependencies declared as functions.
But that's not the only way to declare dependencies (although it would probably be the more common).
The key factor is that a dependency should be a "callable".
A "
callable
" in Python is anything that Python can "call" like a function.
So, if you have an object
something
(that might
not
be a function) and you can "call" it (execute it) like:
something
()
or
something
(
some_argument
,
some_keyword_argument
=
"foo"
)
then it is a "callable".
Classes as dependencies
You might notice that to create an instance of a Python class, you use that same syntax.
For example:
class
Cat
:
def
__init__
(
self
,
name
:
str
):
self
.
name
=
name
fluffy
=
Cat
(
name
=
"Mr Fluffy"
)
In this case,
fluffy
is an instance of the class
Cat
.
And to create
fluffy
, you are "calling"
Cat
.
So, a Python class is also a
callable
.
Then, in
FastAPI
, you could use a Python class as a dependency.
What FastAPI actually checks is that it is a "callable" (function, class or anything else) and the parameters defined.
If you pass a "callable" as a dependency in
FastAPI
, it will analyze the parameters for that "callable", and process them in the same way as the parameters for a
path operation function
. Including sub-dependencies.
That also applies to callables with no parameters at all. The same as it would be for
path operation functions
with no parameters.
Then, we can change the dependency "dependable"
common_parameters
from above to the class
CommonQueryParams
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Pay attention to the
__init__
method used to create the instance of the class:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
...it has the same parameters as our previous
common_parameters
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Those parameters are what
FastAPI
will use to "solve" the dependency.
In both cases, it will have:
An optional
q
query parameter that is a
str
.
A
skip
query parameter that is an
int
, with a default of
0
.
A
limit
query parameter that is an
int
, with a default of
100
.
In both cases the data will be converted, validated, documented on the OpenAPI schema, etc.
Use it
Now you can declare your dependency using this class.
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
FastAPI
calls the
CommonQueryParams
class. This creates an "instance" of that class and the instance will be passed as the parameter
commons
to your function.
Type annotation vs
Depends
Notice how we write
CommonQueryParams
twice in the above code:
Python 3.8+
Python 3.8+ non-Annotated
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]
Tip
Prefer to use the
Annotated
version if possible.
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)
The last
CommonQueryParams
, in:
...
Depends
(
CommonQueryParams
)
...is what
FastAPI
will actually use to know what is the dependency.
It is from this one that FastAPI will extract the declared parameters and that is what FastAPI will actually call.
In this case, the first
CommonQueryParams
, in:
Python 3.8+
Python 3.8+ non-Annotated
commons
:
Annotated
[
CommonQueryParams
,
...
Tip
Prefer to use the
Annotated
version if possible.
commons
:
CommonQueryParams
...
...doesn't have any special meaning for
FastAPI
. FastAPI won't use it for data conversion, validation, etc. (as it is using the
Depends(CommonQueryParams)
for that).
You could actually write just:
Python 3.8+
Python 3.8+ non-Annotated
commons
:
Annotated
[
Any
,
Depends
(
CommonQueryParams
)]
Tip
Prefer to use the
Annotated
version if possible.
commons
=
Depends
(
CommonQueryParams
)
...as in:
Python 3.10+
from
typing
import
Annotated
,
Any
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
Any
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Any
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
Any
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
from
typing
import
Any
,
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
Any
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
But declaring the type is encouraged as that way your editor will know what will be passed as the parameter
commons
, and then it can help you with code completion, type checks, etc:
Shortcut
But you see that we are having some code repetition here, writing
CommonQueryParams
twice:
Python 3.8+
Python 3.8+ non-Annotated
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]
Tip
Prefer to use the
Annotated
version if possible.
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)
FastAPI
provides a shortcut for these cases, in where the dependency is
specifically
a class that
FastAPI
will "call" to create an instance of the class itself.
For those specific cases, you can do the following:
Instead of writing:
Python 3.8+
Python 3.8+ non-Annotated
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]
Tip
Prefer to use the
Annotated
version if possible.
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)
...you write:
Python 3.8+
Python 3.8 non-Annotated
commons
:
Annotated
[
CommonQueryParams
,
Depends
()]
Tip
Prefer to use the
Annotated
version if possible.
commons
:
CommonQueryParams
=
Depends
()
You declare the dependency as the type of the parameter, and you use
Depends()
without any parameter, instead of having to write the full class
again
inside of
Depends(CommonQueryParams)
.
The same example would then look like:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
()]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
()]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
()]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
()):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
()):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
...and
FastAPI
will know what to do.
Tip
If that seems more confusing than helpful, disregard it, you don't
need
it.
It is just a shortcut. Because
FastAPI
cares about helping you minimize code repetition.

## 122_TUTORIAL_DEPENDENCIES_DEPENDENCIES_IN_PATH_OPERATION_DECORATORS
Dependencies in path operation decorators¶
---

Dependencies in path operation decorators
In some cases you don't really need the return value of a dependency inside your
path operation function
.
Or the dependency doesn't return a value.
But you still need it to be executed/solved.
For those cases, instead of declaring a
path operation function
parameter with
Depends
, you can add a
list
of
dependencies
to the
path operation decorator
.
Add
dependencies
to the
path operation decorator
The
path operation decorator
receives an optional argument
dependencies
.
It should be a
list
of
Depends()
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
str
=
Header
()):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
These dependencies will be executed/solved the same way as normal dependencies. But their value (if they return any) won't be passed to your
path operation function
.
Tip
Some editors check for unused function parameters, and show them as errors.
Using these
dependencies
in the
path operation decorator
you can make sure they are executed while avoiding editor/tooling errors.
It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.
Info
In this example we use invented custom headers
X-Key
and
X-Token
.
But in real cases, when implementing security, you would get more benefits from using the integrated
Security utilities (the next chapter)
.
Dependencies errors and return values
You can use the same dependency
functions
you use normally.
Dependency requirements
They can declare request requirements (like headers) or other sub-dependencies:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
str
=
Header
()):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Raise exceptions
These dependencies can
raise
exceptions, the same as normal dependencies:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
str
=
Header
()):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Return values
And they can return values or not, the values won't be used.
So, you can reuse a normal dependency (that returns a value) you already use somewhere else, and even though the value won't be used, the dependency will be executed:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
str
=
Header
()):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Dependencies for a group of
path operations
Later, when reading about how to structure bigger applications (
Bigger Applications - Multiple Files
), possibly with multiple files, you will learn how to declare a single
dependencies
parameter for a group of
path operations
.
Global Dependencies
Next we will see how to add dependencies to the whole
FastAPI
application, so that they apply to each
path operation
.

## 123_TUTORIAL_DEPENDENCIES_DEPENDENCIES_WITH_YIELD
Dependencies with yield¶
---

Dependencies with yield
FastAPI supports dependencies that do some
extra steps after finishing
.
To do this, use
yield
instead of
return
, and write the extra steps (code) after.
Tip
Make sure to use
yield
one single time per dependency.
Technical Details
Any function that is valid to use with:
@contextlib.contextmanager
or
@contextlib.asynccontextmanager
would be valid to use as a
FastAPI
dependency.
In fact, FastAPI uses those two decorators internally.
A database dependency with
yield
For example, you could use this to create a database session and close it after finishing.
Only the code prior to and including the
yield
statement is executed before creating a response:
Python 3.8+
async
def
get_db
():
db
=
DBSession
()
try
:
yield
db
finally
:
db
.
close
()
The yielded value is what is injected into
path operations
and other dependencies:
Python 3.8+
async
def
get_db
():
db
=
DBSession
()
try
:
yield
db
finally
:
db
.
close
()
The code following the
yield
statement is executed after creating the response but before sending it:
Python 3.8+
async
def
get_db
():
db
=
DBSession
()
try
:
yield
db
finally
:
db
.
close
()
Tip
You can use
async
or regular functions.
FastAPI
will do the right thing with each, the same as with normal dependencies.
A dependency with
yield
and
try
If you use a
try
block in a dependency with
yield
, you'll receive any exception that was thrown when using the dependency.
For example, if some code at some point in the middle, in another dependency or in a
path operation
, made a database transaction "rollback" or create any other error, you will receive the exception in your dependency.
So, you can look for that specific exception inside the dependency with
except SomeException
.
In the same way, you can use
finally
to make sure the exit steps are executed, no matter if there was an exception or not.
Python 3.8+
async
def
get_db
():
db
=
DBSession
()
try
:
yield
db
finally
:
db
.
close
()
Sub-dependencies with
yield
You can have sub-dependencies and "trees" of sub-dependencies of any size and shape, and any or all of them can use
yield
.
FastAPI
will make sure that the "exit code" in each dependency with
yield
is run in the correct order.
For example,
dependency_c
can have a dependency on
dependency_b
, and
dependency_b
on
dependency_a
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
:
Annotated
[
DepA
,
Depends
(
dependency_a
)]):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
:
Annotated
[
DepB
,
Depends
(
dependency_b
)]):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
from
typing_extensions
import
Annotated
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
:
Annotated
[
DepA
,
Depends
(
dependency_a
)]):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
:
Annotated
[
DepB
,
Depends
(
dependency_b
)]):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
=
Depends
(
dependency_a
)):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
=
Depends
(
dependency_b
)):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
And all of them can use
yield
.
In this case
dependency_c
, to execute its exit code, needs the value from
dependency_b
(here named
dep_b
) to still be available.
And, in turn,
dependency_b
needs the value from
dependency_a
(here named
dep_a
) to be available for its exit code.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
:
Annotated
[
DepA
,
Depends
(
dependency_a
)]):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
:
Annotated
[
DepB
,
Depends
(
dependency_b
)]):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
from
typing_extensions
import
Annotated
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
:
Annotated
[
DepA
,
Depends
(
dependency_a
)]):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
:
Annotated
[
DepB
,
Depends
(
dependency_b
)]):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
=
Depends
(
dependency_a
)):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
=
Depends
(
dependency_b
)):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
The same way, you could have some dependencies with
yield
and some other dependencies with
return
, and have some of those depend on some of the others.
And you could have a single dependency that requires several other dependencies with
yield
, etc.
You can have any combinations of dependencies that you want.
FastAPI
will make sure everything is run in the correct order.
Technical Details
This works thanks to Python's
Context Managers
.
FastAPI
uses them internally to achieve this.
Dependencies with
yield
and
HTTPException
You saw that you can use dependencies with
yield
and have
try
blocks that catch exceptions.
The same way, you could raise an
HTTPException
or similar in the exit code, after the
yield
.
Tip
This is a somewhat advanced technique, and in most of the cases you won't really need it, as you can raise exceptions (including
HTTPException
) from inside of the rest of your application code, for example, in the
path operation function
.
But it's there for you if you need it. 🤓
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
data
=
{
"plumbus"
:
{
"description"
:
"Freshly pickled plumbus"
,
"owner"
:
"Morty"
},
"portal-gun"
:
{
"description"
:
"Gun to create portals"
,
"owner"
:
"Rick"
},
}
class
OwnerError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
OwnerError
as
e
:
raise
HTTPException
(
status_code
=
400
,
detail
=
f
"Owner error:
{
e
}
"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
not
in
data
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
item
=
data
[
item_id
]
if
item
[
"owner"
]
!=
username
:
raise
OwnerError
(
username
)
return
item
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
data
=
{
"plumbus"
:
{
"description"
:
"Freshly pickled plumbus"
,
"owner"
:
"Morty"
},
"portal-gun"
:
{
"description"
:
"Gun to create portals"
,
"owner"
:
"Rick"
},
}
class
OwnerError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
OwnerError
as
e
:
raise
HTTPException
(
status_code
=
400
,
detail
=
f
"Owner error:
{
e
}
"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
not
in
data
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
item
=
data
[
item_id
]
if
item
[
"owner"
]
!=
username
:
raise
OwnerError
(
username
)
return
item
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
data
=
{
"plumbus"
:
{
"description"
:
"Freshly pickled plumbus"
,
"owner"
:
"Morty"
},
"portal-gun"
:
{
"description"
:
"Gun to create portals"
,
"owner"
:
"Rick"
},
}
class
OwnerError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
OwnerError
as
e
:
raise
HTTPException
(
status_code
=
400
,
detail
=
f
"Owner error:
{
e
}
"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
str
=
Depends
(
get_username
)):
if
item_id
not
in
data
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
item
=
data
[
item_id
]
if
item
[
"owner"
]
!=
username
:
raise
OwnerError
(
username
)
return
item
An alternative you could use to catch exceptions (and possibly also raise another
HTTPException
) is to create a
Custom Exception Handler
.
Dependencies with
yield
and
except
If you catch an exception using
except
in a dependency with
yield
and you don't raise it again (or raise a new exception), FastAPI won't be able to notice there was an exception, the same way that would happen with regular Python:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"Oops, we didn't raise again, Britney 😱"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"Oops, we didn't raise again, Britney 😱"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"Oops, we didn't raise again, Britney 😱"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
str
=
Depends
(
get_username
)):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
In this case, the client will see an
HTTP 500 Internal Server Error
response as it should, given that we are not raising an
HTTPException
or similar, but the server will
not have any logs
or any other indication of what was the error. 😱
Always
raise
in Dependencies with
yield
and
except
If you catch an exception in a dependency with
yield
, unless you are raising another
HTTPException
or similar, you should re-raise the original exception.
You can re-raise the same exception using
raise
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"We don't swallow the internal error here, we raise again 😎"
)
raise
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"We don't swallow the internal error here, we raise again 😎"
)
raise
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"We don't swallow the internal error here, we raise again 😎"
)
raise
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
str
=
Depends
(
get_username
)):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
Now the client will get the same
HTTP 500 Internal Server Error
response, but the server will have our custom
InternalError
in the logs. 😎
Execution of dependencies with
yield
The sequence of execution is more or less like this diagram. Time flows from top to bottom. And each column is one of the parts interacting or executing code.
Info
Only
one response
will be sent to the client. It might be one of the error responses or it will be the response from the
path operation
.
After one of those responses is sent, no other response can be sent.
Tip
This diagram shows
HTTPException
, but you could also raise any other exception that you catch in a dependency with
yield
or with a
Custom Exception Handler
.
If you raise any exception, it will be passed to the dependencies with yield, including
HTTPException
. In most cases you will want to re-raise that same exception or a new one from the dependency with
yield
to make sure it's properly handled.
Dependencies with
yield
,
HTTPException
,
except
and Background Tasks
Warning
You most probably don't need these technical details, you can skip this section and continue below.
These details are useful mainly if you were using a version of FastAPI prior to 0.106.0 and used resources from dependencies with
yield
in background tasks.
Dependencies with
yield
and
except
, Technical Details
Before FastAPI 0.110.0, if you used a dependency with
yield
, and then you captured an exception with
except
in that dependency, and you didn't raise the exception again, the exception would be automatically raised/forwarded to any exception handlers or the internal server error handler.
This was changed in version 0.110.0 to fix unhandled memory consumption from forwarded exceptions without a handler (internal server errors), and to make it consistent with the behavior of regular Python code.
Background Tasks and Dependencies with
yield
, Technical Details
Before FastAPI 0.106.0, raising exceptions after
yield
was not possible, the exit code in dependencies with
yield
was executed
after
the response was sent, so
Exception Handlers
would have already run.
This was designed this way mainly to allow using the same objects "yielded" by dependencies inside of background tasks, because the exit code would be executed after the background tasks were finished.
Nevertheless, as this would mean waiting for the response to travel through the network while unnecessarily holding a resource in a dependency with yield (for example a database connection), this was changed in FastAPI 0.106.0.
Tip
Additionally, a background task is normally an independent set of logic that should be handled separately, with its own resources (e.g. its own database connection).
So, this way you will probably have cleaner code.
If you used to rely on this behavior, now you should create the resources for background tasks inside the background task itself, and use internally only data that doesn't depend on the resources of dependencies with
yield
.
For example, instead of using the same database session, you would create a new database session inside of the background task, and you would obtain the objects from the database using this new session. And then instead of passing the object from the database as a parameter to the background task function, you would pass the ID of that object and then obtain the object again inside the background task function.
Context Managers
What are "Context Managers"
"Context Managers" are any of those Python objects that you can use in a
with
statement.
For example,
you can use
with
to read a file
:
with
open
(
"./somefile.txt"
)
as
f
:
contents
=
f
.
read
()
print
(
contents
)
Underneath, the
open("./somefile.txt")
creates an object that is called a "Context Manager".
When the
with
block finishes, it makes sure to close the file, even if there were exceptions.
When you create a dependency with
yield
,
FastAPI
will internally create a context manager for it, and combine it with some other related tools.
Using context managers in dependencies with
yield
Warning
This is, more or less, an "advanced" idea.
If you are just starting with
FastAPI
you might want to skip it for now.
In Python, you can create Context Managers by
creating a class with two methods:
__enter__()
and
__exit__()
.
You can also use them inside of
FastAPI
dependencies with
yield
by using
with
or
async with
statements inside of the dependency function:
Python 3.8+
class
MySuperContextManager
:
def
__init__
(
self
):
self
.
db
=
DBSession
()
def
__enter__
(
self
):
return
self
.
db
def
__exit__
(
self
,
exc_type
,
exc_value
,
traceback
):
self
.
db
.
close
()
async
def
get_db
():
with
MySuperContextManager
()
as
db
:
yield
db
Tip
Another way to create a context manager is with:
@contextlib.contextmanager
or
@contextlib.asynccontextmanager
using them to decorate a function with a single
yield
.
That's what
FastAPI
uses internally for dependencies with
yield
.
But you don't have to use the decorators for FastAPI dependencies (and you shouldn't).
FastAPI will do it for you internally.

## 124_TUTORIAL_DEPENDENCIES_GLOBAL_DEPENDENCIES
Global Dependencies¶
---

Global Dependencies
For some types of applications you might want to add dependencies to the whole application.
Similar to the way you can
add
dependencies
to the
path operation decorators
, you can add them to the
FastAPI
application.
In that case, they will be applied to all the
path operations
in the application:
Python 3.9+
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
app
=
FastAPI
(
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item"
:
"Portal Gun"
},
{
"item"
:
"Plumbus"
}]
@app
.
get
(
"/users/"
)
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
app
=
FastAPI
(
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item"
:
"Portal Gun"
},
{
"item"
:
"Plumbus"
}]
@app
.
get
(
"/users/"
)
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
async
def
verify_token
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
str
=
Header
()):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
app
=
FastAPI
(
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item"
:
"Portal Gun"
},
{
"item"
:
"Plumbus"
}]
@app
.
get
(
"/users/"
)
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
And all the ideas in the section about
adding
dependencies
to the
path operation decorators
still apply, but in this case, to all of the
path operations
in the app.
Dependencies for groups of
path operations
Later, when reading about how to structure bigger applications (
Bigger Applications - Multiple Files
), possibly with multiple files, you will learn how to declare a single
dependencies
parameter for a group of
path operations
.

## 125_TUTORIAL_DEPENDENCIES_SUB_DEPENDENCIES
Sub-dependencies¶
---

Sub-dependencies
You can create dependencies that have
sub-dependencies
.
They can be as
deep
as you need them to be.
FastAPI
will take care of solving them.
First dependency "dependable"
You could create a first dependency ("dependable") like:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
str
|
None
=
Cookie
(
default
=
None
)
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
),
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
It declares an optional query parameter
q
as a
str
, and then it just returns it.
This is quite simple (not very useful), but will help us focus on how the sub-dependencies work.
Second dependency, "dependable" and "dependant"
Then you can create another dependency function (a "dependable") that at the same time declares a dependency of its own (so it is a "dependant" too):
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
str
|
None
=
Cookie
(
default
=
None
)
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
),
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
Let's focus on the parameters declared:
Even though this function is a dependency ("dependable") itself, it also declares another dependency (it "depends" on something else).
It depends on the
query_extractor
, and assigns the value returned by it to the parameter
q
.
It also declares an optional
last_query
cookie, as a
str
.
If the user didn't provide any query
q
, we use the last query used, which we saved to a cookie before.
Use the dependency
Then we can use the dependency with:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
str
|
None
=
Cookie
(
default
=
None
)
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
),
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
Info
Notice that we are only declaring one dependency in the
path operation function
, the
query_or_cookie_extractor
.
But
FastAPI
will know that it has to solve
query_extractor
first, to pass the results of that to
query_or_cookie_extractor
while calling it.
Using the same dependency multiple times
If one of your dependencies is declared multiple times for the same
path operation
, for example, multiple dependencies have a common sub-dependency,
FastAPI
will know to call that sub-dependency only once per request.
And it will save the returned value in a
"cache"
and pass it to all the "dependants" that need it in that specific request, instead of calling the dependency multiple times for the same request.
In an advanced scenario where you know you need the dependency to be called at every step (possibly multiple times) in the same request instead of using the "cached" value, you can set the parameter
use_cache=False
when using
Depends
:
Python 3.8+
Python 3.8+ non-Annotated
async
def
needy_dependency
(
fresh_value
:
Annotated
[
str
,
Depends
(
get_value
,
use_cache
=
False
)]):
return
{
"fresh_value"
:
fresh_value
}
Tip
Prefer to use the
Annotated
version if possible.
async
def
needy_dependency
(
fresh_value
:
str
=
Depends
(
get_value
,
use_cache
=
False
)):
return
{
"fresh_value"
:
fresh_value
}
Recap
Apart from all the fancy words used here, the
Dependency Injection
system is quite simple.
Just functions that look the same as the
path operation functions
.
But still, it is very powerful, and allows you to declare arbitrarily deeply nested dependency "graphs" (trees).
Tip
All this might not seem as useful with these simple examples.
But you will see how useful it is in the chapters about
security
.
And you will also see the amounts of code it will save you.

## 126_TUTORIAL_ENCODER
JSON Compatible Encoder¶
---

JSON Compatible Encoder
There are some cases where you might need to convert a data type (like a Pydantic model) to something compatible with JSON (like a
dict
,
list
, etc).
For example, if you need to store it in a database.
For that,
FastAPI
provides a
jsonable_encoder()
function.
Using the
jsonable_encoder
Let's imagine that you have a database
fake_db
that only receives JSON compatible data.
For example, it doesn't receive
datetime
objects, as those are not compatible with JSON.
So, a
datetime
object would have to be converted to a
str
containing the data in
ISO format
.
The same way, this database wouldn't receive a Pydantic model (an object with attributes), only a
dict
.
You can use
jsonable_encoder
for that.
It receives an object, like a Pydantic model, and returns a JSON compatible version:
Python 3.10+
from
datetime
import
datetime
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
fake_db
=
{}
class
Item
(
BaseModel
):
title
:
str
timestamp
:
datetime
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{id}
"
)
def
update_item
(
id
:
str
,
item
:
Item
):
json_compatible_item_data
=
jsonable_encoder
(
item
)
fake_db
[
id
]
=
json_compatible_item_data
🤓 Other versions and variants
Python 3.8+
from
datetime
import
datetime
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
fake_db
=
{}
class
Item
(
BaseModel
):
title
:
str
timestamp
:
datetime
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{id}
"
)
def
update_item
(
id
:
str
,
item
:
Item
):
json_compatible_item_data
=
jsonable_encoder
(
item
)
fake_db
[
id
]
=
json_compatible_item_data
In this example, it would convert the Pydantic model to a
dict
, and the
datetime
to a
str
.
The result of calling it is something that can be encoded with the Python standard
json.dumps()
.
It doesn't return a large
str
containing the data in JSON format (as a string). It returns a Python standard data structure (e.g. a
dict
) with values and sub-values that are all compatible with JSON.
Note
jsonable_encoder
is actually used by
FastAPI
internally to convert data. But it is useful in many other scenarios.

## 127_TUTORIAL_EXTRA_DATA_TYPES
Extra Data Types¶
---

Extra Data Types
Up to now, you have been using common data types, like:
int
float
str
bool
But you can also use more complex data types.
And you will still have the same features as seen up to now:
Great editor support.
Data conversion from incoming requests.
Data conversion for response data.
Data validation.
Automatic annotation and documentation.
Other data types
Here are some of the additional data types you can use:
UUID
:
A standard "Universally Unique Identifier", common as an ID in many databases and systems.
In requests and responses will be represented as a
str
.
datetime.datetime
:
A Python
datetime.datetime
.
In requests and responses will be represented as a
str
in ISO 8601 format, like:
2008-09-15T15:53:00+05:00
.
datetime.date
:
Python
datetime.date
.
In requests and responses will be represented as a
str
in ISO 8601 format, like:
2008-09-15
.
datetime.time
:
A Python
datetime.time
.
In requests and responses will be represented as a
str
in ISO 8601 format, like:
14:23:55.003
.
datetime.timedelta
:
A Python
datetime.timedelta
.
In requests and responses will be represented as a
float
of total seconds.
Pydantic also allows representing it as a "ISO 8601 time diff encoding",
see the docs for more info
.
frozenset
:
In requests and responses, treated the same as a
set
:
In requests, a list will be read, eliminating duplicates and converting it to a
set
.
In responses, the
set
will be converted to a
list
.
The generated schema will specify that the
set
values are unique (using JSON Schema's
uniqueItems
).
bytes
:
Standard Python
bytes
.
In requests and responses will be treated as
str
.
The generated schema will specify that it's a
str
with
binary
"format".
Decimal
:
Standard Python
Decimal
.
In requests and responses, handled the same as a
float
.
You can check all the valid Pydantic data types here:
Pydantic data types
.
Example
Here's an example
path operation
with parameters using some of the above types.
Python 3.10+
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Annotated
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
time
|
None
,
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Annotated
,
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
Union
[
time
,
None
],
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
Union
[
time
,
None
],
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
time
,
timedelta
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
datetime
=
Body
(),
end_datetime
:
datetime
=
Body
(),
process_after
:
timedelta
=
Body
(),
repeat_at
:
time
|
None
=
Body
(
default
=
None
),
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
datetime
=
Body
(),
end_datetime
:
datetime
=
Body
(),
process_after
:
timedelta
=
Body
(),
repeat_at
:
Union
[
time
,
None
]
=
Body
(
default
=
None
),
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
Note that the parameters inside the function have their natural data type, and you can, for example, perform normal date manipulations, like:
Python 3.10+
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Annotated
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
time
|
None
,
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Annotated
,
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
Union
[
time
,
None
],
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
Union
[
time
,
None
],
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
time
,
timedelta
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
datetime
=
Body
(),
end_datetime
:
datetime
=
Body
(),
process_after
:
timedelta
=
Body
(),
repeat_at
:
time
|
None
=
Body
(
default
=
None
),
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
datetime
=
Body
(),
end_datetime
:
datetime
=
Body
(),
process_after
:
timedelta
=
Body
(),
repeat_at
:
Union
[
time
,
None
]
=
Body
(
default
=
None
),
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}

## 128_TUTORIAL_EXTRA_MODELS
Extra Models¶
---

Extra Models
Continuing with the previous example, it will be common to have more than one related model.
This is especially the case for user models, because:
The
input model
needs to be able to have a password.
The
output model
should not have a password.
The
database model
would probably need to have a hashed password.
Danger
Never store user's plaintext passwords. Always store a "secure hash" that you can then verify.
If you don't know, you will learn what a "password hash" is in the
security chapters
.
Multiple models
Here's a general idea of how the models could look like with their password fields and the places where they are used:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserInDB
(
BaseModel
):
username
:
str
hashed_password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
def
fake_password_hasher
(
raw_password
:
str
):
return
"supersecret"
+
raw_password
def
fake_save_user
(
user_in
:
UserIn
):
hashed_password
=
fake_password_hasher
(
user_in
.
password
)
user_in_db
=
UserInDB
(
**
user_in
.
dict
(),
hashed_password
=
hashed_password
)
print
(
"User saved! ..not really"
)
return
user_in_db
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user_in
:
UserIn
):
user_saved
=
fake_save_user
(
user_in
)
return
user_saved
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserInDB
(
BaseModel
):
username
:
str
hashed_password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
def
fake_password_hasher
(
raw_password
:
str
):
return
"supersecret"
+
raw_password
def
fake_save_user
(
user_in
:
UserIn
):
hashed_password
=
fake_password_hasher
(
user_in
.
password
)
user_in_db
=
UserInDB
(
**
user_in
.
dict
(),
hashed_password
=
hashed_password
)
print
(
"User saved! ..not really"
)
return
user_in_db
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user_in
:
UserIn
):
user_saved
=
fake_save_user
(
user_in
)
return
user_saved
Info
In Pydantic v1 the method was called
.dict()
, it was deprecated (but still supported) in Pydantic v2, and renamed to
.model_dump()
.
The examples here use
.dict()
for compatibility with Pydantic v1, but you should use
.model_dump()
instead if you can use Pydantic v2.
About
**user_in.dict()
Pydantic's
.dict()
user_in
is a Pydantic model of class
UserIn
.
Pydantic models have a
.dict()
method that returns a
dict
with the model's data.
So, if we create a Pydantic object
user_in
like:
user_in
=
UserIn
(
username
=
"john"
,
password
=
"secret"
,
email
=
"john.doe@example.com"
)
and then we call:
user_dict
=
user_in
.
dict
()
we now have a
dict
with the data in the variable
user_dict
(it's a
dict
instead of a Pydantic model object).
And if we call:
print
(
user_dict
)
we would get a Python
dict
with:
{
'username'
:
'john'
,
'password'
:
'secret'
,
'email'
:
'john.doe@example.com'
,
'full_name'
:
None
,
}
Unpacking a
dict
If we take a
dict
like
user_dict
and pass it to a function (or class) with
**user_dict
, Python will "unpack" it. It will pass the keys and values of the
user_dict
directly as key-value arguments.
So, continuing with the
user_dict
from above, writing:
UserInDB
(
**
user_dict
)
would result in something equivalent to:
UserInDB
(
username
=
"john"
,
password
=
"secret"
,
email
=
"john.doe@example.com"
,
full_name
=
None
,
)
Or more exactly, using
user_dict
directly, with whatever contents it might have in the future:
UserInDB
(
username
=
user_dict
[
"username"
],
password
=
user_dict
[
"password"
],
email
=
user_dict
[
"email"
],
full_name
=
user_dict
[
"full_name"
],
)
A Pydantic model from the contents of another
As in the example above we got
user_dict
from
user_in.dict()
, this code:
user_dict
=
user_in
.
dict
()
UserInDB
(
**
user_dict
)
would be equivalent to:
UserInDB
(
**
user_in
.
dict
())
...because
user_in.dict()
is a
dict
, and then we make Python "unpack" it by passing it to
UserInDB
prefixed with
**
.
So, we get a Pydantic model from the data in another Pydantic model.
Unpacking a
dict
and extra keywords
And then adding the extra keyword argument
hashed_password=hashed_password
, like in:
UserInDB
(
**
user_in
.
dict
(),
hashed_password
=
hashed_password
)
...ends up being like:
UserInDB
(
username
=
user_dict
[
"username"
],
password
=
user_dict
[
"password"
],
email
=
user_dict
[
"email"
],
full_name
=
user_dict
[
"full_name"
],
hashed_password
=
hashed_password
,
)
Warning
The supporting additional functions
fake_password_hasher
and
fake_save_user
are just to demo a possible flow of the data, but they of course are not providing any real security.
Reduce duplication
Reducing code duplication is one of the core ideas in
FastAPI
.
As code duplication increments the chances of bugs, security issues, code desynchronization issues (when you update in one place but not in the others), etc.
And these models are all sharing a lot of the data and duplicating attribute names and types.
We could do better.
We can declare a
UserBase
model that serves as a base for our other models. And then we can make subclasses of that model that inherit its attributes (type declarations, validation, etc).
All the data conversion, validation, documentation, etc. will still work as normally.
That way, we can declare just the differences between the models (with plaintext
password
, with
hashed_password
and without password):
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserBase
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserIn
(
UserBase
):
password
:
str
class
UserOut
(
UserBase
):
pass
class
UserInDB
(
UserBase
):
hashed_password
:
str
def
fake_password_hasher
(
raw_password
:
str
):
return
"supersecret"
+
raw_password
def
fake_save_user
(
user_in
:
UserIn
):
hashed_password
=
fake_password_hasher
(
user_in
.
password
)
user_in_db
=
UserInDB
(
**
user_in
.
dict
(),
hashed_password
=
hashed_password
)
print
(
"User saved! ..not really"
)
return
user_in_db
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user_in
:
UserIn
):
user_saved
=
fake_save_user
(
user_in
)
return
user_saved
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserBase
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserIn
(
UserBase
):
password
:
str
class
UserOut
(
UserBase
):
pass
class
UserInDB
(
UserBase
):
hashed_password
:
str
def
fake_password_hasher
(
raw_password
:
str
):
return
"supersecret"
+
raw_password
def
fake_save_user
(
user_in
:
UserIn
):
hashed_password
=
fake_password_hasher
(
user_in
.
password
)
user_in_db
=
UserInDB
(
**
user_in
.
dict
(),
hashed_password
=
hashed_password
)
print
(
"User saved! ..not really"
)
return
user_in_db
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user_in
:
UserIn
):
user_saved
=
fake_save_user
(
user_in
)
return
user_saved
Union
or
anyOf
You can declare a response to be the
Union
of two or more types, that means, that the response would be any of them.
It will be defined in OpenAPI with
anyOf
.
To do that, use the standard Python type hint
typing.Union
:
Note
When defining a
Union
, include the most specific type first, followed by the less specific type. In the example below, the more specific
PlaneItem
comes before
CarItem
in
Union[PlaneItem, CarItem]
.
Python 3.10+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
BaseItem
(
BaseModel
):
description
:
str
type
:
str
class
CarItem
(
BaseItem
):
type
:
str
=
"car"
class
PlaneItem
(
BaseItem
):
type
:
str
=
"plane"
size
:
int
items
=
{
"item1"
:
{
"description"
:
"All my friends drive a low rider"
,
"type"
:
"car"
},
"item2"
:
{
"description"
:
"Music is my aeroplane, it's my aeroplane"
,
"type"
:
"plane"
,
"size"
:
5
,
},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Union
[
PlaneItem
,
CarItem
])
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
BaseItem
(
BaseModel
):
description
:
str
type
:
str
class
CarItem
(
BaseItem
):
type
:
str
=
"car"
class
PlaneItem
(
BaseItem
):
type
:
str
=
"plane"
size
:
int
items
=
{
"item1"
:
{
"description"
:
"All my friends drive a low rider"
,
"type"
:
"car"
},
"item2"
:
{
"description"
:
"Music is my aeroplane, it's my aeroplane"
,
"type"
:
"plane"
,
"size"
:
5
,
},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Union
[
PlaneItem
,
CarItem
])
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
Union
in Python 3.10
In this example we pass
Union[PlaneItem, CarItem]
as the value of the argument
response_model
.
Because we are passing it as a
value to an argument
instead of putting it in a
type annotation
, we have to use
Union
even in Python 3.10.
If it was in a type annotation we could have used the vertical bar, as:
some_variable
:
PlaneItem
|
CarItem
But if we put that in the assignment
response_model=PlaneItem | CarItem
we would get an error, because Python would try to perform an
invalid operation
between
PlaneItem
and
CarItem
instead of interpreting that as a type annotation.
List of models
The same way, you can declare responses of lists of objects.
For that, use the standard Python
typing.List
(or just
list
in Python 3.9 and above):
Python 3.9+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
items
=
[
{
"name"
:
"Foo"
,
"description"
:
"There comes my hero"
},
{
"name"
:
"Red"
,
"description"
:
"It's my aeroplane"
},
]
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
])
async
def
read_items
():
return
items
🤓 Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
items
=
[
{
"name"
:
"Foo"
,
"description"
:
"There comes my hero"
},
{
"name"
:
"Red"
,
"description"
:
"It's my aeroplane"
},
]
@app
.
get
(
"/items/"
,
response_model
=
List
[
Item
])
async
def
read_items
():
return
items
Response with arbitrary
dict
You can also declare a response using a plain arbitrary
dict
, declaring just the type of the keys and values, without using a Pydantic model.
This is useful if you don't know the valid field/attribute names (that would be needed for a Pydantic model) beforehand.
In this case, you can use
typing.Dict
(or just
dict
in Python 3.9 and above):
Python 3.9+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/keyword-weights/"
,
response_model
=
dict
[
str
,
float
])
async
def
read_keyword_weights
():
return
{
"foo"
:
2.3
,
"bar"
:
3.4
}
🤓 Other versions and variants
Python 3.8+
from
typing
import
Dict
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/keyword-weights/"
,
response_model
=
Dict
[
str
,
float
])
async
def
read_keyword_weights
():
return
{
"foo"
:
2.3
,
"bar"
:
3.4
}
Recap
Use multiple Pydantic models and inherit freely for each case.
You don't need to have a single data model per entity if that entity must be able to have different "states". As the case with the user "entity" with a state including
password
,
password_hash
and no password.

## 129_TUTORIAL_FIRST_STEPS
First Steps¶
---

First Steps
The simplest FastAPI file could look like this:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
Copy that to a file
main.py
.
Run the live server:
fast →
fastapi dev main.py
FastAPI
Starting development server 🚀
Searching for package file structure from directories
with
__init__.py
files
Importing from
/home/user/code/
awesomeapp
module
🐍 main.py
code
Importing the FastAPI app object from the module with
the following code:
from
main
import
app
app
Using import string:
main:app
server
Server started at
http://127.0.0.1:8000
server
Documentation at
http://127.0.0.1:8000/docs
tip
Running in development mode, for production use:
fastapi run
Logs:
INFO
Will watch for changes in these directories:
[
'/home/user/code/awesomeapp'
]
INFO
Uvicorn running on
http://127.0.0.1:8000
(
Press CTRL+C
to quit
)
INFO
Started reloader process
[
383138
]
using WatchFiles
INFO
Started server process
[
383153
]
INFO
Waiting for application startup.
INFO
Application startup complete.
In the output, there's a line with something like:
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
That line shows the URL where your app is being served, in your local machine.
Check it
Open your browser at
http://127.0.0.1:8000
.
You will see the JSON response as:
{
"message"
:
"Hello World"
}
Interactive API docs
Now go to
http://127.0.0.1:8000/docs
.
You will see the automatic interactive API documentation (provided by
Swagger UI
):
Alternative API docs
And now, go to
http://127.0.0.1:8000/redoc
.
You will see the alternative automatic documentation (provided by
ReDoc
):
OpenAPI
FastAPI
generates a "schema" with all your API using the
OpenAPI
standard for defining APIs.
"Schema"
A "schema" is a definition or description of something. Not the code that implements it, but just an abstract description.
API "schema"
In this case,
OpenAPI
is a specification that dictates how to define a schema of your API.
This schema definition includes your API paths, the possible parameters they take, etc.
Data "schema"
The term "schema" might also refer to the shape of some data, like a JSON content.
In that case, it would mean the JSON attributes, and data types they have, etc.
OpenAPI and JSON Schema
OpenAPI defines an API schema for your API. And that schema includes definitions (or "schemas") of the data sent and received by your API using
JSON Schema
, the standard for JSON data schemas.
Check the
openapi.json
If you are curious about how the raw OpenAPI schema looks like, FastAPI automatically generates a JSON (schema) with the descriptions of all your API.
You can see it directly at:
http://127.0.0.1:8000/openapi.json
.
It will show a JSON starting with something like:
{
"openapi"
:
"3.1.0"
,
"info"
:
{
"title"
:
"FastAPI"
,
"version"
:
"0.1.0"
},
"paths"
:
{
"/items/"
:
{
"get"
:
{
"responses"
:
{
"200"
:
{
"description"
:
"Successful Response"
,
"content"
:
{
"application/json"
:
{
...
What is OpenAPI for
The OpenAPI schema is what powers the two interactive documentation systems included.
And there are dozens of alternatives, all based on OpenAPI. You could easily add any of those alternatives to your application built with
FastAPI
.
You could also use it to generate code automatically, for clients that communicate with your API. For example, frontend, mobile or IoT applications.
Recap, step by step
Step 1: import
FastAPI
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
FastAPI
is a Python class that provides all the functionality for your API.
Technical Details
FastAPI
is a class that inherits directly from
Starlette
.
You can use all the
Starlette
functionality with
FastAPI
too.
Step 2: create a
FastAPI
"instance"
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
Here the
app
variable will be an "instance" of the class
FastAPI
.
This will be the main point of interaction to create all your API.
Step 3: create a
path operation
Path
"Path" here refers to the last part of the URL starting from the first
/
.
So, in a URL like:
https://example.com/items/foo
...the path would be:
/items/foo
Info
A "path" is also commonly called an "endpoint" or a "route".
While building an API, the "path" is the main way to separate "concerns" and "resources".
Operation
"Operation" here refers to one of the HTTP "methods".
One of:
POST
GET
PUT
DELETE
...and the more exotic ones:
OPTIONS
HEAD
PATCH
TRACE
In the HTTP protocol, you can communicate to each path using one (or more) of these "methods".
When building APIs, you normally use these specific HTTP methods to perform a specific action.
Normally you use:
POST
: to create data.
GET
: to read data.
PUT
: to update data.
DELETE
: to delete data.
So, in OpenAPI, each of the HTTP methods is called an "operation".
We are going to call them "
operations
" too.
Define a
path operation decorator
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
The
@app.get("/")
tells
FastAPI
that the function right below is in charge of handling requests that go to:
the path
/
using a
get
operation
@decorator
Info
That
@something
syntax in Python is called a "decorator".
You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from).
A "decorator" takes the function below and does something with it.
In our case, this decorator tells
FastAPI
that the function below corresponds to the
path
/
with an
operation
get
.
It is the "
path operation decorator
".
You can also use the other operations:
@app.post()
@app.put()
@app.delete()
And the more exotic ones:
@app.options()
@app.head()
@app.patch()
@app.trace()
Tip
You are free to use each operation (HTTP method) as you wish.
FastAPI
doesn't enforce any specific meaning.
The information here is presented as a guideline, not a requirement.
For example, when using GraphQL you normally perform all the actions using only
POST
operations.
Step 4: define the
path operation function
This is our "
path operation function
":
path
: is
/
.
operation
: is
get
.
function
: is the function below the "decorator" (below
@app.get("/")
).
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
This is a Python function.
It will be called by
FastAPI
whenever it receives a request to the URL "
/
" using a
GET
operation.
In this case, it is an
async
function.
You could also define it as a normal function instead of
async def
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
root
():
return
{
"message"
:
"Hello World"
}
Note
If you don't know the difference, check the
Async:
"In a hurry?"
.
Step 5: return the content
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
You can return a
dict
,
list
, singular values as
str
,
int
, etc.
You can also return Pydantic models (you'll see more about that later).
There are many other objects and models that will be automatically converted to JSON (including ORMs, etc). Try using your favorite ones, it's highly probable that they are already supported.
Recap
Import
FastAPI
.
Create an
app
instance.
Write a
path operation decorator
using decorators like
@app.get("/")
.
Define a
path operation function
; for example,
def root(): ...
.
Run the development server using the command
fastapi dev
.

## 130_TUTORIAL_HANDLING_ERRORS
Handling Errors¶
---

Handling Errors
There are many situations in which you need to notify an error to a client that is using your API.
This client could be a browser with a frontend, a code from someone else, an IoT device, etc.
You could need to tell the client that:
The client doesn't have enough privileges for that operation.
The client doesn't have access to that resource.
The item the client was trying to access doesn't exist.
etc.
In these cases, you would normally return an
HTTP status code
in the range of
400
(from 400 to 499).
This is similar to the 200 HTTP status codes (from 200 to 299). Those "200" status codes mean that somehow there was a "success" in the request.
The status codes in the 400 range mean that there was an error from the client.
Remember all those
"404 Not Found"
errors (and jokes)?
Use
HTTPException
To return HTTP responses with errors to the client you use
HTTPException
.
Import
HTTPException
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
app
=
FastAPI
()
items
=
{
"foo"
:
"The Foo Wrestlers"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
items
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"item"
:
items
[
item_id
]}
Raise an
HTTPException
in your code
HTTPException
is a normal Python exception with additional data relevant for APIs.
Because it's a Python exception, you don't
return
it, you
raise
it.
This also means that if you are inside a utility function that you are calling inside of your
path operation function
, and you raise the
HTTPException
from inside of that utility function, it won't run the rest of the code in the
path operation function
, it will terminate that request right away and send the HTTP error from the
HTTPException
to the client.
The benefit of raising an exception over returning a value will be more evident in the section about Dependencies and Security.
In this example, when the client requests an item by an ID that doesn't exist, raise an exception with a status code of
404
:
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
app
=
FastAPI
()
items
=
{
"foo"
:
"The Foo Wrestlers"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
items
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"item"
:
items
[
item_id
]}
The resulting response
If the client requests
http://example.com/items/foo
(an
item_id
"foo"
), that client will receive an HTTP status code of 200, and a JSON response of:
{
"item"
:
"The Foo Wrestlers"
}
But if the client requests
http://example.com/items/bar
(a non-existent
item_id
"bar"
), that client will receive an HTTP status code of 404 (the "not found" error), and a JSON response of:
{
"detail"
:
"Item not found"
}
Tip
When raising an
HTTPException
, you can pass any value that can be converted to JSON as the parameter
detail
, not only
str
.
You could pass a
dict
, a
list
, etc.
They are handled automatically by
FastAPI
and converted to JSON.
Add custom headers
There are some situations in where it's useful to be able to add custom headers to the HTTP error. For example, for some types of security.
You probably won't need to use it directly in your code.
But in case you needed it for an advanced scenario, you can add custom headers:
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
app
=
FastAPI
()
items
=
{
"foo"
:
"The Foo Wrestlers"
}
@app
.
get
(
"/items-header/
{item_id}
"
)
async
def
read_item_header
(
item_id
:
str
):
if
item_id
not
in
items
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
,
headers
=
{
"X-Error"
:
"There goes my error"
},
)
return
{
"item"
:
items
[
item_id
]}
Install custom exception handlers
You can add custom exception handlers with
the same exception utilities from Starlette
.
Let's say you have a custom exception
UnicornException
that you (or a library you use) might
raise
.
And you want to handle this exception globally with FastAPI.
You could add a custom exception handler with
@app.exception_handler()
:
Python 3.8+
from
fastapi
import
FastAPI
,
Request
from
fastapi.responses
import
JSONResponse
class
UnicornException
(
Exception
):
def
__init__
(
self
,
name
:
str
):
self
.
name
=
name
app
=
FastAPI
()
@app
.
exception_handler
(
UnicornException
)
async
def
unicorn_exception_handler
(
request
:
Request
,
exc
:
UnicornException
):
return
JSONResponse
(
status_code
=
418
,
content
=
{
"message"
:
f
"Oops!
{
exc
.
name
}
did something. There goes a rainbow..."
},
)
@app
.
get
(
"/unicorns/
{name}
"
)
async
def
read_unicorn
(
name
:
str
):
if
name
==
"yolo"
:
raise
UnicornException
(
name
=
name
)
return
{
"unicorn_name"
:
name
}
Here, if you request
/unicorns/yolo
, the
path operation
will
raise
a
UnicornException
.
But it will be handled by the
unicorn_exception_handler
.
So, you will receive a clean error, with an HTTP status code of
418
and a JSON content of:
{
"message"
:
"Oops! yolo did something. There goes a rainbow..."
}
Technical Details
You could also use
from starlette.requests import Request
and
from starlette.responses import JSONResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with
Request
.
Override the default exception handlers
FastAPI
has some default exception handlers.
These handlers are in charge of returning the default JSON responses when you
raise
an
HTTPException
and when the request has invalid data.
You can override these exception handlers with your own.
Override request validation exceptions
When a request contains invalid data,
FastAPI
internally raises a
RequestValidationError
.
And it also includes a default exception handler for it.
To override it, import the
RequestValidationError
and use it with
@app.exception_handler(RequestValidationError)
to decorate the exception handler.
The exception handler will receive a
Request
and the exception.
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
from
fastapi.exceptions
import
RequestValidationError
from
fastapi.responses
import
PlainTextResponse
from
starlette.exceptions
import
HTTPException
as
StarletteHTTPException
app
=
FastAPI
()
@app
.
exception_handler
(
StarletteHTTPException
)
async
def
http_exception_handler
(
request
,
exc
):
return
PlainTextResponse
(
str
(
exc
.
detail
),
status_code
=
exc
.
status_code
)
@app
.
exception_handler
(
RequestValidationError
)
async
def
validation_exception_handler
(
request
,
exc
):
return
PlainTextResponse
(
str
(
exc
),
status_code
=
400
)
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
):
if
item_id
==
3
:
raise
HTTPException
(
status_code
=
418
,
detail
=
"Nope! I don't like 3."
)
return
{
"item_id"
:
item_id
}
Now, if you go to
/items/foo
, instead of getting the default JSON error with:
{
"detail"
:
[
{
"loc"
:
[
"path"
,
"item_id"
],
"msg"
:
"value is not a valid integer"
,
"type"
:
"type_error.integer"
}
]
}
you will get a text version, with:
1 validation error
path -> item_id
value is not a valid integer (type=type_error.integer)
RequestValidationError
vs
ValidationError
Warning
These are technical details that you might skip if it's not important for you now.
RequestValidationError
is a sub-class of Pydantic's
ValidationError
.
FastAPI
uses it so that, if you use a Pydantic model in
response_model
, and your data has an error, you will see the error in your log.
But the client/user will not see it. Instead, the client will receive an "Internal Server Error" with an HTTP status code
500
.
It should be this way because if you have a Pydantic
ValidationError
in your
response
or anywhere in your code (not in the client's
request
), it's actually a bug in your code.
And while you fix it, your clients/users shouldn't have access to internal information about the error, as that could expose a security vulnerability.
Override the
HTTPException
error handler
The same way, you can override the
HTTPException
handler.
For example, you could want to return a plain text response instead of JSON for these errors:
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
from
fastapi.exceptions
import
RequestValidationError
from
fastapi.responses
import
PlainTextResponse
from
starlette.exceptions
import
HTTPException
as
StarletteHTTPException
app
=
FastAPI
()
@app
.
exception_handler
(
StarletteHTTPException
)
async
def
http_exception_handler
(
request
,
exc
):
return
PlainTextResponse
(
str
(
exc
.
detail
),
status_code
=
exc
.
status_code
)
@app
.
exception_handler
(
RequestValidationError
)
async
def
validation_exception_handler
(
request
,
exc
):
return
PlainTextResponse
(
str
(
exc
),
status_code
=
400
)
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
):
if
item_id
==
3
:
raise
HTTPException
(
status_code
=
418
,
detail
=
"Nope! I don't like 3."
)
return
{
"item_id"
:
item_id
}
Technical Details
You could also use
from starlette.responses import PlainTextResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
Use the
RequestValidationError
body
The
RequestValidationError
contains the
body
it received with invalid data.
You could use it while developing your app to log the body and debug it, return it to the user, etc.
Python 3.8+
from
fastapi
import
FastAPI
,
Request
,
status
from
fastapi.encoders
import
jsonable_encoder
from
fastapi.exceptions
import
RequestValidationError
from
fastapi.responses
import
JSONResponse
from
pydantic
import
BaseModel
app
=
FastAPI
()
@app
.
exception_handler
(
RequestValidationError
)
async
def
validation_exception_handler
(
request
:
Request
,
exc
:
RequestValidationError
):
return
JSONResponse
(
status_code
=
status
.
HTTP_422_UNPROCESSABLE_ENTITY
,
content
=
jsonable_encoder
({
"detail"
:
exc
.
errors
(),
"body"
:
exc
.
body
}),
)
class
Item
(
BaseModel
):
title
:
str
size
:
int
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
Now try sending an invalid item like:
{
"title"
:
"towel"
,
"size"
:
"XL"
}
You will receive a response telling you that the data is invalid containing the received body:
{
"detail"
:
[
{
"loc"
:
[
"body"
,
"size"
],
"msg"
:
"value is not a valid integer"
,
"type"
:
"type_error.integer"
}
],
"body"
:
{
"title"
:
"towel"
,
"size"
:
"XL"
}
}
FastAPI's
HTTPException
vs Starlette's
HTTPException
FastAPI
has its own
HTTPException
.
And
FastAPI
's
HTTPException
error class inherits from Starlette's
HTTPException
error class.
The only difference is that
FastAPI
's
HTTPException
accepts any JSON-able data for the
detail
field, while Starlette's
HTTPException
only accepts strings for it.
So, you can keep raising
FastAPI
's
HTTPException
as normally in your code.
But when you register an exception handler, you should register it for Starlette's
HTTPException
.
This way, if any part of Starlette's internal code, or a Starlette extension or plug-in, raises a Starlette
HTTPException
, your handler will be able to catch and handle it.
In this example, to be able to have both
HTTPException
s in the same code, Starlette's exceptions is renamed to
StarletteHTTPException
:
from
starlette.exceptions
import
HTTPException
as
StarletteHTTPException
Reuse
FastAPI
's exception handlers
If you want to use the exception along with the same default exception handlers from
FastAPI
, you can import and reuse the default exception handlers from
fastapi.exception_handlers
:
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
from
fastapi.exception_handlers
import
(
http_exception_handler
,
request_validation_exception_handler
,
)
from
fastapi.exceptions
import
RequestValidationError
from
starlette.exceptions
import
HTTPException
as
StarletteHTTPException
app
=
FastAPI
()
@app
.
exception_handler
(
StarletteHTTPException
)
async
def
custom_http_exception_handler
(
request
,
exc
):
print
(
f
"OMG! An HTTP error!:
{
repr
(
exc
)
}
"
)
return
await
http_exception_handler
(
request
,
exc
)
@app
.
exception_handler
(
RequestValidationError
)
async
def
validation_exception_handler
(
request
,
exc
):
print
(
f
"OMG! The client sent invalid data!:
{
exc
}
"
)
return
await
request_validation_exception_handler
(
request
,
exc
)
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
):
if
item_id
==
3
:
raise
HTTPException
(
status_code
=
418
,
detail
=
"Nope! I don't like 3."
)
return
{
"item_id"
:
item_id
}
In this example you are just printing the error with a very expressive message, but you get the idea. You can use the exception and then just reuse the default exception handlers.

## 131_TUTORIAL_HEADER_PARAM_MODELS
Header Parameter Models¶
---

Header Parameter Models
If you have a group of related
header parameters
, you can create a
Pydantic model
to declare them.
This would allow you to
re-use the model
in
multiple places
and also to declare validations and metadata for all the parameters at once. 😎
Note
This is supported since FastAPI version
0.115.0
. 🤓
Header Parameters with a Pydantic Model
Declare the
header parameters
that you need in a
Pydantic model
, and then declare the parameter as
Header
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
FastAPI
will
extract
the data for
each field
from the
headers
in the request and give you the Pydantic model you defined.
Check the Docs
You can see the required headers in the docs UI at
/docs
:
Forbid Extra Headers
In some special use cases (probably not very common), you might want to
restrict
the headers that you want to receive.
You can use Pydantic's model configuration to
forbid
any
extra
fields:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
If a client tries to send some
extra headers
, they will receive an
error
response.
For example, if the client tries to send a
tool
header with a value of
plumbus
, they will receive an
error
response telling them that the header parameter
tool
is not allowed:
{
"detail"
:
[
{
"type"
:
"extra_forbidden"
,
"loc"
:
[
"header"
,
"tool"
],
"msg"
:
"Extra inputs are not permitted"
,
"input"
:
"plumbus"
,
}
]
}
Disable Convert Underscores
The same way as with regular header parameters, when you have underscore characters in the parameter names, they are
automatically converted to hyphens
.
For example, if you have a header parameter
save_data
in the code, the expected HTTP header will be
save-data
, and it will show up like that in the docs.
If for some reason you need to disable this automatic conversion, you can do it as well for Pydantic models for header parameters.
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
(
convert_underscores
=
False
)],
):
return
headers
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
(
convert_underscores
=
False
)],
):
return
headers
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
(
convert_underscores
=
False
)],
):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
(
convert_underscores
=
False
)):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
(
convert_underscores
=
False
)):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
(
convert_underscores
=
False
)):
return
headers
Warning
Before setting
convert_underscores
to
False
, bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.
Summary
You can use
Pydantic models
to declare
headers
in
FastAPI
. 😎

## 132_TUTORIAL_HEADER_PARAMS
Header Parameters¶
---

Header Parameters
You can define Header parameters the same way you define
Query
,
Path
and
Cookie
parameters.
Import
Header
First import
Header
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
str
|
None
,
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
Union
[
str
,
None
],
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
Union
[
str
,
None
],
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
str
|
None
=
Header
(
default
=
None
)):
return
{
"User-Agent"
:
user_agent
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Union
[
str
,
None
]
=
Header
(
default
=
None
)):
return
{
"User-Agent"
:
user_agent
}
Declare
Header
parameters
Then declare the header parameters using the same structure as with
Path
,
Query
and
Cookie
.
You can define the default value as well as all the extra validation or annotation parameters:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
str
|
None
,
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
Union
[
str
,
None
],
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
Union
[
str
,
None
],
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
str
|
None
=
Header
(
default
=
None
)):
return
{
"User-Agent"
:
user_agent
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Union
[
str
,
None
]
=
Header
(
default
=
None
)):
return
{
"User-Agent"
:
user_agent
}
Technical Details
Header
is a "sister" class of
Path
,
Query
and
Cookie
. It also inherits from the same common
Param
class.
But remember that when you import
Query
,
Path
,
Header
, and others from
fastapi
, those are actually functions that return special classes.
Info
To declare headers, you need to use
Header
, because otherwise the parameters would be interpreted as query parameters.
Automatic conversion
Header
has a little extra functionality on top of what
Path
,
Query
and
Cookie
provide.
Most of the standard headers are separated by a "hyphen" character, also known as the "minus symbol" (
-
).
But a variable like
user-agent
is invalid in Python.
So, by default,
Header
will convert the parameter names characters from underscore (
_
) to hyphen (
-
) to extract and document the headers.
Also, HTTP headers are case-insensitive, so, you can declare them with standard Python style (also known as "snake_case").
So, you can use
user_agent
as you normally would in Python code, instead of needing to capitalize the first letters as
User_Agent
or something similar.
If for some reason you need to disable automatic conversion of underscores to hyphens, set the parameter
convert_underscores
of
Header
to
False
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
strange_header
:
Annotated
[
str
|
None
,
Header
(
convert_underscores
=
False
)]
=
None
,
):
return
{
"strange_header"
:
strange_header
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
strange_header
:
Annotated
[
Union
[
str
,
None
],
Header
(
convert_underscores
=
False
)
]
=
None
,
):
return
{
"strange_header"
:
strange_header
}
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
strange_header
:
Annotated
[
Union
[
str
,
None
],
Header
(
convert_underscores
=
False
)
]
=
None
,
):
return
{
"strange_header"
:
strange_header
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
strange_header
:
str
|
None
=
Header
(
default
=
None
,
convert_underscores
=
False
),
):
return
{
"strange_header"
:
strange_header
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
strange_header
:
Union
[
str
,
None
]
=
Header
(
default
=
None
,
convert_underscores
=
False
),
):
return
{
"strange_header"
:
strange_header
}
Warning
Before setting
convert_underscores
to
False
, bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.
Duplicate headers
It is possible to receive duplicate headers. That means, the same header with multiple values.
You can define those cases using a list in the type declaration.
You will receive all the values from the duplicate header as a Python
list
.
For example, to declare a header of
X-Token
that can appear more than once, you can write:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
Annotated
[
list
[
str
]
|
None
,
Header
()]
=
None
):
return
{
"X-Token values"
:
x_token
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
List
,
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
Annotated
[
Union
[
List
[
str
],
None
],
Header
()]
=
None
):
return
{
"X-Token values"
:
x_token
}
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
Annotated
[
Union
[
List
[
str
],
None
],
Header
()]
=
None
):
return
{
"X-Token values"
:
x_token
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
list
[
str
]
|
None
=
Header
(
default
=
None
)):
return
{
"X-Token values"
:
x_token
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
Union
[
list
[
str
],
None
]
=
Header
(
default
=
None
)):
return
{
"X-Token values"
:
x_token
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
Union
[
List
[
str
],
None
]
=
Header
(
default
=
None
)):
return
{
"X-Token values"
:
x_token
}
If you communicate with that
path operation
sending two HTTP headers like:
X-Token: foo
X-Token: bar
The response would be like:
{
"X-Token values"
:
[
"bar"
,
"foo"
]
}
Recap
Declare headers with
Header
, using the same common pattern as
Query
,
Path
and
Cookie
.
And don't worry about underscores in your variables,
FastAPI
will take care of converting them.

## 133_TUTORIAL_METADATA
Metadata and Docs URLs¶
---

Metadata and Docs URLs
You can customize several metadata configurations in your
FastAPI
application.
Metadata for API
You can set the following fields that are used in the OpenAPI specification and the automatic API docs UIs:
Parameter
Type
Description
title
str
The title of the API.
summary
str
A short summary of the API.
Available since OpenAPI 3.1.0, FastAPI 0.99.0.
description
str
A short description of the API. It can use Markdown.
version
string
The version of the API. This is the version of your own application, not of OpenAPI. For example
2.5.0
.
terms_of_service
str
A URL to the Terms of Service for the API. If provided, this has to be a URL.
contact
dict
The contact information for the exposed API. It can contain several fields.
contact
fields
Parameter
Type
Description
name
str
The identifying name of the contact person/organization.
url
str
The URL pointing to the contact information. MUST be in the format of a URL.
email
str
The email address of the contact person/organization. MUST be in the format of an email address.
license_info
dict
The license information for the exposed API. It can contain several fields.
license_info
fields
Parameter
Type
Description
name
str
REQUIRED
(if a
license_info
is set). The license name used for the API.
identifier
str
An
SPDX
license expression for the API. The
identifier
field is mutually exclusive of the
url
field.
Available since OpenAPI 3.1.0, FastAPI 0.99.0.
url
str
A URL to the license used for the API. MUST be in the format of a URL.
You can set them as follows:
Python 3.8+
from
fastapi
import
FastAPI
description
=
"""
ChimichangApp API helps you do awesome stuff. 🚀
## Items
You can **read items**.
## Users
You will be able to:
* **Create users** (_not implemented_).
* **Read users** (_not implemented_).
"""
app
=
FastAPI
(
title
=
"ChimichangApp"
,
description
=
description
,
summary
=
"Deadpool's favorite app. Nuff said."
,
version
=
"0.0.1"
,
terms_of_service
=
"http://example.com/terms/"
,
contact
=
{
"name"
:
"Deadpoolio the Amazing"
,
"url"
:
"http://x-force.example.com/contact/"
,
"email"
:
"dp@x-force.example.com"
,
},
license_info
=
{
"name"
:
"Apache 2.0"
,
"url"
:
"https://www.apache.org/licenses/LICENSE-2.0.html"
,
},
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Katana"
}]
Tip
You can write Markdown in the
description
field and it will be rendered in the output.
With this configuration, the automatic API docs would look like:
License identifier
Since OpenAPI 3.1.0 and FastAPI 0.99.0, you can also set the
license_info
with an
identifier
instead of a
url
.
For example:
Python 3.8+
from
fastapi
import
FastAPI
description
=
"""
ChimichangApp API helps you do awesome stuff. 🚀
## Items
You can **read items**.
## Users
You will be able to:
* **Create users** (_not implemented_).
* **Read users** (_not implemented_).
"""
app
=
FastAPI
(
title
=
"ChimichangApp"
,
description
=
description
,
summary
=
"Deadpool's favorite app. Nuff said."
,
version
=
"0.0.1"
,
terms_of_service
=
"http://example.com/terms/"
,
contact
=
{
"name"
:
"Deadpoolio the Amazing"
,
"url"
:
"http://x-force.example.com/contact/"
,
"email"
:
"dp@x-force.example.com"
,
},
license_info
=
{
"name"
:
"Apache 2.0"
,
"identifier"
:
"MIT"
,
},
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Katana"
}]
Metadata for tags
You can also add additional metadata for the different tags used to group your path operations with the parameter
openapi_tags
.
It takes a list containing one dictionary for each tag.
Each dictionary can contain:
name
(
required
): a
str
with the same tag name you use in the
tags
parameter in your
path operations
and
APIRouter
s.
description
: a
str
with a short description for the tag. It can have Markdown and will be shown in the docs UI.
externalDocs
: a
dict
describing external documentation with:
description
: a
str
with a short description for the external docs.
url
(
required
): a
str
with the URL for the external documentation.
Create metadata for tags
Let's try that in an example with tags for
users
and
items
.
Create metadata for your tags and pass it to the
openapi_tags
parameter:
Python 3.8+
from
fastapi
import
FastAPI
tags_metadata
=
[
{
"name"
:
"users"
,
"description"
:
"Operations with users. The **login** logic is also here."
,
},
{
"name"
:
"items"
,
"description"
:
"Manage items. So _fancy_ they have their own docs."
,
"externalDocs"
:
{
"description"
:
"Items external docs"
,
"url"
:
"https://fastapi.tiangolo.com/"
,
},
},
]
app
=
FastAPI
(
openapi_tags
=
tags_metadata
)
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
get_users
():
return
[{
"name"
:
"Harry"
},
{
"name"
:
"Ron"
}]
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
get_items
():
return
[{
"name"
:
"wand"
},
{
"name"
:
"flying broom"
}]
Notice that you can use Markdown inside of the descriptions, for example "login" will be shown in bold (
login
) and "fancy" will be shown in italics (
fancy
).
Tip
You don't have to add metadata for all the tags that you use.
Use your tags
Use the
tags
parameter with your
path operations
(and
APIRouter
s) to assign them to different tags:
Python 3.8+
from
fastapi
import
FastAPI
tags_metadata
=
[
{
"name"
:
"users"
,
"description"
:
"Operations with users. The **login** logic is also here."
,
},
{
"name"
:
"items"
,
"description"
:
"Manage items. So _fancy_ they have their own docs."
,
"externalDocs"
:
{
"description"
:
"Items external docs"
,
"url"
:
"https://fastapi.tiangolo.com/"
,
},
},
]
app
=
FastAPI
(
openapi_tags
=
tags_metadata
)
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
get_users
():
return
[{
"name"
:
"Harry"
},
{
"name"
:
"Ron"
}]
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
get_items
():
return
[{
"name"
:
"wand"
},
{
"name"
:
"flying broom"
}]
Info
Read more about tags in
Path Operation Configuration
.
Check the docs
Now, if you check the docs, they will show all the additional metadata:
Order of tags
The order of each tag metadata dictionary also defines the order shown in the docs UI.
For example, even though
users
would go after
items
in alphabetical order, it is shown before them, because we added their metadata as the first dictionary in the list.
OpenAPI URL
By default, the OpenAPI schema is served at
/openapi.json
.
But you can configure it with the parameter
openapi_url
.
For example, to set it to be served at
/api/v1/openapi.json
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
(
openapi_url
=
"/api/v1/openapi.json"
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
If you want to disable the OpenAPI schema completely you can set
openapi_url=None
, that will also disable the documentation user interfaces that use it.
Docs URLs
You can configure the two documentation user interfaces included:
Swagger UI
: served at
/docs
.
You can set its URL with the parameter
docs_url
.
You can disable it by setting
docs_url=None
.
ReDoc
: served at
/redoc
.
You can set its URL with the parameter
redoc_url
.
You can disable it by setting
redoc_url=None
.
For example, to set Swagger UI to be served at
/documentation
and disable ReDoc:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
(
docs_url
=
"/documentation"
,
redoc_url
=
None
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]

## 134_TUTORIAL_MIDDLEWARE
Middleware¶
---

Middleware
You can add middleware to
FastAPI
applications.
A "middleware" is a function that works with every
request
before it is processed by any specific
path operation
. And also with every
response
before returning it.
It takes each
request
that comes to your application.
It can then do something to that
request
or run any needed code.
Then it passes the
request
to be processed by the rest of the application (by some
path operation
).
It then takes the
response
generated by the application (by some
path operation
).
It can do something to that
response
or run any needed code.
Then it returns the
response
.
Technical Details
If you have dependencies with
yield
, the exit code will run
after
the middleware.
If there were any background tasks (covered in the
Background Tasks
section, you will see it later), they will run
after
all the middleware.
Create a middleware
To create a middleware you use the decorator
@app.middleware("http")
on top of a function.
The middleware function receives:
The
request
.
A function
call_next
that will receive the
request
as a parameter.
This function will pass the
request
to the corresponding
path operation
.
Then it returns the
response
generated by the corresponding
path operation
.
You can then further modify the
response
before returning it.
Python 3.8+
import
time
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
@app
.
middleware
(
"http"
)
async
def
add_process_time_header
(
request
:
Request
,
call_next
):
start_time
=
time
.
perf_counter
()
response
=
await
call_next
(
request
)
process_time
=
time
.
perf_counter
()
-
start_time
response
.
headers
[
"X-Process-Time"
]
=
str
(
process_time
)
return
response
Tip
Keep in mind that custom proprietary headers can be added
using the 'X-' prefix
.
But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (
CORS (Cross-Origin Resource Sharing)
) using the parameter
expose_headers
documented in
Starlette's CORS docs
.
Technical Details
You could also use
from starlette.requests import Request
.
FastAPI
provides it as a convenience for you, the developer. But it comes directly from Starlette.
Before and after the
response
You can add code to be run with the
request
, before any
path operation
receives it.
And also after the
response
is generated, before returning it.
For example, you could add a custom header
X-Process-Time
containing the time in seconds that it took to process the request and generate a response:
Python 3.8+
import
time
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
@app
.
middleware
(
"http"
)
async
def
add_process_time_header
(
request
:
Request
,
call_next
):
start_time
=
time
.
perf_counter
()
response
=
await
call_next
(
request
)
process_time
=
time
.
perf_counter
()
-
start_time
response
.
headers
[
"X-Process-Time"
]
=
str
(
process_time
)
return
response
Tip
Here we use
time.perf_counter()
instead of
time.time()
because it can be more precise for these use cases. 🤓
Multiple middleware execution order
When you add multiple middlewares using either
@app.middleware()
decorator or
app.add_middleware()
method, each new middleware wraps the application, forming a stack. The last middleware added is the
outermost
, and the first is the
innermost
.
On the request path, the
outermost
middleware runs first.
On the response path, it runs last.
For example:
app
.
add_middleware
(
MiddlewareA
)
app
.
add_middleware
(
MiddlewareB
)
This results in the following execution order:
Request
: MiddlewareB → MiddlewareA → route
Response
: route → MiddlewareA → MiddlewareB
This stacking behavior ensures that middlewares are executed in a predictable and controllable order.
Other middlewares
You can later read more about other middlewares in the
Advanced User Guide: Advanced Middleware
.
You will read about how to handle
CORS
with a middleware in the next section.

## 135_TUTORIAL_PATH_OPERATION_CONFIGURATION
Path Operation Configuration¶
---

Path Operation Configuration
There are several parameters that you can pass to your
path operation decorator
to configure it.
Warning
Notice that these parameters are passed directly to the
path operation decorator
, not to your
path operation function
.
Response Status Code
You can define the (HTTP)
status_code
to be used in the response of your
path operation
.
You can pass directly the
int
code, like
404
.
But if you don't remember what each number code is for, you can use the shortcut constants in
status
:
Python 3.10+
from
fastapi
import
FastAPI
,
status
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
status_code
=
status
.
HTTP_201_CREATED
)
async
def
create_item
(
item
:
Item
):
return
item
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
,
status
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
status_code
=
status
.
HTTP_201_CREATED
)
async
def
create_item
(
item
:
Item
):
return
item
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
,
status
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
status_code
=
status
.
HTTP_201_CREATED
)
async
def
create_item
(
item
:
Item
):
return
item
That status code will be used in the response and will be added to the OpenAPI schema.
Technical Details
You could also use
from starlette import status
.
FastAPI
provides the same
starlette.status
as
fastapi.status
just as a convenience for you, the developer. But it comes directly from Starlette.
Tags
You can add tags to your
path operation
, pass the parameter
tags
with a
list
of
str
(commonly just one
str
):
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
read_items
():
return
[{
"name"
:
"Foo"
,
"price"
:
42
}]
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"johndoe"
}]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
read_items
():
return
[{
"name"
:
"Foo"
,
"price"
:
42
}]
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"johndoe"
}]
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
read_items
():
return
[{
"name"
:
"Foo"
,
"price"
:
42
}]
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"johndoe"
}]
They will be added to the OpenAPI schema and used by the automatic documentation interfaces:
Tags with Enums
If you have a big application, you might end up accumulating
several tags
, and you would want to make sure you always use the
same tag
for related
path operations
.
In these cases, it could make sense to store the tags in an
Enum
.
FastAPI
supports that the same way as with plain strings:
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
app
=
FastAPI
()
class
Tags
(
Enum
):
items
=
"items"
users
=
"users"
@app
.
get
(
"/items/"
,
tags
=
[
Tags
.
items
])
async
def
get_items
():
return
[
"Portal gun"
,
"Plumbus"
]
@app
.
get
(
"/users/"
,
tags
=
[
Tags
.
users
])
async
def
read_users
():
return
[
"Rick"
,
"Morty"
]
Summary and description
You can add a
summary
and
description
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
description
=
"Create an item with all the information, name, description, price, tax and a set of unique tags"
,
)
async
def
create_item
(
item
:
Item
):
return
item
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
description
=
"Create an item with all the information, name, description, price, tax and a set of unique tags"
,
)
async
def
create_item
(
item
:
Item
):
return
item
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
description
=
"Create an item with all the information, name, description, price, tax and a set of unique tags"
,
)
async
def
create_item
(
item
:
Item
):
return
item
Description from docstring
As descriptions tend to be long and cover multiple lines, you can declare the
path operation
description in the function
docstring
and
FastAPI
will read it from there.
You can write
Markdown
in the docstring, it will be interpreted and displayed correctly (taking into account docstring indentation).
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
It will be used in the interactive docs:
Response description
You can specify the response description with the parameter
response_description
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
response_description
=
"The created item"
,
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
response_description
=
"The created item"
,
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
response_description
=
"The created item"
,
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
Info
Notice that
response_description
refers specifically to the response, the
description
refers to the
path operation
in general.
Check
OpenAPI specifies that each
path operation
requires a response description.
So, if you don't provide one,
FastAPI
will automatically generate one of "Successful response".
Deprecate a
path operation
If you need to mark a
path operation
as
deprecated
, but without removing it, pass the parameter
deprecated
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
read_items
():
return
[{
"name"
:
"Foo"
,
"price"
:
42
}]
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"johndoe"
}]
@app
.
get
(
"/elements/"
,
tags
=
[
"items"
],
deprecated
=
True
)
async
def
read_elements
():
return
[{
"item_id"
:
"Foo"
}]
It will be clearly marked as deprecated in the interactive docs:
Check how deprecated and non-deprecated
path operations
look like:
Recap
You can configure and add metadata for your
path operations
easily by passing parameters to the
path operation decorators
.

## 136_TUTORIAL_PATH_PARAMS_NUMERIC_VALIDATIONS
Path Parameters and Numeric Validations¶
---

Path Parameters and Numeric Validations
In the same way that you can declare more validations and metadata for query parameters with
Query
, you can declare the same type of validations and metadata for path parameters with
Path
.
Import Path
First, import
Path
from
fastapi
, and import
Annotated
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
str
|
None
,
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
str
|
None
=
Query
(
default
=
None
,
alias
=
"item-query"
),
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
alias
=
"item-query"
),
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Info
FastAPI added support for
Annotated
(and started recommending it) in version 0.95.0.
If you have an older version, you would get errors when trying to use
Annotated
.
Make sure you
Upgrade the FastAPI version
to at least 0.95.1 before using
Annotated
.
Declare metadata
You can declare all the same parameters as for
Query
.
For example, to declare a
title
metadata value for the path parameter
item_id
you can type:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
str
|
None
,
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
str
|
None
=
Query
(
default
=
None
,
alias
=
"item-query"
),
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
alias
=
"item-query"
),
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Note
A path parameter is always required as it has to be part of the path. Even if you declared it with
None
or set a default value, it would not affect anything, it would still be always required.
Order the parameters as you need
Tip
This is probably not as important or necessary if you use
Annotated
.
Let's say that you want to declare the query parameter
q
as a required
str
.
And you don't need to declare anything else for that parameter, so you don't really need to use
Query
.
But you still need to use
Path
for the
item_id
path parameter. And you don't want to use
Annotated
for some reason.
Python will complain if you put a value with a "default" before a value that doesn't have a "default".
But you can re-order them, and have the value without a default (the query parameter
q
) first.
It doesn't matter for
FastAPI
. It will detect the parameters by their names, types and default declarations (
Query
,
Path
, etc), it doesn't care about the order.
So, you can declare your function as:
Python 3.8 non-Annotated
Tip
Prefer to use the
Annotated
version if possible.
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
)):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)]
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)]
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
But keep in mind that if you use
Annotated
, you won't have this problem, it won't matter as you're not using the function parameter default values for
Query()
or
Path()
.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)]
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)]
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
)):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Order the parameters as you need, tricks
Tip
This is probably not as important or necessary if you use
Annotated
.
Here's a
small trick
that can be handy, but you won't need it often.
If you want to:
declare the
q
query parameter without a
Query
nor any default value
declare the path parameter
item_id
using
Path
have them in a different order
not use
Annotated
...Python has a little special syntax for that.
Pass
*
, as the first parameter of the function.
Python won't do anything with that
*
, but it will know that all the following parameters should be called as keyword arguments (key-value pairs), also known as
kwargs
. Even if they don't have a default value.
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Better with
Annotated
Keep in mind that if you use
Annotated
, as you are not using function parameter default values, you won't have this problem, and you probably won't need to use
*
.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Number validations: greater than or equal
With
Query
and
Path
(and others you'll see later) you can declare number constraints.
Here, with
ge=1
,
item_id
will need to be an integer number "
g
reater than or
e
qual" to
1
.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
1
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
1
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
,
ge
=
1
),
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Number validations: greater than and less than or equal
The same applies for:
gt
:
g
reater
t
han
le
:
l
ess than or
e
qual
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
gt
=
0
,
le
=
1000
)],
q
:
str
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
gt
=
0
,
le
=
1000
)],
q
:
str
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
,
gt
=
0
,
le
=
1000
),
q
:
str
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Number validations: floats, greater than and less than
Number validations also work for
float
values.
Here's where it becomes important to be able to declare
gt
and not just
ge
. As with it you can require, for example, that a value must be greater than
0
, even if it is less than
1
.
So,
0.5
would be a valid value. But
0.0
or
0
would not.
And the same for
lt
.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
)],
q
:
str
,
size
:
Annotated
[
float
,
Query
(
gt
=
0
,
lt
=
10.5
)],
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
size
:
results
.
update
({
"size"
:
size
})
return
results
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
)],
q
:
str
,
size
:
Annotated
[
float
,
Query
(
gt
=
0
,
lt
=
10.5
)],
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
size
:
results
.
update
({
"size"
:
size
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
),
q
:
str
,
size
:
float
=
Query
(
gt
=
0
,
lt
=
10.5
),
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
size
:
results
.
update
({
"size"
:
size
})
return
results
Recap
With
Query
,
Path
(and others you haven't seen yet) you can declare metadata and string validations in the same ways as with
Query Parameters and String Validations
.
And you can also declare numeric validations:
gt
:
g
reater
t
han
ge
:
g
reater than or
e
qual
lt
:
l
ess
t
han
le
:
l
ess than or
e
qual
Info
Query
,
Path
, and other classes you will see later are subclasses of a common
Param
class.
All of them share the same parameters for additional validation and metadata you have seen.
Technical Details
When you import
Query
,
Path
and others from
fastapi
, they are actually functions.
That when called, return instances of classes of the same name.
So, you import
Query
, which is a function. And when you call it, it returns an instance of a class also named
Query
.
These functions are there (instead of just using the classes directly) so that your editor doesn't mark errors about their types.
That way you can use your normal editor and coding tools without having to add custom configurations to disregard those errors.

## 137_TUTORIAL_PATH_PARAMS
Path Parameters¶
---

Path Parameters
You can declare path "parameters" or "variables" with the same syntax used by Python format strings:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
):
return
{
"item_id"
:
item_id
}
The value of the path parameter
item_id
will be passed to your function as the argument
item_id
.
So, if you run this example and go to
http://127.0.0.1:8000/items/foo
, you will see a response of:
{
"item_id"
:
"foo"
}
Path parameters with types
You can declare the type of a path parameter in the function, using standard Python type annotations:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
):
return
{
"item_id"
:
item_id
}
In this case,
item_id
is declared to be an
int
.
Check
This will give you editor support inside of your function, with error checks, completion, etc.
Data
conversion
If you run this example and open your browser at
http://127.0.0.1:8000/items/3
, you will see a response of:
{
"item_id"
:
3
}
Check
Notice that the value your function received (and returned) is
3
, as a Python
int
, not a string
"3"
.
So, with that type declaration,
FastAPI
gives you automatic request
"parsing"
.
Data validation
But if you go to the browser at
http://127.0.0.1:8000/items/foo
, you will see a nice HTTP error of:
{
"detail"
:
[
{
"type"
:
"int_parsing"
,
"loc"
:
[
"path"
,
"item_id"
],
"msg"
:
"Input should be a valid integer, unable to parse string as an integer"
,
"input"
:
"foo"
,
"url"
:
"https://errors.pydantic.dev/2.1/v/int_parsing"
}
]
}
because the path parameter
item_id
had a value of
"foo"
, which is not an
int
.
The same error would appear if you provided a
float
instead of an
int
, as in:
http://127.0.0.1:8000/items/4.2
Check
So, with the same Python type declaration,
FastAPI
gives you data validation.
Notice that the error also clearly states exactly the point where the validation didn't pass.
This is incredibly helpful while developing and debugging code that interacts with your API.
Documentation
And when you open your browser at
http://127.0.0.1:8000/docs
, you will see an automatic, interactive, API documentation like:
Check
Again, just with that same Python type declaration,
FastAPI
gives you automatic, interactive documentation (integrating Swagger UI).
Notice that the path parameter is declared to be an integer.
Standards-based benefits, alternative documentation
And because the generated schema is from the
OpenAPI
standard, there are many compatible tools.
Because of this,
FastAPI
itself provides an alternative API documentation (using ReDoc), which you can access at
http://127.0.0.1:8000/redoc
:
The same way, there are many compatible tools. Including code generation tools for many languages.
Pydantic
All the data validation is performed under the hood by
Pydantic
, so you get all the benefits from it. And you know you are in good hands.
You can use the same type declarations with
str
,
float
,
bool
and many other complex data types.
Several of these are explored in the next chapters of the tutorial.
Order matters
When creating
path operations
, you can find situations where you have a fixed path.
Like
/users/me
, let's say that it's to get data about the current user.
And then you can also have a path
/users/{user_id}
to get data about a specific user by some user ID.
Because
path operations
are evaluated in order, you need to make sure that the path for
/users/me
is declared before the one for
/users/{user_id}
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/users/me"
)
async
def
read_user_me
():
return
{
"user_id"
:
"the current user"
}
@app
.
get
(
"/users/
{user_id}
"
)
async
def
read_user
(
user_id
:
str
):
return
{
"user_id"
:
user_id
}
Otherwise, the path for
/users/{user_id}
would match also for
/users/me
, "thinking" that it's receiving a parameter
user_id
with a value of
"me"
.
Similarly, you cannot redefine a path operation:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/users"
)
async
def
read_users
():
return
[
"Rick"
,
"Morty"
]
@app
.
get
(
"/users"
)
async
def
read_users2
():
return
[
"Bean"
,
"Elfo"
]
The first one will always be used since the path matches first.
Predefined values
If you have a
path operation
that receives a
path parameter
, but you want the possible valid
path parameter
values to be predefined, you can use a standard Python
Enum
.
Create an
Enum
class
Import
Enum
and create a sub-class that inherits from
str
and from
Enum
.
By inheriting from
str
the API docs will be able to know that the values must be of type
string
and will be able to render correctly.
Then create class attributes with fixed values, which will be the available valid values:
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
class
ModelName
(
str
,
Enum
):
alexnet
=
"alexnet"
resnet
=
"resnet"
lenet
=
"lenet"
app
=
FastAPI
()
@app
.
get
(
"/models/
{model_name}
"
)
async
def
get_model
(
model_name
:
ModelName
):
if
model_name
is
ModelName
.
alexnet
:
return
{
"model_name"
:
model_name
,
"message"
:
"Deep Learning FTW!"
}
if
model_name
.
value
==
"lenet"
:
return
{
"model_name"
:
model_name
,
"message"
:
"LeCNN all the images"
}
return
{
"model_name"
:
model_name
,
"message"
:
"Have some residuals"
}
Info
Enumerations (or enums) are available in Python
since version 3.4.
Tip
If you are wondering, "AlexNet", "ResNet", and "LeNet" are just names of Machine Learning
models
.
Declare a
path parameter
Then create a
path parameter
with a type annotation using the enum class you created (
ModelName
):
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
class
ModelName
(
str
,
Enum
):
alexnet
=
"alexnet"
resnet
=
"resnet"
lenet
=
"lenet"
app
=
FastAPI
()
@app
.
get
(
"/models/
{model_name}
"
)
async
def
get_model
(
model_name
:
ModelName
):
if
model_name
is
ModelName
.
alexnet
:
return
{
"model_name"
:
model_name
,
"message"
:
"Deep Learning FTW!"
}
if
model_name
.
value
==
"lenet"
:
return
{
"model_name"
:
model_name
,
"message"
:
"LeCNN all the images"
}
return
{
"model_name"
:
model_name
,
"message"
:
"Have some residuals"
}
Check the docs
Because the available values for the
path parameter
are predefined, the interactive docs can show them nicely:
Working with Python
enumerations
The value of the
path parameter
will be an
enumeration member
.
Compare
enumeration members
You can compare it with the
enumeration member
in your created enum
ModelName
:
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
class
ModelName
(
str
,
Enum
):
alexnet
=
"alexnet"
resnet
=
"resnet"
lenet
=
"lenet"
app
=
FastAPI
()
@app
.
get
(
"/models/
{model_name}
"
)
async
def
get_model
(
model_name
:
ModelName
):
if
model_name
is
ModelName
.
alexnet
:
return
{
"model_name"
:
model_name
,
"message"
:
"Deep Learning FTW!"
}
if
model_name
.
value
==
"lenet"
:
return
{
"model_name"
:
model_name
,
"message"
:
"LeCNN all the images"
}
return
{
"model_name"
:
model_name
,
"message"
:
"Have some residuals"
}
Get the
enumeration value
You can get the actual value (a
str
in this case) using
model_name.value
, or in general,
your_enum_member.value
:
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
class
ModelName
(
str
,
Enum
):
alexnet
=
"alexnet"
resnet
=
"resnet"
lenet
=
"lenet"
app
=
FastAPI
()
@app
.
get
(
"/models/
{model_name}
"
)
async
def
get_model
(
model_name
:
ModelName
):
if
model_name
is
ModelName
.
alexnet
:
return
{
"model_name"
:
model_name
,
"message"
:
"Deep Learning FTW!"
}
if
model_name
.
value
==
"lenet"
:
return
{
"model_name"
:
model_name
,
"message"
:
"LeCNN all the images"
}
return
{
"model_name"
:
model_name
,
"message"
:
"Have some residuals"
}
Tip
You could also access the value
"lenet"
with
ModelName.lenet.value
.
Return
enumeration members
You can return
enum members
from your
path operation
, even nested in a JSON body (e.g. a
dict
).
They will be converted to their corresponding values (strings in this case) before returning them to the client:
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
class
ModelName
(
str
,
Enum
):
alexnet
=
"alexnet"
resnet
=
"resnet"
lenet
=
"lenet"
app
=
FastAPI
()
@app
.
get
(
"/models/
{model_name}
"
)
async
def
get_model
(
model_name
:
ModelName
):
if
model_name
is
ModelName
.
alexnet
:
return
{
"model_name"
:
model_name
,
"message"
:
"Deep Learning FTW!"
}
if
model_name
.
value
==
"lenet"
:
return
{
"model_name"
:
model_name
,
"message"
:
"LeCNN all the images"
}
return
{
"model_name"
:
model_name
,
"message"
:
"Have some residuals"
}
In your client you will get a JSON response like:
{
"model_name"
:
"alexnet"
,
"message"
:
"Deep Learning FTW!"
}
Path parameters containing paths
Let's say you have a
path operation
with a path
/files/{file_path}
.
But you need
file_path
itself to contain a
path
, like
home/johndoe/myfile.txt
.
So, the URL for that file would be something like:
/files/home/johndoe/myfile.txt
.
OpenAPI support
OpenAPI doesn't support a way to declare a
path parameter
to contain a
path
inside, as that could lead to scenarios that are difficult to test and define.
Nevertheless, you can still do it in
FastAPI
, using one of the internal tools from Starlette.
And the docs would still work, although not adding any documentation telling that the parameter should contain a path.
Path convertor
Using an option directly from Starlette you can declare a
path parameter
containing a
path
using a URL like:
/files/{file_path:path}
In this case, the name of the parameter is
file_path
, and the last part,
:path
, tells it that the parameter should match any
path
.
So, you can use it with:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/files/{file_path:path}"
)
async
def
read_file
(
file_path
:
str
):
return
{
"file_path"
:
file_path
}
Tip
You could need the parameter to contain
/home/johndoe/myfile.txt
, with a leading slash (
/
).
In that case, the URL would be:
/files//home/johndoe/myfile.txt
, with a double slash (
//
) between
files
and
home
.
Recap
With
FastAPI
, by using short, intuitive and standard Python type declarations, you get:
Editor support: error checks, autocompletion, etc.
Data "
parsing
"
Data validation
API annotation and automatic documentation
And you only have to declare them once.
That's probably the main visible advantage of
FastAPI
compared to alternative frameworks (apart from the raw performance).

## 138_TUTORIAL_QUERY_PARAM_MODELS
Query Parameter Models¶
---

Query Parameter Models
If you have a group of
query parameters
that are related, you can create a
Pydantic model
to declare them.
This would allow you to
re-use the model
in
multiple places
and also to declare validations and metadata for all the parameters at once. 😎
Note
This is supported since FastAPI version
0.115.0
. 🤓
Query Parameters with a Pydantic Model
Declare the
query parameters
that you need in a
Pydantic model
, and then declare the parameter as
Query
:
Python 3.10+
from
typing
import
Annotated
,
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
,
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
,
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
FastAPI
will
extract
the data for
each field
from the
query parameters
in the request and give you the Pydantic model you defined.
Check the Docs
You can see the query parameters in the docs UI at
/docs
:
Forbid Extra Query Parameters
In some special use cases (probably not very common), you might want to
restrict
the query parameters that you want to receive.
You can use Pydantic's model configuration to
forbid
any
extra
fields:
Python 3.10+
from
typing
import
Annotated
,
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
,
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
,
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
If a client tries to send some
extra
data in the
query parameters
, they will receive an
error
response.
For example, if the client tries to send a
tool
query parameter with a value of
plumbus
, like:
https://example.com/items/?limit=10&tool=plumbus
They will receive an
error
response telling them that the query parameter
tool
is not allowed:
{
"detail"
:
[
{
"type"
:
"extra_forbidden"
,
"loc"
:
[
"query"
,
"tool"
],
"msg"
:
"Extra inputs are not permitted"
,
"input"
:
"plumbus"
}
]
}
Summary
You can use
Pydantic models
to declare
query parameters
in
FastAPI
. 😎
Tip
Spoiler alert: you can also use Pydantic models to declare cookies and headers, but you will read about that later in the tutorial. 🤫

## 139_TUTORIAL_QUERY_PARAMS_STR_VALIDATIONS
Query Parameters and String Validations¶
---

Query Parameters and String Validations
FastAPI
allows you to declare additional information and validation for your parameters.
Let's take this application as example:
Python 3.10+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
The query parameter
q
is of type
str | None
, that means that it's of type
str
but could also be
None
, and indeed, the default value is
None
, so FastAPI will know it's not required.
Note
FastAPI will know that the value of
q
is not required because of the default value
= None
.
Having
str | None
will allow your editor to give you better support and detect errors.
Additional validation
We are going to enforce that even though
q
is optional, whenever it is provided,
its length doesn't exceed 50 characters
.
Import
Query
and
Annotated
To achieve that, first import:
Query
from
fastapi
Annotated
from
typing
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Info
FastAPI added support for
Annotated
(and started recommending it) in version 0.95.0.
If you have an older version, you would get errors when trying to use
Annotated
.
Make sure you
Upgrade the FastAPI version
to at least 0.95.1 before using
Annotated
.
Use
Annotated
in the type for the
q
parameter
Remember I told you before that
Annotated
can be used to add metadata to your parameters in the
Python Types Intro
?
Now it's the time to use it with FastAPI. 🚀
We had this type annotation:
Python 3.10+
Python 3.8+
q
:
str
|
None
=
None
q
:
Union
[
str
,
None
]
=
None
What we will do is wrap that with
Annotated
, so it becomes:
Python 3.10+
Python 3.8+
q
:
Annotated
[
str
|
None
]
=
None
q
:
Annotated
[
Union
[
str
,
None
]]
=
None
Both of those versions mean the same thing,
q
is a parameter that can be a
str
or
None
, and by default, it is
None
.
Now let's jump to the fun stuff. 🎉
Add
Query
to
Annotated
in the
q
parameter
Now that we have this
Annotated
where we can put more information (in this case some additional validation), add
Query
inside of
Annotated
, and set the parameter
max_length
to
50
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Notice that the default value is still
None
, so the parameter is still optional.
But now, having
Query(max_length=50)
inside of
Annotated
, we are telling FastAPI that we want it to have
additional validation
for this value, we want it to have maximum 50 characters. 😎
Tip
Here we are using
Query()
because this is a
query parameter
. Later we will see others like
Path()
,
Body()
,
Header()
, and
Cookie()
, that also accept the same arguments as
Query()
.
FastAPI will now:
Validate
the data making sure that the max length is 50 characters
Show a
clear error
for the client when the data is not valid
Document
the parameter in the OpenAPI schema
path operation
(so it will show up in the
automatic docs UI
)
Alternative (old):
Query
as the default value
Previous versions of FastAPI (before
0.95.0
) required you to use
Query
as the default value of your parameter, instead of putting it in
Annotated
, there's a high chance that you will see code using it around, so I'll explain it to you.
Tip
For new code and whenever possible, use
Annotated
as explained above. There are multiple advantages (explained below) and no disadvantages. 🍰
This is how you would use
Query()
as the default value of your function parameter, setting the parameter
max_length
to 50:
Python 3.10+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.10+
Python 3.8+
Python 3.8+ - non-Annotated
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
As in this case (without using
Annotated
) we have to replace the default value
None
in the function with
Query()
, we now need to set the default value with the parameter
Query(default=None)
, it serves the same purpose of defining that default value (at least for FastAPI).
So:
q
:
str
|
None
=
Query
(
default
=
None
)
...makes the parameter optional, with a default value of
None
, the same as:
q
:
str
|
None
=
None
But the
Query
version declares it explicitly as being a query parameter.
Then, we can pass more parameters to
Query
. In this case, the
max_length
parameter that applies to strings:
q
:
str
|
None
=
Query
(
default
=
None
,
max_length
=
50
)
This will validate the data, show a clear error when the data is not valid, and document the parameter in the OpenAPI schema
path operation
.
Query
as the default value or in
Annotated
Keep in mind that when using
Query
inside of
Annotated
you cannot use the
default
parameter for
Query
.
Instead, use the actual default value of the function parameter. Otherwise, it would be inconsistent.
For example, this is not allowed:
q
:
Annotated
[
str
,
Query
(
default
=
"rick"
)]
=
"morty"
...because it's not clear if the default value should be
"rick"
or
"morty"
.
So, you would use (preferably):
q
:
Annotated
[
str
,
Query
()]
=
"rick"
...or in older code bases you will find:
q
:
str
=
Query
(
default
=
"rick"
)
Advantages of
Annotated
Using
Annotated
is recommended
instead of the default value in function parameters, it is
better
for multiple reasons. 🤓
The
default
value of the
function parameter
is the
actual default
value, that's more intuitive with Python in general. 😌
You could
call
that same function in
other places
without FastAPI, and it would
work as expected
. If there's a
required
parameter (without a default value), your
editor
will let you know with an error,
Python
will also complain if you run it without passing the required parameter.
When you don't use
Annotated
and instead use the
(old) default value style
, if you call that function without FastAPI in
other places
, you have to
remember
to pass the arguments to the function for it to work correctly, otherwise the values will be different from what you expect (e.g.
QueryInfo
or something similar instead of
str
). And your editor won't complain, and Python won't complain running that function, only when the operations inside error out.
Because
Annotated
can have more than one metadata annotation, you could now even use the same function with other tools, like
Typer
. 🚀
Add more validations
You can also add a parameter
min_length
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
min_length
=
3
,
max_length
=
50
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
,
max_length
=
50
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
,
max_length
=
50
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
min_length
=
3
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
min_length
=
3
,
max_length
=
50
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Add regular expressions
You can define a
regular expression
pattern
that the parameter should match:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
)
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
)
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
)
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
This specific regular expression pattern checks that the received parameter value:
^
: starts with the following characters, doesn't have characters before.
fixedquery
: has the exact value
fixedquery
.
$
: ends there, doesn't have any more characters after
fixedquery
.
If you feel lost with all these
"regular expression"
ideas, don't worry. They are a hard topic for many people. You can still do a lot of stuff without needing regular expressions yet.
Now you know that whenever you need them you can use them in
FastAPI
.
Pydantic v1
regex
instead of
pattern
Before Pydantic version 2 and before FastAPI 0.100.0, the parameter was called
regex
instead of
pattern
, but it's now deprecated.
You could still see some code using it:
Pydantic v1
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
min_length
=
3
,
max_length
=
50
,
regex
=
"^fixedquery$"
)
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
But know that this is deprecated and it should be updated to use the new parameter
pattern
. 🤓
Default values
You can, of course, use default values other than
None
.
Let's say that you want to declare the
q
query parameter to have a
min_length
of
3
, and to have a default value of
"fixedquery"
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
,
Query
(
min_length
=
3
)]
=
"fixedquery"
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
,
Query
(
min_length
=
3
)]
=
"fixedquery"
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
=
Query
(
default
=
"fixedquery"
,
min_length
=
3
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Note
Having a default value of any type, including
None
, makes the parameter optional (not required).
Required parameters
When we don't need to declare more validations or metadata, we can make the
q
query parameter required just by not declaring a default value, like:
q
:
str
instead of:
q
:
str
|
None
=
None
But we are now declaring it with
Query
, for example like:
Annotated
q
:
Annotated
[
str
|
None
,
Query
(
min_length
=
3
)]
=
None
So, when you need to declare a value as required while using
Query
, you can simply not declare a default value:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
,
Query
(
min_length
=
3
)]):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
,
Query
(
min_length
=
3
)]):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
=
Query
(
min_length
=
3
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Required, can be
None
You can declare that a parameter can accept
None
, but that it's still required. This would force clients to send a value, even if the value is
None
.
To do that, you can declare that
None
is a valid type but simply do not declare a default value:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
min_length
=
3
)]):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
)]):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
)]):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
min_length
=
3
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
min_length
=
3
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Query parameter list / multiple values
When you define a query parameter explicitly with
Query
you can also declare it to receive a list of values, or said in another way, to receive multiple values.
For example, to declare a query parameter
q
that can appear multiple times in the URL, you can write:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
list
[
str
]
|
None
,
Query
()]
=
None
):
query_items
=
{
"q"
:
q
}
return
query_items
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
list
[
str
],
None
],
Query
()]
=
None
):
query_items
=
{
"q"
:
q
}
return
query_items
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
List
[
str
],
None
],
Query
()]
=
None
):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
list
[
str
]
|
None
=
Query
(
default
=
None
)):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
list
[
str
],
None
]
=
Query
(
default
=
None
)):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
List
[
str
],
None
]
=
Query
(
default
=
None
)):
query_items
=
{
"q"
:
q
}
return
query_items
Then, with a URL like:
http://localhost:8000/items/?q=foo&q=bar
you would receive the multiple
q
query parameters'
values (
foo
and
bar
) in a Python
list
inside your
path operation function
, in the
function parameter
q
.
So, the response to that URL would be:
{
"q"
:
[
"foo"
,
"bar"
]
}
Tip
To declare a query parameter with a type of
list
, like in the example above, you need to explicitly use
Query
, otherwise it would be interpreted as a request body.
The interactive API docs will update accordingly, to allow multiple values:
Query parameter list / multiple values with defaults
You can also define a default
list
of values if none are provided:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
list
[
str
],
Query
()]
=
[
"foo"
,
"bar"
]):
query_items
=
{
"q"
:
q
}
return
query_items
🤓 Other versions and variants
Python 3.8+
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
List
[
str
],
Query
()]
=
[
"foo"
,
"bar"
]):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
list
[
str
]
=
Query
(
default
=
[
"foo"
,
"bar"
])):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
List
[
str
]
=
Query
(
default
=
[
"foo"
,
"bar"
])):
query_items
=
{
"q"
:
q
}
return
query_items
If you go to:
http://localhost:8000/items/
the default of
q
will be:
["foo", "bar"]
and your response will be:
{
"q"
:
[
"foo"
,
"bar"
]
}
Using just
list
You can also use
list
directly instead of
list[str]
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
list
,
Query
()]
=
[]):
query_items
=
{
"q"
:
q
}
return
query_items
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
list
,
Query
()]
=
[]):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
list
=
Query
(
default
=
[])):
query_items
=
{
"q"
:
q
}
return
query_items
Note
Keep in mind that in this case, FastAPI won't check the contents of the list.
For example,
list[int]
would check (and document) that the contents of the list are integers. But
list
alone wouldn't.
Declare more metadata
You can add more information about the parameter.
That information will be included in the generated OpenAPI and used by the documentation user interfaces and external tools.
Note
Keep in mind that different tools might have different levels of OpenAPI support.
Some of them might not show all the extra information declared yet, although in most of the cases, the missing feature is already planned for development.
You can add a
title
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
title
=
"Query string"
,
min_length
=
3
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
title
=
"Query string"
,
min_length
=
3
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
title
=
"Query string"
,
min_length
=
3
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
title
=
"Query string"
,
min_length
=
3
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
title
=
"Query string"
,
min_length
=
3
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
And a
description
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Alias parameters
Imagine that you want the parameter to be
item-query
.
Like in:
http://127.0.0.1:8000/items/?item-query=foobaritems
But
item-query
is not a valid Python variable name.
The closest would be
item_query
.
But you still need it to be exactly
item-query
...
Then you can declare an
alias
, and that alias is what will be used to find the parameter value:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
alias
=
"item-query"
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
alias
=
"item-query"
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
alias
=
"item-query"
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Deprecating parameters
Now let's say you don't like this parameter anymore.
You have to leave it there a while because there are clients using it, but you want the docs to clearly show it as
deprecated
.
Then pass the parameter
deprecated=True
to
Query
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
alias
=
"item-query"
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
,
deprecated
=
True
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
,
deprecated
=
True
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
,
deprecated
=
True
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
alias
=
"item-query"
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
,
deprecated
=
True
,
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
alias
=
"item-query"
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
,
deprecated
=
True
,
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
The docs will show it like this:
Exclude parameters from OpenAPI
To exclude a query parameter from the generated OpenAPI schema (and thus, from the automatic documentation systems), set the parameter
include_in_schema
of
Query
to
False
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
hidden_query
:
Annotated
[
str
|
None
,
Query
(
include_in_schema
=
False
)]
=
None
,
):
if
hidden_query
:
return
{
"hidden_query"
:
hidden_query
}
else
:
return
{
"hidden_query"
:
"Not found"
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
hidden_query
:
Annotated
[
Union
[
str
,
None
],
Query
(
include_in_schema
=
False
)]
=
None
,
):
if
hidden_query
:
return
{
"hidden_query"
:
hidden_query
}
else
:
return
{
"hidden_query"
:
"Not found"
}
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
hidden_query
:
Annotated
[
Union
[
str
,
None
],
Query
(
include_in_schema
=
False
)]
=
None
,
):
if
hidden_query
:
return
{
"hidden_query"
:
hidden_query
}
else
:
return
{
"hidden_query"
:
"Not found"
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
hidden_query
:
str
|
None
=
Query
(
default
=
None
,
include_in_schema
=
False
),
):
if
hidden_query
:
return
{
"hidden_query"
:
hidden_query
}
else
:
return
{
"hidden_query"
:
"Not found"
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
hidden_query
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
include_in_schema
=
False
),
):
if
hidden_query
:
return
{
"hidden_query"
:
hidden_query
}
else
:
return
{
"hidden_query"
:
"Not found"
}
Custom Validation
There could be cases where you need to do some
custom validation
that can't be done with the parameters shown above.
In those cases, you can use a
custom validator function
that is applied after the normal validation (e.g. after validating that the value is a
str
).
You can achieve that using
Pydantic's
AfterValidator
inside of
Annotated
.
Tip
Pydantic also has
BeforeValidator
and others. 🤓
For example, this custom validator checks that the item ID starts with
isbn-
for an
ISBN
book number or with
imdb-
for an
IMDB
movie URL ID:
Python 3.10+
import
random
from
typing
import
Annotated
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
str
|
None
,
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
import
random
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
import
random
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
from
typing_extensions
import
Annotated
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
Info
This is available with Pydantic version 2 or above. 😎
Tip
If you need to do any type of validation that requires communicating with any
external component
, like a database or another API, you should instead use
FastAPI Dependencies
, you will learn about them later.
These custom validators are for things that can be checked with
only
the
same data
provided in the request.
Understand that Code
The important point is just using
AfterValidator
with a function inside
Annotated
. Feel free to skip this part. 🤸
But if you're curious about this specific code example and you're still entertained, here are some extra details.
String with
value.startswith()
Did you notice? a string using
value.startswith()
can take a tuple, and it will check each value in the tuple:
Python 3.10+
## Code above omitted 👆
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
## Code below omitted 👇
👀 Full file preview
Python 3.10+
import
random
from
typing
import
Annotated
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
str
|
None
,
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
import
random
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
import
random
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
from
typing_extensions
import
Annotated
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
A Random Item
With
data.items()
we get an
iterable object
with tuples containing the key and value for each dictionary item.
We convert this iterable object into a proper
list
with
list(data.items())
.
Then with
random.choice()
we can get a
random value
from the list, so, we get a tuple with
(id, name)
. It will be something like
("imdb-tt0371724", "The Hitchhiker's Guide to the Galaxy")
.
Then we
assign those two values
of the tuple to the variables
id
and
name
.
So, if the user didn't provide an item ID, they will still receive a random suggestion.
...we do all this in a
single simple line
. 🤯 Don't you love Python? 🐍
Python 3.10+
## Code above omitted 👆
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
str
|
None
,
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
👀 Full file preview
Python 3.10+
import
random
from
typing
import
Annotated
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
str
|
None
,
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
import
random
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
import
random
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
from
typing_extensions
import
Annotated
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
Recap
You can declare additional validations and metadata for your parameters.
Generic validations and metadata:
alias
title
description
deprecated
Validations specific for strings:
min_length
max_length
pattern
Custom validations using
AfterValidator
.
In these examples you saw how to declare validations for
str
values.
See the next chapters to learn how to declare validations for other types, like numbers.

## 140_TUTORIAL_QUERY_PARAMS
Query Parameters¶
---

Query Parameters
When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as "query" parameters.
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
@app
.
get
(
"/items/"
)
async
def
read_item
(
skip
:
int
=
0
,
limit
:
int
=
10
):
return
fake_items_db
[
skip
:
skip
+
limit
]
The query is the set of key-value pairs that go after the
?
in a URL, separated by
&
characters.
For example, in the URL:
http://127.0.0.1:8000/items/?skip=0&limit=10
...the query parameters are:
skip
: with a value of
0
limit
: with a value of
10
As they are part of the URL, they are "naturally" strings.
But when you declare them with Python types (in the example above, as
int
), they are converted to that type and validated against it.
All the same process that applied for path parameters also applies for query parameters:
Editor support (obviously)
Data
"parsing"
Data validation
Automatic documentation
Defaults
As query parameters are not a fixed part of a path, they can be optional and can have default values.
In the example above they have default values of
skip=0
and
limit=10
.
So, going to the URL:
http://127.0.0.1:8000/items/
would be the same as going to:
http://127.0.0.1:8000/items/?skip=0&limit=10
But if you go to, for example:
http://127.0.0.1:8000/items/?skip=20
The parameter values in your function will be:
skip=20
: because you set it in the URL
limit=10
: because that was the default value
Optional parameters
The same way, you can declare optional query parameters, by setting their default to
None
:
Python 3.10+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
,
q
:
str
|
None
=
None
):
if
q
:
return
{
"item_id"
:
item_id
,
"q"
:
q
}
return
{
"item_id"
:
item_id
}
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
,
q
:
Union
[
str
,
None
]
=
None
):
if
q
:
return
{
"item_id"
:
item_id
,
"q"
:
q
}
return
{
"item_id"
:
item_id
}
In this case, the function parameter
q
will be optional, and will be
None
by default.
Check
Also notice that
FastAPI
is smart enough to notice that the path parameter
item_id
is a path parameter and
q
is not, so, it's a query parameter.
Query parameter type conversion
You can also declare
bool
types, and they will be converted:
Python 3.10+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
,
q
:
str
|
None
=
None
,
short
:
bool
=
False
):
item
=
{
"item_id"
:
item_id
}
if
q
:
item
.
update
({
"q"
:
q
})
if
not
short
:
item
.
update
(
{
"description"
:
"This is an amazing item that has a long description"
}
)
return
item
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
,
q
:
Union
[
str
,
None
]
=
None
,
short
:
bool
=
False
):
item
=
{
"item_id"
:
item_id
}
if
q
:
item
.
update
({
"q"
:
q
})
if
not
short
:
item
.
update
(
{
"description"
:
"This is an amazing item that has a long description"
}
)
return
item
In this case, if you go to:
http://127.0.0.1:8000/items/foo?short=1
or
http://127.0.0.1:8000/items/foo?short=True
or
http://127.0.0.1:8000/items/foo?short=true
or
http://127.0.0.1:8000/items/foo?short=on
or
http://127.0.0.1:8000/items/foo?short=yes
or any other case variation (uppercase, first letter in uppercase, etc), your function will see the parameter
short
with a
bool
value of
True
. Otherwise as
False
.
Multiple path and query parameters
You can declare multiple path parameters and query parameters at the same time,
FastAPI
knows which is which.
And you don't have to declare them in any specific order.
They will be detected by name:
Python 3.10+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/users/
{user_id}
/items/
{item_id}
"
)
async
def
read_user_item
(
user_id
:
int
,
item_id
:
str
,
q
:
str
|
None
=
None
,
short
:
bool
=
False
):
item
=
{
"item_id"
:
item_id
,
"owner_id"
:
user_id
}
if
q
:
item
.
update
({
"q"
:
q
})
if
not
short
:
item
.
update
(
{
"description"
:
"This is an amazing item that has a long description"
}
)
return
item
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/users/
{user_id}
/items/
{item_id}
"
)
async
def
read_user_item
(
user_id
:
int
,
item_id
:
str
,
q
:
Union
[
str
,
None
]
=
None
,
short
:
bool
=
False
):
item
=
{
"item_id"
:
item_id
,
"owner_id"
:
user_id
}
if
q
:
item
.
update
({
"q"
:
q
})
if
not
short
:
item
.
update
(
{
"description"
:
"This is an amazing item that has a long description"
}
)
return
item
Required query parameters
When you declare a default value for non-path parameters (for now, we have only seen query parameters), then it is not required.
If you don't want to add a specific value but just make it optional, set the default as
None
.
But when you want to make a query parameter required, you can just not declare any default value:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_user_item
(
item_id
:
str
,
needy
:
str
):
item
=
{
"item_id"
:
item_id
,
"needy"
:
needy
}
return
item
Here the query parameter
needy
is a required query parameter of type
str
.
If you open in your browser a URL like:
http://127.0.0.1:8000/items/foo-item
...without adding the required parameter
needy
, you will see an error like:
{
"detail"
:
[
{
"type"
:
"missing"
,
"loc"
:
[
"query"
,
"needy"
],
"msg"
:
"Field required"
,
"input"
:
null
,
"url"
:
"https://errors.pydantic.dev/2.1/v/missing"
}
]
}
As
needy
is a required parameter, you would need to set it in the URL:
http://127.0.0.1:8000/items/foo-item?needy=sooooneedy
...this would work:
{
"item_id"
:
"foo-item"
,
"needy"
:
"sooooneedy"
}
And of course, you can define some parameters as required, some as having a default value, and some entirely optional:
Python 3.10+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_user_item
(
item_id
:
str
,
needy
:
str
,
skip
:
int
=
0
,
limit
:
int
|
None
=
None
):
item
=
{
"item_id"
:
item_id
,
"needy"
:
needy
,
"skip"
:
skip
,
"limit"
:
limit
}
return
item
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_user_item
(
item_id
:
str
,
needy
:
str
,
skip
:
int
=
0
,
limit
:
Union
[
int
,
None
]
=
None
):
item
=
{
"item_id"
:
item_id
,
"needy"
:
needy
,
"skip"
:
skip
,
"limit"
:
limit
}
return
item
In this case, there are 3 query parameters:
needy
, a required
str
.
skip
, an
int
with a default value of
0
.
limit
, an optional
int
.
Tip
You could also use
Enum
s the same way as with
Path Parameters
.

## 141_TUTORIAL_REQUEST_FILES
Request Files¶
---

Request Files
You can define files to be uploaded by the client using
File
.
Info
To receive uploaded files, first install
python-multipart
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
python-multipart
This is because uploaded files are sent as "form data".
Import
File
Import
File
and
UploadFile
from
fastapi
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
()):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Define
File
Parameters
Create file parameters the same way you would for
Body
or
Form
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
()):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Info
File
is a class that inherits directly from
Form
.
But remember that when you import
Query
,
Path
,
File
and others from
fastapi
, those are actually functions that return special classes.
Tip
To declare File bodies, you need to use
File
, because otherwise the parameters would be interpreted as query parameters or body (JSON) parameters.
The files will be uploaded as "form data".
If you declare the type of your
path operation function
parameter as
bytes
,
FastAPI
will read the file for you and you will receive the contents as
bytes
.
Keep in mind that this means that the whole contents will be stored in memory. This will work well for small files.
But there are several cases in which you might benefit from using
UploadFile
.
File Parameters with
UploadFile
Define a file parameter with a type of
UploadFile
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
()):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Using
UploadFile
has several advantages over
bytes
:
You don't have to use
File()
in the default value of the parameter.
It uses a "spooled" file:
A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk.
This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory.
You can get metadata from the uploaded file.
It has a
file-like
async
interface.
It exposes an actual Python
SpooledTemporaryFile
object that you can pass directly to other libraries that expect a file-like object.
UploadFile
UploadFile
has the following attributes:
filename
: A
str
with the original file name that was uploaded (e.g.
myimage.jpg
).
content_type
: A
str
with the content type (MIME type / media type) (e.g.
image/jpeg
).
file
: A
SpooledTemporaryFile
(a
file-like
object). This is the actual Python file object that you can pass directly to other functions or libraries that expect a "file-like" object.
UploadFile
has the following
async
methods. They all call the corresponding file methods underneath (using the internal
SpooledTemporaryFile
).
write(data)
: Writes
data
(
str
or
bytes
) to the file.
read(size)
: Reads
size
(
int
) bytes/characters of the file.
seek(offset)
: Goes to the byte position
offset
(
int
) in the file.
E.g.,
await myfile.seek(0)
would go to the start of the file.
This is especially useful if you run
await myfile.read()
once and then need to read the contents again.
close()
: Closes the file.
As all these methods are
async
methods, you need to "await" them.
For example, inside of an
async
path operation function
you can get the contents with:
contents
=
await
myfile
.
read
()
If you are inside of a normal
def
path operation function
, you can access the
UploadFile.file
directly, for example:
contents
=
myfile
.
file
.
read
()
async
Technical Details
When you use the
async
methods,
FastAPI
runs the file methods in a threadpool and awaits for them.
Starlette Technical Details
FastAPI
's
UploadFile
inherits directly from
Starlette
's
UploadFile
, but adds some necessary parts to make it compatible with
Pydantic
and the other parts of FastAPI.
What is "Form Data"
The way HTML forms (
<form></form>
) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.
FastAPI
will make sure to read that data from the right place instead of JSON.
Technical Details
Data from forms is normally encoded using the "media type"
application/x-www-form-urlencoded
when it doesn't include files.
But when the form includes files, it is encoded as
multipart/form-data
. If you use
File
,
FastAPI
will know it has to get the files from the correct part of the body.
If you want to read more about these encodings and form fields, head to the
MDN
web docs for
POST
.
Warning
You can declare multiple
File
and
Form
parameters in a
path operation
, but you can't also declare
Body
fields that you expect to receive as JSON, as the request will have the body encoded using
multipart/form-data
instead of
application/json
.
This is not a limitation of
FastAPI
, it's part of the HTTP protocol.
Optional File Upload
You can make a file optional by using standard type annotations and setting a default value of
None
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
|
None
,
File
()]
=
None
):
if
not
file
:
return
{
"message"
:
"No file sent"
}
else
:
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
|
None
=
None
):
if
not
file
:
return
{
"message"
:
"No upload file sent"
}
else
:
return
{
"filename"
:
file
.
filename
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
Union
[
bytes
,
None
],
File
()]
=
None
):
if
not
file
:
return
{
"message"
:
"No file sent"
}
else
:
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
Union
[
UploadFile
,
None
]
=
None
):
if
not
file
:
return
{
"message"
:
"No upload file sent"
}
else
:
return
{
"filename"
:
file
.
filename
}
from
typing
import
Union
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
Union
[
bytes
,
None
],
File
()]
=
None
):
if
not
file
:
return
{
"message"
:
"No file sent"
}
else
:
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
Union
[
UploadFile
,
None
]
=
None
):
if
not
file
:
return
{
"message"
:
"No upload file sent"
}
else
:
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
|
None
=
File
(
default
=
None
)):
if
not
file
:
return
{
"message"
:
"No file sent"
}
else
:
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
|
None
=
None
):
if
not
file
:
return
{
"message"
:
"No upload file sent"
}
else
:
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Union
[
bytes
,
None
]
=
File
(
default
=
None
)):
if
not
file
:
return
{
"message"
:
"No file sent"
}
else
:
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
Union
[
UploadFile
,
None
]
=
None
):
if
not
file
:
return
{
"message"
:
"No upload file sent"
}
else
:
return
{
"filename"
:
file
.
filename
}
UploadFile
with Additional Metadata
You can also use
File()
with
UploadFile
, for example, to set additional metadata:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
(
description
=
"A file read as bytes"
)]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
Annotated
[
UploadFile
,
File
(
description
=
"A file read as UploadFile"
)],
):
return
{
"filename"
:
file
.
filename
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
(
description
=
"A file read as bytes"
)]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
Annotated
[
UploadFile
,
File
(
description
=
"A file read as UploadFile"
)],
):
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
(
description
=
"A file read as bytes"
)):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
=
File
(
description
=
"A file read as UploadFile"
),
):
return
{
"filename"
:
file
.
filename
}
Multiple File Uploads
It's possible to upload several files at the same time.
They would be associated to the same "form field" sent using "form data".
To use that, declare a list of
bytes
or
UploadFile
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
Annotated
[
list
[
bytes
],
File
()]):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
list
[
UploadFile
]):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
🤓 Other versions and variants
Python 3.8+
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
List
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
Annotated
[
List
[
bytes
],
File
()]):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
List
[
UploadFile
]):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
list
[
bytes
]
=
File
()):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
list
[
UploadFile
]):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
List
[
bytes
]
=
File
()):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
List
[
UploadFile
]):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
You will receive, as declared, a
list
of
bytes
or
UploadFile
s.
Technical Details
You could also use
from starlette.responses import HTMLResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
Multiple File Uploads with Additional Metadata
And the same way as before, you can use
File()
to set additional parameters, even for
UploadFile
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
Annotated
[
list
[
bytes
],
File
(
description
=
"Multiple files as bytes"
)],
):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
Annotated
[
list
[
UploadFile
],
File
(
description
=
"Multiple files as UploadFile"
)
],
):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
🤓 Other versions and variants
Python 3.8+
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
List
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
Annotated
[
List
[
bytes
],
File
(
description
=
"Multiple files as bytes"
)],
):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
Annotated
[
List
[
UploadFile
],
File
(
description
=
"Multiple files as UploadFile"
)
],
):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
list
[
bytes
]
=
File
(
description
=
"Multiple files as bytes"
),
):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
list
[
UploadFile
]
=
File
(
description
=
"Multiple files as UploadFile"
),
):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
List
[
bytes
]
=
File
(
description
=
"Multiple files as bytes"
),
):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
List
[
UploadFile
]
=
File
(
description
=
"Multiple files as UploadFile"
),
):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
Recap
Use
File
,
bytes
, and
UploadFile
to declare files to be uploaded in the request, sent as form data.

## 142_TUTORIAL_REQUEST_FORM_MODELS
Form Models¶
---

Form Models
You can use
Pydantic models
to declare
form fields
in FastAPI.
Info
To use forms, first install
python-multipart
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
python-multipart
Note
This is supported since FastAPI version
0.113.0
. 🤓
Pydantic Models for Forms
You just need to declare a
Pydantic model
with the fields you want to receive as
form fields
, and then declare the parameter as
Form
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
FormData
=
Form
()):
return
data
FastAPI
will
extract
the data for
each field
from the
form data
in the request and give you the Pydantic model you defined.
Check the Docs
You can verify it in the docs UI at
/docs
:
Forbid Extra Form Fields
In some special use cases (probably not very common), you might want to
restrict
the form fields to only those declared in the Pydantic model. And
forbid
any
extra
fields.
Note
This is supported since FastAPI version
0.114.0
. 🤓
You can use Pydantic's model configuration to
forbid
any
extra
fields:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
model_config
=
{
"extra"
:
"forbid"
}
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
model_config
=
{
"extra"
:
"forbid"
}
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
model_config
=
{
"extra"
:
"forbid"
}
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
FormData
=
Form
()):
return
data
If a client tries to send some extra data, they will receive an
error
response.
For example, if the client tries to send the form fields:
username
:
Rick
password
:
Portal Gun
extra
:
Mr. Poopybutthole
They will receive an error response telling them that the field
extra
is not allowed:
{
"detail"
:
[
{
"type"
:
"extra_forbidden"
,
"loc"
:
[
"body"
,
"extra"
],
"msg"
:
"Extra inputs are not permitted"
,
"input"
:
"Mr. Poopybutthole"
}
]
}
Summary
You can use Pydantic models to declare form fields in FastAPI. 😎

## 143_TUTORIAL_REQUEST_FORMS_AND_FILES
Request Forms and Files¶
---

Request Forms and Files
You can define files and form fields at the same time using
File
and
Form
.
Info
To receive uploaded files and/or form data, first install
python-multipart
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
python-multipart
Import
File
and
Form
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()],
fileb
:
Annotated
[
UploadFile
,
File
()],
token
:
Annotated
[
str
,
Form
()],
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()],
fileb
:
Annotated
[
UploadFile
,
File
()],
token
:
Annotated
[
str
,
Form
()],
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
(),
fileb
:
UploadFile
=
File
(),
token
:
str
=
Form
()
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
Define
File
and
Form
parameters
Create file and form parameters the same way you would for
Body
or
Query
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()],
fileb
:
Annotated
[
UploadFile
,
File
()],
token
:
Annotated
[
str
,
Form
()],
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()],
fileb
:
Annotated
[
UploadFile
,
File
()],
token
:
Annotated
[
str
,
Form
()],
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
(),
fileb
:
UploadFile
=
File
(),
token
:
str
=
Form
()
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
The files and form fields will be uploaded as form data and you will receive the files and form fields.
And you can declare some of the files as
bytes
and some as
UploadFile
.
Warning
You can declare multiple
File
and
Form
parameters in a
path operation
, but you can't also declare
Body
fields that you expect to receive as JSON, as the request will have the body encoded using
multipart/form-data
instead of
application/json
.
This is not a limitation of
FastAPI
, it's part of the HTTP protocol.
Recap
Use
File
and
Form
together when you need to receive data and files in the same request.

## 144_TUTORIAL_REQUEST_FORMS
Form Data¶
---

Form Data
When you need to receive form fields instead of JSON, you can use
Form
.
Info
To use forms, first install
python-multipart
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
python-multipart
Import
Form
Import
Form
from
fastapi
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
Annotated
[
str
,
Form
()],
password
:
Annotated
[
str
,
Form
()]):
return
{
"username"
:
username
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Form
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
Annotated
[
str
,
Form
()],
password
:
Annotated
[
str
,
Form
()]):
return
{
"username"
:
username
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Form
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
str
=
Form
(),
password
:
str
=
Form
()):
return
{
"username"
:
username
}
Define
Form
parameters
Create form parameters the same way you would for
Body
or
Query
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
Annotated
[
str
,
Form
()],
password
:
Annotated
[
str
,
Form
()]):
return
{
"username"
:
username
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Form
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
Annotated
[
str
,
Form
()],
password
:
Annotated
[
str
,
Form
()]):
return
{
"username"
:
username
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Form
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
str
=
Form
(),
password
:
str
=
Form
()):
return
{
"username"
:
username
}
For example, in one of the ways the OAuth2 specification can be used (called "password flow") it is required to send a
username
and
password
as form fields.
The
spec
requires the fields to be exactly named
username
and
password
, and to be sent as form fields, not JSON.
With
Form
you can declare the same configurations as with
Body
(and
Query
,
Path
,
Cookie
), including validation, examples, an alias (e.g.
user-name
instead of
username
), etc.
Info
Form
is a class that inherits directly from
Body
.
Tip
To declare form bodies, you need to use
Form
explicitly, because without it the parameters would be interpreted as query parameters or body (JSON) parameters.
About "Form Fields"
The way HTML forms (
<form></form>
) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.
FastAPI
will make sure to read that data from the right place instead of JSON.
Technical Details
Data from forms is normally encoded using the "media type"
application/x-www-form-urlencoded
.
But when the form includes files, it is encoded as
multipart/form-data
. You'll read about handling files in the next chapter.
If you want to read more about these encodings and form fields, head to the
MDN
web docs for
POST
.
Warning
You can declare multiple
Form
parameters in a
path operation
, but you can't also declare
Body
fields that you expect to receive as JSON, as the request will have the body encoded using
application/x-www-form-urlencoded
instead of
application/json
.
This is not a limitation of
FastAPI
, it's part of the HTTP protocol.
Recap
Use
Form
to declare form data input parameters.

## 145_TUTORIAL_RESPONSE_MODEL
Response Model - Return Type¶
---

Response Model - Return Type
You can declare the type used for the response by annotating the
path operation function
return type
.
You can use
type annotations
the same way you would for input data in function
parameters
, you can use Pydantic models, lists, dictionaries, scalar values like integers, booleans, etc.
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
list
[
str
]
=
[]
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
)
->
Item
:
return
item
@app
.
get
(
"/items/"
)
async
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
price
=
42.0
),
Item
(
name
=
"Plumbus"
,
price
=
32.0
),
]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
list
[
str
]
=
[]
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
)
->
Item
:
return
item
@app
.
get
(
"/items/"
)
async
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
price
=
42.0
),
Item
(
name
=
"Plumbus"
,
price
=
32.0
),
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
List
[
str
]
=
[]
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
)
->
Item
:
return
item
@app
.
get
(
"/items/"
)
async
def
read_items
()
->
List
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
price
=
42.0
),
Item
(
name
=
"Plumbus"
,
price
=
32.0
),
]
FastAPI will use this return type to:
Validate
the returned data.
If the data is invalid (e.g. you are missing a field), it means that
your
app code is broken, not returning what it should, and it will return a server error instead of returning incorrect data. This way you and your clients can be certain that they will receive the data and the data shape expected.
Add a
JSON Schema
for the response, in the OpenAPI
path operation
.
This will be used by the
automatic docs
.
It will also be used by automatic client code generation tools.
But most importantly:
It will
limit and filter
the output data to what is defined in the return type.
This is particularly important for
security
, we'll see more of that below.
response_model
Parameter
There are some cases where you need or want to return some data that is not exactly what the type declares.
For example, you could want to
return a dictionary
or a database object, but
declare it as a Pydantic model
. This way the Pydantic model would do all the data documentation, validation, etc. for the object that you returned (e.g. a dictionary or database object).
If you added the return type annotation, tools and editors would complain with a (correct) error telling you that your function is returning a type (e.g. a dict) that is different from what you declared (e.g. a Pydantic model).
In those cases, you can use the
path operation decorator
parameter
response_model
instead of the return type.
You can use the
response_model
parameter in any of the
path operations
:
@app.get()
@app.post()
@app.put()
@app.delete()
etc.
Python 3.10+
from
typing
import
Any
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
list
[
str
]
=
[]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
)
->
Any
:
return
item
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
])
async
def
read_items
()
->
Any
:
return
[
{
"name"
:
"Portal Gun"
,
"price"
:
42.0
},
{
"name"
:
"Plumbus"
,
"price"
:
32.0
},
]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Any
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
list
[
str
]
=
[]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
)
->
Any
:
return
item
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
])
async
def
read_items
()
->
Any
:
return
[
{
"name"
:
"Portal Gun"
,
"price"
:
42.0
},
{
"name"
:
"Plumbus"
,
"price"
:
32.0
},
]
from
typing
import
Any
,
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
List
[
str
]
=
[]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
)
->
Any
:
return
item
@app
.
get
(
"/items/"
,
response_model
=
List
[
Item
])
async
def
read_items
()
->
Any
:
return
[
{
"name"
:
"Portal Gun"
,
"price"
:
42.0
},
{
"name"
:
"Plumbus"
,
"price"
:
32.0
},
]
Note
Notice that
response_model
is a parameter of the "decorator" method (
get
,
post
, etc). Not of your
path operation function
, like all the parameters and body.
response_model
receives the same type you would declare for a Pydantic model field, so, it can be a Pydantic model, but it can also be, e.g. a
list
of Pydantic models, like
List[Item]
.
FastAPI will use this
response_model
to do all the data documentation, validation, etc. and also to
convert and filter the output data
to its type declaration.
Tip
If you have strict type checks in your editor, mypy, etc, you can declare the function return type as
Any
.
That way you tell the editor that you are intentionally returning anything. But FastAPI will still do the data documentation, validation, filtering, etc. with the
response_model
.
response_model
Priority
If you declare both a return type and a
response_model
, the
response_model
will take priority and be used by FastAPI.
This way you can add correct type annotations to your functions even when you are returning a type different than the response model, to be used by the editor and tools like mypy. And still you can have FastAPI do the data validation, documentation, etc. using the
response_model
.
You can also use
response_model=None
to disable creating a response model for that
path operation
, you might need to do it if you are adding type annotations for things that are not valid Pydantic fields, you will see an example of that in one of the sections below.
Return the same input data
Here we are declaring a
UserIn
model, it will contain a plaintext password:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
## Don't do this in production!
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
UserIn
:
return
user
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
## Don't do this in production!
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
UserIn
:
return
user
Info
To use
EmailStr
, first install
email-validator
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
email-validator
or with:
$
pip
install
"pydantic[email]"
And we are using this model to declare our input and the same model to declare our output:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
## Don't do this in production!
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
UserIn
:
return
user
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
## Don't do this in production!
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
UserIn
:
return
user
Now, whenever a browser is creating a user with a password, the API will return the same password in the response.
In this case, it might not be a problem, because it's the same user sending the password.
But if we use the same model for another
path operation
, we could be sending our user's passwords to every client.
Danger
Never store the plain password of a user or send it in a response like this, unless you know all the caveats and you know what you are doing.
Add an output model
We can instead create an input model with the plaintext password and an output model without it:
Python 3.10+
from
typing
import
Any
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
🤓 Other versions and variants
Python 3.8+
from
typing
import
Any
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
Here, even though our
path operation function
is returning the same input user that contains the password:
Python 3.10+
from
typing
import
Any
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
🤓 Other versions and variants
Python 3.8+
from
typing
import
Any
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
...we declared the
response_model
to be our model
UserOut
, that doesn't include the password:
Python 3.10+
from
typing
import
Any
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
🤓 Other versions and variants
Python 3.8+
from
typing
import
Any
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
So,
FastAPI
will take care of filtering out all the data that is not declared in the output model (using Pydantic).
response_model
or Return Type
In this case, because the two models are different, if we annotated the function return type as
UserOut
, the editor and tools would complain that we are returning an invalid type, as those are different classes.
That's why in this example we have to declare it in the
response_model
parameter.
...but continue reading below to see how to overcome that.
Return Type and Data Filtering
Let's continue from the previous example. We wanted to
annotate the function with one type
, but we wanted to be able to return from the function something that actually includes
more data
.
We want FastAPI to keep
filtering
the data using the response model. So that even though the function returns more data, the response will only include the fields declared in the response model.
In the previous example, because the classes were different, we had to use the
response_model
parameter. But that also means that we don't get the support from the editor and tools checking the function return type.
But in most of the cases where we need to do something like this, we want the model just to
filter/remove
some of the data as in this example.
And in those cases, we can use classes and inheritance to take advantage of function
type annotations
to get better support in the editor and tools, and still get the FastAPI
data filtering
.
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
BaseUser
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserIn
(
BaseUser
):
password
:
str
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
BaseUser
:
return
user
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
BaseUser
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserIn
(
BaseUser
):
password
:
str
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
BaseUser
:
return
user
With this, we get tooling support, from editors and mypy as this code is correct in terms of types, but we also get the data filtering from FastAPI.
How does this work? Let's check that out. 🤓
Type Annotations and Tooling
First let's see how editors, mypy and other tools would see this.
BaseUser
has the base fields. Then
UserIn
inherits from
BaseUser
and adds the
password
field, so, it will include all the fields from both models.
We annotate the function return type as
BaseUser
, but we are actually returning a
UserIn
instance.
The editor, mypy, and other tools won't complain about this because, in typing terms,
UserIn
is a subclass of
BaseUser
, which means it's a
valid
type when what is expected is anything that is a
BaseUser
.
FastAPI Data Filtering
Now, for FastAPI, it will see the return type and make sure that what you return includes
only
the fields that are declared in the type.
FastAPI does several things internally with Pydantic to make sure that those same rules of class inheritance are not used for the returned data filtering, otherwise you could end up returning much more data than what you expected.
This way, you can get the best of both worlds: type annotations with
tooling support
and
data filtering
.
See it in the docs
When you see the automatic docs, you can check that the input model and output model will both have their own JSON Schema:
And both models will be used for the interactive API documentation:
Other Return Type Annotations
There might be cases where you return something that is not a valid Pydantic field and you annotate it in the function, only to get the support provided by tooling (the editor, mypy, etc).
Return a Response Directly
The most common case would be
returning a Response directly as explained later in the advanced docs
.
Python 3.8+
from
fastapi
import
FastAPI
,
Response
from
fastapi.responses
import
JSONResponse
,
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/portal"
)
async
def
get_portal
(
teleport
:
bool
=
False
)
->
Response
:
if
teleport
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
return
JSONResponse
(
content
=
{
"message"
:
"Here's your interdimensional portal."
})
This simple case is handled automatically by FastAPI because the return type annotation is the class (or a subclass of)
Response
.
And tools will also be happy because both
RedirectResponse
and
JSONResponse
are subclasses of
Response
, so the type annotation is correct.
Annotate a Response Subclass
You can also use a subclass of
Response
in the type annotation:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/teleport"
)
async
def
get_teleport
()
->
RedirectResponse
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
This will also work because
RedirectResponse
is a subclass of
Response
, and FastAPI will automatically handle this simple case.
Invalid Return Type Annotations
But when you return some other arbitrary object that is not a valid Pydantic type (e.g. a database object) and you annotate it like that in the function, FastAPI will try to create a Pydantic response model from that type annotation, and will fail.
The same would happen if you had something like a
union
between different types where one or more of them are not valid Pydantic types, for example this would fail 💥:
Python 3.10+
from
fastapi
import
FastAPI
,
Response
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/portal"
)
async
def
get_portal
(
teleport
:
bool
=
False
)
->
Response
|
dict
:
if
teleport
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
return
{
"message"
:
"Here's your interdimensional portal."
}
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
,
Response
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/portal"
)
async
def
get_portal
(
teleport
:
bool
=
False
)
->
Union
[
Response
,
dict
]:
if
teleport
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
return
{
"message"
:
"Here's your interdimensional portal."
}
...this fails because the type annotation is not a Pydantic type and is not just a single
Response
class or subclass, it's a union (any of the two) between a
Response
and a
dict
.
Disable Response Model
Continuing from the example above, you might not want to have the default data validation, documentation, filtering, etc. that is performed by FastAPI.
But you might want to still keep the return type annotation in the function to get the support from tools like editors and type checkers (e.g. mypy).
In this case, you can disable the response model generation by setting
response_model=None
:
Python 3.10+
from
fastapi
import
FastAPI
,
Response
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/portal"
,
response_model
=
None
)
async
def
get_portal
(
teleport
:
bool
=
False
)
->
Response
|
dict
:
if
teleport
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
return
{
"message"
:
"Here's your interdimensional portal."
}
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
,
Response
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/portal"
,
response_model
=
None
)
async
def
get_portal
(
teleport
:
bool
=
False
)
->
Union
[
Response
,
dict
]:
if
teleport
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
return
{
"message"
:
"Here's your interdimensional portal."
}
This will make FastAPI skip the response model generation and that way you can have any return type annotations you need without it affecting your FastAPI application. 🤓
Response Model encoding parameters
Your response model could have default values, like:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
description: Union[str, None] = None
(or
str | None = None
in Python 3.10) has a default of
None
.
tax: float = 10.5
has a default of
10.5
.
tags: List[str] = []
has a default of an empty list:
[]
.
but you might want to omit them from the result if they were not actually stored.
For example, if you have models with many optional attributes in a NoSQL database, but you don't want to send very long JSON responses full of default values.
Use the
response_model_exclude_unset
parameter
You can set the
path operation decorator
parameter
response_model_exclude_unset=True
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
and those default values won't be included in the response, only the values actually set.
So, if you send a request to that
path operation
for the item with ID
foo
, the response (not including default values) will be:
{
"name"
:
"Foo"
,
"price"
:
50.2
}
Info
In Pydantic v1 the method was called
.dict()
, it was deprecated (but still supported) in Pydantic v2, and renamed to
.model_dump()
.
The examples here use
.dict()
for compatibility with Pydantic v1, but you should use
.model_dump()
instead if you can use Pydantic v2.
Info
FastAPI uses Pydantic model's
.dict()
with
its
exclude_unset
parameter
to achieve this.
Info
You can also use:
response_model_exclude_defaults=True
response_model_exclude_none=True
as described in
the Pydantic docs
for
exclude_defaults
and
exclude_none
.
Data with values for fields with defaults
But if your data has values for the model's fields with default values, like the item with ID
bar
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
}
they will be included in the response.
Data with the same values as the defaults
If the data has the same values as the default ones, like the item with ID
baz
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]
}
FastAPI is smart enough (actually, Pydantic is smart enough) to realize that, even though
description
,
tax
, and
tags
have the same values as the defaults, they were set explicitly (instead of taken from the defaults).
So, they will be included in the JSON response.
Tip
Notice that the default values can be anything, not only
None
.
They can be a list (
[]
), a
float
of
10.5
, etc.
response_model_include
and
response_model_exclude
You can also use the
path operation decorator
parameters
response_model_include
and
response_model_exclude
.
They take a
set
of
str
with the name of the attributes to include (omitting the rest) or to exclude (including the rest).
This can be used as a quick shortcut if you have only one Pydantic model and want to remove some data from the output.
Tip
But it is still recommended to use the ideas above, using multiple classes, instead of these parameters.
This is because the JSON Schema generated in your app's OpenAPI (and the docs) will still be the one for the complete model, even if you use
response_model_include
or
response_model_exclude
to omit some attributes.
This also applies to
response_model_by_alias
that works similarly.
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
=
10.5
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The Bar fighters"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
"There goes my baz"
,
"price"
:
50.2
,
"tax"
:
10.5
,
},
}
@app
.
get
(
"/items/
{item_id}
/name"
,
response_model
=
Item
,
response_model_include
=
{
"name"
,
"description"
},
)
async
def
read_item_name
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
get
(
"/items/
{item_id}
/public"
,
response_model
=
Item
,
response_model_exclude
=
{
"tax"
})
async
def
read_item_public_data
(
item_id
:
str
):
return
items
[
item_id
]
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The Bar fighters"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
"There goes my baz"
,
"price"
:
50.2
,
"tax"
:
10.5
,
},
}
@app
.
get
(
"/items/
{item_id}
/name"
,
response_model
=
Item
,
response_model_include
=
{
"name"
,
"description"
},
)
async
def
read_item_name
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
get
(
"/items/
{item_id}
/public"
,
response_model
=
Item
,
response_model_exclude
=
{
"tax"
})
async
def
read_item_public_data
(
item_id
:
str
):
return
items
[
item_id
]
Tip
The syntax
{"name", "description"}
creates a
set
with those two values.
It is equivalent to
set(["name", "description"])
.
Using
list
s instead of
set
s
If you forget to use a
set
and use a
list
or
tuple
instead, FastAPI will still convert it to a
set
and it will work correctly:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
=
10.5
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The Bar fighters"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
"There goes my baz"
,
"price"
:
50.2
,
"tax"
:
10.5
,
},
}
@app
.
get
(
"/items/
{item_id}
/name"
,
response_model
=
Item
,
response_model_include
=
[
"name"
,
"description"
],
)
async
def
read_item_name
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
get
(
"/items/
{item_id}
/public"
,
response_model
=
Item
,
response_model_exclude
=
[
"tax"
])
async
def
read_item_public_data
(
item_id
:
str
):
return
items
[
item_id
]
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The Bar fighters"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
"There goes my baz"
,
"price"
:
50.2
,
"tax"
:
10.5
,
},
}
@app
.
get
(
"/items/
{item_id}
/name"
,
response_model
=
Item
,
response_model_include
=
[
"name"
,
"description"
],
)
async
def
read_item_name
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
get
(
"/items/
{item_id}
/public"
,
response_model
=
Item
,
response_model_exclude
=
[
"tax"
])
async
def
read_item_public_data
(
item_id
:
str
):
return
items
[
item_id
]
Recap
Use the
path operation decorator's
parameter
response_model
to define response models and especially to ensure private data is filtered out.
Use
response_model_exclude_unset
to return only the values explicitly set.

## 146_TUTORIAL_RESPONSE_STATUS_CODE
Response Status Code¶
---

Response Status Code
The same way you can specify a response model, you can also declare the HTTP status code used for the response with the parameter
status_code
in any of the
path operations
:
@app.get()
@app.post()
@app.put()
@app.delete()
etc.
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
post
(
"/items/"
,
status_code
=
201
)
async
def
create_item
(
name
:
str
):
return
{
"name"
:
name
}
Note
Notice that
status_code
is a parameter of the "decorator" method (
get
,
post
, etc). Not of your
path operation function
, like all the parameters and body.
The
status_code
parameter receives a number with the HTTP status code.
Info
status_code
can alternatively also receive an
IntEnum
, such as Python's
http.HTTPStatus
.
It will:
Return that status code in the response.
Document it as such in the OpenAPI schema (and so, in the user interfaces):
Note
Some response codes (see the next section) indicate that the response does not have a body.
FastAPI knows this, and will produce OpenAPI docs that state there is no response body.
About HTTP status codes
Note
If you already know what HTTP status codes are, skip to the next section.
In HTTP, you send a numeric status code of 3 digits as part of the response.
These status codes have a name associated to recognize them, but the important part is the number.
In short:
100 - 199
are for "Information". You rarely use them directly. Responses with these status codes cannot have a body.
200 - 299
are for "Successful" responses. These are the ones you would use the most.
200
is the default status code, which means everything was "OK".
Another example would be
201
, "Created". It is commonly used after creating a new record in the database.
A special case is
204
, "No Content". This response is used when there is no content to return to the client, and so the response must not have a body.
300 - 399
are for "Redirection". Responses with these status codes may or may not have a body, except for
304
, "Not Modified", which must not have one.
400 - 499
are for "Client error" responses. These are the second type you would probably use the most.
An example is
404
, for a "Not Found" response.
For generic errors from the client, you can just use
400
.
500 - 599
are for server errors. You almost never use them directly. When something goes wrong at some part in your application code, or server, it will automatically return one of these status codes.
Tip
To know more about each status code and which code is for what, check the
MDN
documentation about HTTP status codes
.
Shortcut to remember the names
Let's see the previous example again:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
post
(
"/items/"
,
status_code
=
201
)
async
def
create_item
(
name
:
str
):
return
{
"name"
:
name
}
201
is the status code for "Created".
But you don't have to memorize what each of these codes mean.
You can use the convenience variables from
fastapi.status
.
Python 3.8+
from
fastapi
import
FastAPI
,
status
app
=
FastAPI
()
@app
.
post
(
"/items/"
,
status_code
=
status
.
HTTP_201_CREATED
)
async
def
create_item
(
name
:
str
):
return
{
"name"
:
name
}
They are just a convenience, they hold the same number, but that way you can use the editor's autocomplete to find them:
Technical Details
You could also use
from starlette import status
.
FastAPI
provides the same
starlette.status
as
fastapi.status
just as a convenience for you, the developer. But it comes directly from Starlette.
Changing the default
Later, in the
Advanced User Guide
, you will see how to return a different status code than the default you are declaring here.

## 147_TUTORIAL_SCHEMA_EXTRA_EXAMPLE
Declare Request Example Data¶
---

Declare Request Example Data
You can declare examples of the data your app can receive.
Here are several ways to do it.
Extra JSON Schema data in Pydantic models
You can declare
examples
for a Pydantic model that will be added to the generated JSON Schema.
Pydantic v2
Pydantic v1
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
model_config
=
{
"json_schema_extra"
:
{
"examples"
:
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
]
}
}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
model_config
=
{
"json_schema_extra"
:
{
"examples"
:
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
]
}
}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
Config
:
schema_extra
=
{
"examples"
:
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
]
}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
Config
:
schema_extra
=
{
"examples"
:
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
]
}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
That extra info will be added as-is to the output
JSON Schema
for that model, and it will be used in the API docs.
Pydantic v2
Pydantic v1
In Pydantic version 2, you would use the attribute
model_config
, that takes a
dict
as described in
Pydantic's docs: Configuration
.
You can set
"json_schema_extra"
with a
dict
containing any additional data you would like to show up in the generated JSON Schema, including
examples
.
In Pydantic version 1, you would use an internal class
Config
and
schema_extra
, as described in
Pydantic's docs: Schema customization
.
You can set
schema_extra
with a
dict
containing any additional data you would like to show up in the generated JSON Schema, including
examples
.
Tip
You could use the same technique to extend the JSON Schema and add your own custom extra info.
For example you could use it to add metadata for a frontend user interface, etc.
Info
OpenAPI 3.1.0 (used since FastAPI 0.99.0) added support for
examples
, which is part of the
JSON Schema
standard.
Before that, it only supported the keyword
example
with a single example. That is still supported by OpenAPI 3.1.0, but is deprecated and is not part of the JSON Schema standard. So you are encouraged to migrate
example
to
examples
. 🤓
You can read more at the end of this page.
Field
additional arguments
When using
Field()
with Pydantic models, you can also declare additional
examples
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
=
Field
(
examples
=
[
"Foo"
])
description
:
str
|
None
=
Field
(
default
=
None
,
examples
=
[
"A very nice Item"
])
price
:
float
=
Field
(
examples
=
[
35.4
])
tax
:
float
|
None
=
Field
(
default
=
None
,
examples
=
[
3.2
])
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
=
Field
(
examples
=
[
"Foo"
])
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
examples
=
[
"A very nice Item"
])
price
:
float
=
Field
(
examples
=
[
35.4
])
tax
:
Union
[
float
,
None
]
=
Field
(
default
=
None
,
examples
=
[
3.2
])
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
examples
in JSON Schema - OpenAPI
When using any of:
Path()
Query()
Header()
Cookie()
Body()
Form()
File()
you can also declare a group of
examples
with additional information that will be added to their
JSON Schemas
inside of
OpenAPI
.
Body
with
examples
Here we pass
examples
containing one example of the data expected in
Body()
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
],
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
],
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Example in the docs UI
With any of the methods above it would look like this in the
/docs
:
Body
with multiple
examples
You can of course also pass multiple
examples
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
=
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
],
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
=
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
],
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
When you do this, the examples will be part of the internal
JSON Schema
for that body data.
Nevertheless, at the
time of writing this
, Swagger UI, the tool in charge of showing the docs UI, doesn't support showing multiple examples for the data in
JSON Schema
. But read below for a workaround.
OpenAPI-specific
examples
Since before
JSON Schema
supported
examples
OpenAPI had support for a different field also called
examples
.
This
OpenAPI-specific
examples
goes in another section in the OpenAPI specification. It goes in the
details for each
path operation
, not inside each JSON Schema.
And Swagger UI has supported this particular
examples
field for a while. So, you can use it to
show
different
examples in the docs UI
.
The shape of this OpenAPI-specific field
examples
is a
dict
with
multiple examples
(instead of a
list
), each with extra information that will be added to
OpenAPI
too.
This doesn't go inside of each JSON Schema contained in OpenAPI, this goes outside, in the
path operation
directly.
Using the
openapi_examples
Parameter
You can declare the OpenAPI-specific
examples
in FastAPI with the parameter
openapi_examples
for:
Path()
Query()
Header()
Cookie()
Body()
Form()
File()
The keys of the
dict
identify each example, and each value is another
dict
.
Each specific example
dict
in the
examples
can contain:
summary
: Short description for the example.
description
: A long description that can contain Markdown text.
value
: This is the actual example shown, e.g. a
dict
.
externalValue
: alternative to
value
, a URL pointing to the example. Although this might not be supported by as many tools as
value
.
You can use it like this:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
openapi_examples
=
{
"normal"
:
{
"summary"
:
"A normal example"
,
"description"
:
"A **normal** item works correctly."
,
"value"
:
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
},
"converted"
:
{
"summary"
:
"An example with converted data"
,
"description"
:
"FastAPI can convert price `strings` to actual `numbers` automatically"
,
"value"
:
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
},
"invalid"
:
{
"summary"
:
"Invalid data is rejected with an error"
,
"value"
:
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
},
},
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
openapi_examples
=
{
"normal"
:
{
"summary"
:
"A normal example"
,
"description"
:
"A **normal** item works correctly."
,
"value"
:
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
},
"converted"
:
{
"summary"
:
"An example with converted data"
,
"description"
:
"FastAPI can convert price `strings` to actual `numbers` automatically"
,
"value"
:
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
},
"invalid"
:
{
"summary"
:
"Invalid data is rejected with an error"
,
"value"
:
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
},
},
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
openapi_examples
=
{
"normal"
:
{
"summary"
:
"A normal example"
,
"description"
:
"A **normal** item works correctly."
,
"value"
:
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
},
"converted"
:
{
"summary"
:
"An example with converted data"
,
"description"
:
"FastAPI can convert price `strings` to actual `numbers` automatically"
,
"value"
:
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
},
"invalid"
:
{
"summary"
:
"Invalid data is rejected with an error"
,
"value"
:
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
},
},
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
=
Body
(
openapi_examples
=
{
"normal"
:
{
"summary"
:
"A normal example"
,
"description"
:
"A **normal** item works correctly."
,
"value"
:
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
},
"converted"
:
{
"summary"
:
"An example with converted data"
,
"description"
:
"FastAPI can convert price `strings` to actual `numbers` automatically"
,
"value"
:
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
},
"invalid"
:
{
"summary"
:
"Invalid data is rejected with an error"
,
"value"
:
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
},
},
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
=
Body
(
openapi_examples
=
{
"normal"
:
{
"summary"
:
"A normal example"
,
"description"
:
"A **normal** item works correctly."
,
"value"
:
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
},
"converted"
:
{
"summary"
:
"An example with converted data"
,
"description"
:
"FastAPI can convert price `strings` to actual `numbers` automatically"
,
"value"
:
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
},
"invalid"
:
{
"summary"
:
"Invalid data is rejected with an error"
,
"value"
:
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
},
},
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
OpenAPI Examples in the Docs UI
With
openapi_examples
added to
Body()
the
/docs
would look like:
Technical Details
Tip
If you are already using
FastAPI
version
0.99.0 or above
, you can probably
skip
these details.
They are more relevant for older versions, before OpenAPI 3.1.0 was available.
You can consider this a brief OpenAPI and JSON Schema
history lesson
. 🤓
Warning
These are very technical details about the standards
JSON Schema
and
OpenAPI
.
If the ideas above already work for you, that might be enough, and you probably don't need these details, feel free to skip them.
Before OpenAPI 3.1.0, OpenAPI used an older and modified version of
JSON Schema
.
JSON Schema didn't have
examples
, so OpenAPI added its own
example
field to its own modified version.
OpenAPI also added
example
and
examples
fields to other parts of the specification:
Parameter Object
(in the specification)
that was used by FastAPI's:
Path()
Query()
Header()
Cookie()
Request Body Object
, in the field
content
, on the
Media Type Object
(in the specification)
that was used by FastAPI's:
Body()
File()
Form()
Info
This old OpenAPI-specific
examples
parameter is now
openapi_examples
since FastAPI
0.103.0
.
JSON Schema's
examples
field
But then JSON Schema added an
examples
field to a new version of the specification.
And then the new OpenAPI 3.1.0 was based on the latest version (JSON Schema 2020-12) that included this new field
examples
.
And now this new
examples
field takes precedence over the old single (and custom)
example
field, that is now deprecated.
This new
examples
field in JSON Schema is
just a
list
of examples, not a dict with extra metadata as in the other places in OpenAPI (described above).
Info
Even after OpenAPI 3.1.0 was released with this new simpler integration with JSON Schema, for a while, Swagger UI, the tool that provides the automatic docs, didn't support OpenAPI 3.1.0 (it does since version 5.0.0 🎉).
Because of that, versions of FastAPI previous to 0.99.0 still used versions of OpenAPI lower than 3.1.0.
Pydantic and FastAPI
examples
When you add
examples
inside a Pydantic model, using
schema_extra
or
Field(examples=["something"])
that example is added to the
JSON Schema
for that Pydantic model.
And that
JSON Schema
of the Pydantic model is included in the
OpenAPI
of your API, and then it's used in the docs UI.
In versions of FastAPI before 0.99.0 (0.99.0 and above use the newer OpenAPI 3.1.0) when you used
example
or
examples
with any of the other utilities (
Query()
,
Body()
, etc.) those examples were not added to the JSON Schema that describes that data (not even to OpenAPI's own version of JSON Schema), they were added directly to the
path operation
declaration in OpenAPI (outside the parts of OpenAPI that use JSON Schema).
But now that FastAPI 0.99.0 and above uses OpenAPI 3.1.0, that uses JSON Schema 2020-12, and Swagger UI 5.0.0 and above, everything is more consistent and the examples are included in JSON Schema.
Swagger UI and OpenAPI-specific
examples
Now, as Swagger UI didn't support multiple JSON Schema examples (as of 2023-08-26), users didn't have a way to show multiple examples in the docs.
To solve that, FastAPI
0.103.0
added support
for declaring the same old
OpenAPI-specific
examples
field with the new parameter
openapi_examples
. 🤓
Summary
I used to say I didn't like history that much... and look at me now giving "tech history" lessons. 😅
In short,
upgrade to FastAPI 0.99.0 or above
, and things are much
simpler, consistent, and intuitive
, and you don't have to know all these historic details. 😎

## 148_TUTORIAL_SECURITY
Security¶
---

Security
There are many ways to handle security, authentication and authorization.
And it normally is a complex and "difficult" topic.
In many frameworks and systems just handling security and authentication takes a big amount of effort and code (in many cases it can be 50% or more of all the code written).
FastAPI
provides several tools to help you deal with
Security
easily, rapidly, in a standard way, without having to study and learn all the security specifications.
But first, let's check some small concepts.
In a hurry?
If you don't care about any of these terms and you just need to add security with authentication based on username and password
right now
, skip to the next chapters.
OAuth2
OAuth2 is a specification that defines several ways to handle authentication and authorization.
It is quite an extensive specification and covers several complex use cases.
It includes ways to authenticate using a "third party".
That's what all the systems with "login with Facebook, Google, Twitter, GitHub" use underneath.
OAuth 1
There was an OAuth 1, which is very different from OAuth2, and more complex, as it included direct specifications on how to encrypt the communication.
It is not very popular or used nowadays.
OAuth2 doesn't specify how to encrypt the communication, it expects you to have your application served with HTTPS.
Tip
In the section about
deployment
you will see how to set up HTTPS for free, using Traefik and Let's Encrypt.
OpenID Connect
OpenID Connect is another specification, based on
OAuth2
.
It just extends OAuth2 specifying some things that are relatively ambiguous in OAuth2, to try to make it more interoperable.
For example, Google login uses OpenID Connect (which underneath uses OAuth2).
But Facebook login doesn't support OpenID Connect. It has its own flavor of OAuth2.
OpenID (not "OpenID Connect")
There was also an "OpenID" specification. That tried to solve the same thing as
OpenID Connect
, but was not based on OAuth2.
So, it was a complete additional system.
It is not very popular or used nowadays.
OpenAPI
OpenAPI (previously known as Swagger) is the open specification for building APIs (now part of the Linux Foundation).
FastAPI
is based on
OpenAPI
.
That's what makes it possible to have multiple automatic interactive documentation interfaces, code generation, etc.
OpenAPI has a way to define multiple security "schemes".
By using them, you can take advantage of all these standard-based tools, including these interactive documentation systems.
OpenAPI defines the following security schemes:
apiKey
: an application specific key that can come from:
A query parameter.
A header.
A cookie.
http
: standard HTTP authentication systems, including:
bearer
: a header
Authorization
with a value of
Bearer
plus a token. This is inherited from OAuth2.
HTTP Basic authentication.
HTTP Digest, etc.
oauth2
: all the OAuth2 ways to handle security (called "flows").
Several of these flows are appropriate for building an OAuth 2.0 authentication provider (like Google, Facebook, Twitter, GitHub, etc):
implicit
clientCredentials
authorizationCode
But there is one specific "flow" that can be perfectly used for handling authentication in the same application directly:
password
: some next chapters will cover examples of this.
openIdConnect
: has a way to define how to discover OAuth2 authentication data automatically.
This automatic discovery is what is defined in the OpenID Connect specification.
Tip
Integrating other authentication/authorization providers like Google, Facebook, Twitter, GitHub, etc. is also possible and relatively easy.
The most complex problem is building an authentication/authorization provider like those, but
FastAPI
gives you the tools to do it easily, while doing the heavy lifting for you.
FastAPI
utilities
FastAPI provides several tools for each of these security schemes in the
fastapi.security
module that simplify using these security mechanisms.
In the next chapters you will see how to add security to your API using those tools provided by
FastAPI
.
And you will also see how it gets automatically integrated into the interactive documentation system.

## 149_TUTORIAL_SECURITY_FIRST_STEPS
Security - First Steps¶
---

Security - First Steps
Let's imagine that you have your
backend
API in some domain.
And you have a
frontend
in another domain or in a different path of the same domain (or in a mobile application).
And you want to have a way for the frontend to authenticate with the backend, using a
username
and
password
.
We can use
OAuth2
to build that with
FastAPI
.
But let's save you the time of reading the full long specification just to find those little pieces of information you need.
Let's use the tools provided by
FastAPI
to handle security.
How it looks
Let's first just use the code and see how it works, and then we'll come back to understand what's happening.
Create
main.py
Copy the example in a file
main.py
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
str
=
Depends
(
oauth2_scheme
)):
return
{
"token"
:
token
}
Run it
Info
The
python-multipart
package is automatically installed with
FastAPI
when you run the
pip install "fastapi[standard]"
command.
However, if you use the
pip install fastapi
command, the
python-multipart
package is not included by default.
To install it manually, make sure you create a
virtual environment
, activate it, and then install it with:
$
pip
install
python-multipart
This is because
OAuth2
uses "form data" for sending the
username
and
password
.
Run the example with:
fast →
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
Check it
Go to the interactive docs at:
http://127.0.0.1:8000/docs
.
You will see something like this:
Authorize button!
You already have a shiny new "Authorize" button.
And your
path operation
has a little lock in the top-right corner that you can click.
And if you click it, you have a little authorization form to type a
username
and
password
(and other optional fields):
Note
It doesn't matter what you type in the form, it won't work yet. But we'll get there.
This is of course not the frontend for the final users, but it's a great automatic tool to document interactively all your API.
It can be used by the frontend team (that can also be yourself).
It can be used by third party applications and systems.
And it can also be used by yourself, to debug, check and test the same application.
The
password
flow
Now let's go back a bit and understand what is all that.
The
password
"flow" is one of the ways ("flows") defined in OAuth2, to handle security and authentication.
OAuth2 was designed so that the backend or API could be independent of the server that authenticates the user.
But in this case, the same
FastAPI
application will handle the API and the authentication.
So, let's review it from that simplified point of view:
The user types the
username
and
password
in the frontend, and hits
Enter
.
The frontend (running in the user's browser) sends that
username
and
password
to a specific URL in our API (declared with
tokenUrl="token"
).
The API checks that
username
and
password
, and responds with a "token" (we haven't implemented any of this yet).
A "token" is just a string with some content that we can use later to verify this user.
Normally, a token is set to expire after some time.
So, the user will have to log in again at some point later.
And if the token is stolen, the risk is less. It is not like a permanent key that will work forever (in most of the cases).
The frontend stores that token temporarily somewhere.
The user clicks in the frontend to go to another section of the frontend web app.
The frontend needs to fetch some more data from the API.
But it needs authentication for that specific endpoint.
So, to authenticate with our API, it sends a header
Authorization
with a value of
Bearer
plus the token.
If the token contains
foobar
, the content of the
Authorization
header would be:
Bearer foobar
.
FastAPI
's
OAuth2PasswordBearer
FastAPI
provides several tools, at different levels of abstraction, to implement these security features.
In this example we are going to use
OAuth2
, with the
Password
flow, using a
Bearer
token. We do that using the
OAuth2PasswordBearer
class.
Info
A "bearer" token is not the only option.
But it's the best one for our use case.
And it might be the best for most use cases, unless you are an OAuth2 expert and know exactly why there's another option that better suits your needs.
In that case,
FastAPI
also provides you with the tools to build it.
When we create an instance of the
OAuth2PasswordBearer
class we pass in the
tokenUrl
parameter. This parameter contains the URL that the client (the frontend running in the user's browser) will use to send the
username
and
password
in order to get a token.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
str
=
Depends
(
oauth2_scheme
)):
return
{
"token"
:
token
}
Tip
Here
tokenUrl="token"
refers to a relative URL
token
that we haven't created yet. As it's a relative URL, it's equivalent to
./token
.
Because we are using a relative URL, if your API was located at
https://example.com/
, then it would refer to
https://example.com/token
. But if your API was located at
https://example.com/api/v1/
, then it would refer to
https://example.com/api/v1/token
.
Using a relative URL is important to make sure your application keeps working even in an advanced use case like
Behind a Proxy
.
This parameter doesn't create that endpoint /
path operation
, but declares that the URL
/token
will be the one that the client should use to get the token. That information is used in OpenAPI, and then in the interactive API documentation systems.
We will soon also create the actual path operation.
Info
If you are a very strict "Pythonista" you might dislike the style of the parameter name
tokenUrl
instead of
token_url
.
That's because it is using the same name as in the OpenAPI spec. So that if you need to investigate more about any of these security schemes you can just copy and paste it to find more information about it.
The
oauth2_scheme
variable is an instance of
OAuth2PasswordBearer
, but it is also a "callable".
It could be called as:
oauth2_scheme
(
some
,
parameters
)
So, it can be used with
Depends
.
Use it
Now you can pass that
oauth2_scheme
in a dependency with
Depends
.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
str
=
Depends
(
oauth2_scheme
)):
return
{
"token"
:
token
}
This dependency will provide a
str
that is assigned to the parameter
token
of the
path operation function
.
FastAPI
will know that it can use this dependency to define a "security scheme" in the OpenAPI schema (and the automatic API docs).
Technical Details
FastAPI
will know that it can use the class
OAuth2PasswordBearer
(declared in a dependency) to define the security scheme in OpenAPI because it inherits from
fastapi.security.oauth2.OAuth2
, which in turn inherits from
fastapi.security.base.SecurityBase
.
All the security utilities that integrate with OpenAPI (and the automatic API docs) inherit from
SecurityBase
, that's how
FastAPI
can know how to integrate them in OpenAPI.
What it does
It will go and look in the request for that
Authorization
header, check if the value is
Bearer
plus some token, and will return the token as a
str
.
If it doesn't see an
Authorization
header, or the value doesn't have a
Bearer
token, it will respond with a 401 status code error (
UNAUTHORIZED
) directly.
You don't even have to check if the token exists to return an error. You can be sure that if your function is executed, it will have a
str
in that token.
You can try it already in the interactive docs:
We are not verifying the validity of the token yet, but that's a start already.
Recap
So, in just 3 or 4 extra lines, you already have some primitive form of security.

## 150_TUTORIAL_SECURITY_GET_CURRENT_USER
Get Current User¶
---

Get Current User
In the previous chapter the security system (which is based on the dependency injection system) was giving the
path operation function
a
token
as a
str
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
🤓 Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
str
=
Depends
(
oauth2_scheme
)):
return
{
"token"
:
token
}
But that is still not that useful.
Let's make it give us the current user.
Create a user model
First, let's create a Pydantic user model.
The same way we use Pydantic to declare bodies, we can use it anywhere else:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Create a
get_current_user
dependency
Let's create a dependency
get_current_user
.
Remember that dependencies can have sub-dependencies?
get_current_user
will have a dependency with the same
oauth2_scheme
we created before.
The same as we were doing before in the
path operation
directly, our new dependency
get_current_user
will receive a
token
as a
str
from the sub-dependency
oauth2_scheme
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Get the user
get_current_user
will use a (fake) utility function we created, that takes a token as a
str
and returns our Pydantic
User
model:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Inject the current user
So now we can use the same
Depends
with our
get_current_user
in the
path operation
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Notice that we declare the type of
current_user
as the Pydantic model
User
.
This will help us inside of the function with all the completion and type checks.
Tip
You might remember that request bodies are also declared with Pydantic models.
Here
FastAPI
won't get confused because you are using
Depends
.
Check
The way this dependency system is designed allows us to have different dependencies (different "dependables") that all return a
User
model.
We are not restricted to having only one dependency that can return that type of data.
Other models
You can now get the current user directly in the
path operation functions
and deal with the security mechanisms at the
Dependency Injection
level, using
Depends
.
And you can use any model or data for the security requirements (in this case, a Pydantic model
User
).
But you are not restricted to using some specific data model, class or type.
Do you want to have an
id
and
email
and not have any
username
in your model? Sure. You can use these same tools.
Do you want to just have a
str
? Or just a
dict
? Or a database class model instance directly? It all works the same way.
You actually don't have users that log in to your application but robots, bots, or other systems, that have just an access token? Again, it all works the same.
Just use any kind of model, any kind of class, any kind of database that you need for your application.
FastAPI
has you covered with the dependency injection system.
Code size
This example might seem verbose. Keep in mind that we are mixing security, data models, utility functions and
path operations
in the same file.
But here's the key point.
The security and dependency injection stuff is written once.
And you can make it as complex as you want. And still, have it written only once, in a single place. With all the flexibility.
But you can have thousands of endpoints (
path operations
) using the same security system.
And all of them (or any portion of them that you want) can take advantage of re-using these dependencies or any other dependencies you create.
And all these thousands of
path operations
can be as small as 3 lines:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Recap
You can now get the current user directly in your
path operation function
.
We are already halfway there.
We just need to add a
path operation
for the user/client to actually send the
username
and
password
.
That comes next.

## 151_TUTORIAL_SECURITY_OAUTH2_JWT
OAuth2 with Password (and hashing), Bearer with JWT tokens¶
---

OAuth2 with Password (and hashing), Bearer with JWT tokens
Now that we have all the security flow, let's make the application actually secure, using
JWT
tokens and secure password hashing.
This code is something you can actually use in your application, save the password hashes in your database, etc.
We are going to start from where we left in the previous chapter and increment it.
About JWT
JWT means "JSON Web Tokens".
It's a standard to codify a JSON object in a long dense string without spaces. It looks like this:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
It is not encrypted, so, anyone could recover the information from the contents.
But it's signed. So, when you receive a token that you emitted, you can verify that you actually emitted it.
That way, you can create a token with an expiration of, let's say, 1 week. And then when the user comes back the next day with the token, you know that user is still logged in to your system.
After a week, the token will be expired and the user will not be authorized and will have to sign in again to get a new token. And if the user (or a third party) tried to modify the token to change the expiration, you would be able to discover it, because the signatures would not match.
If you want to play with JWT tokens and see how they work, check
https://jwt.io
.
Install
PyJWT
We need to install
PyJWT
to generate and verify the JWT tokens in Python.
Make sure you create a
virtual environment
, activate it, and then install
pyjwt
:
fast →
pip install pyjwt
restart ↻
Info
If you are planning to use digital signature algorithms like RSA or ECDSA, you should install the cryptography library dependency
pyjwt[crypto]
.
You can read more about it in the
PyJWT Installation docs
.
Password hashing
"Hashing" means converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.
Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.
But you cannot convert from the gibberish back to the password.
Why use password hashing
If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.
So, the thief won't be able to try to use that password in another system (as many users use the same password everywhere, this would be dangerous).
Install
passlib
PassLib is a great Python package to handle password hashes.
It supports many secure hashing algorithms and utilities to work with them.
The recommended algorithm is "Bcrypt".
Make sure you create a
virtual environment
, activate it, and then install PassLib with Bcrypt:
fast →
pip install "passlib[bcrypt]"
restart ↻
Tip
With
passlib
, you could even configure it to be able to read passwords created by
Django
, a
Flask
security plug-in or many others.
So, you would be able to, for example, share the same data from a Django application in a database with a FastAPI application. Or gradually migrate a Django application using the same database.
And your users would be able to login from your Django app or from your
FastAPI
app, at the same time.
Hash and verify the passwords
Import the tools we need from
passlib
.
Create a PassLib "context". This is what will be used to hash and verify passwords.
Tip
The PassLib context also has functionality to use different hashing algorithms, including deprecated old ones only to allow verifying them, etc.
For example, you could use it to read and verify passwords generated by another system (like Django) but hash any new passwords with a different algorithm like Bcrypt.
And be compatible with all of them at the same time.
Create a utility function to hash a password coming from the user.
And another utility to verify if a received password matches the hash stored.
And another one to authenticate and return a user.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Note
If you check the new (fake) database
fake_users_db
, you will see how the hashed password looks like now:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
.
Handle JWT tokens
Import the modules installed.
Create a random secret key that will be used to sign the JWT tokens.
To generate a secure random secret key use the command:
fast →
openssl rand -hex 32
09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7
restart ↻
And copy the output to the variable
SECRET_KEY
(don't use the one in the example).
Create a variable
ALGORITHM
with the algorithm used to sign the JWT token and set it to
"HS256"
.
Create a variable for the expiration of the token.
Define a Pydantic Model that will be used in the token endpoint for the response.
Create a utility function to generate a new access token.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Update the dependencies
Update
get_current_user
to receive the same token as before, but this time, using JWT tokens.
Decode the received token, verify it, and return the current user.
If the token is invalid, return an HTTP error right away.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Update the
/token
path operation
Create a
timedelta
with the expiration time of the token.
Create a real JWT access token and return it.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Technical details about the JWT "subject"
sub
The JWT specification says that there's a key
sub
, with the subject of the token.
It's optional to use it, but that's where you would put the user's identification, so we are using it here.
JWT might be used for other things apart from identifying a user and allowing them to perform operations directly on your API.
For example, you could identify a "car" or a "blog post".
Then you could add permissions about that entity, like "drive" (for the car) or "edit" (for the blog).
And then, you could give that JWT token to a user (or bot), and they could use it to perform those actions (drive the car, or edit the blog post) without even needing to have an account, just with the JWT token your API generated for that.
Using these ideas, JWT can be used for way more sophisticated scenarios.
In those cases, several of those entities could have the same ID, let's say
foo
(a user
foo
, a car
foo
, and a blog post
foo
).
So, to avoid ID collisions, when creating the JWT token for the user, you could prefix the value of the
sub
key, e.g. with
username:
. So, in this example, the value of
sub
could have been:
username:johndoe
.
The important thing to keep in mind is that the
sub
key should have a unique identifier across the entire application, and it should be a string.
Check it
Run the server and go to the docs:
http://127.0.0.1:8000/docs
.
You'll see the user interface like:
Authorize the application the same way as before.
Using the credentials:
Username:
johndoe
Password:
secret
Check
Notice that nowhere in the code is the plaintext password "
secret
", we only have the hashed version.
Call the endpoint
/users/me/
, you will get the response as:
{
"username"
:
"johndoe"
,
"email"
:
"johndoe@example.com"
,
"full_name"
:
"John Doe"
,
"disabled"
:
false
}
If you open the developer tools, you could see how the data sent only includes the token, the password is only sent in the first request to authenticate the user and get that access token, but not afterwards:
Note
Notice the header
Authorization
, with a value that starts with
Bearer
.
Advanced usage with
scopes
OAuth2 has the notion of "scopes".
You can use them to add a specific set of permissions to a JWT token.
Then you can give this token to a user directly or a third party, to interact with your API with a set of restrictions.
You can learn how to use them and how they are integrated into
FastAPI
later in the
Advanced User Guide
.
Recap
With what you have seen up to now, you can set up a secure
FastAPI
application using standards like OAuth2 and JWT.
In almost any framework handling the security becomes a rather complex subject quite quickly.
Many packages that simplify it a lot have to make many compromises with the data model, database, and available features. And some of these packages that simplify things too much actually have security flaws underneath.
FastAPI
doesn't make any compromise with any database, data model or tool.
It gives you all the flexibility to choose the ones that fit your project the best.
And you can use directly many well maintained and widely used packages like
passlib
and
PyJWT
, because
FastAPI
doesn't require any complex mechanisms to integrate external packages.
But it provides you the tools to simplify the process as much as possible without compromising flexibility, robustness, or security.
And you can use and implement secure, standard protocols, like OAuth2 in a relatively simple way.
You can learn more in the
Advanced User Guide
about how to use OAuth2 "scopes", for a more fine-grained permission system, following these same standards. OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. to authorize third party applications to interact with their APIs on behalf of their users.

## 152_TUTORIAL_SECURITY_SIMPLE_OAUTH2
Simple OAuth2 with Password and Bearer¶
---

Simple OAuth2 with Password and Bearer
Now let's build from the previous chapter and add the missing parts to have a complete security flow.
Get the
username
and
password
We are going to use
FastAPI
security utilities to get the
username
and
password
.
OAuth2 specifies that when using the "password flow" (that we are using) the client/user must send a
username
and
password
fields as form data.
And the spec says that the fields have to be named like that. So
user-name
or
email
wouldn't work.
But don't worry, you can show it as you wish to your final users in the frontend.
And your database models can use any other names you want.
But for the login
path operation
, we need to use these names to be compatible with the spec (and be able to, for example, use the integrated API documentation system).
The spec also states that the
username
and
password
must be sent as form data (so, no JSON here).
scope
The spec also says that the client can send another form field "
scope
".
The form field name is
scope
(in singular), but it is actually a long string with "scopes" separated by spaces.
Each "scope" is just a string (without spaces).
They are normally used to declare specific security permissions, for example:
users:read
or
users:write
are common examples.
instagram_basic
is used by Facebook / Instagram.
https://www.googleapis.com/auth/drive
is used by Google.
Info
In OAuth2 a "scope" is just a string that declares a specific permission required.
It doesn't matter if it has other characters like
:
or if it is a URL.
Those details are implementation specific.
For OAuth2 they are just strings.
Code to get the
username
and
password
Now let's use the utilities provided by
FastAPI
to handle this.
OAuth2PasswordRequestForm
First, import
OAuth2PasswordRequestForm
, and use it as a dependency with
Depends
in the
path operation
for
/token
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
OAuth2PasswordRequestForm
is a class dependency that declares a form body with:
The
username
.
The
password
.
An optional
scope
field as a big string, composed of strings separated by spaces.
An optional
grant_type
.
Tip
The OAuth2 spec actually
requires
a field
grant_type
with a fixed value of
password
, but
OAuth2PasswordRequestForm
doesn't enforce it.
If you need to enforce it, use
OAuth2PasswordRequestFormStrict
instead of
OAuth2PasswordRequestForm
.
An optional
client_id
(we don't need it for our example).
An optional
client_secret
(we don't need it for our example).
Info
The
OAuth2PasswordRequestForm
is not a special class for
FastAPI
as is
OAuth2PasswordBearer
.
OAuth2PasswordBearer
makes
FastAPI
know that it is a security scheme. So it is added that way to OpenAPI.
But
OAuth2PasswordRequestForm
is just a class dependency that you could have written yourself, or you could have declared
Form
parameters directly.
But as it's a common use case, it is provided by
FastAPI
directly, just to make it easier.
Use the form data
Tip
The instance of the dependency class
OAuth2PasswordRequestForm
won't have an attribute
scope
with the long string separated by spaces, instead, it will have a
scopes
attribute with the actual list of strings for each scope sent.
We are not using
scopes
in this example, but the functionality is there if you need it.
Now, get the user data from the (fake) database, using the
username
from the form field.
If there is no such user, we return an error saying "Incorrect username or password".
For the error, we use the exception
HTTPException
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Check the password
At this point we have the user data from our database, but we haven't checked the password.
Let's put that data in the Pydantic
UserInDB
model first.
You should never save plaintext passwords, so, we'll use the (fake) password hashing system.
If the passwords don't match, we return the same error.
Password hashing
"Hashing" means: converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.
Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.
But you cannot convert from the gibberish back to the password.
Why use password hashing
If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.
So, the thief won't be able to try to use those same passwords in another system (as many users use the same password everywhere, this would be dangerous).
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
About
**user_dict
UserInDB(**user_dict)
means:
Pass the keys and values of the
user_dict
directly as key-value arguments, equivalent to:
UserInDB
(
username
=
user_dict
[
"username"
],
email
=
user_dict
[
"email"
],
full_name
=
user_dict
[
"full_name"
],
disabled
=
user_dict
[
"disabled"
],
hashed_password
=
user_dict
[
"hashed_password"
],
)
Info
For a more complete explanation of
**user_dict
check back in
the documentation for
Extra Models
.
Return the token
The response of the
token
endpoint must be a JSON object.
It should have a
token_type
. In our case, as we are using "Bearer" tokens, the token type should be "
bearer
".
And it should have an
access_token
, with a string containing our access token.
For this simple example, we are going to just be completely insecure and return the same
username
as the token.
Tip
In the next chapter, you will see a real secure implementation, with password hashing and
JWT
tokens.
But for now, let's focus on the specific details we need.
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
By the spec, you should return a JSON with an
access_token
and a
token_type
, the same as in this example.
This is something that you have to do yourself in your code, and make sure you use those JSON keys.
It's almost the only thing that you have to remember to do correctly yourself, to be compliant with the specifications.
For the rest,
FastAPI
handles it for you.
Update the dependencies
Now we are going to update our dependencies.
We want to get the
current_user
only
if this user is active.
So, we create an additional dependency
get_current_active_user
that in turn uses
get_current_user
as a dependency.
Both of these dependencies will just return an HTTP error if the user doesn't exist, or if is inactive.
So, in our endpoint, we will only get a user if the user exists, was correctly authenticated, and is active:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Info
The additional header
WWW-Authenticate
with value
Bearer
we are returning here is also part of the spec.
Any HTTP (error) status code 401 "UNAUTHORIZED" is supposed to also return a
WWW-Authenticate
header.
In the case of bearer tokens (our case), the value of that header should be
Bearer
.
You can actually skip that extra header and it would still work.
But it's provided here to be compliant with the specifications.
Also, there might be tools that expect and use it (now or in the future) and that might be useful for you or your users, now or in the future.
That's the benefit of standards...
See it in action
Open the interactive docs:
http://127.0.0.1:8000/docs
.
Authenticate
Click the "Authorize" button.
Use the credentials:
User:
johndoe
Password:
secret
After authenticating in the system, you will see it like:
Get your own user data
Now use the operation
GET
with the path
/users/me
.
You will get your user's data, like:
{
"username"
:
"johndoe"
,
"email"
:
"johndoe@example.com"
,
"full_name"
:
"John Doe"
,
"disabled"
:
false
,
"hashed_password"
:
"fakehashedsecret"
}
If you click the lock icon and logout, and then try the same operation again, you will get an HTTP 401 error of:
{
"detail"
:
"Not authenticated"
}
Inactive user
Now try with an inactive user, authenticate with:
User:
alice
Password:
secret2
And try to use the operation
GET
with the path
/users/me
.
You will get an "Inactive user" error, like:
{
"detail"
:
"Inactive user"
}
Recap
You now have the tools to implement a complete security system based on
username
and
password
for your API.
Using these tools, you can make the security system compatible with any database and with any user or data model.
The only detail missing is that it is not actually "secure" yet.
In the next chapter you'll see how to use a secure password hashing library and
JWT
tokens.

## 153_TUTORIAL_SQL_DATABASES
SQL (Relational) Databases¶
---

SQL (Relational) Databases
FastAPI
doesn't require you to use a SQL (relational) database. But you can use
any database
that you want.
Here we'll see an example using
SQLModel
.
SQLModel
is built on top of
SQLAlchemy
and Pydantic. It was made by the same author of
FastAPI
to be the perfect match for FastAPI applications that need to use
SQL databases
.
Tip
You could use any other SQL or NoSQL database library you want (in some cases called
"ORMs"
), FastAPI doesn't force you to use anything. 😎
As SQLModel is based on SQLAlchemy, you can easily use
any database supported
by SQLAlchemy (which makes them also supported by SQLModel), like:
PostgreSQL
MySQL
SQLite
Oracle
Microsoft SQL Server, etc.
In this example, we'll use
SQLite
, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is.
Later, for your production application, you might want to use a database server like
PostgreSQL
.
Tip
There is an official project generator with
FastAPI
and
PostgreSQL
including a frontend and more tools:
https://github.com/fastapi/full-stack-fastapi-template
This is a very simple and short tutorial, if you want to learn about databases in general, about SQL, or more advanced features, go to the
SQLModel docs
.
Install
SQLModel
First, make sure you create your
virtual environment
, activate it, and then install
sqlmodel
:
fast →
pip install sqlmodel
restart ↻
Create the App with a Single Model
We'll create the simplest first version of the app with a single
SQLModel
model first.
Later we'll improve it increasing security and versatility with
multiple models
below. 🤓
Create Models
Import
SQLModel
and create a database model:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
The
Hero
class is very similar to a Pydantic model (in fact, underneath, it actually
is a Pydantic model
).
There are a few differences:
table=True
tells SQLModel that this is a
table model
, it should represent a
table
in the SQL database, it's not just a
data model
(as would be any other regular Pydantic class).
Field(primary_key=True)
tells SQLModel that the
id
is the
primary key
in the SQL database (you can learn more about SQL primary keys in the SQLModel docs).
By having the type as
int | None
, SQLModel will know that this column should be an
INTEGER
in the SQL database and that it should be
NULLABLE
.
Field(index=True)
tells SQLModel that it should create a
SQL index
for this column, that would allow faster lookups in the database when reading data filtered by this column.
SQLModel will know that something declared as
str
will be a SQL column of type
TEXT
(or
VARCHAR
, depending on the database).
Create an Engine
A SQLModel
engine
(underneath it's actually a SQLAlchemy
engine
) is what
holds the connections
to the database.
You would have
one single
engine
object
for all your code to connect to the same database.
Python 3.10+
## Code above omitted 👆
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Using
check_same_thread=False
allows FastAPI to use the same SQLite database in different threads. This is necessary as
one single request
could use
more than one thread
(for example in dependencies).
Don't worry, with the way the code is structured, we'll make sure we use
a single SQLModel
session
per request
later, this is actually what the
check_same_thread
is trying to achieve.
Create the Tables
We then add a function that uses
SQLModel.metadata.create_all(engine)
to
create the tables
for all the
table models
.
Python 3.10+
## Code above omitted 👆
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Create a Session Dependency
A
Session
is what stores the
objects in memory
and keeps track of any changes needed in the data, then it
uses the
engine
to communicate with the database.
We will create a FastAPI
dependency
with
yield
that will provide a new
Session
for each request. This is what ensures that we use a single session per request. 🤓
Then we create an
Annotated
dependency
SessionDep
to simplify the rest of the code that will use this dependency.
Python 3.10+
## Code above omitted 👆
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Create Database Tables on Startup
We will create the database tables when the application starts.
Python 3.10+
## Code above omitted 👆
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Here we create the tables on an application startup event.
For production you would probably use a migration script that runs before you start your app. 🤓
Tip
SQLModel will have migration utilities wrapping Alembic, but for now, you can use
Alembic
directly.
Create a Hero
Because each SQLModel model is also a Pydantic model, you can use it in the same
type annotations
that you could use Pydantic models.
For example, if you declare a parameter of type
Hero
, it will be read from the
JSON body
.
The same way, you can declare it as the function's
return type
, and then the shape of the data will show up in the automatic API docs UI.
Python 3.10+
## Code above omitted 👆
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Here we use the
SessionDep
dependency (a
Session
) to add the new
Hero
to the
Session
instance, commit the changes to the database, refresh the data in the
hero
, and then return it.
Read Heroes
We can
read
Hero
s from the database using a
select()
. We can include a
limit
and
offset
to paginate the results.
Python 3.10+
## Code above omitted 👆
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Read One Hero
We can
read
a single
Hero
.
Python 3.10+
## Code above omitted 👆
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Delete a Hero
We can also
delete
a
Hero
.
Python 3.10+
## Code above omitted 👆
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Run the App
You can run the app:
fast →
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
Then go to the
/docs
UI, you will see that
FastAPI
is using these
models
to
document
the API, and it will use them to
serialize
and
validate
the data too.
Update the App with Multiple Models
Now let's
refactor
this app a bit to increase
security
and
versatility
.
If you check the previous app, in the UI you can see that, up to now, it lets the client decide the
id
of the
Hero
to create. 😱
We shouldn't let that happen, they could overwrite an
id
we already have assigned in the DB. Deciding the
id
should be done by the
backend
or the
database
,
not by the client
.
Additionally, we create a
secret_name
for the hero, but so far, we are returning it everywhere, that's not very
secret
... 😅
We'll fix these things by adding a few
extra models
. Here's where SQLModel will shine. ✨
Create Multiple Models
In
SQLModel
, any model class that has
table=True
is a
table model
.
And any model class that doesn't have
table=True
is a
data model
, these ones are actually just Pydantic models (with a couple of small extra features). 🤓
With SQLModel, we can use
inheritance
to
avoid duplicating
all the fields in all the cases.
HeroBase
- the base class
Let's start with a
HeroBase
model that has all the
fields that are shared
by all the models:
name
age
Python 3.10+
## Code above omitted 👆
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Hero
- the
table model
Then let's create
Hero
, the actual
table model
, with the
extra fields
that are not always in the other models:
id
secret_name
Because
Hero
inherits form
HeroBase
, it
also
has the
fields
declared in
HeroBase
, so all the fields for
Hero
are:
id
name
age
secret_name
Python 3.10+
## Code above omitted 👆
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
HeroPublic
- the public
data model
Next, we create a
HeroPublic
model, this is the one that will be
returned
to the clients of the API.
It has the same fields as
HeroBase
, so it won't include
secret_name
.
Finally, the identity of our heroes is protected! 🥷
It also re-declares
id: int
. By doing this, we are making a
contract
with the API clients, so that they can always expect the
id
to be there and to be an
int
(it will never be
None
).
Tip
Having the return model ensure that a value is always available and always
int
(not
None
) is very useful for the API clients, they can write much simpler code having this certainty.
Also,
automatically generated clients
will have simpler interfaces, so that the developers communicating with your API can have a much better time working with your API. 😎
All the fields in
HeroPublic
are the same as in
HeroBase
, with
id
declared as
int
(not
None
):
id
name
age
Python 3.10+
## Code above omitted 👆
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
HeroCreate
- the
data model
to create a hero
Now we create a
HeroCreate
model, this is the one that will
validate
the data from the clients.
It has the same fields as
HeroBase
, and it also has
secret_name
.
Now, when the clients
create a new hero
, they will send the
secret_name
, it will be stored in the database, but those secret names won't be returned in the API to the clients.
Tip
This is how you would handle
passwords
. Receive them, but don't return them in the API.
You would also
hash
the values of the passwords before storing them,
never store them in plain text
.
The fields of
HeroCreate
are:
name
age
secret_name
Python 3.10+
## Code above omitted 👆
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
HeroUpdate
- the
data model
to update a hero
We didn't have a way to
update a hero
in the previous version of the app, but now with
multiple models
, we can do it. 🎉
The
HeroUpdate
data model
is somewhat special, it has
all the same fields
that would be needed to create a new hero, but all the fields are
optional
(they all have a default value). This way, when you update a hero, you can send just the fields that you want to update.
Because all the
fields actually change
(the type now includes
None
and they now have a default value of
None
), we need to
re-declare
them.
We don't really need to inherit from
HeroBase
because we are re-declaring all the fields. I'll leave it inheriting just for consistency, but this is not necessary. It's more a matter of personal taste. 🤷
The fields of
HeroUpdate
are:
name
age
secret_name
Python 3.10+
## Code above omitted 👆
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Create with
HeroCreate
and return a
HeroPublic
Now that we have
multiple models
, we can update the parts of the app that use them.
We receive in the request a
HeroCreate
data model
, and from it, we create a
Hero
table model
.
This new
table model
Hero
will have the fields sent by the client, and will also have an
id
generated by the database.
Then we return the same
table model
Hero
as is from the function. But as we declare the
response_model
with the
HeroPublic
data model
,
FastAPI
will use
HeroPublic
to validate and serialize the data.
Python 3.10+
## Code above omitted 👆
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Now we use
response_model=HeroPublic
instead of the
return type annotation
-> HeroPublic
because the value that we are returning is actually
not
a
HeroPublic
.
If we had declared
-> HeroPublic
, your editor and linter would complain (rightfully so) that you are returning a
Hero
instead of a
HeroPublic
.
By declaring it in
response_model
we are telling
FastAPI
to do its thing, without interfering with the type annotations and the help from your editor and other tools.
Read Heroes with
HeroPublic
We can do the same as before to
read
Hero
s, again, we use
response_model=list[HeroPublic]
to ensure that the data is validated and serialized correctly.
Python 3.10+
## Code above omitted 👆
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Read One Hero with
HeroPublic
We can
read
a single hero:
Python 3.10+
## Code above omitted 👆
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Update a Hero with
HeroUpdate
We can
update a hero
. For this we use an HTTP
PATCH
operation.
And in the code, we get a
dict
with all the data sent by the client,
only the data sent by the client
, excluding any values that would be there just for being the default values. To do it we use
exclude_unset=True
. This is the main trick. 🪄
Then we use
hero_db.sqlmodel_update(hero_data)
to update the
hero_db
with the data from
hero_data
.
Python 3.10+
## Code above omitted 👆
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
## Code below omitted 👇
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Delete a Hero Again
Deleting
a hero stays pretty much the same.
We won't satisfy the desire to refactor everything in this one. 😅
Python 3.10+
## Code above omitted 👆
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
👀 Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
🤓 Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Run the App Again
You can run the app again:
fast →
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ↻
If you go to the
/docs
API UI, you will see that it is now updated, and it won't expect to receive the
id
from the client when creating a hero, etc.
Recap
You can use
SQLModel
to interact with a SQL database and simplify the code with
data models
and
table models
.
You can learn a lot more at the
SQLModel
docs, there's a longer mini
tutorial on using SQLModel with
FastAPI
. 🚀

## 154_TUTORIAL_STATIC_FILES
Static Files¶
---

Static Files
You can serve static files automatically from a directory using
StaticFiles
.
Use
StaticFiles
Import
StaticFiles
.
"Mount" a
StaticFiles()
instance in a specific path.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.staticfiles
import
StaticFiles
app
=
FastAPI
()
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
Technical Details
You could also use
from starlette.staticfiles import StaticFiles
.
FastAPI
provides the same
starlette.staticfiles
as
fastapi.staticfiles
just as a convenience for you, the developer. But it actually comes directly from Starlette.
What is "Mounting"
"Mounting" means adding a complete "independent" application in a specific path, that then takes care of handling all the sub-paths.
This is different from using an
APIRouter
as a mounted application is completely independent. The OpenAPI and docs from your main application won't include anything from the mounted application, etc.
You can read more about this in the
Advanced User Guide
.
Details
The first
"/static"
refers to the sub-path this "sub-application" will be "mounted" on. So, any path that starts with
"/static"
will be handled by it.
The
directory="static"
refers to the name of the directory that contains your static files.
The
name="static"
gives it a name that can be used internally by
FastAPI
.
All these parameters can be different than "
static
", adjust them with the needs and specific details of your own application.
More info
For more details and options check
Starlette's docs about Static Files
.

## 155_TUTORIAL_TESTING
Testing¶
---

Testing
Thanks to
Starlette
, testing
FastAPI
applications is easy and enjoyable.
It is based on
HTTPX
, which in turn is designed based on Requests, so it's very familiar and intuitive.
With it, you can use
pytest
directly with
FastAPI
.
Using
TestClient
Info
To use
TestClient
, first install
httpx
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
httpx
Import
TestClient
.
Create a
TestClient
by passing your
FastAPI
application to it.
Create functions with a name that starts with
test_
(this is standard
pytest
conventions).
Use the
TestClient
object the same way as you do with
httpx
.
Write simple
assert
statements with the standard Python expressions that you need to check (again, standard
pytest
).
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_main
():
return
{
"msg"
:
"Hello World"
}
client
=
TestClient
(
app
)
def
test_read_main
():
response
=
client
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"msg"
:
"Hello World"
}
Tip
Notice that the testing functions are normal
def
, not
async def
.
And the calls to the client are also normal calls, not using
await
.
This allows you to use
pytest
directly without complications.
Technical Details
You could also use
from starlette.testclient import TestClient
.
FastAPI
provides the same
starlette.testclient
as
fastapi.testclient
just as a convenience for you, the developer. But it comes directly from Starlette.
Tip
If you want to call
async
functions in your tests apart from sending requests to your FastAPI application (e.g. asynchronous database functions), have a look at the
Async Tests
in the advanced tutorial.
Separating tests
In a real application, you probably would have your tests in a different file.
And your
FastAPI
application might also be composed of several files/modules, etc.
FastAPI
app file
Let's say you have a file structure as described in
Bigger Applications
:
.
├── app
│   ├── __init__.py
│   └── main.py
In the file
main.py
you have your
FastAPI
app:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_main
():
return
{
"msg"
:
"Hello World"
}
Testing file
Then you could have a file
test_main.py
with your tests. It could live on the same Python package (the same directory with a
__init__.py
file):
.
├── app
│   ├── __init__.py
│   ├── main.py
│   └── test_main.py
Because this file is in the same package, you can use relative imports to import the object
app
from the
main
module (
main.py
):
Python 3.8+
from
fastapi.testclient
import
TestClient
from
.main
import
app
client
=
TestClient
(
app
)
def
test_read_main
():
response
=
client
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"msg"
:
"Hello World"
}
...and have the code for the tests just like before.
Testing: extended example
Now let's extend this example and add more details to see how to test different parts.
Extended
FastAPI
app file
Let's continue with the same file structure as before:
.
├── app
│   ├── __init__.py
│   ├── main.py
│   └── test_main.py
Let's say that now the file
main.py
with your
FastAPI
app has some other
path operations
.
It has a
GET
operation that could return an error.
It has a
POST
operation that could return several errors.
Both
path operations
require an
X-Token
header.
Python 3.10+
Python 3.9+
Python 3.8+
Python 3.10+ non-Annotated
Python 3.8+ non-Annotated
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
,
HTTPException
from
pydantic
import
BaseModel
fake_secret_token
=
"coneofsilence"
fake_db
=
{
"foo"
:
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
},
"bar"
:
{
"id"
:
"bar"
,
"title"
:
"Bar"
,
"description"
:
"The bartenders"
},
}
app
=
FastAPI
()
class
Item
(
BaseModel
):
id
:
str
title
:
str
description
:
str
|
None
=
None
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_main
(
item_id
:
str
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item_id
not
in
fake_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
fake_db
[
item_id
]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item
.
id
in
fake_db
:
raise
HTTPException
(
status_code
=
409
,
detail
=
"Item already exists"
)
fake_db
[
item
.
id
]
=
item
return
item
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
,
HTTPException
from
pydantic
import
BaseModel
fake_secret_token
=
"coneofsilence"
fake_db
=
{
"foo"
:
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
},
"bar"
:
{
"id"
:
"bar"
,
"title"
:
"Bar"
,
"description"
:
"The bartenders"
},
}
app
=
FastAPI
()
class
Item
(
BaseModel
):
id
:
str
title
:
str
description
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_main
(
item_id
:
str
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item_id
not
in
fake_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
fake_db
[
item_id
]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item
.
id
in
fake_db
:
raise
HTTPException
(
status_code
=
409
,
detail
=
"Item already exists"
)
fake_db
[
item
.
id
]
=
item
return
item
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
,
HTTPException
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_secret_token
=
"coneofsilence"
fake_db
=
{
"foo"
:
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
},
"bar"
:
{
"id"
:
"bar"
,
"title"
:
"Bar"
,
"description"
:
"The bartenders"
},
}
app
=
FastAPI
()
class
Item
(
BaseModel
):
id
:
str
title
:
str
description
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_main
(
item_id
:
str
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item_id
not
in
fake_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
fake_db
[
item_id
]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item
.
id
in
fake_db
:
raise
HTTPException
(
status_code
=
409
,
detail
=
"Item already exists"
)
fake_db
[
item
.
id
]
=
item
return
item
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
,
HTTPException
from
pydantic
import
BaseModel
fake_secret_token
=
"coneofsilence"
fake_db
=
{
"foo"
:
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
},
"bar"
:
{
"id"
:
"bar"
,
"title"
:
"Bar"
,
"description"
:
"The bartenders"
},
}
app
=
FastAPI
()
class
Item
(
BaseModel
):
id
:
str
title
:
str
description
:
str
|
None
=
None
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_main
(
item_id
:
str
,
x_token
:
str
=
Header
()):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item_id
not
in
fake_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
fake_db
[
item_id
]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
,
x_token
:
str
=
Header
()):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item
.
id
in
fake_db
:
raise
HTTPException
(
status_code
=
409
,
detail
=
"Item already exists"
)
fake_db
[
item
.
id
]
=
item
return
item
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
,
HTTPException
from
pydantic
import
BaseModel
fake_secret_token
=
"coneofsilence"
fake_db
=
{
"foo"
:
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
},
"bar"
:
{
"id"
:
"bar"
,
"title"
:
"Bar"
,
"description"
:
"The bartenders"
},
}
app
=
FastAPI
()
class
Item
(
BaseModel
):
id
:
str
title
:
str
description
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_main
(
item_id
:
str
,
x_token
:
str
=
Header
()):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item_id
not
in
fake_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
fake_db
[
item_id
]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
,
x_token
:
str
=
Header
()):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item
.
id
in
fake_db
:
raise
HTTPException
(
status_code
=
409
,
detail
=
"Item already exists"
)
fake_db
[
item
.
id
]
=
item
return
item
Extended testing file
You could then update
test_main.py
with the extended tests:
Python 3.8+
from
fastapi.testclient
import
TestClient
from
.main
import
app
client
=
TestClient
(
app
)
def
test_read_item
():
response
=
client
.
get
(
"/items/foo"
,
headers
=
{
"X-Token"
:
"coneofsilence"
})
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
,
}
def
test_read_item_bad_token
():
response
=
client
.
get
(
"/items/foo"
,
headers
=
{
"X-Token"
:
"hailhydra"
})
assert
response
.
status_code
==
400
assert
response
.
json
()
==
{
"detail"
:
"Invalid X-Token header"
}
def
test_read_nonexistent_item
():
response
=
client
.
get
(
"/items/baz"
,
headers
=
{
"X-Token"
:
"coneofsilence"
})
assert
response
.
status_code
==
404
assert
response
.
json
()
==
{
"detail"
:
"Item not found"
}
def
test_create_item
():
response
=
client
.
post
(
"/items/"
,
headers
=
{
"X-Token"
:
"coneofsilence"
},
json
=
{
"id"
:
"foobar"
,
"title"
:
"Foo Bar"
,
"description"
:
"The Foo Barters"
},
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"id"
:
"foobar"
,
"title"
:
"Foo Bar"
,
"description"
:
"The Foo Barters"
,
}
def
test_create_item_bad_token
():
response
=
client
.
post
(
"/items/"
,
headers
=
{
"X-Token"
:
"hailhydra"
},
json
=
{
"id"
:
"bazz"
,
"title"
:
"Bazz"
,
"description"
:
"Drop the bazz"
},
)
assert
response
.
status_code
==
400
assert
response
.
json
()
==
{
"detail"
:
"Invalid X-Token header"
}
def
test_create_existing_item
():
response
=
client
.
post
(
"/items/"
,
headers
=
{
"X-Token"
:
"coneofsilence"
},
json
=
{
"id"
:
"foo"
,
"title"
:
"The Foo ID Stealers"
,
"description"
:
"There goes my stealer"
,
},
)
assert
response
.
status_code
==
409
assert
response
.
json
()
==
{
"detail"
:
"Item already exists"
}
Whenever you need the client to pass information in the request and you don't know how to, you can search (Google) how to do it in
httpx
, or even how to do it with
requests
, as HTTPX's design is based on Requests' design.
Then you just do the same in your tests.
E.g.:
To pass a
path
or
query
parameter, add it to the URL itself.
To pass a JSON body, pass a Python object (e.g. a
dict
) to the parameter
json
.
If you need to send
Form Data
instead of JSON, use the
data
parameter instead.
To pass
headers
, use a
dict
in the
headers
parameter.
For
cookies
, a
dict
in the
cookies
parameter.
For more information about how to pass data to the backend (using
httpx
or the
TestClient
) check the
HTTPX documentation
.
Info
Note that the
TestClient
receives data that can be converted to JSON, not Pydantic models.
If you have a Pydantic model in your test and you want to send its data to the application during testing, you can use the
jsonable_encoder
described in
JSON Compatible Encoder
.
Run it
After that, you just need to install
pytest
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
fast →
pip install pytest
restart ↻
It will detect the files and tests automatically, execute them, and report the results back to you.
Run the tests with:
fast →
pytest
--- test session starts ---
platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
rootdir: /home/user/code/superawesome-cli/app
plugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1
collected 6 items
test_main.py
...... [100%]
--- 1 passed in 0.03s ---
restart ↻

## 156_UK
FastAPI
Готовий до продакшину, високопродуктивний, простий у вивченні та швидкий для написання коду фреймворк
Документація
:
https://fastapi.tiangolo.com
Програмний код
:
https://github.com/fastapi/fastapi
FastAPI - це сучасний, швидкий (високопродуктивний), вебфреймворк для створення API за допомогою Python,в основі якого лежить стандартна анотація типів Python.
Ключові особливості:
Швидкий
: Дуже висока продуктивність, на рівні з
NodeJS
та
Go
(завдяки Starlette та Pydantic).
Один із найшвидших фреймворків
.
Швидке написання коду
: Пришвидшує розробку функціоналу приблизно на 200%-300%. *
Менше помилок
: Зменшить кількість помилок спричинених людиною (розробником) на 40%. *
Інтуїтивний
: Чудова підтримка редакторами коду.
Доповнення
всюди. Зменште час на налагодження.
Простий
: Спроектований, для легкого використання та навчання. Знадобиться менше часу на читання документації.
Короткий
: Зведе до мінімуму дублювання коду. Кожен оголошений параметр може виконувати кілька функцій.
Надійний
: Ви матимете стабільний код готовий до продакшину з автоматичною інтерактивною документацією.
Стандартизований
: Оснований та повністю сумісний з відкритими стандартами для API:
OpenAPI
(попередньо відомий як Swagger) та
JSON Schema
.
* оцінка на основі тестів внутрішньої команди розробників, створення продуктових застосунків.
Спонсори
Other sponsors
Враження
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I’m over the moon excited about
FastAPI
. It’s so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, FastAPI CLI
Створюючи
CLI
застосунок для використання в терміналі, замість веб-API зверніть увагу на
Typer
.
Typer
є молодшим братом FastAPI. І це
FastAPI для CLI
. ⌨️ 🚀
Вимоги
FastAPI стоїть на плечах гігантів:
Starlette
для web частини.
Pydantic
для частини даних.
Вставновлення
fast →
pip install fastapi
restart ↻
Вам також знадобиться сервер ASGI для продакшину, наприклад
Uvicorn
або
Hypercorn
.
fast →
pip install uvicorn[standard]
restart ↻
Приклад
Створіть
Створіть файл
main.py
з:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Або використайте
async def
...
Якщо ваш код використовує
async
/
await
, скористайтеся
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Примітка
:
Стикнувшись з проблемами, не зайвим буде ознайомитися з розділом
"In a hurry?"
про
async
та
await
у документації
.
Запустіть
Запустіть server з:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
Про команди
uvicorn main:app --reload
...
Команда
uvicorn main:app
посилається на:
main
: файл
main.py
("Модуль" Python).
app
: об’єкт створений усередині
main.py
рядком
app = FastAPI()
.
--reload
: перезапускає сервер після зміни коду. Використовуйте виключно для розробки.
Перевірте
Відкрийте браузер та введіть адресу
http://127.0.0.1:8000/items/5?q=somequery
.
Ви побачите у відповідь подібний JSON:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Ви вже створили API, який:
Отримує HTTP запити за
шляхами
/
та
/items/{item_id}
.
Обидва
шляхи
приймають
GET
операції
(також відомі як HTTP
методи
).
Шлях
/items/{item_id}
містить
параметр шляху
item_id
який має бути типу
int
.
Шлях
/items/{item_id}
містить необовʼязковий
str
параметр запиту
q
.
Інтерактивні документації API
Перейдемо сюди
http://127.0.0.1:8000/docs
.
Ви побачите автоматичну інтерактивну API документацію (створену завдяки
Swagger UI
):
Альтернативні документації API
Тепер перейдемо сюди
http://127.0.0.1:8000/redoc
.
Ви побачите альтернативну автоматичну документацію (створену завдяки
ReDoc
):
Приклад оновлення
Тепер модифікуйте файл
main.py
, щоб отримати вміст запиту
PUT
.
Оголошуйте вміст запиту за допомогою стандартних типів Python завдяки Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Сервер повинен автоматично перезавантажуватися (тому що Ви додали
--reload
до
uvicorn
команди вище).
Оновлення інтерактивної API документації
Тепер перейдемо сюди
http://127.0.0.1:8000/docs
.
Інтерактивна документація API буде автоматично оновлена, включаючи новий вміст:
Натисніть кнопку "Try it out", це дозволить вам заповнити параметри та безпосередньо взаємодіяти з API:
Потім натисніть кнопку "Execute", інтерфейс користувача зв'яжеться з вашим API, надішле параметри, у відповідь отримає результати та покаже їх на екрані:
Оновлення альтернативної API документації
Зараз перейдемо
http://127.0.0.1:8000/redoc
.
Альтернативна документація також показуватиме новий параметр і вміст запиту:
Підсумки
Таким чином, Ви
один раз
оголошуєте типи параметрів, тіла тощо, як параметри функції.
Ви робите це за допомогою стандартних сучасних типів Python.
Вам не потрібно вивчати новий синтаксис, методи чи класи конкретної бібліотеки тощо.
Використовуючи стандартний
Python
.
Наприклад, для
int
:
item_id
:
int
або для більш складної моделі
Item
:
item
:
Item
...і з цим єдиним оголошенням Ви отримуєте:
Підтримку редактора, включаючи:
Варіанти заповнення.
Перевірку типів.
Перевірку даних:
Автоматичні та зрозумілі помилки, у разі некоректних даних.
Перевірка навіть для JSON з високим рівнем вкладеності.
Перетворення
вхідних даних: з мережі до даних і типів Python. Читання з:
JSON.
Параметрів шляху.
Параметрів запиту.
Cookies.
Headers.
Forms.
Файлів.
Перетворення
вихідних даних: з типів і даних Python до мережевих даних (як JSON):
Конвертація Python типів (
str
,
int
,
float
,
bool
,
list
, тощо).
datetime
об'єкти.
UUID
об'єкти.
Моделі бази даних.
...та багато іншого.
Автоматичну інтерактивну документацію API, включаючи 2 альтернативні інтерфейси користувача:
Swagger UI.
ReDoc.
Повертаючись до попереднього прикладу коду,
FastAPI
:
Підтвердить наявність
item_id
у шляху для запитів
GET
та
PUT
.
Підтвердить, що
item_id
має тип
int
для запитів
GET
and
PUT
.
Якщо це не так, клієнт побачить корисну, зрозумілу помилку.
Перевірить, чи є необов'язковий параметр запиту з назвою
q
(а саме
http://127.0.0.1:8000/items/foo?q=somequery
) для запитів
GET
.
Оскільки параметр
q
оголошено як
= None
, він необов'язковий.
За відсутності
None
він був би обов'язковим (як і вміст у випадку з
PUT
).
Для запитів
PUT
із
/items/{item_id}
, читає вміст як JSON:
Перевірить, чи має обов'язковий атрибут
name
тип
str
.
Перевірить, чи має обов'язковий атрибут
price
тип
float
.
Перевірить, чи існує необов'язковий атрибут
is_offer
та чи має він тип
bool
.
Усе це також працюватиме для глибоко вкладених об'єктів JSON.
Автоматично конвертує із та в JSON.
Документує все за допомогою OpenAPI, який може бути використано в:
Інтерактивних системах документації.
Системах автоматичної генерації клієнтського коду для багатьох мов.
Надає безпосередньо 2 вебінтерфейси інтерактивної документації.
Ми лише трішки доторкнулися до коду, але Ви вже маєте уявлення про те, як все працює.
Спробуйте змінити рядок:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...із:
...
"item_name"
:
item
.
name
...
...на:
...
"item_price"
:
item
.
price
...
...і побачите, як ваш редактор автоматично заповнюватиме атрибути та знатиме їхні типи:
Для більш повного ознайомлення з додатковими функціями, перегляньте
Туторіал - Посібник Користувача
.
Spoiler alert
: туторіал - посібник користувача містить:
Оголошення
параметрів
з інших місць як:
headers
,
cookies
,
form fields
та
files
.
Як встановити
перевірку обмежень
як
maximum_length
або
regex
.
Дуже потужна і проста у використанні система
Ін'єкція Залежностей
.
Безпека та автентифікація, включаючи підтримку
OAuth2
з
JWT tokens
та
HTTP Basic
автентифікацію.
Досконаліші (але однаково прості) техніки для оголошення
глибоко вкладених моделей JSON
(завдяки Pydantic).
Багато додаткових функцій (завдяки Starlette) як-от:
WebSockets
надзвичайно прості тести на основі HTTPX та
pytest
CORS
Cookie Sessions
...та більше.
Продуктивність
Незалежні тести TechEmpower показують що застосунки
FastAPI
, які працюють під керуванням Uvicorn
є одними з найшвидших серед доступних фреймворків в Python
, поступаючись лише Starlette та Uvicorn (які внутрішньо використовуються в FastAPI). (*)
Щоб дізнатися більше про це, перегляньте розділ
Benchmarks
.
Необов'язкові залежності
Pydantic використовує:
email-validator
- для валідації електронної пошти.
pydantic-settings
- для управління налаштуваннями.
pydantic-extra-types
- для додаткових типів, що можуть бути використані з Pydantic.
Starlette використовує:
httpx
- Необхідно, якщо Ви хочете використовувати
TestClient
.
jinja2
- Необхідно, якщо Ви хочете використовувати шаблони як конфігурацію за замовчуванням.
python-multipart
- Необхідно, якщо Ви хочете підтримувати
"розбір"
форми за допомогою
request.form()
.
itsdangerous
- Необхідно для підтримки
SessionMiddleware
.
pyyaml
- Необхідно для підтримки Starlette
SchemaGenerator
(ймовірно, вам це не потрібно з FastAPI).
FastAPI / Starlette використовують:
uvicorn
- для сервера, який завантажує та обслуговує вашу програму.
orjson
- Необхідно, якщо Ви хочете використовувати
ORJSONResponse
.
ujson
- Необхідно, якщо Ви хочете використовувати
UJSONResponse
.
Ви можете встановити все це за допомогою
pip install fastapi[all]
.
Ліцензія
Цей проєкт ліцензовано згідно з умовами ліцензії MIT.

## 157_UR
FastAPI¶
---

FastAPI
Warning
The current page still doesn't have a translation for this language.
But you can help translating it:
Contributing
.
FastAPI framework, high performance, easy to learn, fast to code, ready for production
Documentation
:
https://fastapi.tiangolo.com
Source Code
:
https://github.com/fastapi/fastapi
FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints.
The key features are:
Fast
: Very high performance, on par with
NodeJS
and
Go
(thanks to Starlette and Pydantic).
One of the fastest Python frameworks available
.
Fast to code
: Increase the speed to develop features by about 200% to 300%. *
Fewer bugs
: Reduce about 40% of human (developer) induced errors. *
Intuitive
: Great editor support.
Completion
everywhere. Less time debugging.
Easy
: Designed to be easy to use and learn. Less time reading docs.
Short
: Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs.
Robust
: Get production-ready code. With automatic interactive documentation.
Standards-based
: Based on (and fully compatible with) the open standards for APIs:
OpenAPI
(previously known as Swagger) and
JSON Schema
.
* estimation based on tests on an internal development team, building production applications.
Sponsors
Other sponsors
Opinions
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I’m over the moon excited about
FastAPI
. It’s so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
If anyone is looking to build a production Python API, I would highly recommend
FastAPI
. It is
beautifully designed
,
simple to use
and
highly scalable
, it has become a
key component
in our API first development strategy and is driving many automations and services such as our Virtual TAC Engineer.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, the FastAPI of CLIs
If you are building a
CLI
app to be used in the terminal instead of a web API, check out
Typer
.
Typer
is FastAPI's little sibling. And it's intended to be the
FastAPI of CLIs
. ⌨️ 🚀
Requirements
FastAPI stands on the shoulders of giants:
Starlette
for the web parts.
Pydantic
for the data parts.
Installation
Create and activate a
virtual environment
and then install FastAPI:
fast →
pip install "fastapi[standard]"
restart ↻
Note
: Make sure you put
"fastapi[standard]"
in quotes to ensure it works in all terminals.
Example
Create it
Create a file
main.py
with:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Or use
async def
...
If your code uses
async
/
await
, use
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Note
:
If you don't know, check the
"In a hurry?"
section about
async
and
await
in the docs
.
Run it
Run the server with:
fast →
fastapi dev main.py
╭────────── FastAPI CLI - Development mode ───────────╮
│ │
│ Serving at: http://127.0.0.1:8000 │
│ │
│ API docs: http://127.0.0.1:8000/docs │
│ │
│ Running in development mode, for production use: │
│ │
│ fastapi run │
│ │
╰─────────────────────────────────────────────────────╯
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
About the command
fastapi dev main.py
...
The command
fastapi dev
reads your
main.py
file, detects the
FastAPI
app in it, and starts a server using
Uvicorn
.
By default,
fastapi dev
will start with auto-reload enabled for local development.
You can read more about it in the
FastAPI CLI docs
.
Check it
Open your browser at
http://127.0.0.1:8000/items/5?q=somequery
.
You will see the JSON response as:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
You already created an API that:
Receives HTTP requests in the
paths
/
and
/items/{item_id}
.
Both
paths
take
GET
operations
(also known as HTTP
methods
).
The
path
/items/{item_id}
has a
path parameter
item_id
that should be an
int
.
The
path
/items/{item_id}
has an optional
str
query parameter
q
.
Interactive API docs
Now go to
http://127.0.0.1:8000/docs
.
You will see the automatic interactive API documentation (provided by
Swagger UI
):
Alternative API docs
And now, go to
http://127.0.0.1:8000/redoc
.
You will see the alternative automatic documentation (provided by
ReDoc
):
Example upgrade
Now modify the file
main.py
to receive a body from a
PUT
request.
Declare the body using standard Python types, thanks to Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
The
fastapi dev
server should reload automatically.
Interactive API docs upgrade
Now go to
http://127.0.0.1:8000/docs
.
The interactive API documentation will be automatically updated, including the new body:
Click on the button "Try it out", it allows you to fill the parameters and directly interact with the API:
Then click on the "Execute" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen:
Alternative API docs upgrade
And now, go to
http://127.0.0.1:8000/redoc
.
The alternative documentation will also reflect the new query parameter and body:
Recap
In summary, you declare
once
the types of parameters, body, etc. as function parameters.
You do that with standard modern Python types.
You don't have to learn a new syntax, the methods or classes of a specific library, etc.
Just standard
Python
.
For example, for an
int
:
item_id
:
int
or for a more complex
Item
model:
item
:
Item
...and with that single declaration you get:
Editor support, including:
Completion.
Type checks.
Validation of data:
Automatic and clear errors when the data is invalid.
Validation even for deeply nested JSON objects.
Conversion
of input data: coming from the network to Python data and types. Reading from:
JSON.
Path parameters.
Query parameters.
Cookies.
Headers.
Forms.
Files.
Conversion
of output data: converting from Python data and types to network data (as JSON):
Convert Python types (
str
,
int
,
float
,
bool
,
list
, etc).
datetime
objects.
UUID
objects.
Database models.
...and many more.
Automatic interactive API documentation, including 2 alternative user interfaces:
Swagger UI.
ReDoc.
Coming back to the previous code example,
FastAPI
will:
Validate that there is an
item_id
in the path for
GET
and
PUT
requests.
Validate that the
item_id
is of type
int
for
GET
and
PUT
requests.
If it is not, the client will see a useful, clear error.
Check if there is an optional query parameter named
q
(as in
http://127.0.0.1:8000/items/foo?q=somequery
) for
GET
requests.
As the
q
parameter is declared with
= None
, it is optional.
Without the
None
it would be required (as is the body in the case with
PUT
).
For
PUT
requests to
/items/{item_id}
, read the body as JSON:
Check that it has a required attribute
name
that should be a
str
.
Check that it has a required attribute
price
that has to be a
float
.
Check that it has an optional attribute
is_offer
, that should be a
bool
, if present.
All this would also work for deeply nested JSON objects.
Convert from and to JSON automatically.
Document everything with OpenAPI, that can be used by:
Interactive documentation systems.
Automatic client code generation systems, for many languages.
Provide 2 interactive documentation web interfaces directly.
We just scratched the surface, but you already get the idea of how it all works.
Try changing the line with:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...from:
...
"item_name"
:
item
.
name
...
...to:
...
"item_price"
:
item
.
price
...
...and see how your editor will auto-complete the attributes and know their types:
For a more complete example including more features, see the
Tutorial - User Guide
.
Spoiler alert
: the tutorial - user guide includes:
Declaration of
parameters
from other different places as:
headers
,
cookies
,
form fields
and
files
.
How to set
validation constraints
as
maximum_length
or
regex
.
A very powerful and easy to use
Dependency Injection
system.
Security and authentication, including support for
OAuth2
with
JWT tokens
and
HTTP Basic
auth.
More advanced (but equally easy) techniques for declaring
deeply nested JSON models
(thanks to Pydantic).
GraphQL
integration with
Strawberry
and other libraries.
Many extra features (thanks to Starlette) as:
WebSockets
extremely easy tests based on HTTPX and
pytest
CORS
Cookie Sessions
...and more.
Performance
Independent TechEmpower benchmarks show
FastAPI
applications running under Uvicorn as
one of the fastest Python frameworks available
, only below Starlette and Uvicorn themselves (used internally by FastAPI). (*)
To understand more about it, see the section
Benchmarks
.
Dependencies
FastAPI depends on Pydantic and Starlette.
standard
Dependencies
When you install FastAPI with
pip install "fastapi[standard]"
it comes with the
standard
group of optional dependencies:
Used by Pydantic:
email-validator
- for email validation.
Used by Starlette:
httpx
- Required if you want to use the
TestClient
.
jinja2
- Required if you want to use the default template configuration.
python-multipart
- Required if you want to support form
"parsing"
, with
request.form()
.
Used by FastAPI / Starlette:
uvicorn
- for the server that loads and serves your application. This includes
uvicorn[standard]
, which includes some dependencies (e.g.
uvloop
) needed for high performance serving.
fastapi-cli
- to provide the
fastapi
command.
Without
standard
Dependencies
If you don't want to include the
standard
optional dependencies, you can install with
pip install fastapi
instead of
pip install "fastapi[standard]"
.
Additional Optional Dependencies
There are some additional dependencies you might want to install.
Additional optional Pydantic dependencies:
pydantic-settings
- for settings management.
pydantic-extra-types
- for extra types to be used with Pydantic.
Additional optional FastAPI dependencies:
orjson
- Required if you want to use
ORJSONResponse
.
ujson
- Required if you want to use
UJSONResponse
.
License
This project is licensed under the terms of the MIT license.

## 158_VI
FastAPI¶
---

FastAPI
FastAPI framework, hiệu năng cao, dễ học, dễ code, sẵn sàng để tạo ra sản phẩm
Tài liệu
:
https://fastapi.tiangolo.com
Mã nguồn
:
https://github.com/fastapi/fastapi
FastAPI là một web framework hiện đại, hiệu năng cao để xây dựng web APIs với Python dựa trên tiêu chuẩn Python type hints.
Những tính năng như:
Nhanh
: Hiệu năng rất cao khi so sánh với
NodeJS
và
Go
(cảm ơn Starlette và Pydantic).
Một trong những Python framework nhanh nhất
.
Code nhanh
: Tăng tốc độ phát triển tính năng từ 200% tới 300%. *
Ít lỗi hơn
: Giảm khoảng 40% những lỗi phát sinh bởi con người (nhà phát triển). *
Trực giác tốt hơn
: Được các trình soạn thảo hỗ tuyệt vời.
Completion
mọi nơi. Ít thời gian gỡ lỗi.
Dễ dàng
: Được thiết kế để dễ dàng học và sử dụng. Ít thời gian đọc tài liệu.
Ngắn
: Tối thiểu code bị trùng lặp. Nhiều tính năng được tích hợp khi định nghĩa tham số. Ít lỗi hơn.
Tăng tốc
: Có được sản phẩm cùng với tài liệu (được tự động tạo) có thể tương tác.
Được dựa trên các tiêu chuẩn
: Dựa trên (và hoàn toàn tương thích với) các tiêu chuẩn mở cho APIs :
OpenAPI
(trước đó được biết đến là Swagger) và
JSON Schema
.
* ước tính được dựa trên những kiểm chứng trong nhóm phát triển nội bộ, xây dựng các ứng dụng sản phẩm.
Nhà tài trợ
Những nhà tài trợ khác
Ý kiến đánh giá
"
[...] Tôi đang sử dụng
FastAPI
vô cùng nhiều vào những ngày này. [...] Tôi thực sự đang lên kế hoạch sử dụng nó cho tất cả các nhóm
dịch vụ ML tại Microsoft
. Một vài trong số đó đang tích hợp vào sản phẩm lõi của
Window
và một vài sản phẩm cho
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
Chúng tôi tích hợp thư viện
FastAPI
để sinh ra một
REST
server, nó có thể được truy vấn để thu được những
dự đoán
.
[bởi Ludwid] "
Piero Molino, Yaroslav Dudin, và Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
vui mừng thông báo việc phát hành framework mã nguồn mở của chúng tôi cho
quản lí khủng hoảng
tập trung:
Dispatch
! [xây dựng với
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Tôi vô cùng hào hứng về
FastAPI
. Nó rất thú vị
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Thành thật, những gì bạn đã xây dựng nhìn siêu chắc chắn và bóng bẩy. Theo nhiều cách, nó là những gì tôi đã muốn Hug trở thành - thật sự truyền cảm hứng để thấy ai đó xây dựng nó.
"
Timothy Crosley - người tạo ra
Hug
(ref)
"
Nếu bạn đang tìm kiếm một
framework hiện đại
để xây dựng một REST APIs, thử xem xét
FastAPI
[...] Nó nhanh, dễ dùng và dễ học [...]
"
"
Chúng tôi đã chuyển qua
FastAPI cho **APIs
của chúng tôi [...] Tôi nghĩ bạn sẽ thích nó [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Ines Montani - Matthew Honnibal -
nhà sáng lập
Explosion AI
- người tạo ra
spaCy
(ref)
-
(ref)
"
Nếu ai đó đang tìm cách xây dựng sản phẩm API bằng Python, tôi sẽ đề xuất
FastAPI
. Nó
được thiết kế đẹp đẽ
,
sử dụng đơn giản
và
có khả năng mở rộng cao
, nó đã trở thành một
thành phần quan trọng
trong chiến lược phát triển API của chúng tôi và đang thúc đẩy nhiều dịch vụ và mảng tự động hóa như Kỹ sư TAC ảo của chúng tôi.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, giao diện dòng lệnh của FastAPI
Nếu bạn đang xây dựng một
CLI
- ứng dụng được sử dụng trong giao diện dòng lệnh, xem về
Typer
.
Typer
là một người anh em của FastAPI. Và nó được dự định trở thành
giao diện dòng lệnh cho FastAPI
. ⌨️ 🚀
Yêu cầu
FastAPI đứng trên vai những người khổng lồ:
Starlette
cho phần web.
Pydantic
cho phần data.
Cài đặt
fast →
pip install fastapi
restart ↻
Bạn cũng sẽ cần một ASGI server cho production như
Uvicorn
hoặc
Hypercorn
.
fast →
pip install "uvicorn[standard]"
restart ↻
Ví dụ
Khởi tạo
Tạo một tệp tin
main.py
như sau:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Hoặc sử dụng
async def
...
Nếu code của bạn sử dụng
async
/
await
, hãy sử dụng
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Lưu ý
:
Nếu bạn không biết, xem phần
"In a hurry?"
về
async
và
await
trong tài liệu này
.
Chạy ứng dụng
Chạy server như sau:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
Về lệnh
uvicorn main:app --reload
...
Lệnh
uvicorn main:app
tham chiếu tới những thành phần sau:
main
: tệp tin
main.py
(một Python "module").
app
: object được tạo trong tệp tin
main.py
tại dòng
app = FastAPI()
.
--reload
: chạy lại server sau khi code thay đổi. Chỉ sử dụng trong quá trình phát triển.
Kiểm tra
Mở trình duyệt của bạn tại
http://127.0.0.1:8000/items/5?q=somequery
.
Bạn sẽ thấy một JSON response:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Bạn đã sẵn sàng để tạo một API như sau:
Nhận HTTP request với
đường dẫn
/
và
/items/{item_id}
.
Cả hai
đường dẫn
sử dụng
toán tử
GET
(cũng đươc biết đến là
phương thức
HTTP).
Đường dẫn
/items/{item_id}
có một
tham số đường dẫn
item_id
, nó là một tham số kiểu
int
.
Đường dẫn
/items/{item_id}
có một
tham số query string
q
, nó là một tham số tùy chọn kiểu
str
.
Tài liệu tương tác API
Truy cập
http://127.0.0.1:8000/docs
.
Bạn sẽ thấy tài liệu tương tác API được tạo tự động (cung cấp bởi
Swagger UI
):
Tài liệu API thay thế
Và bây giờ, hãy truy cập tới
http://127.0.0.1:8000/redoc
.
Bạn sẽ thấy tài liệu được thay thế (cung cấp bởi
ReDoc
):
Nâng cấp ví dụ
Bây giờ sửa tệp tin
main.py
để nhận body từ một request
PUT
.
Định nghĩa của body sử dụng kiểu dữ liệu chuẩn của Python, cảm ơn Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Server nên tự động chạy lại (bởi vì bạn đã thêm
--reload
trong lệnh
uvicorn
ở trên).
Nâng cấp tài liệu API
Bây giờ truy cập tới
http://127.0.0.1:8000/docs
.
Tài liệu API sẽ được tự động cập nhật, bao gồm body mới:
Click vào nút "Try it out", nó cho phép bạn điền những tham số và tương tác trực tiếp với API:
Sau khi click vào nút "Execute", giao diện người dùng sẽ giao tiếp với API của bạn bao gồm: gửi các tham số, lấy kết quả và hiển thị chúng trên màn hình:
Nâng cấp tài liệu API thay thế
Và bây giờ truy cập tới
http://127.0.0.1:8000/redoc
.
Tài liệu thay thế cũng sẽ phản ánh tham số và body mới:
Tóm lại
Bạn khai báo
một lần
kiểu dữ liệu của các tham số, body, etc là các tham số của hàm số.
Bạn định nghĩa bằng cách sử dụng các kiểu dữ liệu chuẩn của Python.
Bạn không phải học một cú pháp mới, các phương thức và class của một thư viện cụ thể nào.
Chỉ cần sử dụng các chuẩn của
Python
.
Ví dụ, với một tham số kiểu
int
:
item_id
:
int
hoặc với một model
Item
phức tạp hơn:
item
:
Item
...và với định nghĩa đơn giản đó, bạn có được:
Sự hỗ trợ từ các trình soạn thảo, bao gồm:
Completion.
Kiểm tra kiểu dữ liệu.
Kiểm tra kiểu dữ liệu:
Tự động sinh lỗi rõ ràng khi dữ liệu không hợp lệ .
Kiểm tra JSON lồng nhau .
Chuyển đổi
dữ liệu đầu vào: tới từ network sang dữ liệu kiểu Python. Đọc từ:
JSON.
Các tham số trong đường dẫn.
Các tham số trong query string.
Cookies.
Headers.
Forms.
Files.
Chuyển đổi
dữ liệu đầu ra: chuyển đổi từ kiểu dữ liệu Python sang dữ liệu network (như JSON):
Chuyển đổi kiểu dữ liệu Python (
str
,
int
,
float
,
bool
,
list
,...).
datetime
objects.
UUID
objects.
Database models.
...và nhiều hơn thế.
Tự động tạo tài liệu tương tác API, bao gồm 2 giao diện người dùng:
Swagger UI.
ReDoc.
Quay trở lại ví dụ trước,
FastAPI
sẽ thực hiện:
Kiểm tra xem có một
item_id
trong đường dẫn với các request
GET
và
PUT
không?
Kiểm tra xem
item_id
có phải là kiểu
int
trong các request
GET
và
PUT
không?
Nếu không, client sẽ thấy một lỗi rõ ràng và hữu ích.
Kiểm tra xem nếu có một tham số
q
trong query string (ví dụ như
http://127.0.0.1:8000/items/foo?q=somequery
) cho request
GET
.
Tham số
q
được định nghĩa
= None
, nó là tùy chọn.
Nếu không phải
None
, nó là bắt buộc (như body trong trường hợp của
PUT
).
Với request
PUT
tới
/items/{item_id}
, đọc body như JSON:
Kiểm tra xem nó có một thuộc tính bắt buộc kiểu
str
là
name
không?
Kiểm tra xem nó có một thuộc tính bắt buộc kiểu
float
là
price
không?
Kiểm tra xem nó có một thuộc tính tùy chọn là
is_offer
không? Nếu có, nó phải có kiểu
bool
.
Tất cả những kiểm tra này cũng được áp dụng với các JSON lồng nhau.
Chuyển đổi tự động các JSON object đến và JSON object đi.
Tài liệu hóa mọi thứ với OpenAPI, tài liệu đó có thể được sử dụng bởi:
Các hệ thống tài liệu có thể tương tác.
Hệ thống sinh code tự động, cho nhiều ngôn ngữ lập trình.
Cung cấp trực tiếp 2 giao diện web cho tài liệu tương tác
Chúng tôi chỉ trình bày những thứ cơ bản bên ngoài, nhưng bạn đã hiểu cách thức hoạt động của nó.
Thử thay đổi dòng này:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...từ:
...
"item_name"
:
item
.
name
...
...sang:
...
"item_price"
:
item
.
price
...
...và thấy trình soạn thảo của bạn nhận biết kiểu dữ liệu và gợi ý hoàn thiện các thuộc tính.
Ví dụ hoàn chỉnh bao gồm nhiều tính năng hơn, xem
Tutorial - User Guide
.
Cảnh báo tiết lỗ
: Tutorial - User Guide:
Định nghĩa
tham số
từ các nguồn khác nhau như:
headers
,
cookies
,
form fields
và
files
.
Cách thiết lập
các ràng buộc cho validation
như
maximum_length
hoặc
regex
.
Một hệ thống **
Dependency Injection
vô cùng mạnh mẽ và dễ dàng sử dụng.
Bảo mật và xác thực, hỗ trợ
OAuth2
(với
JWT tokens
) và
HTTP Basic
.
Những kĩ thuật nâng cao hơn (nhưng tương đối dễ) để định nghĩa
JSON models lồng nhau
(cảm ơn Pydantic).
Tích hợp
GraphQL
với
Strawberry
và các thư viện khác.
Nhiều tính năng mở rộng (cảm ơn Starlette) như:
WebSockets
kiểm thử vô cùng dễ dàng dựa trên HTTPX và
pytest
CORS
Cookie Sessions
...và nhiều hơn thế.
Hiệu năng
Independent TechEmpower benchmarks cho thấy các ứng dụng
FastAPI
chạy dưới Uvicorn là
một trong những Python framework nhanh nhất
, chỉ đứng sau Starlette và Uvicorn (được sử dụng bên trong FastAPI). (*)
Để hiểu rõ hơn, xem phần
Benchmarks
.
Các dependency tùy chọn
Sử dụng bởi Pydantic:
email-validator
- cho email validation.
Sử dụng Starlette:
httpx
- Bắt buộc nếu bạn muốn sử dụng
TestClient
.
jinja2
- Bắt buộc nếu bạn muốn sử dụng cấu hình template engine mặc định.
python-multipart
- Bắt buộc nếu bạn muốn hỗ trợ
"parsing"
, form với
request.form()
.
itsdangerous
- Bắt buộc để hỗ trợ
SessionMiddleware
.
pyyaml
- Bắt buộc để hỗ trợ
SchemaGenerator
cho Starlette (bạn có thể không cần nó trong FastAPI).
Sử dụng bởi FastAPI / Starlette:
uvicorn
- Server để chạy ứng dụng của bạn.
orjson
- Bắt buộc nếu bạn muốn sử dụng
ORJSONResponse
.
ujson
- Bắt buộc nếu bạn muốn sử dụng
UJSONResponse
.
Bạn có thể cài đặt tất cả những dependency trên với
pip install "fastapi[all]"
.
Giấy phép
Dự án này được cấp phép dưới những điều lệ của giấy phép MIT.

## 159_VIRTUAL_ENVIRONMENTS
Virtual Environments¶
---

Virtual Environments
When you work in Python projects you probably should use a
virtual environment
(or a similar mechanism) to isolate the packages you install for each project.
Info
If you already know about virtual environments, how to create them and use them, you might want to skip this section. 🤓
Tip
A
virtual environment
is different than an
environment variable
.
An
environment variable
is a variable in the system that can be used by programs.
A
virtual environment
is a directory with some files in it.
Info
This page will teach you how to use
virtual environments
and how they work.
If you are ready to adopt a
tool that manages everything
for you (including installing Python), try
uv
.
Create a Project
First, create a directory for your project.
What I normally do is that I create a directory named
code
inside my home/user directory.
And inside of that I create one directory per project.
fast →
💬 Go to the home directory
cd
💬 Create a directory for all your code projects
mkdir code
💬 Enter into that code directory
cd code
💬 Create a directory for this project
mkdir awesome-project
💬 Enter into that project directory
cd awesome-project
restart ↻
Create a Virtual Environment
When you start working on a Python project
for the first time
, create a virtual environment
inside your project
.
Tip
You only need to do this
once per project
, not every time you work.
venv
uv
To create a virtual environment, you can use the
venv
module that comes with Python.
fast →
python -m venv .venv
restart ↻
What that command means
python
: use the program called
python
-m
: call a module as a script, we'll tell it which module next
venv
: use the module called
venv
that normally comes installed with Python
.venv
: create the virtual environment in the new directory
.venv
If you have
uv
installed, you can use it to create a virtual environment.
fast →
uv venv
restart ↻
Tip
By default,
uv
will create a virtual environment in a directory called
.venv
.
But you could customize it passing an additional argument with the directory name.
That command creates a new virtual environment in a directory called
.venv
.
.venv
or other name
You could create the virtual environment in a different directory, but there's a convention of calling it
.venv
.
Activate the Virtual Environment
Activate the new virtual environment so that any Python command you run or package you install uses it.
Tip
Do this
every time
you start a
new terminal session
to work on the project.
Linux, macOS
Windows PowerShell
Windows Bash
fast →
source .venv/bin/activate
restart ↻
fast →
.venv\Scripts\Activate.ps1
Or if you use Bash for Windows (e.g.
Git Bash
):
fast →
source .venv/Scripts/activate
Tip
Every time you install a
new package
in that environment,
activate
the environment again.
This makes sure that if you use a
terminal (
CLI
) program
installed by that package, you use the one from your virtual environment and not any other that could be installed globally, probably with a different version than what you need.
Check the Virtual Environment is Active
Check that the virtual environment is active (the previous command worked).
Tip
This is
optional
, but it's a good way to
check
that everything is working as expected and you are using the virtual environment you intended.
Linux, macOS, Windows Bash
Windows PowerShell
fast →
which python
/home/user/code/awesome-project/.venv/bin/python
restart ↻
If it shows the
python
binary at
.venv/bin/python
, inside of your project (in this case
awesome-project
), then it worked. 🎉
fast →
Get-Command python
C:\Users\user\code\awesome-project\.venv\Scripts\python
restart ↻
If it shows the
python
binary at
.venv\Scripts\python
, inside of your project (in this case
awesome-project
), then it worked. 🎉
Upgrade
pip
Tip
If you use
uv
you would use it to install things instead of
pip
, so you don't need to upgrade
pip
. 😎
If you are using
pip
to install packages (it comes by default with Python), you should
upgrade
it to the latest version.
Many exotic errors while installing a package are solved by just upgrading
pip
first.
Tip
You would normally do this
once
, right after you create the virtual environment.
Make sure the virtual environment is active (with the command above) and then run:
fast →
python -m pip install --upgrade pip
restart ↻
Add
.gitignore
If you are using
Git
(you should), add a
.gitignore
file to exclude everything in your
.venv
from Git.
Tip
If you used
uv
to create the virtual environment, it already did this for you, you can skip this step. 😎
Tip
Do this
once
, right after you create the virtual environment.
fast →
echo "*" > .venv/.gitignore
restart ↻
What that command means
echo "*"
: will "print" the text
*
in the terminal (the next part changes that a bit)
>
: anything printed to the terminal by the command to the left of
>
should not be printed but instead written to the file that goes to the right of
>
.gitignore
: the name of the file where the text should be written
And
*
for Git means "everything". So, it will ignore everything in the
.venv
directory.
That command will create a file
.gitignore
with the content:
*
Install Packages
After activating the environment, you can install packages in it.
Tip
Do this
once
when installing or upgrading the packages your project needs.
If you need to upgrade a version or add a new package you would
do this again
.
Install Packages Directly
If you're in a hurry and don't want to use a file to declare your project's package requirements, you can install them directly.
Tip
It's a (very) good idea to put the packages and versions your program needs in a file (for example
requirements.txt
or
pyproject.toml
).
pip
uv
fast →
pip install "fastapi[standard]"
restart ↻
If you have
uv
:
fast →
uv pip install "fastapi[stand
Install from
requirements.txt
If you have a
requirements.txt
, you can now use it to install its packages.
pip
uv
fast →
pip install -r requirements.txt
restart ↻
If you have
uv
:
fast →
uv pip install -r requirement
requirements.txt
A
requirements.txt
with some packages could look like:
fastapi[standard]==0.113.0
pydantic==2.8.0
Run Your Program
After you activated the virtual environment, you can run your program, and it will use the Python inside of your virtual environment with the packages you installed there.
fast →
python main.py
Hello World
restart ↻
Configure Your Editor
You would probably use an editor, make sure you configure it to use the same virtual environment you created (it will probably autodetect it) so that you can get autocompletion and inline errors.
For example:
VS Code
PyCharm
Tip
You normally have to do this only
once
, when you create the virtual environment.
Deactivate the Virtual Environment
Once you are done working on your project you can
deactivate
the virtual environment.
fast →
deactivate
restart ↻
This way, when you run
python
it won't try to run it from that virtual environment with the packages installed there.
Ready to Work
Now you're ready to start working on your project.
Tip
Do you want to understand what's all that above?
Continue reading. 👇🤓
Why Virtual Environments
To work with FastAPI you need to install
Python
.
After that, you would need to
install
FastAPI and any other
packages
you want to use.
To install packages you would normally use the
pip
command that comes with Python (or similar alternatives).
Nevertheless, if you just use
pip
directly, the packages would be installed in your
global Python environment
(the global installation of Python).
The Problem
So, what's the problem with installing packages in the global Python environment?
At some point, you will probably end up writing many different programs that depend on
different packages
. And some of these projects you work on will depend on
different versions
of the same package. 😱
For example, you could create a project called
philosophers-stone
, this program depends on another package called
harry
, using the version
1
. So, you need to install
harry
.
Then, at some point later, you create another project called
prisoner-of-azkaban
, and this project also depends on
harry
, but this project needs
harry
version
3
.
But now the problem is, if you install the packages globally (in the global environment) instead of in a local
virtual environment
, you will have to choose which version of
harry
to install.
If you want to run
philosophers-stone
you will need to first install
harry
version
1
, for example with:
fast →
pip install "harry==1"
restart ↻
And then you would end up with
harry
version
1
installed in your global Python environment.
But then if you want to run
prisoner-of-azkaban
, you will need to uninstall
harry
version
1
and install
harry
version
3
(or just installing version
3
would automatically uninstall version
1
).
fast →
pip install "harry==3"
restart ↻
And then you would end up with
harry
version
3
installed in your global Python environment.
And if you try to run
philosophers-stone
again, there's a chance it would
not work
because it needs
harry
version
1
.
Tip
It's very common in Python packages to try the best to
avoid breaking changes
in
new versions
, but it's better to be safe, and install newer versions intentionally and when you can run the tests to check everything is working correctly.
Now, imagine that with
many
other
packages
that all your
projects depend on
. That's very difficult to manage. And you would probably end up running some projects with some
incompatible versions
of the packages, and not knowing why something isn't working.
Also, depending on your operating system (e.g. Linux, Windows, macOS), it could have come with Python already installed. And in that case it probably had some packages pre-installed with some specific versions
needed by your system
. If you install packages in the global Python environment, you could end up
breaking
some of the programs that came with your operating system.
Where are Packages Installed
When you install Python, it creates some directories with some files in your computer.
Some of these directories are the ones in charge of having all the packages you install.
When you run:
fast →
💬 Don't run this now, it's just an example 🤓
pip install "fastapi[standard]"
restart ↻
That will download a compressed file with the FastAPI code, normally from
PyPI
.
It will also
download
files for other packages that FastAPI depends on.
Then it will
extract
all those files and put them in a directory in your computer.
By default, it will put those files downloaded and extracted in the directory that comes with your Python installation, that's the
global environment
.
What are Virtual Environments
The solution to the problems of having all the packages in the global environment is to use a
virtual environment for each project
you work on.
A virtual environment is a
directory
, very similar to the global one, where you can install the packages for a project.
This way, each project will have its own virtual environment (
.venv
directory) with its own packages.
What Does Activating a Virtual Environment Mean
When you activate a virtual environment, for example with:
Linux, macOS
Windows PowerShell
Windows Bash
fast →
source .venv/bin/activate
restart ↻
fast →
.venv\Scripts\Activate.ps1
Or if you use Bash for Windows (e.g.
Git Bash
):
fast →
source .venv/Scripts/activate
That command will create or modify some
environment variables
that will be available for the next commands.
One of those variables is the
PATH
variable.
Tip
You can learn more about the
PATH
environment variable in the
Environment Variables
section.
Activating a virtual environment adds its path
.venv/bin
(on Linux and macOS) or
.venv\Scripts
(on Windows) to the
PATH
environment variable.
Let's say that before activating the environment, the
PATH
variable looked like this:
Linux, macOS
Windows
/usr/bin:/bin:/usr/sbin:/sbin
That means that the system would look for programs in:
/usr/bin
/bin
/usr/sbin
/sbin
C:\Windows\System32
That means that the system would look for programs in:
C:\Windows\System32
After activating the virtual environment, the
PATH
variable would look something like this:
Linux, macOS
Windows
/home/user/code/awesome-project/.venv/bin:/usr/bin:/bin:/usr/sbin:/sbin
That means that the system will now start looking first for programs in:
/home/user/code/awesome-project/.venv/bin
before looking in the other directories.
So, when you type
python
in the terminal, the system will find the Python program in
/home/user/code/awesome-project/.venv/bin/python
and use that one.
C:\Users\user\code\awesome-project\.venv\Scripts;C:\Windows\System32
That means that the system will now start looking first for programs in:
C:\Users\user\code\awesome-project\.venv\Scripts
before looking in the other directories.
So, when you type
python
in the terminal, the system will find the Python program in
C:\Users\user\code\awesome-project\.venv\Scripts\python
and use that one.
An important detail is that it will put the virtual environment path at the
beginning
of the
PATH
variable. The system will find it
before
finding any other Python available. This way, when you run
python
, it will use the Python
from the virtual environment
instead of any other
python
(for example, a
python
from a global environment).
Activating a virtual environment also changes a couple of other things, but this is one of the most important things it does.
Checking a Virtual Environment
When you check if a virtual environment is active, for example with:
Linux, macOS, Windows Bash
Windows PowerShell
fast →
which python
/home/user/code/awesome-project/.venv/bin/python
restart ↻
fast →
Get-Command python
C:\Users\user\code\awesome-project\.venv\Scripts\python
restart ↻
That means that the
python
program that will be used is the one
in the virtual environment
.
You use
which
in Linux and macOS and
Get-Command
in Windows PowerShell.
The way that command works is that it will go and check in the
PATH
environment variable, going through
each path in order
, looking for the program called
python
. Once it finds it, it will
show you the path
to that program.
The most important part is that when you call
python
, that is the exact "
python
" that will be executed.
So, you can confirm if you are in the correct virtual environment.
Tip
It's easy to activate one virtual environment, get one Python, and then
go to another project
.
And the second project
wouldn't work
because you are using the
incorrect Python
, from a virtual environment for another project.
It's useful being able to check what
python
is being used. 🤓
Why Deactivate a Virtual Environment
For example, you could be working on a project
philosophers-stone
,
activate that virtual environment
, install packages and work with that environment.
And then you want to work on
another project
prisoner-of-azkaban
.
You go to that project:
fast →
cd ~/code/prisoner-of-azkaban
restart ↻
If you don't deactivate the virtual environment for
philosophers-stone
, when you run
python
in the terminal, it will try to use the Python from
philosophers-stone
.
fast →
cd ~/code/prisoner-of-azkaban
python main.py
💬 Error importing sirius, it's not installed 😱
Traceback (most recent call last):
File "main.py", line 1, in
import sirius
restart ↻
But if you deactivate the virtual environment and activate the new one for
prisoner-of-askaban
then when you run
python
it will use the Python from the virtual environment in
prisoner-of-azkaban
.
fast →
cd ~/code/prisoner-of-azkaban
💬 You don't need to be in the old directory to deactivate, you can do it wherever you are, even after going to the other project 😎
deactivate
💬 Activate the virtual environment in prisoner-of-azkaban/.venv 🚀
source .venv/bin/activate
💬 Now when you run python, it will find the package sirius installed in this virtual environment ✨
python main.py
I solemnly swear 🐺
restart ↻
Alternatives
This is a simple guide to get you started and teach you how everything works
underneath
.
There are many
alternatives
to managing virtual environments, package dependencies (requirements), projects.
Once you are ready and want to use a tool to
manage the entire project
, packages dependencies, virtual environments, etc. I would suggest you try
uv
.
uv
can do a lot of things, it can:
Install Python
for you, including different versions
Manage the
virtual environment
for your projects
Install
packages
Manage package
dependencies and versions
for your project
Make sure you have an
exact
set of packages and versions to install, including their dependencies, so that you can be sure that you can run your project in production exactly the same as in your computer while developing, this is called
locking
And many other things
Conclusion
If you read and understood all this, now
you know much more
about virtual environments than many developers out there. 🤓
Knowing these details will most probably be useful in a future time when you are debugging something that seems complex, but you will know
how it all works underneath
. 😎

## 160_YO
FastAPI¶
---

FastAPI
Ìlànà wẹ́ẹ́bù FastAPI, iṣẹ́ gíga, ó rọrùn láti kọ̀, o yára láti kóòdù, ó sì ṣetán fún iṣelọpọ ní lílo
Àkọsílẹ̀
:
https://fastapi.tiangolo.com
Orisun Kóòdù
:
https://github.com/fastapi/fastapi
FastAPI jẹ́ ìgbàlódé, tí ó yára (iṣẹ-giga), ìlànà wẹ́ẹ́bù fún kikọ àwọn API pẹ̀lú Python èyí tí ó da lori àwọn ìtọ́kasí àmì irúfẹ́ Python.
Àwọn ẹya pàtàkì ni:
Ó yára
: Iṣẹ tí ó ga púpọ̀, tí ó wa ni ibamu pẹ̀lú
NodeJS
àti
Go
(ọpẹ si Starlette àti Pydantic).
Ọkan nínú àwọn ìlànà Python ti o yára jùlọ ti o wa
.
Ó yára láti kóòdù
: O mu iyara pọ si láti kọ àwọn ẹya tuntun kóòdù nipasẹ "Igba ìdá ọgọ́rùn-ún" (i.e. 200%) si "ọ̀ọ́dúrún ìdá ọgọ́rùn-ún" (i.e. 300%).
Àìtọ́ kékeré
: O n din aṣiṣe ku bi ọgbon ìdá ọgọ́rùn-ún (i.e. 40%) ti eda eniyan (oṣiṣẹ kóòdù) fa. *
Ọgbọ́n àti ìmọ̀
: Atilẹyin olootu nla.
Ìparí
nibi gbogbo. Àkókò díẹ̀ nipa wíwá ibi tí ìṣòro kóòdù wà.
Irọrun
: A kọ kí ó le rọrun láti lo àti láti kọ ẹkọ nínú rè. Ó máa fún ọ ní àkókò díẹ̀ látı ka àkọsílẹ.
Ó kúkurú ní kikọ
: Ó dín àtúnkọ àti àtúntò kóòdù kù. Ìkéde àṣàyàn kọ̀ọ̀kan nínú rẹ̀ ní ọ̀pọ̀lọpọ̀ àwọn ìlò. O ṣe iranlọwọ láti má ṣe ní ọ̀pọ̀lọpọ̀ àṣìṣe.
Ó lágbára
: Ó ń ṣe àgbéjáde kóòdù tí ó ṣetán fún ìṣelọ́pọ̀. Pẹ̀lú àkọsílẹ̀ tí ó máa ṣàlàyé ara rẹ̀ fún ẹ ní ìbáṣepọ̀ aládàáṣiṣẹ́ pẹ̀lú rè.
Ajohunše/Ìtọ́kasí
: Ó da lori (àti ibamu ni kikun pẹ̀lú) àwọn ìmọ ajohunše/ìtọ́kasí fún àwọn API:
OpenAPI
(èyí tí a mọ tẹlẹ si Swagger) àti
JSON Schema
.
* iṣiro yi da lori àwọn idanwo tí ẹgbẹ ìdàgbàsókè FastAPI ṣe, nígbàtí wọn kọ àwọn ohun elo iṣelọpọ kóòdù pẹ̀lú rẹ.
Àwọn onígbọ̀wọ́
Àwọn onígbọ̀wọ́ míràn
Àwọn ero àti èsì
"
[...] Mò ń lo
FastAPI
púpọ̀ ní lẹ́nu àìpẹ́ yìí. [...] Mo n gbero láti lo o pẹ̀lú àwọn ẹgbẹ mi fún gbogbo iṣẹ
ML wa ni Microsoft
. Diẹ nínú wọn ni afikun ti ifilelẹ àwọn ẹya ara ti ọja
Windows
wa pẹ̀lú àwọn ti
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
A gba àwọn ohun èlò ìwé afọwọkọ
FastAPI
tí kò yí padà láti ṣẹ̀dá olùpín
REST
tí a lè béèrè lọ́wọ́ rẹ̀ láti gba
àsọtẹ́lẹ̀
. [fún Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
ni inudidun láti kede itusilẹ orisun kóòdù ti ìlànà iṣọkan
iṣakoso Ìṣòro
wa:
Ìfiránṣẹ́
! [a kọ pẹ̀lú
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Inú mi dùn púpọ̀ nípa
FastAPI
. Ó mú inú ẹnì dùn púpọ̀!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Ní tòótọ́, ohun tí o kọ dára ó sì tún dán. Ní ọ̀pọ̀lọpọ̀ ọ̀nà, ohun tí mo fẹ́ kí
Hug
jẹ́ nìyẹn - ó wúni lórí gan-an láti rí ẹnìkan tí ó kọ́ nǹkan bí èyí.
"
Timothy Crosley -
Hug
creator
(ref)
"
Ti o ba n wa láti kọ ọkan
ìlànà igbalode
fún kikọ àwọn REST API, ṣayẹwo
FastAPI
[...] Ó yára, ó rọrùn láti lò, ó sì rọrùn láti kọ́[...]
"
"
A ti yipada si
FastAPI
fún
APIs
wa [...] Mo lérò pé wà á fẹ́ràn rẹ̀ [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
Ti ẹnikẹni ba n wa láti kọ iṣelọpọ API pẹ̀lú Python, èmi yóò ṣe'dúró fún
FastAPI
. Ó jẹ́ ohun tí
àgbékalẹ̀ rẹ̀ lẹ́wà
,
ó rọrùn láti lò
àti wipe ó ni
ìwọ̀n gíga
, o tí dí
bọtini paati
nínú alakọkọ API ìdàgbàsókè kikọ fún wa, àti pe o ni ipa lori adaṣiṣẹ àti àwọn iṣẹ gẹ́gẹ́ bíi Onímọ̀-ẹ̀rọ TAC tí órí Íńtánẹ́ẹ̀tì
"
Deon Pillsbury -
Cisco
(ref)
Typer
, FastAPI ti CLIs
Ti o ba n kọ ohun èlò
CLI
láti ṣeé lọ nínú ohun èlò lori ebute kọmputa dipo API, ṣayẹwo
Typer
.
Typer
jẹ́ àbúrò ìyá FastAPI kékeré. Àti pé wọ́n kọ́ láti jẹ́
FastAPI ti CLIs
. ⌨️ 🚀
Èròjà
FastAPI dúró lórí àwọn èjìká tí àwọn òmíràn:
Starlette
fún àwọn ẹ̀yà ayélujára.
Pydantic
fún àwọn ẹ̀yà àkójọf'áyẹ̀wò.
Fifi sórí ẹrọ
fast →
pip install fastapi
restart ↻
Iwọ yóò tún nílò olupin ASGI, fún iṣelọpọ bii
Uvicorn
tabi
Hypercorn
.
fast →
pip install "uvicorn[standard]"
restart ↻
Àpẹẹrẹ
Ṣẹ̀dá rẹ̀
Ṣẹ̀dá fáìlì
main.py (èyí tíí ṣe, akọkọ.py)
pẹ̀lú:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Tàbí lò
async def
...
Tí kóòdù rẹ̀ bá ń lò
async
/
await
, lò
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Akiyesi
:
Tí o kò bá mọ̀, ṣàyẹ̀wò ibi tí a ti ní
"In a hurry?"
(i.e.
"Ní kíákíá?"
) nípa
async
and
await
nínú àkọsílẹ̀
.
Mu ṣiṣẹ
Mú olupin ṣiṣẹ pẹ̀lú:
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
Nipa aṣẹ kóòdù náà
uvicorn main:app --reload
...
Àṣẹ
uvicorn main:app
ń tọ́ka sí:
main
: fáìlì náà 'main.py' (Python "module").
app
jẹ object( i.e. nǹkan) tí a ṣẹ̀dá nínú
main.py
pẹ̀lú ilà
app = FastAPI()
.
--reload
: èyí yóò jẹ́ ki olupin tún bẹ̀rẹ̀ lẹ́hìn àwọn àyípadà kóòdù. Jọ̀wọ́, ṣe èyí fún ìdàgbàsókè kóòdù nìkan, má ṣe é ṣe lori àgbéjáde kóòdù tabi fún iṣelọpọ kóòdù.
Ṣayẹwo rẹ
Ṣii aṣàwákiri kọ̀ǹpútà rẹ ni
http://127.0.0.1:8000/items/5?q=somequery
.
Ìwọ yóò sì rí ìdáhùn JSON bíi:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
O tí ṣẹ̀dá API èyí tí yóò:
Gbà àwọn ìbéèrè HTTP ni àwọn
ipa ọ̀nà
/
àti
/items/{item_id}
.
Èyí tí àwọn
ipa ọ̀nà
(i.e.
paths
) méjèèjì gbà àwọn
iṣẹ
GET
(a tun mọ si
àwọn ọna
HTTP).
Èyí tí
ipa ọ̀nà
(i.e.
paths
)
/items/{item_id}
ní
àwọn ohun-ini ipa ọ̀nà
tí ó yẹ kí ó jẹ́
int
i.e.
ÒǸKÀ
.
Èyí tí
ipa ọ̀nà
(i.e.
paths
)
/items/{item_id}
ní àṣàyàn
str
àwọn ohun-ini
(i.e.
query parameter
)
q
.
Ìbáṣepọ̀ àkọsílẹ̀ API
Ní báyìí, lọ sí
http://127.0.0.1:8000/docs
.
Lẹ́yìn náà, iwọ yóò rí ìdáhùn àkọsílẹ̀ API tí ó jẹ́ ìbáṣepọ̀ alaifọwọyi/aládàáṣiṣẹ́ (tí a pèṣè nípaṣẹ̀
Swagger UI
):
Ìdàkejì àkọsílẹ̀ API
Ní báyìí, lọ sí
http://127.0.0.1:8000/redoc
.
Wà á rí àwọn àkọsílẹ̀ aládàáṣiṣẹ́ mìíràn (tí a pese nipasẹ
ReDoc
):
Àpẹẹrẹ ìgbésókè mìíràn
Ní báyìí ṣe àtúnṣe fáìlì
main.py
láti gba kókó èsì láti inú ìbéèrè
PUT
.
Ní báyìí, ṣe ìkéde kókó èsì API nínú kóòdù rẹ nipa lílo àwọn ìtọ́kasí àmì irúfẹ́ Python, ọpẹ́ pàtàkìsi sí Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Olupin yóò tún ṣe àtúnṣe laifọwọyi/aládàáṣiṣẹ́ (nítorí wípé ó se àfikún
-reload
si àṣẹ kóòdù
uvicorn
lókè).
Ìbáṣepọ̀ ìgbésókè àkọsílẹ̀ API
Ní báyìí, lọ sí
http://127.0.0.1:8000/docs
.
Ìbáṣepọ̀ àkọsílẹ̀ API yóò ṣe imudojuiwọn àkọsílẹ̀ API laifọwọyi, pẹ̀lú kókó èsì ìdáhùn API tuntun:
Tẹ bọtini "Gbiyanju rẹ" i.e. "Try it out", yóò gbà ọ́ láàyè láti jẹ́ kí ó tẹ́ àlàyé tí ó nílò kí ó le sọ̀rọ̀ tààrà pẹ̀lú API:
Lẹhinna tẹ bọtini "Ṣiṣe" i.e. "Execute", olùmúlò (i.e. user interface) yóò sọrọ pẹ̀lú API rẹ, yóò ṣe afiranṣẹ àwọn èròjà, pàápàá jùlọ yóò gba àwọn àbájáde yóò si ṣafihan wọn loju ìbòjú:
Ìdàkejì ìgbésókè àkọsílẹ̀ API
Ní báyìí, lọ sí
http://127.0.0.1:8000/redoc
.
Ìdàkejì àkọsílẹ̀ API yóò ṣ'afihan ìbéèrè èròjà/pàrámítà tuntun àti kókó èsì ti API:
Àtúnyẹ̀wò
Ni akopọ, ìwọ yóò kéde ni
kete
àwọn iru èròjà/pàrámítà, kókó èsì API, abbl (i.e. àti bẹbẹ lọ), bi àwọn èròjà iṣẹ.
O ṣe ìyẹn pẹ̀lú irúfẹ́ àmì ìtọ́kasí ìgbàlódé Python.
O ò nílò láti kọ́ síńtáàsì tuntun, ìlànà tàbí ọ̀wọ́ kíláàsì kan pàtó, abbl (i.e. àti bẹbẹ lọ).
Ìtọ́kasí
Python
Fún àpẹẹrẹ, fún
int
:
item_id
:
int
tàbí fún àwòṣe
Item
tí ó nira díẹ̀ síi:
item
:
Item
... àti pẹ̀lú ìkéde kan ṣoṣo yẹn ìwọ yóò gbà:
Atilẹyin olootu, pẹ̀lú:
Pipari.
Àyẹ̀wò irúfẹ́ àmì ìtọ́kasí.
Ìfọwọ́sí àkójọf'áyẹ̀wò (i.e. data):
Aṣiṣe alaifọwọyi/aládàáṣiṣẹ́ àti aṣiṣe ti ó hàn kedere nígbàtí àwọn àkójọf'áyẹ̀wò (i.e. data) kò wulo tabi tí kò fẹsẹ̀ múlẹ̀.
Ìfọwọ́sí fún ohun elo JSON tí ó jìn gan-an.
Ìyípadà
tí input àkójọf'áyẹ̀wò: tí ó wà láti nẹtiwọọki si àkójọf'áyẹ̀wò àti irúfẹ́ àmì ìtọ́kasí Python. Ó ń ka láti:
JSON.
èròjà ọ̀nà tí ò gbé gbà.
èròjà ìbéèrè.
Àwọn Kúkì
Àwọn Àkọlé
Àwọn Fọọmu
Àwọn Fáìlì
Ìyípadà
èsì àkójọf'áyẹ̀wò: yíyípadà láti àkójọf'áyẹ̀wò àti irúfẹ́ àmì ìtọ́kasí Python si nẹtiwọọki (gẹ́gẹ́ bí JSON):
Yí irúfẹ́ àmì ìtọ́kasí padà (
str
,
int
,
float
,
bool
,
list
, abbl i.e. àti bèbè ló).
Àwọn ohun èlò
datetime
.
Àwọn ohun èlò
UUID
.
Àwọn awoṣẹ́ ibi ìpamọ́ àkójọf'áyẹ̀wò.
...àti ọ̀pọ̀lọpọ̀ díẹ̀ síi.
Ìbáṣepọ̀ àkọsílẹ̀ API aládàáṣiṣẹ́, pẹ̀lú ìdàkejì àgbékalẹ̀-àwọn-olùmúlò (i.e user interfaces) méjì:
Àgbékalẹ̀-olùmúlò Swagger.
ReDoc.
Nisinsin yi, tí ó padà sí àpẹẹrẹ ti tẹ́lẹ̀,
FastAPI
yóò:
Fọwọ́ sí i pé
item_id
wà nínú ọ̀nà ìbéèrè HTTP fún
GET
àti
PUT
.
Fọwọ́ sí i pé
item_id
jẹ́ irúfẹ́ àmì ìtọ́kasí
int
fún ìbéèrè HTTP
GET
àti
PUT
.
Tí kìí bá ṣe bẹ, oníbàárà yóò ríi àṣìṣe tí ó wúlò, kedere.
Ṣàyẹ̀wò bóyá ìbéèrè àṣàyàn pàrámítà kan wà tí orúkọ rẹ̀ ń jẹ́
q
(gẹ́gẹ́ bíi
http://127.0.0.1:8000/items/foo?q=somequery
) fún ìbéèrè HTTP
GET
.
Bí wọ́n ṣe kéde pàrámítà
q
pẹ̀lú
= None
, ó jẹ́ àṣàyàn (i.e optional).
Láìsí
None
yóò nílò (gẹ́gẹ́ bí kókó èsì ìbéèrè HTTP ṣe wà pẹ̀lú
PUT
).
Fún àwọn ìbéèrè HTTP
PUT
sí
/items/{item_id}
, kà kókó èsì ìbéèrè HTTP gẹ́gẹ́ bí JSON:
Ṣàyẹ̀wò pé ó ní àbùdá tí ó nílò èyí tíí ṣe
name
i.e.
orúkọ
tí ó yẹ kí ó jẹ́
str
.
Ṣàyẹ̀wò pé ó ní àbùdá tí ó nílò èyí tíí ṣe
price
i.e.
iye
tí ó gbọ́dọ̀ jẹ́
float
.
Ṣàyẹ̀wò pé ó ní àbùdá àṣàyàn
is_offer
, tí ó yẹ kí ó jẹ́
bool
, tí ó bá wà níbẹ̀.
Gbogbo èyí yóò tún ṣiṣẹ́ fún àwọn ohun èlò JSON tí ó jìn gidi gan-an.
Yìí padà láti àti sí JSON lai fi ọwọ́ yi.
Ṣe àkọsílẹ̀ ohun gbogbo pẹ̀lú OpenAPI, èyí tí yóò wà ní lílo nípaṣẹ̀:
Àwọn ètò àkọsílẹ̀ ìbáṣepọ̀.
Aládàáṣiṣẹ́ oníbárà èlètò tíí ṣẹ̀dá kóòdù, fún ọ̀pọ̀lọpọ̀ àwọn èdè.
Pese àkọsílẹ̀ òní ìbáṣepọ̀ ti àwọn àgbékalẹ̀ ayélujára méjì tààrà.
A ń ṣẹ̀ṣẹ̀ ń mú ẹyẹ bọ́ làpò ní, ṣùgbọ́n ó ti ni òye bí gbogbo rẹ̀ ṣe ń ṣiṣẹ́.
Gbiyanju láti yí ìlà padà pẹ̀lú:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...láti:
...
"item_name"
:
item
.
name
...
...ṣí:
...
"item_price"
:
item
.
price
...
.. kí o sì wo bí olóòtú rẹ yóò ṣe parí àwọn àbùdá náà fúnra rẹ̀, yóò sì mọ irúfẹ́ wọn:
Fún àpẹẹrẹ pípé síi pẹ̀lú àwọn àbùdá mìíràn, wo
Ìdánilẹ́kọ̀ọ́ - Ìtọ́sọ́nà Olùmúlò
.
Itaniji gẹ́gẹ́ bí isọ'ye
: ìdánilẹ́kọ̀ọ́ - itọsọna olùmúlò pẹ̀lú:
Ìkéde àṣàyàn
pàrámítà
láti àwọn oriṣiriṣi ibòmíràn gẹ́gẹ́ bíi: àwọn
àkọlé èsì API
,
kúkì
,
ààyè fọọmu
, àti
fáìlì
.
Bíi ó ṣe lé ṣètò
àwọn ìdíwọ́ ìfọwọ́sí
bí
maximum_length
tàbí
regex
.
Ó lágbára púpọ̀ ó sì rọrùn láti lo ètò
Àfikún Ìgbẹ́kẹ̀lé Kóòdù
.
Ààbò àti ìfọwọ́sowọ́pọ̀, pẹ̀lú àtìlẹ́yìn fún
OAuth2
pẹ̀lú
àmì JWT
àti
HTTP Ipilẹ ìfọwọ́sowọ́pọ̀
.
Àwọn ìlànà ìlọsíwájú (ṣùgbọ́n tí ó rọrùn bákan náà) fún ìkéde
àwọn àwòṣe JSON tó jinlẹ̀
(ọpẹ́ pàtàkìsi sí Pydantic).
Iṣọpọ
GraphQL
pẹ̀lú
Strawberry
àti àwọn ohun èlò ìwé kóòdù afọwọkọ mìíràn tí kò yí padà.
Ọpọlọpọ àwọn àfikún àwọn ẹ̀yà (ọpẹ́ pàtàkìsi sí Starlette) bí:
WebSockets
àwọn ìdánwò tí ó rọrùn púpọ̀ lórí HTTPX àti
pytest
CORS
Cookie Sessions
...àti síwájú síi.
Ìṣesí
Àwọn àlá TechEmpower fi hàn pé
FastAPI
ń ṣiṣẹ́ lábẹ́ Uvicorn gẹ́gẹ́ bí
ọ̀kan lára àwọn ìlànà Python tí ó yára jùlọ tí ó wà
, ní ìsàlẹ̀ Starlette àti Uvicorn fúnra wọn (tí FastAPI ń lò fúnra rẹ̀). (*)
Láti ní òye síi nípa rẹ̀, wo abala àwọn
Àlá
.
Àṣàyàn Àwọn Àfikún Ìgbẹ́kẹ̀lé Kóòdù
Èyí tí Pydantic ń lò:
email-validator
- fún ifọwọsi ímeèlì.
pydantic-settings
- fún ètò ìsàkóso.
pydantic-extra-types
- fún àfikún oríṣi láti lọ pẹ̀lú Pydantic.
Èyí tí Starlette ń lò:
httpx
- Nílò tí ó bá fẹ́ láti lọ
TestClient
.
jinja2
- Nílò tí ó bá fẹ́ láti lọ iṣeto awoṣe aiyipada.
python-multipart
- Nílò tí ó bá fẹ́ láti ṣe àtìlẹ́yìn fún
"àyẹ̀wò"
fọọmu, pẹ̀lú
request.form()
.
itsdangerous
- Nílò fún àtìlẹ́yìn
SessionMiddleware
.
pyyaml
- Nílò fún àtìlẹ́yìn Starlette's
SchemaGenerator
(ó ṣe ṣe kí ó má nílò rẹ̀ fún FastAPI).
Èyí tí FastAPI / Starlette ń lò:
uvicorn
- Fún olupin tí yóò sẹ́ àmúyẹ àti tí yóò ṣe ìpèsè fún iṣẹ́ rẹ tàbí ohun èlò rẹ.
orjson
- Nílò tí ó bá fẹ́ láti lọ
ORJSONResponse
.
ujson
- Nílò tí ó bá fẹ́ láti lọ
UJSONResponse
.
Ó lè fi gbogbo àwọn wọ̀nyí sórí ẹrọ pẹ̀lú
pip install "fastapi[all]"
.
Iwe-aṣẹ
Iṣẹ́ yìí ni iwe-aṣẹ lábẹ́ àwọn òfin tí iwe-aṣẹ MIT.

## 161_ZH_HANT
FastAPI
FastAPI 框架，高效能，易於學習，快速開發，適用於生產環境
文件
：
https://fastapi.tiangolo.com
程式碼
：
https://github.com/fastapi/fastapi
FastAPI 是一個現代、快速（高效能）的 web 框架，用於 Python 並採用標準 Python 型別提示。
主要特點包含：
快速
： 非常高的效能，可與
NodeJS
和
Go
效能相當 (歸功於 Starlette and Pydantic)。
FastAPI 是最快的 Python web 框架之一
。
極速開發
： 提高開發功能的速度約 200% 至 300%。 *
更少的 Bug
： 減少約 40% 的人為（開發者）導致的錯誤。 *
直覺
： 具有出色的編輯器支援，處處都有
自動補全
以減少偵錯時間。
簡單
： 設計上易於使用和學習，大幅減少閱讀文件的時間。
簡潔
： 最小化程式碼重複性。可以通過不同的參數聲明來實現更豐富的功能，和更少的錯誤。
穩健
： 立即獲得生產級可用的程式碼，還有自動生成互動式文件。
標準化
： 基於 (且完全相容於) OpenAPIs 的相關標準：
OpenAPI
（之前被稱為 Swagger）和
JSON Schema
。
* 基於內部開發團隊在建立生產應用程式時的測試預估。
贊助
其他贊助商
評價
"
[...] 近期大量的使用
FastAPI
。 [...] 目前正在計畫在
微軟
團隊的
機器學習
服務中導入。其中一些正在整合到核心的
Windows
產品和一些
Office
產品。
"
Kabir Khan -
Microsoft
(ref)
"
我們使用
FastAPI
來建立產生
預測
結果的
REST
伺服器。 [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
很榮幸地宣布開源
危機管理
協調框架：
Dispatch
! [是使用
FastAPI
建構]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
我對
FastAPI
興奮得不得了。它太有趣了！
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
老實說，你建造的東西看起來非常堅固和精緻。在很多方面，這就是我想要的，看到有人建造它真的很鼓舞人心。
"
Timothy Crosley -
Hug
creator
(ref)
"
如果您想學習一種用於構建 REST API 的
現代框架
，不能錯過
FastAPI
[...] 它非常快速、且易於使用和學習 [...]
"
"
我們的
APIs
已經改用
FastAPI
[...] 我想你會喜歡它 [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
創辦人 -
spaCy
creators
(ref)
-
(ref)
"
如果有人想要建立一個生產環境的 Python API，我強烈推薦
FastAPI
，它
設計精美
，
使用簡單
且
高度可擴充
，它已成為我們 API 優先開發策略中的
關鍵組件
，並且驅動了許多自動化服務，例如我們的 Virtual TAC Engineer。
"
Deon Pillsbury -
Cisco
(ref)
Typer
，命令列中的 FastAPI
如果你不是在開發網頁 API，而是正在開發一個在終端機中運行的
命令列
應用程式，不妨嘗試
Typer
。
Typer
是 FastAPI 的小兄弟。他立志成為命令列的
FastAPI
。 ⌨️ 🚀
安裝需求
FastAPI 是站在以下巨人的肩膀上：
Starlette
負責網頁的部分
Pydantic
負責資料的部分
安裝
fast →
pip install fastapi
restart ↻
你同時也會需要 ASGI 伺服器用於生產環境，像是
Uvicorn
或
Hypercorn
。
fast →
pip install "uvicorn[standard]"
restart ↻
範例
建立
建立一個 python 檔案
main.py
，並寫入以下程式碼：
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
或可以使用
async def
...
如果你的程式使用
async
/
await
，請使用
async def
：
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
注意
：
如果你不知道是否會用到，可以查看
"In a hurry?"
章節中，關於
async
和
await
的部分
。
運行
使用以下指令運行伺服器：
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
關於指令
uvicorn main:app --reload
...
該指令
uvicorn main:app
指的是：
main
：
main.py
檔案（一個 python 的 "模組"）。
app
：在
main.py
檔案中，使用
app = FastAPI()
建立的物件。
--reload
：程式碼更改後會自動重新啟動，請僅在開發時使用此參數。
檢查
使用瀏覽器開啟
http://127.0.0.1:8000/items/5?q=somequery
。
你將會看到以下的 JSON 回應：
{
"item_id"
:
5
,
"q"
:
"somequery"
}
你已經建立了一個具有以下功能的 API：
透過路徑
/
和
/items/{item_id}
接受 HTTP 請求。
以上路經都接受
GET
請求
（也被稱為 HTTP
方法
）。
路徑
/items/{item_id}
有一個
int
型別的
item_id
參數。
路徑
/items/{item_id}
有一個
str
型別的查詢參數
q
。
互動式 API 文件
使用瀏覽器開啟
http://127.0.0.1:8000/docs
。
你會看到自動生成的互動式 API 文件（由
Swagger UI
生成）：
ReDoc API 文件
使用瀏覽器開啟
http://127.0.0.1:8000/redoc
。
你將看到 ReDoc 文件 (由
ReDoc
生成)：
範例升級
現在繼續修改
main.py
檔案，來接收一個帶有 body 的
PUT
請求。
我們使用 Pydantic 來使用標準的 Python 型別聲明請求。
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
伺服器將自動重新載入（因為在上一步中，你向
uvicorn
指令添加了
--reload
的選項）。
互動式 API 文件升級
使用瀏覽器開啟
http://127.0.0.1:8000/docs
。
互動式 API 文件會自動更新，並加入新的 body 請求：
點擊 "Try it out" 按鈕， 你可以填寫參數並直接與 API 互動：
然後點擊 "Execute" 按鈕，使用者介面將會向 API 發送請求，並將結果顯示在螢幕上：
ReDoc API 文件升級
使用瀏覽器開啟
http://127.0.0.1:8000/redoc
。
ReDoc API 文件會自動更新，並加入新的參數和 body 請求：
總結
總結來說， 你就像宣告函式的參數型別一樣，只宣告了一次請求參數和請求主體參數等型別。
你使用 Python 標準型別來完成聲明。
你不需要學習新的語法、類別、方法或函式庫等等。
只需要使用
Python 以上的版本
。
舉個範例，比如宣告 int 的型別：
item_id
:
int
或是一個更複雜的
Item
模型：
item
:
Item
在進行一次宣告後，你將獲得：
編輯器支援：
自動補全
型別檢查
資料驗證：
驗證失敗時自動生成清楚的錯誤訊息
可驗證多層巢狀的 JSON 物件
轉換
輸入的資料： 轉換來自網路請求到 Python 資料型別。包含以下數據：
JSON
路徑參數
查詢參數
Cookies
請求標頭
表單
文件
轉換
輸出的資料： 轉換 Python 資料型別到網路傳輸的 JSON：
轉換 Python 型別 (
str
、
int
、
float
、
bool
、
list
等)
datetime
物件
UUID
物件
數據模型
...還有其他更多
自動生成的 API 文件，包含 2 種不同的使用介面：
Swagger UI
ReDoc
回到前面的的程式碼範例，
FastAPI
還會：
驗證
GET
和
PUT
請求路徑中是否包含
item_id
。
驗證
GET
和
PUT
請求中的
item_id
是否是
int
型別。
如果驗證失敗，將會返回清楚有用的錯誤訊息。
查看
GET
請求中是否有命名為
q
的查詢參數 (例如
http://127.0.0.1:8000/items/foo?q=somequery
)。
因為
q
參數被宣告為
= None
，所以是選填的。
如果沒有宣告
None
，則此參數將會是必填 (例如
PUT
範例的請求 body)。
對於
PUT
的請求
/items/{item_id}
，將會讀取 body 為 JSON：
驗證是否有必填屬性
name
且型別是
str
。
驗證是否有必填屬性
price
且型別是
float
。
驗證是否有選填屬性
is_offer
且型別是
bool
。
以上驗證都適用於多層次巢狀 JSON 物件。
自動轉換 JSON 格式。
透過 OpenAPI 文件來記錄所有內容，可以被用於：
互動式文件系統。
自動為多種程式語言生成用戶端的程式碼。
提供兩種交互式文件介面。
雖然我們只敘述了表面的功能，但其實你已經理解了它是如何執行。
試著修改以下程式碼：
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
從：
...
"item_name"
:
item
.
name
...
修改為：
...
"item_price"
:
item
.
price
...
然後觀察你的編輯器，會自動補全並且還知道他們的型別：
有關更多功能的完整範例，可以參考
教學 - 使用者指南
。
劇透警告
： 教學 - 使用者指南內容有：
對來自不同地方的
參數
進行宣告：像是
headers
,
cookies
,
form 表單
以及
上傳檔案
。
如何設定
驗證限制
像是
maximum_length
or
regex
。
簡單且非常容易使用的
依賴注入
系統。
安全性和身份驗證，包含提供支援
OAuth2
、
JWT tokens
和
HTTP Basic
驗證。
更進階 (但同樣簡單) 的宣告
多層次的巢狀 JSON 格式
(感謝 Pydantic)。
GraphQL
與
Strawberry
以及其他的相關函式庫進行整合。
更多其他的功能 (感謝 Starlette) 像是：
WebSockets
於 HTTPX 和
pytest
的非常簡單測試
CORS
Cookie Sessions
...以及更多
效能
來自獨立機構 TechEmpower 的測試結果，顯示在 Uvicorn 執行下的
FastAPI
是
最快的 Python 框架之一
， 僅次於 Starlette 和 Uvicorn 本身 (兩者是 FastAPI 的底層)。 (*)
想了解更多訊息，可以參考
測試結果
。
可選的依賴套件
用於 Pydantic：
email-validator
- 用於電子郵件驗證。
pydantic-settings
- 用於設定管理。
pydantic-extra-types
- 用於與 Pydantic 一起使用的額外型別。
用於 Starlette：
httpx
- 使用
TestClient
時必須安裝。
jinja2
- 使用預設的模板配置時必須安裝。
python-multipart
- 需要使用
request.form()
對表單進行
"解析"
時安裝。
itsdangerous
- 需要使用
SessionMiddleware
支援時安裝。
pyyaml
- 用於支援 Starlette 的
SchemaGenerator
(如果你使用 FastAPI，可能不需要它)。
用於 FastAPI / Starlette：
uvicorn
- 用於加載和運行應用程式的服務器。
orjson
- 使用
ORJSONResponse
時必須安裝。
ujson
- 使用
UJSONResponse
時必須安裝。
你可以使用
pip install "fastapi[all]"
來安裝這些所有依賴套件。
授權
該項目遵循 MIT 許可協議。

## 162_ZH
FastAPI¶
---

FastAPI
FastAPI 框架，高性能，易于学习，高效编码，生产可用
文档
：
https://fastapi.tiangolo.com
源码
：
https://github.com/fastapi/fastapi
FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 并基于标准的 Python 类型提示。
关键特性:
快速
：可与
NodeJS
和
Go
并肩的极高性能（归功于 Starlette 和 Pydantic）。
最快的 Python web 框架之一
。
高效编码
：提高功能开发速度约 200％ 至 300％。*
更少 bug
：减少约 40％ 的人为（开发者）导致错误。*
智能
：极佳的编辑器支持。处处皆可
自动补全
，减少调试时间。
简单
：设计的易于使用和学习，阅读文档的时间更短。
简短
：使代码重复最小化。通过不同的参数声明实现丰富功能。bug 更少。
健壮
：生产可用级别的代码。还有自动生成的交互式文档。
标准化
：基于（并完全兼容）API 的相关开放标准：
OpenAPI
(以前被称为 Swagger) 和
JSON Schema
。
* 根据对某个构建线上应用的内部开发团队所进行的测试估算得出。
Sponsors
Other sponsors
评价
「
[...] 最近我一直在使用
FastAPI
。[...] 实际上我正在计划将其用于我所在的
微软
团队的所有
机器学习服务
。其中一些服务正被集成进核心
Windows
产品和一些
Office
产品。
」
Kabir Khan -
微软
(ref)
「
我们选择了
FastAPI
来创建用于获取
预测结果
的
REST
服务。[用于 Ludwig]
」
Piero Molino，Yaroslav Dudin 和 Sai Sumanth Miryala -
Uber
(ref)
「
Netflix
非常高兴地宣布，正式开源我们的
危机管理
编排框架：
Dispatch
！[使用
FastAPI
构建]
」
Kevin Glisson，Marc Vilanova，Forest Monsen -
Netflix
(ref)
「
FastAPI
让我兴奋的欣喜若狂。它太棒了！
」
Brian Okken -
Python Bytes
播客主持人
(ref)
「
老实说，你的作品看起来非常可靠和优美。在很多方面，这就是我想让
Hug
成为的样子 - 看到有人实现了它真的很鼓舞人心。
」
Timothy Crosley -
Hug
作者
(ref)
「
如果你正打算学习一个
现代框架
用来构建 REST API，来看下
FastAPI
[...] 它快速、易用且易于学习 [...]
」
「
我们已经将
API
服务切换到了
FastAPI
[...] 我认为你会喜欢它的 [...]
」
Ines Montani - Matthew Honnibal -
Explosion AI
创始人 -
spaCy
作者
(ref)
-
(ref)
Typer
，命令行中的 FastAPI
如果你正在开发一个在终端中运行的
命令行
应用而不是 web API，不妨试下
Typer
。
Typer
是 FastAPI 的小同胞。它想要成为
命令行中的 FastAPI
。 ⌨️ 🚀
依赖
Python 及更高版本
FastAPI 站在以下巨人的肩膀之上：
Starlette
负责 web 部分。
Pydantic
负责数据部分。
安装
fast →
pip install fastapi
restart ↻
你还会需要一个 ASGI 服务器，生产环境可以使用
Uvicorn
或者
Hypercorn
。
fast →
pip install "uvicorn[standard]"
restart ↻
示例
创建
创建一个
main.py
文件并写入以下内容:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
或者使用
async def
...
如果你的代码里会出现
async
/
await
，请使用
async def
：
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Note
:
如果你不知道是否会用到，可以查看文档的
"In a hurry?"
章节中
关于
async
和
await
的部分
。
运行
通过以下命令运行服务器：
fast →
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ↻
关于
uvicorn main:app --reload
命令......
uvicorn main:app
命令含义如下:
main
：
main.py
文件（一个 Python "模块"）。
app
：在
main.py
文件中通过
app = FastAPI()
创建的对象。
--reload
：让服务器在更新代码后重新启动。仅在开发时使用该选项。
检查
使用浏览器访问
http://127.0.0.1:8000/items/5?q=somequery
。
你将会看到如下 JSON 响应：
{
"item_id"
:
5
,
"q"
:
"somequery"
}
你已经创建了一个具有以下功能的 API：
通过
路径
/
和
/items/{item_id}
接受 HTTP 请求。
以上
路径
都接受
GET
操作
（也被称为 HTTP
方法
）。
/items/{item_id}
路径
有一个
路径参数
item_id
并且应该为
int
类型。
/items/{item_id}
路径
有一个可选的
str
类型的
查询参数
q
。
交互式 API 文档
现在访问
http://127.0.0.1:8000/docs
。
你会看到自动生成的交互式 API 文档（由
Swagger UI
生成）：
可选的 API 文档
访问
http://127.0.0.1:8000/redoc
。
你会看到另一个自动生成的文档（由
ReDoc
生成）：
示例升级
现在修改
main.py
文件来从
PUT
请求中接收请求体。
我们借助 Pydantic 来使用标准的 Python 类型声明请求体。
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
服务器将会自动重载（因为在上面的步骤中你向
uvicorn
命令添加了
--reload
选项）。
交互式 API 文档升级
访问
http://127.0.0.1:8000/docs
。
交互式 API 文档将会自动更新，并加入新的请求体：
点击「Try it out」按钮，之后你可以填写参数并直接调用 API：
然后点击「Execute」按钮，用户界面将会和 API 进行通信，发送参数，获取结果并在屏幕上展示：
可选文档升级
访问
http://127.0.0.1:8000/redoc
。
可选文档同样会体现新加入的请求参数和请求体：
总结
总的来说，你就像声明函数的参数类型一样只声明了
一次
请求参数、请求体等的类型。
你使用了标准的现代 Python 类型来完成声明。
你不需要去学习新的语法、了解特定库的方法或类，等等。
只需要使用标准的
Python 及更高版本
。
举个例子，比如声明
int
类型：
item_id
:
int
或者一个更复杂的
Item
模型：
item
:
Item
......在进行一次声明之后，你将获得：
编辑器支持，包括：
自动补全
类型检查
数据校验：
在校验失败时自动生成清晰的错误信息
对多层嵌套的 JSON 对象依然执行校验
转换
来自网络请求的输入数据为 Python 数据类型。包括以下数据：
JSON
路径参数
查询参数
Cookies
请求头
表单
文件
转换
输出的数据：转换 Python 数据类型为供网络传输的 JSON 数据：
转换 Python 基础类型 （
str
、
int
、
float
、
bool
、
list
等）
datetime
对象
UUID
对象
数据库模型
......以及更多其他类型
自动生成的交互式 API 文档，包括两种可选的用户界面：
Swagger UI
ReDoc
回到前面的代码示例，
FastAPI
将会：
校验
GET
和
PUT
请求的路径中是否含有
item_id
。
校验
GET
和
PUT
请求中的
item_id
是否为
int
类型。
如果不是，客户端将会收到清晰有用的错误信息。
检查
GET
请求中是否有命名为
q
的可选查询参数（比如
http://127.0.0.1:8000/items/foo?q=somequery
）。
因为
q
被声明为
= None
，所以它是可选的。
如果没有
None
它将会是必需的 (如
PUT
例子中的请求体)。
对于访问
/items/{item_id}
的
PUT
请求，将请求体读取为 JSON 并：
检查是否有必需属性
name
并且值为
str
类型 。
检查是否有必需属性
price
并且值为
float
类型。
检查是否有可选属性
is_offer
， 如果有的话值应该为
bool
类型。
以上过程对于多层嵌套的 JSON 对象同样也会执行
自动对 JSON 进行转换或转换成 JSON。
通过 OpenAPI 文档来记录所有内容，可被用于：
交互式文档系统
许多编程语言的客户端代码自动生成系统
直接提供 2 种交互式文档 web 界面。
虽然我们才刚刚开始，但其实你已经了解了这一切是如何工作的。
尝试更改下面这行代码：
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
......从：
...
"item_name"
:
item
.
name
...
......改为：
...
"item_price"
:
item
.
price
...
......注意观察编辑器是如何自动补全属性并且还知道它们的类型：
教程 - 用户指南
中有包含更多特性的更完整示例。
剧透警告
： 教程 - 用户指南中的内容有：
对来自不同地方的参数进行声明，如：
请求头
、
cookies
、
form 表单
以及
上传的文件
。
如何设置
校验约束
如
maximum_length
或者
regex
。
一个强大并易于使用的
依赖注入
系统。
安全性和身份验证，包括通过
JWT 令牌
和
HTTP 基本身份认证
来支持
OAuth2
。
更进阶（但同样简单）的技巧来声明
多层嵌套 JSON 模型
（借助 Pydantic）。
许多额外功能（归功于 Starlette）比如：
WebSockets
GraphQL
基于 HTTPX 和
pytest
的极其简单的测试
CORS
Cookie Sessions
......以及更多
性能
独立机构 TechEmpower 所作的基准测试结果显示，基于 Uvicorn 运行的
FastAPI
程序是
最快的 Python web 框架之一
，仅次于 Starlette 和 Uvicorn 本身（FastAPI 内部使用了它们）。(*)
想了解更多，请查阅
基准测试
章节。
可选依赖
用于 Pydantic：
email-validator
- 用于 email 校验。
用于 Starlette：
httpx
- 使用
TestClient
时安装。
jinja2
- 使用默认模板配置时安装。
python-multipart
- 需要通过
request.form()
对表单进行
「解析」
时安装。
itsdangerous
- 需要
SessionMiddleware
支持时安装。
pyyaml
- 使用 Starlette 提供的
SchemaGenerator
时安装（有 FastAPI 你可能并不需要它）。
graphene
- 需要
GraphQLApp
支持时安装。
用于 FastAPI / Starlette：
uvicorn
- 用于加载和运行你的应用程序的服务器。
orjson
- 使用
ORJSONResponse
时安装。
ujson
- 使用
UJSONResponse
时安装。
你可以通过
pip install "fastapi[all]"
命令来安装以上所有依赖。
许可协议
该项目遵循 MIT 许可协议。