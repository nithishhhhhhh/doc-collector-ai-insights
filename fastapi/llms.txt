# FASTAPI DOCUMENTATION
Generated: 2025-06-19 21:28:25
Files processed: 162
Total characters: 3,039,930
Source: Auto-scraped documentation

## OVERVIEW
This file contains the complete documentation for fastapi, minified and optimized for LLM consumption.
All content has been cleaned, deduplicated, and formatted for maximum information density.

---


## 001_INDEX
FastAPI¬∂
---

FastAPI
FastAPI framework, high performance, easy to learn, fast to code, ready for production
Documentation
:
https://fastapi.tiangolo.com
Source Code
:
https://github.com/fastapi/fastapi
FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints.
The key features are:
Fast
: Very high performance, on par with
NodeJS
and
Go
(thanks to Starlette and Pydantic).
One of the fastest Python frameworks available
.
Fast to code
: Increase the speed to develop features by about 200% to 300%. *
Fewer bugs
: Reduce about 40% of human (developer) induced errors. *
Intuitive
: Great editor support.
Completion
everywhere. Less time debugging.
Easy
: Designed to be easy to use and learn. Less time reading docs.
Short
: Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs.
Robust
: Get production-ready code. With automatic interactive documentation.
Standards-based
: Based on (and fully compatible with) the open standards for APIs:
OpenAPI
(previously known as Swagger) and
JSON Schema
.
* estimation based on tests on an internal development team, building production applications.
Sponsors
Other sponsors
Opinions
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I‚Äôm over the moon excited about
FastAPI
. It‚Äôs so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
If anyone is looking to build a production Python API, I would highly recommend
FastAPI
. It is
beautifully designed
,
simple to use
and
highly scalable
, it has become a
key component
in our API first development strategy and is driving many automations and services such as our Virtual TAC Engineer.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, the FastAPI of CLIs
If you are building a
CLI
app to be used in the terminal instead of a web API, check out
Typer
.
Typer
is FastAPI's little sibling. And it's intended to be the
FastAPI of CLIs
. ‚å®Ô∏è üöÄ
Requirements
FastAPI stands on the shoulders of giants:
Starlette
for the web parts.
Pydantic
for the data parts.
Installation
Create and activate a
virtual environment
and then install FastAPI:
fast ‚Üí
pip install "fastapi[standard]"
restart ‚Üª
Note
: Make sure you put
"fastapi[standard]"
in quotes to ensure it works in all terminals.
Example
Create it
Create a file
main.py
with:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Or use
async def
...
If your code uses
async
/
await
, use
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Note
:
If you don't know, check the
"In a hurry?"
section about
async
and
await
in the docs
.
Run it
Run the server with:
fast ‚Üí
fastapi dev main.py
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FastAPI CLI - Development mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ ‚îÇ
‚îÇ Serving at: http://127.0.0.1:8000 ‚îÇ
‚îÇ ‚îÇ
‚îÇ API docs: http://127.0.0.1:8000/docs ‚îÇ
‚îÇ ‚îÇ
‚îÇ Running in development mode, for production use: ‚îÇ
‚îÇ ‚îÇ
‚îÇ fastapi run ‚îÇ
‚îÇ ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
About the command
fastapi dev main.py
...
The command
fastapi dev
reads your
main.py
file, detects the
FastAPI
app in it, and starts a server using
Uvicorn
.
By default,
fastapi dev
will start with auto-reload enabled for local development.
You can read more about it in the
FastAPI CLI docs
.
Check it
Open your browser at
http://127.0.0.1:8000/items/5?q=somequery
.
You will see the JSON response as:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
You already created an API that:
Receives HTTP requests in the
paths
/
and
/items/{item_id}
.
Both
paths
take
GET
operations
(also known as HTTP
methods
).
The
path
/items/{item_id}
has a
path parameter
item_id
that should be an
int
.
The
path
/items/{item_id}
has an optional
str
query parameter
q
.
Interactive API docs
Now go to
http://127.0.0.1:8000/docs
.
You will see the automatic interactive API documentation (provided by
Swagger UI
):
Alternative API docs
And now, go to
http://127.0.0.1:8000/redoc
.
You will see the alternative automatic documentation (provided by
ReDoc
):
Example upgrade
Now modify the file
main.py
to receive a body from a
PUT
request.
Declare the body using standard Python types, thanks to Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
The
fastapi dev
server should reload automatically.
Interactive API docs upgrade
Now go to
http://127.0.0.1:8000/docs
.
The interactive API documentation will be automatically updated, including the new body:
Click on the button "Try it out", it allows you to fill the parameters and directly interact with the API:
Then click on the "Execute" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen:
Alternative API docs upgrade
And now, go to
http://127.0.0.1:8000/redoc
.
The alternative documentation will also reflect the new query parameter and body:
Recap
In summary, you declare
once
the types of parameters, body, etc. as function parameters.
You do that with standard modern Python types.
You don't have to learn a new syntax, the methods or classes of a specific library, etc.
Just standard
Python
.
For example, for an
int
:
item_id
:
int
or for a more complex
Item
model:
item
:
Item
...and with that single declaration you get:
Editor support, including:
Completion.
Type checks.
Validation of data:
Automatic and clear errors when the data is invalid.
Validation even for deeply nested JSON objects.
Conversion
of input data: coming from the network to Python data and types. Reading from:
JSON.
Path parameters.
Query parameters.
Cookies.
Headers.
Forms.
Files.
Conversion
of output data: converting from Python data and types to network data (as JSON):
Convert Python types (
str
,
int
,
float
,
bool
,
list
, etc).
datetime
objects.
UUID
objects.
Database models.
...and many more.
Automatic interactive API documentation, including 2 alternative user interfaces:
Swagger UI.
ReDoc.
Coming back to the previous code example,
FastAPI
will:
Validate that there is an
item_id
in the path for
GET
and
PUT
requests.
Validate that the
item_id
is of type
int
for
GET
and
PUT
requests.
If it is not, the client will see a useful, clear error.
Check if there is an optional query parameter named
q
(as in
http://127.0.0.1:8000/items/foo?q=somequery
) for
GET
requests.
As the
q
parameter is declared with
= None
, it is optional.
Without the
None
it would be required (as is the body in the case with
PUT
).
For
PUT
requests to
/items/{item_id}
, read the body as JSON:
Check that it has a required attribute
name
that should be a
str
.
Check that it has a required attribute
price
that has to be a
float
.
Check that it has an optional attribute
is_offer
, that should be a
bool
, if present.
All this would also work for deeply nested JSON objects.
Convert from and to JSON automatically.
Document everything with OpenAPI, that can be used by:
Interactive documentation systems.
Automatic client code generation systems, for many languages.
Provide 2 interactive documentation web interfaces directly.
We just scratched the surface, but you already get the idea of how it all works.
Try changing the line with:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...from:
...
"item_name"
:
item
.
name
...
...to:
...
"item_price"
:
item
.
price
...
...and see how your editor will auto-complete the attributes and know their types:
For a more complete example including more features, see the
Tutorial - User Guide
.
Spoiler alert
: the tutorial - user guide includes:
Declaration of
parameters
from other different places as:
headers
,
cookies
,
form fields
and
files
.
How to set
validation constraints
as
maximum_length
or
regex
.
A very powerful and easy to use
Dependency Injection
system.
Security and authentication, including support for
OAuth2
with
JWT tokens
and
HTTP Basic
auth.
More advanced (but equally easy) techniques for declaring
deeply nested JSON models
(thanks to Pydantic).
GraphQL
integration with
Strawberry
and other libraries.
Many extra features (thanks to Starlette) as:
WebSockets
extremely easy tests based on HTTPX and
pytest
CORS
Cookie Sessions
...and more.
Performance
Independent TechEmpower benchmarks show
FastAPI
applications running under Uvicorn as
one of the fastest Python frameworks available
, only below Starlette and Uvicorn themselves (used internally by FastAPI). (*)
To understand more about it, see the section
Benchmarks
.
Dependencies
FastAPI depends on Pydantic and Starlette.
standard
Dependencies
When you install FastAPI with
pip install "fastapi[standard]"
it comes with the
standard
group of optional dependencies:
Used by Pydantic:
email-validator
- for email validation.
Used by Starlette:
httpx
- Required if you want to use the
TestClient
.
jinja2
- Required if you want to use the default template configuration.
python-multipart
- Required if you want to support form
"parsing"
, with
request.form()
.
Used by FastAPI / Starlette:
uvicorn
- for the server that loads and serves your application. This includes
uvicorn[standard]
, which includes some dependencies (e.g.
uvloop
) needed for high performance serving.
fastapi-cli
- to provide the
fastapi
command.
Without
standard
Dependencies
If you don't want to include the
standard
optional dependencies, you can install with
pip install fastapi
instead of
pip install "fastapi[standard]"
.
Additional Optional Dependencies
There are some additional dependencies you might want to install.
Additional optional Pydantic dependencies:
pydantic-settings
- for settings management.
pydantic-extra-types
- for extra types to be used with Pydantic.
Additional optional FastAPI dependencies:
orjson
- Required if you want to use
ORJSONResponse
.
ujson
- Required if you want to use
UJSONResponse
.
License
This project is licensed under the terms of the MIT license.

## 002_ADVANCED
Advanced User Guide¬∂
---

Advanced User Guide
Additional Features
The main
Tutorial - User Guide
should be enough to give you a tour through all the main features of
FastAPI
.
In the next sections you will see other options, configurations, and additional features.
Tip
The next sections are
not necessarily "advanced"
.
And it's possible that for your use case, the solution is in one of them.
Read the Tutorial first
You could still use most of the features in
FastAPI
with the knowledge from the main
Tutorial - User Guide
.
And the next sections assume you already read it, and assume that you know those main ideas.

## 003_ADVANCED_ADDITIONAL_RESPONSES
Additional Responses in OpenAPI¬∂
---

Additional Responses in OpenAPI
Warning
This is a rather advanced topic.
If you are starting with
FastAPI
, you might not need this.
You can declare additional responses, with additional status codes, media types, descriptions, etc.
Those additional responses will be included in the OpenAPI schema, so they will also appear in the API docs.
But for those additional responses you have to make sure you return a
Response
like
JSONResponse
directly, with your status code and content.
Additional Response with
model
You can pass to your
path operation decorators
a parameter
responses
.
It receives a
dict
: the keys are status codes for each response (like
200
), and the values are other
dict
s with the information for each of them.
Each of those response
dict
s can have a key
model
, containing a Pydantic model, just like
response_model
.
FastAPI
will take that model, generate its JSON Schema and include it in the correct place in OpenAPI.
For example, to declare another response with a status code
404
and a Pydantic model
Message
, you can write:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
JSONResponse
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
id
:
str
value
:
str
class
Message
(
BaseModel
):
message
:
str
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
responses
=
{
404
:
{
"model"
:
Message
}})
async
def
read_item
(
item_id
:
str
):
if
item_id
==
"foo"
:
return
{
"id"
:
"foo"
,
"value"
:
"there goes my hero"
}
return
JSONResponse
(
status_code
=
404
,
content
=
{
"message"
:
"Item not found"
})
Note
Keep in mind that you have to return the
JSONResponse
directly.
Info
The
model
key is not part of OpenAPI.
FastAPI
will take the Pydantic model from there, generate the JSON Schema, and put it in the correct place.
The correct place is:
In the key
content
, that has as value another JSON object (
dict
) that contains:
A key with the media type, e.g.
application/json
, that contains as value another JSON object, that contains:
A key
schema
, that has as the value the JSON Schema from the model, here's the correct place.
FastAPI
adds a reference here to the global JSON Schemas in another place in your OpenAPI instead of including it directly. This way, other applications and clients can use those JSON Schemas directly, provide better code generation tools, etc.
The generated responses in the OpenAPI for this
path operation
will be:
{
"responses"
:
{
"404"
:
{
"description"
:
"Additional Response"
,
"content"
:
{
"application/json"
:
{
"schema"
:
{
"$ref"
:
"#/components/schemas/Message"
}
}
}
},
"200"
:
{
"description"
:
"Successful Response"
,
"content"
:
{
"application/json"
:
{
"schema"
:
{
"$ref"
:
"#/components/schemas/Item"
}
}
}
},
"422"
:
{
"description"
:
"Validation Error"
,
"content"
:
{
"application/json"
:
{
"schema"
:
{
"$ref"
:
"#/components/schemas/HTTPValidationError"
}
}
}
}
}
}
The schemas are referenced to another place inside the OpenAPI schema:
{
"components"
:
{
"schemas"
:
{
"Message"
:
{
"title"
:
"Message"
,
"required"
:
[
"message"
],
"type"
:
"object"
,
"properties"
:
{
"message"
:
{
"title"
:
"Message"
,
"type"
:
"string"
}
}
},
"Item"
:
{
"title"
:
"Item"
,
"required"
:
[
"id"
,
"value"
],
"type"
:
"object"
,
"properties"
:
{
"id"
:
{
"title"
:
"Id"
,
"type"
:
"string"
},
"value"
:
{
"title"
:
"Value"
,
"type"
:
"string"
}
}
},
"ValidationError"
:
{
"title"
:
"ValidationError"
,
"required"
:
[
"loc"
,
"msg"
,
"type"
],
"type"
:
"object"
,
"properties"
:
{
"loc"
:
{
"title"
:
"Location"
,
"type"
:
"array"
,
"items"
:
{
"type"
:
"string"
}
},
"msg"
:
{
"title"
:
"Message"
,
"type"
:
"string"
},
"type"
:
{
"title"
:
"Error Type"
,
"type"
:
"string"
}
}
},
"HTTPValidationError"
:
{
"title"
:
"HTTPValidationError"
,
"type"
:
"object"
,
"properties"
:
{
"detail"
:
{
"title"
:
"Detail"
,
"type"
:
"array"
,
"items"
:
{
"$ref"
:
"#/components/schemas/ValidationError"
}
}
}
}
}
}
}
Additional media types for the main response
You can use this same
responses
parameter to add different media types for the same main response.
For example, you can add an additional media type of
image/png
, declaring that your
path operation
can return a JSON object (with media type
application/json
) or a PNG image:
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.responses
import
FileResponse
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
id
:
str
value
:
str
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
responses
=
{
200
:
{
"content"
:
{
"image/png"
:
{}},
"description"
:
"Return the JSON item or an image."
,
}
},
)
async
def
read_item
(
item_id
:
str
,
img
:
Union
[
bool
,
None
]
=
None
):
if
img
:
return
FileResponse
(
"image.png"
,
media_type
=
"image/png"
)
else
:
return
{
"id"
:
"foo"
,
"value"
:
"there goes my hero"
}
Note
Notice that you have to return the image using a
FileResponse
directly.
Info
Unless you specify a different media type explicitly in your
responses
parameter, FastAPI will assume the response has the same media type as the main response class (default
application/json
).
But if you have specified a custom response class with
None
as its media type, FastAPI will use
application/json
for any additional response that has an associated model.
Combining information
You can also combine response information from multiple places, including the
response_model
,
status_code
, and
responses
parameters.
You can declare a
response_model
, using the default status code
200
(or a custom one if you need), and then declare additional information for that same response in
responses
, directly in the OpenAPI schema.
FastAPI
will keep the additional information from
responses
, and combine it with the JSON Schema from your model.
For example, you can declare a response with a status code
404
that uses a Pydantic model and has a custom
description
.
And a response with a status code
200
that uses your
response_model
, but includes a custom
example
:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
JSONResponse
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
id
:
str
value
:
str
class
Message
(
BaseModel
):
message
:
str
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
responses
=
{
404
:
{
"model"
:
Message
,
"description"
:
"The item was not found"
},
200
:
{
"description"
:
"Item requested by ID"
,
"content"
:
{
"application/json"
:
{
"example"
:
{
"id"
:
"bar"
,
"value"
:
"The bar tenders"
}
}
},
},
},
)
async
def
read_item
(
item_id
:
str
):
if
item_id
==
"foo"
:
return
{
"id"
:
"foo"
,
"value"
:
"there goes my hero"
}
else
:
return
JSONResponse
(
status_code
=
404
,
content
=
{
"message"
:
"Item not found"
})
It will all be combined and included in your OpenAPI, and shown in the API docs:
Combine predefined responses and custom ones
You might want to have some predefined responses that apply to many
path operations
, but you want to combine them with custom responses needed by each
path operation
.
For those cases, you can use the Python technique of "unpacking" a
dict
with
**dict_to_unpack
:
old_dict
=
{
"old key"
:
"old value"
,
"second old key"
:
"second old value"
,
}
new_dict
=
{
**
old_dict
,
"new key"
:
"new value"
}
Here,
new_dict
will contain all the key-value pairs from
old_dict
plus the new key-value pair:
{
"old key"
:
"old value"
,
"second old key"
:
"second old value"
,
"new key"
:
"new value"
,
}
You can use that technique to reuse some predefined responses in your
path operations
and combine them with additional custom ones.
For example:
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.responses
import
FileResponse
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
id
:
str
value
:
str
responses
=
{
404
:
{
"description"
:
"Item not found"
},
302
:
{
"description"
:
"The item was moved"
},
403
:
{
"description"
:
"Not enough privileges"
},
}
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
responses
=
{
**
responses
,
200
:
{
"content"
:
{
"image/png"
:
{}}}},
)
async
def
read_item
(
item_id
:
str
,
img
:
Union
[
bool
,
None
]
=
None
):
if
img
:
return
FileResponse
(
"image.png"
,
media_type
=
"image/png"
)
else
:
return
{
"id"
:
"foo"
,
"value"
:
"there goes my hero"
}
More information about OpenAPI responses
To see what exactly you can include in the responses, you can check these sections in the OpenAPI specification:
OpenAPI Responses Object
, it includes the
Response Object
.
OpenAPI Response Object
, you can include anything from this directly in each response inside your
responses
parameter. Including
description
,
headers
,
content
(inside of this is that you declare different media types and JSON Schemas), and
links
.

## 004_ADVANCED_ADDITIONAL_STATUS_CODES
Additional Status Codes¬∂
---

Additional Status Codes
By default,
FastAPI
will return the responses using a
JSONResponse
, putting the content you return from your
path operation
inside of that
JSONResponse
.
It will use the default status code or the one you set in your
path operation
.
Additional status codes
If you want to return additional status codes apart from the main one, you can do that by returning a
Response
directly, like a
JSONResponse
, and set the additional status code directly.
For example, let's say that you want to have a
path operation
that allows to update items, and returns HTTP status codes of 200 "OK" when successful.
But you also want it to accept new items. And when the items didn't exist before, it creates them, and returns an HTTP status code of 201 "Created".
To achieve that, import
JSONResponse
, and return your content there directly, setting the
status_code
that you want:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
,
status
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
items
=
{
"foo"
:
{
"name"
:
"Fighters"
,
"size"
:
6
},
"bar"
:
{
"name"
:
"Tenders"
,
"size"
:
3
}}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
upsert_item
(
item_id
:
str
,
name
:
Annotated
[
str
|
None
,
Body
()]
=
None
,
size
:
Annotated
[
int
|
None
,
Body
()]
=
None
,
):
if
item_id
in
items
:
item
=
items
[
item_id
]
item
[
"name"
]
=
name
item
[
"size"
]
=
size
return
item
else
:
item
=
{
"name"
:
name
,
"size"
:
size
}
items
[
item_id
]
=
item
return
JSONResponse
(
status_code
=
status
.
HTTP_201_CREATED
,
content
=
item
)
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
,
status
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
items
=
{
"foo"
:
{
"name"
:
"Fighters"
,
"size"
:
6
},
"bar"
:
{
"name"
:
"Tenders"
,
"size"
:
3
}}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
upsert_item
(
item_id
:
str
,
name
:
Annotated
[
Union
[
str
,
None
],
Body
()]
=
None
,
size
:
Annotated
[
Union
[
int
,
None
],
Body
()]
=
None
,
):
if
item_id
in
items
:
item
=
items
[
item_id
]
item
[
"name"
]
=
name
item
[
"size"
]
=
size
return
item
else
:
item
=
{
"name"
:
name
,
"size"
:
size
}
items
[
item_id
]
=
item
return
JSONResponse
(
status_code
=
status
.
HTTP_201_CREATED
,
content
=
item
)
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
,
status
from
fastapi.responses
import
JSONResponse
from
typing_extensions
import
Annotated
app
=
FastAPI
()
items
=
{
"foo"
:
{
"name"
:
"Fighters"
,
"size"
:
6
},
"bar"
:
{
"name"
:
"Tenders"
,
"size"
:
3
}}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
upsert_item
(
item_id
:
str
,
name
:
Annotated
[
Union
[
str
,
None
],
Body
()]
=
None
,
size
:
Annotated
[
Union
[
int
,
None
],
Body
()]
=
None
,
):
if
item_id
in
items
:
item
=
items
[
item_id
]
item
[
"name"
]
=
name
item
[
"size"
]
=
size
return
item
else
:
item
=
{
"name"
:
name
,
"size"
:
size
}
items
[
item_id
]
=
item
return
JSONResponse
(
status_code
=
status
.
HTTP_201_CREATED
,
content
=
item
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
,
status
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
items
=
{
"foo"
:
{
"name"
:
"Fighters"
,
"size"
:
6
},
"bar"
:
{
"name"
:
"Tenders"
,
"size"
:
3
}}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
upsert_item
(
item_id
:
str
,
name
:
str
|
None
=
Body
(
default
=
None
),
size
:
int
|
None
=
Body
(
default
=
None
),
):
if
item_id
in
items
:
item
=
items
[
item_id
]
item
[
"name"
]
=
name
item
[
"size"
]
=
size
return
item
else
:
item
=
{
"name"
:
name
,
"size"
:
size
}
items
[
item_id
]
=
item
return
JSONResponse
(
status_code
=
status
.
HTTP_201_CREATED
,
content
=
item
)
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
,
status
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
items
=
{
"foo"
:
{
"name"
:
"Fighters"
,
"size"
:
6
},
"bar"
:
{
"name"
:
"Tenders"
,
"size"
:
3
}}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
upsert_item
(
item_id
:
str
,
name
:
Union
[
str
,
None
]
=
Body
(
default
=
None
),
size
:
Union
[
int
,
None
]
=
Body
(
default
=
None
),
):
if
item_id
in
items
:
item
=
items
[
item_id
]
item
[
"name"
]
=
name
item
[
"size"
]
=
size
return
item
else
:
item
=
{
"name"
:
name
,
"size"
:
size
}
items
[
item_id
]
=
item
return
JSONResponse
(
status_code
=
status
.
HTTP_201_CREATED
,
content
=
item
)
Warning
When you return a
Response
directly, like in the example above, it will be returned directly.
It won't be serialized with a model, etc.
Make sure it has the data you want it to have, and that the values are valid JSON (if you are using
JSONResponse
).
Technical Details
You could also use
from starlette.responses import JSONResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with
status
.
OpenAPI and API docs
If you return additional status codes and responses directly, they won't be included in the OpenAPI schema (the API docs), because FastAPI doesn't have a way to know beforehand what you are going to return.
But you can document that in your code, using:
Additional Responses
.

## 005_ADVANCED_ADVANCED_DEPENDENCIES
Advanced Dependencies¬∂
---

Advanced Dependencies
Parameterized dependencies
All the dependencies we have seen are a fixed function or class.
But there could be cases where you want to be able to set parameters on the dependency, without having to declare many different functions or classes.
Let's imagine that we want to have a dependency that checks if the query parameter
q
contains some fixed content.
But we want to be able to parameterize that fixed content.
A "callable" instance
In Python there's a way to make an instance of a class a "callable".
Not the class itself (which is already a callable), but an instance of that class.
To do that, we declare a method
__call__
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
bool
=
Depends
(
checker
)):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
In this case, this
__call__
is what
FastAPI
will use to check for additional parameters and sub-dependencies, and this is what will be called to pass a value to the parameter in your
path operation function
later.
Parameterize the instance
And now, we can use
__init__
to declare the parameters of the instance that we can use to "parameterize" the dependency:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
bool
=
Depends
(
checker
)):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
In this case,
FastAPI
won't ever touch or care about
__init__
, we will use it directly in our code.
Create an instance
We could create an instance of this class with:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
bool
=
Depends
(
checker
)):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
And that way we are able to "parameterize" our dependency, that now has
"bar"
inside of it, as the attribute
checker.fixed_content
.
Use the instance as a dependency
Then, we could use this
checker
in a
Depends(checker)
, instead of
Depends(FixedContentQueryChecker)
, because the dependency is the instance,
checker
, not the class itself.
And when solving the dependency,
FastAPI
will call this
checker
like:
checker
(
q
=
"somequery"
)
...and pass whatever that returns as the value of the dependency in our
path operation function
as the parameter
fixed_content_included
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
Annotated
[
bool
,
Depends
(
checker
)]):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
class
FixedContentQueryChecker
:
def
__init__
(
self
,
fixed_content
:
str
):
self
.
fixed_content
=
fixed_content
def
__call__
(
self
,
q
:
str
=
""
):
if
q
:
return
self
.
fixed_content
in
q
return
False
checker
=
FixedContentQueryChecker
(
"bar"
)
@app
.
get
(
"/query-checker/"
)
async
def
read_query_check
(
fixed_content_included
:
bool
=
Depends
(
checker
)):
return
{
"fixed_content_in_query"
:
fixed_content_included
}
Tip
All this might seem contrived. And it might not be very clear how is it useful yet.
These examples are intentionally simple, but show how it all works.
In the chapters about security, there are utility functions that are implemented in this same way.
If you understood all this, you already know how those utility tools for security work underneath.

## 006_ADVANCED_ASYNC_TESTS
Async Tests¬∂
---

Async Tests
You have already seen how to test your
FastAPI
applications using the provided
TestClient
. Up to now, you have only seen how to write synchronous tests, without using
async
functions.
Being able to use asynchronous functions in your tests could be useful, for example, when you're querying your database asynchronously. Imagine you want to test sending requests to your FastAPI application and then verify that your backend successfully wrote the correct data in the database, while using an async database library.
Let's look at how we can make that work.
pytest.mark.anyio
If we want to call asynchronous functions in our tests, our test functions have to be asynchronous. AnyIO provides a neat plugin for this, that allows us to specify that some test functions are to be called asynchronously.
HTTPX
Even if your
FastAPI
application uses normal
def
functions instead of
async def
, it is still an
async
application underneath.
The
TestClient
does some magic inside to call the asynchronous FastAPI application in your normal
def
test functions, using standard pytest. But that magic doesn't work anymore when we're using it inside asynchronous functions. By running our tests asynchronously, we can no longer use the
TestClient
inside our test functions.
The
TestClient
is based on
HTTPX
, and luckily, we can use it directly to test the API.
Example
For a simple example, let's consider a file structure similar to the one described in
Bigger Applications
and
Testing
:
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_main.py
The file
main.py
would have:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Tomato"
}
The file
test_main.py
would have the tests for
main.py
, it could look like this now:
Python 3.8+
import
pytest
from
httpx
import
ASGITransport
,
AsyncClient
from
.main
import
app
@pytest
.
mark
.
anyio
async
def
test_root
():
async
with
AsyncClient
(
transport
=
ASGITransport
(
app
=
app
),
base_url
=
"http://test"
)
as
ac
:
response
=
await
ac
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Tomato"
}
Run it
You can run your tests as usual via:
fast ‚Üí
pytest
restart ‚Üª
In Detail
The marker
@pytest.mark.anyio
tells pytest that this test function should be called asynchronously:
Python 3.8+
import
pytest
from
httpx
import
ASGITransport
,
AsyncClient
from
.main
import
app
@pytest
.
mark
.
anyio
async
def
test_root
():
async
with
AsyncClient
(
transport
=
ASGITransport
(
app
=
app
),
base_url
=
"http://test"
)
as
ac
:
response
=
await
ac
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Tomato"
}
Tip
Note that the test function is now
async def
instead of just
def
as before when using the
TestClient
.
Then we can create an
AsyncClient
with the app, and send async requests to it, using
await
.
Python 3.8+
import
pytest
from
httpx
import
ASGITransport
,
AsyncClient
from
.main
import
app
@pytest
.
mark
.
anyio
async
def
test_root
():
async
with
AsyncClient
(
transport
=
ASGITransport
(
app
=
app
),
base_url
=
"http://test"
)
as
ac
:
response
=
await
ac
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Tomato"
}
This is the equivalent to:
response
=
client
.
get
(
'/'
)
...that we used to make our requests with the
TestClient
.
Tip
Note that we're using async/await with the new
AsyncClient
- the request is asynchronous.
Warning
If your application relies on lifespan events, the
AsyncClient
won't trigger these events. To ensure they are triggered, use
LifespanManager
from
florimondmanca/asgi-lifespan
.
Other Asynchronous Function Calls
As the testing function is now asynchronous, you can now also call (and
await
) other
async
functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.
Tip
If you encounter a
RuntimeError: Task attached to a different loop
when integrating asynchronous function calls in your tests (e.g. when using
MongoDB's MotorClient
), remember to instantiate objects that need an event loop only within async functions, e.g. an
'@app.on_event("startup")
callback.

## 007_ADVANCED_BEHIND_A_PROXY
Behind a Proxy¬∂
---

Behind a Proxy
In some situations, you might need to use a
proxy
server like Traefik or Nginx with a configuration that adds an extra path prefix that is not seen by your application.
In these cases you can use
root_path
to configure your application.
The
root_path
is a mechanism provided by the ASGI specification (that FastAPI is built on, through Starlette).
The
root_path
is used to handle these specific cases.
And it's also used internally when mounting sub-applications.
Proxy with a stripped path prefix
Having a proxy with a stripped path prefix, in this case, means that you could declare a path at
/app
in your code, but then, you add a layer on top (the proxy) that would put your
FastAPI
application under a path like
/api/v1
.
In this case, the original path
/app
would actually be served at
/api/v1/app
.
Even though all your code is written assuming there's just
/app
.
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
@app
.
get
(
"/app"
)
def
read_main
(
request
:
Request
):
return
{
"message"
:
"Hello World"
,
"root_path"
:
request
.
scope
.
get
(
"root_path"
)}
And the proxy would be
"stripping"
the
path prefix
on the fly before transmitting the request to the app server (probably Uvicorn via FastAPI CLI), keeping your application convinced that it is being served at
/app
, so that you don't have to update all your code to include the prefix
/api/v1
.
Up to here, everything would work as normally.
But then, when you open the integrated docs UI (the frontend), it would expect to get the OpenAPI schema at
/openapi.json
, instead of
/api/v1/openapi.json
.
So, the frontend (that runs in the browser) would try to reach
/openapi.json
and wouldn't be able to get the OpenAPI schema.
Because we have a proxy with a path prefix of
/api/v1
for our app, the frontend needs to fetch the OpenAPI schema at
/api/v1/openapi.json
.
Tip
The IP
0.0.0.0
is commonly used to mean that the program listens on all the IPs available in that machine/server.
The docs UI would also need the OpenAPI schema to declare that this API
server
is located at
/api/v1
(behind the proxy). For example:
{
"openapi"
:
"3.1.0"
,
// More stuff here
"servers"
:
[
{
"url"
:
"/api/v1"
}
],
"paths"
:
{
// More stuff here
}
}
In this example, the "Proxy" could be something like
Traefik
. And the server would be something like FastAPI CLI with
Uvicorn
, running your FastAPI application.
Providing the
root_path
To achieve this, you can use the command line option
--root-path
like:
fast ‚Üí
fastapi run main.py --root-path /api/v1
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
If you use Hypercorn, it also has the option
--root-path
.
Technical Details
The ASGI specification defines a
root_path
for this use case.
And the
--root-path
command line option provides that
root_path
.
Checking the current
root_path
You can get the current
root_path
used by your application for each request, it is part of the
scope
dictionary (that's part of the ASGI spec).
Here we are including it in the message just for demonstration purposes.
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
@app
.
get
(
"/app"
)
def
read_main
(
request
:
Request
):
return
{
"message"
:
"Hello World"
,
"root_path"
:
request
.
scope
.
get
(
"root_path"
)}
Then, if you start Uvicorn with:
fast ‚Üí
fastapi run main.py --root-path /api/v1
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
The response would be something like:
{
"message"
:
"Hello World"
,
"root_path"
:
"/api/v1"
}
Setting the
root_path
in the FastAPI app
Alternatively, if you don't have a way to provide a command line option like
--root-path
or equivalent, you can set the
root_path
parameter when creating your FastAPI app:
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
(
root_path
=
"/api/v1"
)
@app
.
get
(
"/app"
)
def
read_main
(
request
:
Request
):
return
{
"message"
:
"Hello World"
,
"root_path"
:
request
.
scope
.
get
(
"root_path"
)}
Passing the
root_path
to
FastAPI
would be the equivalent of passing the
--root-path
command line option to Uvicorn or Hypercorn.
About
root_path
Keep in mind that the server (Uvicorn) won't use that
root_path
for anything else than passing it to the app.
But if you go with your browser to
http://127.0.0.1:8000/app
you will see the normal response:
{
"message"
:
"Hello World"
,
"root_path"
:
"/api/v1"
}
So, it won't expect to be accessed at
http://127.0.0.1:8000/api/v1/app
.
Uvicorn will expect the proxy to access Uvicorn at
http://127.0.0.1:8000/app
, and then it would be the proxy's responsibility to add the extra
/api/v1
prefix on top.
About proxies with a stripped path prefix
Keep in mind that a proxy with stripped path prefix is only one of the ways to configure it.
Probably in many cases the default will be that the proxy doesn't have a stripped path prefix.
In a case like that (without a stripped path prefix), the proxy would listen on something like
https://myawesomeapp.com
, and then if the browser goes to
https://myawesomeapp.com/api/v1/app
and your server (e.g. Uvicorn) listens on
http://127.0.0.1:8000
the proxy (without a stripped path prefix) would access Uvicorn at the same path:
http://127.0.0.1:8000/api/v1/app
.
Testing locally with Traefik
You can easily run the experiment locally with a stripped path prefix using
Traefik
.
Download Traefik
, it's a single binary, you can extract the compressed file and run it directly from the terminal.
Then create a file
traefik.toml
with:
[entryPoints]
[entryPoints.http]
address
=
":9999"
[providers]
[providers.file]
filename
=
"routes.toml"
This tells Traefik to listen on port 9999 and to use another file
routes.toml
.
Tip
We are using port 9999 instead of the standard HTTP port 80 so that you don't have to run it with admin (
sudo
) privileges.
Now create that other file
routes.toml
:
[http]
[http.middlewares]
[http.middlewares.api-stripprefix.stripPrefix]
prefixes
=
[
"/api/v1"
]
[http.routers]
[http.routers.app-http]
entryPoints
=
[
"http"
]
service
=
"app"
rule
=
"PathPrefix(`/api/v1`)"
middlewares
=
[
"api-stripprefix"
]
[http.services]
[http.services.app]
[http.services.app.loadBalancer]
[[http.services.app.loadBalancer.servers]]
url
=
"http://127.0.0.1:8000"
This file configures Traefik to use the path prefix
/api/v1
.
And then Traefik will redirect its requests to your Uvicorn running on
http://127.0.0.1:8000
.
Now start Traefik:
fast ‚Üí
./traefik --configFile=traefik.toml
INFO[0000] Configuration loaded from file: /home/user/awesomeapi/traefik.toml
restart ‚Üª
And now start your app, using the
--root-path
option:
fast ‚Üí
fastapi run main.py --root-path /api/v1
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
Check the responses
Now, if you go to the URL with the port for Uvicorn:
http://127.0.0.1:8000/app
, you will see the normal response:
{
"message"
:
"Hello World"
,
"root_path"
:
"/api/v1"
}
Tip
Notice that even though you are accessing it at
http://127.0.0.1:8000/app
it shows the
root_path
of
/api/v1
, taken from the option
--root-path
.
And now open the URL with the port for Traefik, including the path prefix:
http://127.0.0.1:9999/api/v1/app
.
We get the same response:
{
"message"
:
"Hello World"
,
"root_path"
:
"/api/v1"
}
but this time at the URL with the prefix path provided by the proxy:
/api/v1
.
Of course, the idea here is that everyone would access the app through the proxy, so the version with the path prefix
/api/v1
is the "correct" one.
And the version without the path prefix (
http://127.0.0.1:8000/app
), provided by Uvicorn directly, would be exclusively for the
proxy
(Traefik) to access it.
That demonstrates how the Proxy (Traefik) uses the path prefix and how the server (Uvicorn) uses the
root_path
from the option
--root-path
.
Check the docs UI
But here's the fun part. ‚ú®
The "official" way to access the app would be through the proxy with the path prefix that we defined. So, as we would expect, if you try the docs UI served by Uvicorn directly, without the path prefix in the URL, it won't work, because it expects to be accessed through the proxy.
You can check it at
http://127.0.0.1:8000/docs
:
But if we access the docs UI at the "official" URL using the proxy with port
9999
, at
/api/v1/docs
, it works correctly! üéâ
You can check it at
http://127.0.0.1:9999/api/v1/docs
:
Right as we wanted it. ‚úîÔ∏è
This is because FastAPI uses this
root_path
to create the default
server
in OpenAPI with the URL provided by
root_path
.
Additional servers
Warning
This is a more advanced use case. Feel free to skip it.
By default,
FastAPI
will create a
server
in the OpenAPI schema with the URL for the
root_path
.
But you can also provide other alternative
servers
, for example if you want
the same
docs UI to interact with both a staging and a production environment.
If you pass a custom list of
servers
and there's a
root_path
(because your API lives behind a proxy),
FastAPI
will insert a "server" with this
root_path
at the beginning of the list.
For example:
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
(
servers
=
[
{
"url"
:
"https://stag.example.com"
,
"description"
:
"Staging environment"
},
{
"url"
:
"https://prod.example.com"
,
"description"
:
"Production environment"
},
],
root_path
=
"/api/v1"
,
)
@app
.
get
(
"/app"
)
def
read_main
(
request
:
Request
):
return
{
"message"
:
"Hello World"
,
"root_path"
:
request
.
scope
.
get
(
"root_path"
)}
Will generate an OpenAPI schema like:
{
"openapi"
:
"3.1.0"
,
// More stuff here
"servers"
:
[
{
"url"
:
"/api/v1"
},
{
"url"
:
"https://stag.example.com"
,
"description"
:
"Staging environment"
},
{
"url"
:
"https://prod.example.com"
,
"description"
:
"Production environment"
}
],
"paths"
:
{
// More stuff here
}
}
Tip
Notice the auto-generated server with a
url
value of
/api/v1
, taken from the
root_path
.
In the docs UI at
http://127.0.0.1:9999/api/v1/docs
it would look like:
Tip
The docs UI will interact with the server that you select.
Disable automatic server from
root_path
If you don't want
FastAPI
to include an automatic server using the
root_path
, you can use the parameter
root_path_in_servers=False
:
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
(
servers
=
[
{
"url"
:
"https://stag.example.com"
,
"description"
:
"Staging environment"
},
{
"url"
:
"https://prod.example.com"
,
"description"
:
"Production environment"
},
],
root_path
=
"/api/v1"
,
root_path_in_servers
=
False
,
)
@app
.
get
(
"/app"
)
def
read_main
(
request
:
Request
):
return
{
"message"
:
"Hello World"
,
"root_path"
:
request
.
scope
.
get
(
"root_path"
)}
and then it won't include it in the OpenAPI schema.
Mounting a sub-application
If you need to mount a sub-application (as described in
Sub Applications - Mounts
) while also using a proxy with
root_path
, you can do it normally, as you would expect.
FastAPI will internally use the
root_path
smartly, so it will just work. ‚ú®

## 008_ADVANCED_CUSTOM_RESPONSE
Custom Response - HTML, Stream, File, others¬∂
---

Custom Response - HTML, Stream, File, others
By default,
FastAPI
will return the responses using
JSONResponse
.
You can override it by returning a
Response
directly as seen in
Return a Response directly
.
But if you return a
Response
directly (or any subclass, like
JSONResponse
), the data won't be automatically converted (even if you declare a
response_model
), and the documentation won't be automatically generated (for example, including the specific "media type", in the HTTP header
Content-Type
as part of the generated OpenAPI).
But you can also declare the
Response
that you want to be used (e.g. any
Response
subclass), in the
path operation decorator
using the
response_class
parameter.
The contents that you return from your
path operation function
will be put inside of that
Response
.
And if that
Response
has a JSON media type (
application/json
), like is the case with the
JSONResponse
and
UJSONResponse
, the data you return will be automatically converted (and filtered) with any Pydantic
response_model
that you declared in the
path operation decorator
.
Note
If you use a response class with no media type, FastAPI will expect your response to have no content, so it will not document the response format in its generated OpenAPI docs.
Use
ORJSONResponse
For example, if you are squeezing performance, you can install and use
orjson
and set the response to be
ORJSONResponse
.
Import the
Response
class (sub-class) you want to use and declare it in the
path operation decorator
.
For large responses, returning a
Response
directly is much faster than returning a dictionary.
This is because by default, FastAPI will inspect every item inside and make sure it is serializable as JSON, using the same
JSON Compatible Encoder
explained in the tutorial. This is what allows you to return
arbitrary objects
, for example database models.
But if you are certain that the content that you are returning is
serializable with JSON
, you can pass it directly to the response class and avoid the extra overhead that FastAPI would have by passing your return content through the
jsonable_encoder
before passing it to the response class.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
ORJSONResponse
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
response_class
=
ORJSONResponse
)
async
def
read_items
():
return
ORJSONResponse
([{
"item_id"
:
"Foo"
}])
Info
The parameter
response_class
will also be used to define the "media type" of the response.
In this case, the HTTP header
Content-Type
will be set to
application/json
.
And it will be documented as such in OpenAPI.
Tip
The
ORJSONResponse
is only available in FastAPI, not in Starlette.
HTML Response
To return a response with HTML directly from
FastAPI
, use
HTMLResponse
.
Import
HTMLResponse
.
Pass
HTMLResponse
as the parameter
response_class
of your
path operation decorator
.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
response_class
=
HTMLResponse
)
async
def
read_items
():
return
"""
<html>
<head>
<title>Some HTML in here</title>
</head>
<body>
<h1>Look ma! HTML!</h1>
</body>
</html>
"""
Info
The parameter
response_class
will also be used to define the "media type" of the response.
In this case, the HTTP header
Content-Type
will be set to
text/html
.
And it will be documented as such in OpenAPI.
Return a
Response
As seen in
Return a Response directly
, you can also override the response directly in your
path operation
, by returning it.
The same example from above, returning an
HTMLResponse
, could look like:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
html_content
=
"""
<html>
<head>
<title>Some HTML in here</title>
</head>
<body>
<h1>Look ma! HTML!</h1>
</body>
</html>
"""
return
HTMLResponse
(
content
=
html_content
,
status_code
=
200
)
Warning
A
Response
returned directly by your
path operation function
won't be documented in OpenAPI (for example, the
Content-Type
won't be documented) and won't be visible in the automatic interactive docs.
Info
Of course, the actual
Content-Type
header, status code, etc, will come from the
Response
object you returned.
Document in OpenAPI and override
Response
If you want to override the response from inside of the function but at the same time document the "media type" in OpenAPI, you can use the
response_class
parameter AND return a
Response
object.
The
response_class
will then be used only to document the OpenAPI
path operation
, but your
Response
will be used as is.
Return an
HTMLResponse
directly
For example, it could be something like:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
def
generate_html_response
():
html_content
=
"""
<html>
<head>
<title>Some HTML in here</title>
</head>
<body>
<h1>Look ma! HTML!</h1>
</body>
</html>
"""
return
HTMLResponse
(
content
=
html_content
,
status_code
=
200
)
@app
.
get
(
"/items/"
,
response_class
=
HTMLResponse
)
async
def
read_items
():
return
generate_html_response
()
In this example, the function
generate_html_response()
already generates and returns a
Response
instead of returning the HTML in a
str
.
By returning the result of calling
generate_html_response()
, you are already returning a
Response
that will override the default
FastAPI
behavior.
But as you passed the
HTMLResponse
in the
response_class
too,
FastAPI
will know how to document it in OpenAPI and the interactive docs as HTML with
text/html
:
Available responses
Here are some of the available responses.
Keep in mind that you can use
Response
to return anything else, or even create a custom sub-class.
Technical Details
You could also use
from starlette.responses import HTMLResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
Response
The main
Response
class, all the other responses inherit from it.
You can return it directly.
It accepts the following parameters:
content
- A
str
or
bytes
.
status_code
- An
int
HTTP status code.
headers
- A
dict
of strings.
media_type
- A
str
giving the media type. E.g.
"text/html"
.
FastAPI (actually Starlette) will automatically include a Content-Length header. It will also include a Content-Type header, based on the
media_type
and appending a charset for text types.
Python 3.8+
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
@app
.
get
(
"/legacy/"
)
def
get_legacy_data
():
data
=
"""<?xml version="1.0"?>
<shampoo>
<Header>
Apply shampoo here.
</Header>
<Body>
You'll have to use soap here.
</Body>
</shampoo>
"""
return
Response
(
content
=
data
,
media_type
=
"application/xml"
)
HTMLResponse
Takes some text or bytes and returns an HTML response, as you read above.
PlainTextResponse
Takes some text or bytes and returns a plain text response.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
PlainTextResponse
app
=
FastAPI
()
@app
.
get
(
"/"
,
response_class
=
PlainTextResponse
)
async
def
main
():
return
"Hello World"
JSONResponse
Takes some data and returns an
application/json
encoded response.
This is the default response used in
FastAPI
, as you read above.
ORJSONResponse
A fast alternative JSON response using
orjson
, as you read above.
Info
This requires installing
orjson
for example with
pip install orjson
.
UJSONResponse
An alternative JSON response using
ujson
.
Info
This requires installing
ujson
for example with
pip install ujson
.
Warning
ujson
is less careful than Python's built-in implementation in how it handles some edge-cases.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
UJSONResponse
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
response_class
=
UJSONResponse
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
Tip
It's possible that
ORJSONResponse
might be a faster alternative.
RedirectResponse
Returns an HTTP redirect. Uses a 307 status code (Temporary Redirect) by default.
You can return a
RedirectResponse
directly:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/typer"
)
async
def
redirect_typer
():
return
RedirectResponse
(
"https://typer.tiangolo.com"
)
Or you can use it in the
response_class
parameter:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/fastapi"
,
response_class
=
RedirectResponse
)
async
def
redirect_fastapi
():
return
"https://fastapi.tiangolo.com"
If you do that, then you can return the URL directly from your
path operation
function.
In this case, the
status_code
used will be the default one for the
RedirectResponse
, which is
307
.
You can also use the
status_code
parameter combined with the
response_class
parameter:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/pydantic"
,
response_class
=
RedirectResponse
,
status_code
=
302
)
async
def
redirect_pydantic
():
return
"https://docs.pydantic.dev/"
StreamingResponse
Takes an async generator or a normal generator/iterator and streams the response body.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
StreamingResponse
app
=
FastAPI
()
async
def
fake_video_streamer
():
for
i
in
range
(
10
):
yield
b
"some fake video bytes"
@app
.
get
(
"/"
)
async
def
main
():
return
StreamingResponse
(
fake_video_streamer
())
Using
StreamingResponse
with file-like objects
If you have a file-like object (e.g. the object returned by
open()
), you can create a generator function to iterate over that file-like object.
That way, you don't have to read it all first in memory, and you can pass that generator function to the
StreamingResponse
, and return it.
This includes many libraries to interact with cloud storage, video processing, and others.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
StreamingResponse
some_file_path
=
"large-video-file.mp4"
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
main
():
def
iterfile
():
## (1)
with
open
(
some_file_path
,
mode
=
"rb"
)
as
file_like
:
## (2)
yield from
file_like
## (3)
return
StreamingResponse
(
iterfile
(),
media_type
=
"video/mp4"
)
This is the generator function. It's a "generator function" because it contains
yield
statements inside.
By using a
with
block, we make sure that the file-like object is closed after the generator function is done. So, after it finishes sending the response.
This
yield from
tells the function to iterate over that thing named
file_like
. And then, for each part iterated, yield that part as coming from this generator function (
iterfile
).
So, it is a generator function that transfers the "generating" work to something else internally.
By doing it this way, we can put it in a
with
block, and that way, ensure that the file-like object is closed after finishing.
Tip
Notice that here as we are using standard
open()
that doesn't support
async
and
await
, we declare the path operation with normal
def
.
FileResponse
Asynchronously streams a file as the response.
Takes a different set of arguments to instantiate than the other response types:
path
- The file path to the file to stream.
headers
- Any custom headers to include, as a dictionary.
media_type
- A string giving the media type. If unset, the filename or path will be used to infer a media type.
filename
- If set, this will be included in the response
Content-Disposition
.
File responses will include appropriate
Content-Length
,
Last-Modified
and
ETag
headers.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
FileResponse
some_file_path
=
"large-video-file.mp4"
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
main
():
return
FileResponse
(
some_file_path
)
You can also use the
response_class
parameter:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
FileResponse
some_file_path
=
"large-video-file.mp4"
app
=
FastAPI
()
@app
.
get
(
"/"
,
response_class
=
FileResponse
)
async
def
main
():
return
some_file_path
In this case, you can return the file path directly from your
path operation
function.
Custom response class
You can create your own custom response class, inheriting from
Response
and using it.
For example, let's say that you want to use
orjson
, but with some custom settings not used in the included
ORJSONResponse
class.
Let's say you want it to return indented and formatted JSON, so you want to use the orjson option
orjson.OPT_INDENT_2
.
You could create a
CustomORJSONResponse
. The main thing you have to do is create a
Response.render(content)
method that returns the content as
bytes
:
Python 3.8+
from
typing
import
Any
import
orjson
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
class
CustomORJSONResponse
(
Response
):
media_type
=
"application/json"
def
render
(
self
,
content
:
Any
)
->
bytes
:
assert
orjson
is
not
None
,
"orjson must be installed"
return
orjson
.
dumps
(
content
,
option
=
orjson
.
OPT_INDENT_2
)
@app
.
get
(
"/"
,
response_class
=
CustomORJSONResponse
)
async
def
main
():
return
{
"message"
:
"Hello World"
}
Now instead of returning:
{
"message"
:
"Hello World"
}
...this response will return:
{
"message"
:
"Hello World"
}
Of course, you will probably find much better ways to take advantage of this than formatting JSON. üòâ
Default response class
When creating a
FastAPI
class instance or an
APIRouter
you can specify which response class to use by default.
The parameter that defines this is
default_response_class
.
In the example below,
FastAPI
will use
ORJSONResponse
by default, in all
path operations
, instead of
JSONResponse
.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
ORJSONResponse
app
=
FastAPI
(
default_response_class
=
ORJSONResponse
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
Tip
You can still override
response_class
in
path operations
as before.
Additional documentation
You can also declare the media type and many other details in OpenAPI using
responses
:
Additional Responses in OpenAPI
.

## 009_ADVANCED_DATACLASSES
Using Dataclasses¬∂
---

Using Dataclasses
FastAPI is built on top of
Pydantic
, and I have been showing you how to use Pydantic models to declare requests and responses.
But FastAPI also supports using
dataclasses
the same way:
Python 3.8+
from
dataclasses
import
dataclass
from
typing
import
Union
from
fastapi
import
FastAPI
@dataclass
class
Item
:
name
:
str
price
:
float
description
:
Union
[
str
,
None
]
=
None
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
This is still supported thanks to
Pydantic
, as it has
internal support for
dataclasses
.
So, even with the code above that doesn't use Pydantic explicitly, FastAPI is using Pydantic to convert those standard dataclasses to Pydantic's own flavor of dataclasses.
And of course, it supports the same:
data validation
data serialization
data documentation, etc.
This works the same way as with Pydantic models. And it is actually achieved in the same way underneath, using Pydantic.
Info
Keep in mind that dataclasses can't do everything Pydantic models can do.
So, you might still need to use Pydantic models.
But if you have a bunch of dataclasses laying around, this is a nice trick to use them to power a web API using FastAPI. ü§ì
Dataclasses in
response_model
You can also use
dataclasses
in the
response_model
parameter:
Python 3.8+
from
dataclasses
import
dataclass
,
field
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
@dataclass
class
Item
:
name
:
str
price
:
float
tags
:
List
[
str
]
=
field
(
default_factory
=
list
)
description
:
Union
[
str
,
None
]
=
None
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
get
(
"/items/next"
,
response_model
=
Item
)
async
def
read_next_item
():
return
{
"name"
:
"Island In The Moon"
,
"price"
:
12.99
,
"description"
:
"A place to be playin' and havin' fun"
,
"tags"
:
[
"breater"
],
}
The dataclass will be automatically converted to a Pydantic dataclass.
This way, its schema will show up in the API docs user interface:
Dataclasses in Nested Data Structures
You can also combine
dataclasses
with other type annotations to make nested data structures.
In some cases, you might still have to use Pydantic's version of
dataclasses
. For example, if you have errors with the automatically generated API documentation.
In that case, you can simply swap the standard
dataclasses
with
pydantic.dataclasses
, which is a drop-in replacement:
Python 3.8+
from
dataclasses
import
field
## (1)
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic.dataclasses
import
dataclass
## (2)
@dataclass
class
Item
:
name
:
str
description
:
Union
[
str
,
None
]
=
None
@dataclass
class
Author
:
name
:
str
items
:
List
[
Item
]
=
field
(
default_factory
=
list
)
## (3)
app
=
FastAPI
()
@app
.
post
(
"/authors/
{author_id}
/items/"
,
response_model
=
Author
)
## (4)
async
def
create_author_items
(
author_id
:
str
,
items
:
List
[
Item
]):
## (5)
return
{
"name"
:
author_id
,
"items"
:
items
}
## (6)
@app
.
get
(
"/authors/"
,
response_model
=
List
[
Author
])
## (7)
def
get_authors
():
## (8)
return
[
## (9)
{
"name"
:
"Breaters"
,
"items"
:
[
{
"name"
:
"Island In The Moon"
,
"description"
:
"A place to be playin' and havin' fun"
,
},
{
"name"
:
"Holy Buddies"
},
],
},
{
"name"
:
"System of an Up"
,
"items"
:
[
{
"name"
:
"Salt"
,
"description"
:
"The kombucha mushroom people's favorite"
,
},
{
"name"
:
"Pad Thai"
},
{
"name"
:
"Lonely Night"
,
"description"
:
"The mostests lonliest nightiest of allest"
,
},
],
},
]
We still import
field
from standard
dataclasses
.
pydantic.dataclasses
is a drop-in replacement for
dataclasses
.
The
Author
dataclass includes a list of
Item
dataclasses.
The
Author
dataclass is used as the
response_model
parameter.
You can use other standard type annotations with dataclasses as the request body.
In this case, it's a list of
Item
dataclasses.
Here we are returning a dictionary that contains
items
which is a list of dataclasses.
FastAPI is still capable of
serializing
the data to JSON.
Here the
response_model
is using a type annotation of a list of
Author
dataclasses.
Again, you can combine
dataclasses
with standard type annotations.
Notice that this
path operation function
uses regular
def
instead of
async def
.
As always, in FastAPI you can combine
def
and
async def
as needed.
If you need a refresher about when to use which, check out the section
"In a hurry?"
in the docs about
async
and
await
.
This
path operation function
is not returning dataclasses (although it could), but a list of dictionaries with internal data.
FastAPI will use the
response_model
parameter (that includes dataclasses) to convert the response.
You can combine
dataclasses
with other type annotations in many different combinations to form complex data structures.
Check the in-code annotation tips above to see more specific details.
Learn More
You can also combine
dataclasses
with other Pydantic models, inherit from them, include them in your own models, etc.
To learn more, check the
Pydantic docs about dataclasses
.
Version
This is available since FastAPI version
0.67.0
. üîñ

## 010_ADVANCED_EVENTS
Lifespan Events¬∂
---

Lifespan Events
You can define logic (code) that should be executed before the application
starts up
. This means that this code will be executed
once
,
before
the application
starts receiving requests
.
The same way, you can define logic (code) that should be executed when the application is
shutting down
. In this case, this code will be executed
once
,
after
having handled possibly
many requests
.
Because this code is executed before the application
starts
taking requests, and right after it
finishes
handling requests, it covers the whole application
lifespan
(the word "lifespan" will be important in a second üòâ).
This can be very useful for setting up
resources
that you need to use for the whole app, and that are
shared
among requests, and/or that you need to
clean up
afterwards. For example, a database connection pool, or loading a shared machine learning model.
Use Case
Let's start with an example
use case
and then see how to solve it with this.
Let's imagine that you have some
machine learning models
that you want to use to handle requests. ü§ñ
The same models are shared among requests, so, it's not one model per request, or one per user or something similar.
Let's imagine that loading the model can
take quite some time
, because it has to read a lot of
data from disk
. So you don't want to do it for every request.
You could load it at the top level of the module/file, but that would also mean that it would
load the model
even if you are just running a simple automated test, then that test would be
slow
because it would have to wait for the model to load before being able to run an independent part of the code.
That's what we'll solve, let's load the model before the requests are handled, but only right before the application starts receiving requests, not while the code is being loaded.
Lifespan
You can define this
startup
and
shutdown
logic using the
lifespan
parameter of the
FastAPI
app, and a "context manager" (I'll show you what that is in a second).
Let's start with an example and then see it in detail.
We create an async function
lifespan()
with
yield
like this:
Python 3.8+
from
contextlib
import
asynccontextmanager
from
fastapi
import
FastAPI
def
fake_answer_to_everything_ml_model
(
x
:
float
):
return
x
*
42
ml_models
=
{}
@asynccontextmanager
async
def
lifespan
(
app
:
FastAPI
):
## Load the ML model
ml_models
[
"answer_to_everything"
]
=
fake_answer_to_everything_ml_model
yield
## Clean up the ML models and release the resources
ml_models
.
clear
()
app
=
FastAPI
(
lifespan
=
lifespan
)
@app
.
get
(
"/predict"
)
async
def
predict
(
x
:
float
):
result
=
ml_models
[
"answer_to_everything"
](
x
)
return
{
"result"
:
result
}
Here we are simulating the expensive
startup
operation of loading the model by putting the (fake) model function in the dictionary with machine learning models before the
yield
. This code will be executed
before
the application
starts taking requests
, during the
startup
.
And then, right after the
yield
, we unload the model. This code will be executed
after
the application
finishes handling requests
, right before the
shutdown
. This could, for example, release resources like memory or a GPU.
Tip
The
shutdown
would happen when you are
stopping
the application.
Maybe you need to start a new version, or you just got tired of running it. ü§∑
Lifespan function
The first thing to notice, is that we are defining an async function with
yield
. This is very similar to Dependencies with
yield
.
Python 3.8+
from
contextlib
import
asynccontextmanager
from
fastapi
import
FastAPI
def
fake_answer_to_everything_ml_model
(
x
:
float
):
return
x
*
42
ml_models
=
{}
@asynccontextmanager
async
def
lifespan
(
app
:
FastAPI
):
## Load the ML model
ml_models
[
"answer_to_everything"
]
=
fake_answer_to_everything_ml_model
yield
## Clean up the ML models and release the resources
ml_models
.
clear
()
app
=
FastAPI
(
lifespan
=
lifespan
)
@app
.
get
(
"/predict"
)
async
def
predict
(
x
:
float
):
result
=
ml_models
[
"answer_to_everything"
](
x
)
return
{
"result"
:
result
}
The first part of the function, before the
yield
, will be executed
before
the application starts.
And the part after the
yield
will be executed
after
the application has finished.
Async Context Manager
If you check, the function is decorated with an
@asynccontextmanager
.
That converts the function into something called an "
async context manager
".
Python 3.8+
from
contextlib
import
asynccontextmanager
from
fastapi
import
FastAPI
def
fake_answer_to_everything_ml_model
(
x
:
float
):
return
x
*
42
ml_models
=
{}
@asynccontextmanager
async
def
lifespan
(
app
:
FastAPI
):
## Load the ML model
ml_models
[
"answer_to_everything"
]
=
fake_answer_to_everything_ml_model
yield
## Clean up the ML models and release the resources
ml_models
.
clear
()
app
=
FastAPI
(
lifespan
=
lifespan
)
@app
.
get
(
"/predict"
)
async
def
predict
(
x
:
float
):
result
=
ml_models
[
"answer_to_everything"
](
x
)
return
{
"result"
:
result
}
A
context manager
in Python is something that you can use in a
with
statement, for example,
open()
can be used as a context manager:
with
open
(
"file.txt"
)
as
file
:
file
.
read
()
In recent versions of Python, there's also an
async context manager
. You would use it with
async with
:
async
with
lifespan
(
app
):
await
do_stuff
()
When you create a context manager or an async context manager like above, what it does is that, before entering the
with
block, it will execute the code before the
yield
, and after exiting the
with
block, it will execute the code after the
yield
.
In our code example above, we don't use it directly, but we pass it to FastAPI for it to use it.
The
lifespan
parameter of the
FastAPI
app takes an
async context manager
, so we can pass our new
lifespan
async context manager to it.
Python 3.8+
from
contextlib
import
asynccontextmanager
from
fastapi
import
FastAPI
def
fake_answer_to_everything_ml_model
(
x
:
float
):
return
x
*
42
ml_models
=
{}
@asynccontextmanager
async
def
lifespan
(
app
:
FastAPI
):
## Load the ML model
ml_models
[
"answer_to_everything"
]
=
fake_answer_to_everything_ml_model
yield
## Clean up the ML models and release the resources
ml_models
.
clear
()
app
=
FastAPI
(
lifespan
=
lifespan
)
@app
.
get
(
"/predict"
)
async
def
predict
(
x
:
float
):
result
=
ml_models
[
"answer_to_everything"
](
x
)
return
{
"result"
:
result
}
Alternative Events (deprecated)
Warning
The recommended way to handle the
startup
and
shutdown
is using the
lifespan
parameter of the
FastAPI
app as described above. If you provide a
lifespan
parameter,
startup
and
shutdown
event handlers will no longer be called. It's all
lifespan
or all events, not both.
You can probably skip this part.
There's an alternative way to define this logic to be executed during
startup
and during
shutdown
.
You can define event handlers (functions) that need to be executed before the application starts up, or when the application is shutting down.
These functions can be declared with
async def
or normal
def
.
startup
event
To add a function that should be run before the application starts, declare it with the event
"startup"
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
items
=
{}
@app
.
on_event
(
"startup"
)
async
def
startup_event
():
items
[
"foo"
]
=
{
"name"
:
"Fighters"
}
items
[
"bar"
]
=
{
"name"
:
"Tenders"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
str
):
return
items
[
item_id
]
In this case, the
startup
event handler function will initialize the items "database" (just a
dict
) with some values.
You can add more than one event handler function.
And your application won't start receiving requests until all the
startup
event handlers have completed.
shutdown
event
To add a function that should be run when the application is shutting down, declare it with the event
"shutdown"
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
on_event
(
"shutdown"
)
def
shutdown_event
():
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
"Application shutdown"
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
Here, the
shutdown
event handler function will write a text line
"Application shutdown"
to a file
log.txt
.
Info
In the
open()
function, the
mode="a"
means "append", so, the line will be added after whatever is on that file, without overwriting the previous contents.
Tip
Notice that in this case we are using a standard Python
open()
function that interacts with a file.
So, it involves I/O (input/output), that requires "waiting" for things to be written to disk.
But
open()
doesn't use
async
and
await
.
So, we declare the event handler function with standard
def
instead of
async def
.
startup
and
shutdown
together
There's a high chance that the logic for your
startup
and
shutdown
is connected, you might want to start something and then finish it, acquire a resource and then release it, etc.
Doing that in separated functions that don't share logic or variables together is more difficult as you would need to store values in global variables or similar tricks.
Because of that, it's now recommended to instead use the
lifespan
as explained above.
Technical Details
Just a technical detail for the curious nerds. ü§ì
Underneath, in the ASGI technical specification, this is part of the
Lifespan Protocol
, and it defines events called
startup
and
shutdown
.
Info
You can read more about the Starlette
lifespan
handlers in
Starlette's Lifespan' docs
.
Including how to handle lifespan state that can be used in other areas of your code.
Sub Applications
üö® Keep in mind that these lifespan events (startup and shutdown) will only be executed for the main application, not for
Sub Applications - Mounts
.

## 011_ADVANCED_GENERATE_CLIENTS
Generate Clients¬∂
---

Generate Clients
As
FastAPI
is based on the OpenAPI specification, you get automatic compatibility with many tools, including the automatic API docs (provided by Swagger UI).
One particular advantage that is not necessarily obvious is that you can
generate clients
(sometimes called
SDKs
) for your API, for many different
programming languages
.
OpenAPI Client Generators
There are many tools to generate clients from
OpenAPI
.
A common tool is
OpenAPI Generator
.
If you are building a
frontend
, a very interesting alternative is
openapi-ts
.
Client and SDK Generators - Sponsor
There are also some
company-backed
Client and SDK generators based on OpenAPI (FastAPI), in some cases they can offer you
additional features
on top of high-quality generated SDKs/clients.
Some of them also ‚ú®
sponsor FastAPI
‚ú®, this ensures the continued and healthy
development
of FastAPI and its
ecosystem
.
And it shows their true commitment to FastAPI and its
community
(you), as they not only want to provide you a
good service
but also want to make sure you have a
good and healthy framework
, FastAPI. üôá
For example, you might want to try:
Speakeasy
Stainless
liblab
There are also several other companies offering similar services that you can search and find online. ü§ì
Generate a TypeScript Frontend Client
Let's start with a simple FastAPI application:
Python 3.9+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
)
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"item received"
}
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
ü§ì Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
)
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"item received"
}
@app
.
get
(
"/items/"
,
response_model
=
List
[
Item
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
Notice that the
path operations
define the models they use for request payload and response payload, using the models
Item
and
ResponseMessage
.
API Docs
If you go to the API docs, you will see that it has the
schemas
for the data to be sent in requests and received in responses:
You can see those schemas because they were declared with the models in the app.
That information is available in the app's
OpenAPI schema
, and then shown in the API docs (by Swagger UI).
And that same information from the models that is included in OpenAPI is what can be used to
generate the client code
.
Generate a TypeScript Client
Now that we have the app with the models, we can generate the client code for the frontend.
Install
openapi-ts
You can install
openapi-ts
in your frontend code with:
fast ‚Üí
npm install @hey-api/openapi-ts --save-dev
restart ‚Üª
Generate Client Code
To generate the client code you can use the command line application
openapi-ts
that would now be installed.
Because it is installed in the local project, you probably wouldn't be able to call that command directly, but you would put it on your
package.json
file.
It could look like this:
{
"name"
:
"frontend-app"
,
"version"
:
"1.0.0"
,
"description"
:
""
,
"main"
:
"index.js"
,
"scripts"
:
{
"generate-client"
:
"openapi-ts --input http://localhost:8000/openapi.json --output ./src/client --client axios"
},
"author"
:
""
,
"license"
:
""
,
"devDependencies"
:
{
"@hey-api/openapi-ts"
:
"^0.27.38"
,
"typescript"
:
"^4.6.2"
}
}
After having that NPM
generate-client
script there, you can run it with:
fast ‚Üí
npm run generate-client
frontend-app@1.0.0 generate-client /home/user/code/frontend-app
> openapi-ts --input http://localhost:8000/openapi.json --output ./src/client --client axios
restart ‚Üª
That command will generate code in
./src/client
and will use
axios
(the frontend HTTP library) internally.
Try Out the Client Code
Now you can import and use the client code, it could look like this, notice that you get autocompletion for the methods:
You will also get autocompletion for the payload to send:
Tip
Notice the autocompletion for
name
and
price
, that was defined in the FastAPI application, in the
Item
model.
You will have inline errors for the data that you send:
The response object will also have autocompletion:
FastAPI App with Tags
In many cases your FastAPI app will be bigger, and you will probably use tags to separate different groups of
path operations
.
For example, you could have a section for
items
and another section for
users
, and they could be separated by tags:
Python 3.9+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
class
User
(
BaseModel
):
username
:
str
email
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item received"
}
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
],
tags
=
[
"items"
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
@app
.
post
(
"/users/"
,
response_model
=
ResponseMessage
,
tags
=
[
"users"
])
async
def
create_user
(
user
:
User
):
return
{
"message"
:
"User received"
}
ü§ì Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
class
User
(
BaseModel
):
username
:
str
email
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item received"
}
@app
.
get
(
"/items/"
,
response_model
=
List
[
Item
],
tags
=
[
"items"
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
@app
.
post
(
"/users/"
,
response_model
=
ResponseMessage
,
tags
=
[
"users"
])
async
def
create_user
(
user
:
User
):
return
{
"message"
:
"User received"
}
Generate a TypeScript Client with Tags
If you generate a client for a FastAPI app using tags, it will normally also separate the client code based on the tags.
This way you will be able to have things ordered and grouped correctly for the client code:
In this case you have:
ItemsService
UsersService
Client Method Names
Right now the generated method names like
createItemItemsPost
don't look very clean:
ItemsService
.
createItemItemsPost
({
name
:
"Plumbus"
,
price
:
5
})
...that's because the client generator uses the OpenAPI internal
operation ID
for each
path operation
.
OpenAPI requires that each operation ID is unique across all the
path operations
, so FastAPI uses the
function name
, the
path
, and the
HTTP method/operation
to generate that operation ID, because that way it can make sure that the operation IDs are unique.
But I'll show you how to improve that next. ü§ì
Custom Operation IDs and Better Method Names
You can
modify
the way these operation IDs are
generated
to make them simpler and have
simpler method names
in the clients.
In this case you will have to ensure that each operation ID is
unique
in some other way.
For example, you could make sure that each
path operation
has a tag, and then generate the operation ID based on the
tag
and the
path operation
name
(the function name).
Custom Generate Unique ID Function
FastAPI uses a
unique ID
for each
path operation
, it is used for the
operation ID
and also for the names of any needed custom models, for requests or responses.
You can customize that function. It takes an
APIRoute
and outputs a string.
For example, here it is using the first tag (you will probably have only one tag) and the
path operation
name (the function name).
You can then pass that custom function to
FastAPI
as the
generate_unique_id_function
parameter:
Python 3.9+
from
fastapi
import
FastAPI
from
fastapi.routing
import
APIRoute
from
pydantic
import
BaseModel
def
custom_generate_unique_id
(
route
:
APIRoute
):
return
f
"
{
route
.
tags
[
0
]
}
-
{
route
.
name
}
"
app
=
FastAPI
(
generate_unique_id_function
=
custom_generate_unique_id
)
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
class
User
(
BaseModel
):
username
:
str
email
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item received"
}
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
],
tags
=
[
"items"
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
@app
.
post
(
"/users/"
,
response_model
=
ResponseMessage
,
tags
=
[
"users"
])
async
def
create_user
(
user
:
User
):
return
{
"message"
:
"User received"
}
ü§ì Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
from
fastapi.routing
import
APIRoute
from
pydantic
import
BaseModel
def
custom_generate_unique_id
(
route
:
APIRoute
):
return
f
"
{
route
.
tags
[
0
]
}
-
{
route
.
name
}
"
app
=
FastAPI
(
generate_unique_id_function
=
custom_generate_unique_id
)
class
Item
(
BaseModel
):
name
:
str
price
:
float
class
ResponseMessage
(
BaseModel
):
message
:
str
class
User
(
BaseModel
):
username
:
str
email
:
str
@app
.
post
(
"/items/"
,
response_model
=
ResponseMessage
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item received"
}
@app
.
get
(
"/items/"
,
response_model
=
List
[
Item
],
tags
=
[
"items"
])
async
def
get_items
():
return
[
{
"name"
:
"Plumbus"
,
"price"
:
3
},
{
"name"
:
"Portal Gun"
,
"price"
:
9001
},
]
@app
.
post
(
"/users/"
,
response_model
=
ResponseMessage
,
tags
=
[
"users"
])
async
def
create_user
(
user
:
User
):
return
{
"message"
:
"User received"
}
Generate a TypeScript Client with Custom Operation IDs
Now if you generate the client again, you will see that it has the improved method names:
As you see, the method names now have the tag and then the function name, now they don't include information from the URL path and the HTTP operation.
Preprocess the OpenAPI Specification for the Client Generator
The generated code still has some
duplicated information
.
We already know that this method is related to the
items
because that word is in the
ItemsService
(taken from the tag), but we still have the tag name prefixed in the method name too. üòï
We will probably still want to keep it for OpenAPI in general, as that will ensure that the operation IDs are
unique
.
But for the generated client we could
modify
the OpenAPI operation IDs right before generating the clients, just to make those method names nicer and
cleaner
.
We could download the OpenAPI JSON to a file
openapi.json
and then we could
remove that prefixed tag
with a script like this:
Python 3.8+
Node.js
import
json
from
pathlib
import
Path
file_path
=
Path
(
"./openapi.json"
)
openapi_content
=
json
.
loads
(
file_path
.
read_text
())
for
path_data
in
openapi_content
[
"paths"
]
.
values
():
for
operation
in
path_data
.
values
():
tag
=
operation
[
"tags"
][
0
]
operation_id
=
operation
[
"operationId"
]
to_remove
=
f
"
{
tag
}
-"
new_operation_id
=
operation_id
[
len
(
to_remove
)
:]
operation
[
"operationId"
]
=
new_operation_id
file_path
.
write_text
(
json
.
dumps
(
openapi_content
))
import
*
as
fs
from
'fs'
async
function
modifyOpenAPIFile
(
filePath
)
{
try
{
const
data
=
await
fs
.
promises
.
readFile
(
filePath
)
const
openapiContent
=
JSON
.
parse
(
data
)
const
paths
=
openapiContent
.
paths
for
(
const
pathKey
of
Object
.
keys
(
paths
))
{
const
pathData
=
paths
[
pathKey
]
for
(
const
method
of
Object
.
keys
(
pathData
))
{
const
operation
=
pathData
[
method
]
if
(
operation
.
tags
&&
operation
.
tags
.
length
>
0
)
{
const
tag
=
operation
.
tags
[
0
]
const
operationId
=
operation
.
operationId
const
toRemove
=
`
${
tag
}
-`
if
(
operationId
.
startsWith
(
toRemove
))
{
const
newOperationId
=
operationId
.
substring
(
toRemove
.
length
)
operation
.
operationId
=
newOperationId
}
}
}
}
await
fs
.
promises
.
writeFile
(
filePath
,
JSON
.
stringify
(
openapiContent
,
null
,
2
),
)
console
.
log
(
'File successfully modified'
)
}
catch
(
err
)
{
console
.
error
(
'Error:'
,
err
)
}
}
const
filePath
=
'./openapi.json'
modifyOpenAPIFile
(
filePath
)
With that, the operation IDs would be renamed from things like
items-get_items
to just
get_items
, that way the client generator can generate simpler method names.
Generate a TypeScript Client with the Preprocessed OpenAPI
Now as the end result is in a file
openapi.json
, you would modify the
package.json
to use that local file, for example:
{
"name"
:
"frontend-app"
,
"version"
:
"1.0.0"
,
"description"
:
""
,
"main"
:
"index.js"
,
"scripts"
:
{
"generate-client"
:
"openapi-ts --input ./openapi.json --output ./src/client --client axios"
},
"author"
:
""
,
"license"
:
""
,
"devDependencies"
:
{
"@hey-api/openapi-ts"
:
"^0.27.38"
,
"typescript"
:
"^4.6.2"
}
}
After generating the new client, you would now have
clean method names
, with all the
autocompletion
,
inline errors
, etc:
Benefits
When using the automatically generated clients you would get
autocompletion
for:
Methods.
Request payloads in the body, query parameters, etc.
Response payloads.
You would also have
inline errors
for everything.
And whenever you update the backend code, and
regenerate
the frontend, it would have any new
path operations
available as methods, the old ones removed, and any other change would be reflected on the generated code. ü§ì
This also means that if something changed it will be
reflected
on the client code automatically. And if you
build
the client it will error out if you have any
mismatch
in the data used.
So, you would
detect many errors
very early in the development cycle instead of having to wait for the errors to show up to your final users in production and then trying to debug where the problem is. ‚ú®

## 012_ADVANCED_MIDDLEWARE
Advanced Middleware¬∂
---

Advanced Middleware
In the main tutorial you read how to add
Custom Middleware
to your application.
And then you also read how to handle
CORS with the
CORSMiddleware
.
In this section we'll see how to use other middlewares.
Adding ASGI middlewares
As
FastAPI
is based on Starlette and implements the
ASGI
specification, you can use any ASGI middleware.
A middleware doesn't have to be made for FastAPI or Starlette to work, as long as it follows the ASGI spec.
In general, ASGI middlewares are classes that expect to receive an ASGI app as the first argument.
So, in the documentation for third-party ASGI middlewares they will probably tell you to do something like:
from
unicorn
import
UnicornMiddleware
app
=
SomeASGIApp
()
new_app
=
UnicornMiddleware
(
app
,
some_config
=
"rainbow"
)
But FastAPI (actually Starlette) provides a simpler way to do it that makes sure that the internal middlewares handle server errors and custom exception handlers work properly.
For that, you use
app.add_middleware()
(as in the example for CORS).
from
fastapi
import
FastAPI
from
unicorn
import
UnicornMiddleware
app
=
FastAPI
()
app
.
add_middleware
(
UnicornMiddleware
,
some_config
=
"rainbow"
)
app.add_middleware()
receives a middleware class as the first argument and any additional arguments to be passed to the middleware.
Integrated middlewares
FastAPI
includes several middlewares for common use cases, we'll see next how to use them.
Technical Details
For the next examples, you could also use
from starlette.middleware.something import SomethingMiddleware
.
FastAPI
provides several middlewares in
fastapi.middleware
just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette.
HTTPSRedirectMiddleware
Enforces that all incoming requests must either be
https
or
wss
.
Any incoming request to
http
or
ws
will be redirected to the secure scheme instead.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.middleware.httpsredirect
import
HTTPSRedirectMiddleware
app
=
FastAPI
()
app
.
add_middleware
(
HTTPSRedirectMiddleware
)
@app
.
get
(
"/"
)
async
def
main
():
return
{
"message"
:
"Hello World"
}
TrustedHostMiddleware
Enforces that all incoming requests have a correctly set
Host
header, in order to guard against HTTP Host Header attacks.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.middleware.trustedhost
import
TrustedHostMiddleware
app
=
FastAPI
()
app
.
add_middleware
(
TrustedHostMiddleware
,
allowed_hosts
=
[
"example.com"
,
"*.example.com"
]
)
@app
.
get
(
"/"
)
async
def
main
():
return
{
"message"
:
"Hello World"
}
The following arguments are supported:
allowed_hosts
- A list of domain names that should be allowed as hostnames. Wildcard domains such as
*.example.com
are supported for matching subdomains. To allow any hostname either use
allowed_hosts=["*"]
or omit the middleware.
If an incoming request does not validate correctly then a
400
response will be sent.
GZipMiddleware
Handles GZip responses for any request that includes
"gzip"
in the
Accept-Encoding
header.
The middleware will handle both standard and streaming responses.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.middleware.gzip
import
GZipMiddleware
app
=
FastAPI
()
app
.
add_middleware
(
GZipMiddleware
,
minimum_size
=
1000
,
compresslevel
=
5
)
@app
.
get
(
"/"
)
async
def
main
():
return
"somebigcontent"
The following arguments are supported:
minimum_size
- Do not GZip responses that are smaller than this minimum size in bytes. Defaults to
500
.
compresslevel
- Used during GZip compression. It is an integer ranging from 1 to 9. Defaults to
9
. Lower value results in faster compression but larger file sizes, while higher value results in slower compression but smaller file sizes.
Other middlewares
There are many other ASGI middlewares.
For example:
Uvicorn's
ProxyHeadersMiddleware
MessagePack
To see other available middlewares check
Starlette's Middleware docs
and the
ASGI Awesome List
.

## 013_ADVANCED_OPENAPI_CALLBACKS
OpenAPI Callbacks¬∂
---

OpenAPI Callbacks
You could create an API with a
path operation
that could trigger a request to an
external API
created by someone else (probably the same developer that would be
using
your API).
The process that happens when your API app calls the
external API
is named a "callback". Because the software that the external developer wrote sends a request to your API and then your API
calls back
, sending a request to an
external API
(that was probably created by the same developer).
In this case, you could want to document how that external API
should
look like. What
path operation
it should have, what body it should expect, what response it should return, etc.
An app with callbacks
Let's see all this with an example.
Imagine you develop an app that allows creating invoices.
These invoices will have an
id
,
title
(optional),
customer
, and
total
.
The user of your API (an external developer) will create an invoice in your API with a POST request.
Then your API will (let's imagine):
Send the invoice to some customer of the external developer.
Collect the money.
Send a notification back to the API user (the external developer).
This will be done by sending a POST request (from
your API
) to some
external API
provided by that external developer (this is the "callback").
The normal
FastAPI
app
Let's first see how the normal API app would look like before adding the callback.
It will have a
path operation
that will receive an
Invoice
body, and a query parameter
callback_url
that will contain the URL for the callback.
This part is pretty normal, most of the code is probably already familiar to you:
Python 3.8+
from
typing
import
Union
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Invoice
(
BaseModel
):
id
:
str
title
:
Union
[
str
,
None
]
=
None
customer
:
str
total
:
float
class
InvoiceEvent
(
BaseModel
):
description
:
str
paid
:
bool
class
InvoiceEventReceived
(
BaseModel
):
ok
:
bool
invoices_callback_router
=
APIRouter
()
@invoices_callback_router
.
post
(
"{$callback_url}/invoices/{$request.body.id}"
,
response_model
=
InvoiceEventReceived
)
def
invoice_notification
(
body
:
InvoiceEvent
):
pass
@app
.
post
(
"/invoices/"
,
callbacks
=
invoices_callback_router
.
routes
)
def
create_invoice
(
invoice
:
Invoice
,
callback_url
:
Union
[
HttpUrl
,
None
]
=
None
):
"""
Create an invoice.
This will (let's imagine) let the API user (some external developer) create an
invoice.
And this path operation will:
* Send the invoice to the client.
* Collect the money from the client.
* Send a notification back to the API user (the external developer), as a callback.
* At this point is that the API will somehow send a POST request to the
external API with the notification of the invoice event
(e.g. "payment successful").
"""
## Send the invoice, collect the money, send the notification (the callback)
return
{
"msg"
:
"Invoice received"
}
Tip
The
callback_url
query parameter uses a Pydantic
Url
type.
The only new thing is the
callbacks=invoices_callback_router.routes
as an argument to the
path operation decorator
. We'll see what that is next.
Documenting the callback
The actual callback code will depend heavily on your own API app.
And it will probably vary a lot from one app to the next.
It could be just one or two lines of code, like:
callback_url
=
"https://example.com/api/v1/invoices/events/"
httpx
.
post
(
callback_url
,
json
=
{
"description"
:
"Invoice paid"
,
"paid"
:
True
})
But possibly the most important part of the callback is making sure that your API user (the external developer) implements the
external API
correctly, according to the data that
your API
is going to send in the request body of the callback, etc.
So, what we will do next is add the code to document how that
external API
should look like to receive the callback from
your API
.
That documentation will show up in the Swagger UI at
/docs
in your API, and it will let external developers know how to build the
external API
.
This example doesn't implement the callback itself (that could be just a line of code), only the documentation part.
Tip
The actual callback is just an HTTP request.
When implementing the callback yourself, you could use something like
HTTPX
or
Requests
.
Write the callback documentation code
This code won't be executed in your app, we only need it to
document
how that
external API
should look like.
But, you already know how to easily create automatic documentation for an API with
FastAPI
.
So we are going to use that same knowledge to document how the
external API
should look like... by creating the
path operation(s)
that the external API should implement (the ones your API will call).
Tip
When writing the code to document a callback, it might be useful to imagine that you are that
external developer
. And that you are currently implementing the
external API
, not
your API
.
Temporarily adopting this point of view (of the
external developer
) can help you feel like it's more obvious where to put the parameters, the Pydantic model for the body, for the response, etc. for that
external API
.
Create a callback
APIRouter
First create a new
APIRouter
that will contain one or more callbacks.
Python 3.8+
from
typing
import
Union
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Invoice
(
BaseModel
):
id
:
str
title
:
Union
[
str
,
None
]
=
None
customer
:
str
total
:
float
class
InvoiceEvent
(
BaseModel
):
description
:
str
paid
:
bool
class
InvoiceEventReceived
(
BaseModel
):
ok
:
bool
invoices_callback_router
=
APIRouter
()
@invoices_callback_router
.
post
(
"{$callback_url}/invoices/{$request.body.id}"
,
response_model
=
InvoiceEventReceived
)
def
invoice_notification
(
body
:
InvoiceEvent
):
pass
@app
.
post
(
"/invoices/"
,
callbacks
=
invoices_callback_router
.
routes
)
def
create_invoice
(
invoice
:
Invoice
,
callback_url
:
Union
[
HttpUrl
,
None
]
=
None
):
"""
Create an invoice.
This will (let's imagine) let the API user (some external developer) create an
invoice.
And this path operation will:
* Send the invoice to the client.
* Collect the money from the client.
* Send a notification back to the API user (the external developer), as a callback.
* At this point is that the API will somehow send a POST request to the
external API with the notification of the invoice event
(e.g. "payment successful").
"""
## Send the invoice, collect the money, send the notification (the callback)
return
{
"msg"
:
"Invoice received"
}
Create the callback
path operation
To create the callback
path operation
use the same
APIRouter
you created above.
It should look just like a normal FastAPI
path operation
:
It should probably have a declaration of the body it should receive, e.g.
body: InvoiceEvent
.
And it could also have a declaration of the response it should return, e.g.
response_model=InvoiceEventReceived
.
Python 3.8+
from
typing
import
Union
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Invoice
(
BaseModel
):
id
:
str
title
:
Union
[
str
,
None
]
=
None
customer
:
str
total
:
float
class
InvoiceEvent
(
BaseModel
):
description
:
str
paid
:
bool
class
InvoiceEventReceived
(
BaseModel
):
ok
:
bool
invoices_callback_router
=
APIRouter
()
@invoices_callback_router
.
post
(
"{$callback_url}/invoices/{$request.body.id}"
,
response_model
=
InvoiceEventReceived
)
def
invoice_notification
(
body
:
InvoiceEvent
):
pass
@app
.
post
(
"/invoices/"
,
callbacks
=
invoices_callback_router
.
routes
)
def
create_invoice
(
invoice
:
Invoice
,
callback_url
:
Union
[
HttpUrl
,
None
]
=
None
):
"""
Create an invoice.
This will (let's imagine) let the API user (some external developer) create an
invoice.
And this path operation will:
* Send the invoice to the client.
* Collect the money from the client.
* Send a notification back to the API user (the external developer), as a callback.
* At this point is that the API will somehow send a POST request to the
external API with the notification of the invoice event
(e.g. "payment successful").
"""
## Send the invoice, collect the money, send the notification (the callback)
return
{
"msg"
:
"Invoice received"
}
There are 2 main differences from a normal
path operation
:
It doesn't need to have any actual code, because your app will never call this code. It's only used to document the
external API
. So, the function could just have
pass
.
The
path
can contain an
OpenAPI 3 expression
(see more below) where it can use variables with parameters and parts of the original request sent to
your API
.
The callback path expression
The callback
path
can have an
OpenAPI 3 expression
that can contain parts of the original request sent to
your API
.
In this case, it's the
str
:
"{$callback_url}/invoices/{$request.body.id}"
So, if your API user (the external developer) sends a request to
your API
to:
https://yourapi.com/invoices/?callback_url=https://www.external.org/events
with a JSON body of:
{
"id"
:
"2expen51ve"
,
"customer"
:
"Mr. Richie Rich"
,
"total"
:
"9999"
}
then
your API
will process the invoice, and at some point later, send a callback request to the
callback_url
(the
external API
):
https://www.external.org/events/invoices/2expen51ve
with a JSON body containing something like:
{
"description"
:
"Payment celebration"
,
"paid"
:
true
}
and it would expect a response from that
external API
with a JSON body like:
{
"ok"
:
true
}
Tip
Notice how the callback URL used contains the URL received as a query parameter in
callback_url
(
https://www.external.org/events
) and also the invoice
id
from inside of the JSON body (
2expen51ve
).
Add the callback router
At this point you have the
callback path operation(s)
needed (the one(s) that the
external developer
should implement in the
external API
) in the callback router you created above.
Now use the parameter
callbacks
in
your API's path operation decorator
to pass the attribute
.routes
(that's actually just a
list
of routes/
path operations
) from that callback router:
Python 3.8+
from
typing
import
Union
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Invoice
(
BaseModel
):
id
:
str
title
:
Union
[
str
,
None
]
=
None
customer
:
str
total
:
float
class
InvoiceEvent
(
BaseModel
):
description
:
str
paid
:
bool
class
InvoiceEventReceived
(
BaseModel
):
ok
:
bool
invoices_callback_router
=
APIRouter
()
@invoices_callback_router
.
post
(
"{$callback_url}/invoices/{$request.body.id}"
,
response_model
=
InvoiceEventReceived
)
def
invoice_notification
(
body
:
InvoiceEvent
):
pass
@app
.
post
(
"/invoices/"
,
callbacks
=
invoices_callback_router
.
routes
)
def
create_invoice
(
invoice
:
Invoice
,
callback_url
:
Union
[
HttpUrl
,
None
]
=
None
):
"""
Create an invoice.
This will (let's imagine) let the API user (some external developer) create an
invoice.
And this path operation will:
* Send the invoice to the client.
* Collect the money from the client.
* Send a notification back to the API user (the external developer), as a callback.
* At this point is that the API will somehow send a POST request to the
external API with the notification of the invoice event
(e.g. "payment successful").
"""
## Send the invoice, collect the money, send the notification (the callback)
return
{
"msg"
:
"Invoice received"
}
Tip
Notice that you are not passing the router itself (
invoices_callback_router
) to
callback=
, but the attribute
.routes
, as in
invoices_callback_router.routes
.
Check the docs
Now you can start your app and go to
http://127.0.0.1:8000/docs
.
You will see your docs including a "Callbacks" section for your
path operation
that shows how the
external API
should look like:

## 014_ADVANCED_OPENAPI_WEBHOOKS
OpenAPI Webhooks¬∂
---

OpenAPI Webhooks
There are cases where you want to tell your API
users
that your app could call
their
app (sending a request) with some data, normally to
notify
of some type of
event
.
This means that instead of the normal process of your users sending requests to your API, it's
your API
(or your app) that could
send requests to their system
(to their API, their app).
This is normally called a
webhook
.
Webhooks steps
The process normally is that
you define
in your code what is the message that you will send, the
body of the request
.
You also define in some way at which
moments
your app will send those requests or events.
And
your users
define in some way (for example in a web dashboard somewhere) the
URL
where your app should send those requests.
All the
logic
about how to register the URLs for webhooks and the code to actually send those requests is up to you. You write it however you want to in
your own code
.
Documenting webhooks with
FastAPI
and OpenAPI
With
FastAPI
, using OpenAPI, you can define the names of these webhooks, the types of HTTP operations that your app can send (e.g.
POST
,
PUT
, etc.) and the request
bodies
that your app would send.
This can make it a lot easier for your users to
implement their APIs
to receive your
webhook
requests, they might even be able to autogenerate some of their own API code.
Info
Webhooks are available in OpenAPI 3.1.0 and above, supported by FastAPI
0.99.0
and above.
An app with webhooks
When you create a
FastAPI
application, there is a
webhooks
attribute that you can use to define
webhooks
, the same way you would define
path operations
, for example with
@app.webhooks.post()
.
Python 3.8+
from
datetime
import
datetime
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Subscription
(
BaseModel
):
username
:
str
monthly_fee
:
float
start_date
:
datetime
@app
.
webhooks
.
post
(
"new-subscription"
)
def
new_subscription
(
body
:
Subscription
):
"""
When a new user subscribes to your service we'll send you a POST request with this
data to the URL that you register for the event `new-subscription` in the dashboard.
"""
@app
.
get
(
"/users/"
)
def
read_users
():
return
[
"Rick"
,
"Morty"
]
The webhooks that you define will end up in the
OpenAPI
schema and the automatic
docs UI
.
Info
The
app.webhooks
object is actually just an
APIRouter
, the same type you would use when structuring your app with multiple files.
Notice that with webhooks you are actually not declaring a
path
(like
/items/
), the text you pass there is just an
identifier
of the webhook (the name of the event), for example in
@app.webhooks.post("new-subscription")
, the webhook name is
new-subscription
.
This is because it is expected that
your users
would define the actual
URL path
where they want to receive the webhook request in some other way (e.g. a web dashboard).
Check the docs
Now you can start your app and go to
http://127.0.0.1:8000/docs
.
You will see your docs have the normal
path operations
and now also some
webhooks
:

## 015_ADVANCED_PATH_OPERATION_ADVANCED_CONFIGURATION
Path Operation Advanced Configuration¬∂
---

Path Operation Advanced Configuration
OpenAPI operationId
Warning
If you are not an "expert" in OpenAPI, you probably don't need this.
You can set the OpenAPI
operationId
to be used in your
path operation
with the parameter
operation_id
.
You would have to make sure that it is unique for each operation.
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
operation_id
=
"some_specific_id_you_define"
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
Using the
path operation function
name as the operationId
If you want to use your APIs' function names as
operationId
s, you can iterate over all of them and override each
path operation's
operation_id
using their
APIRoute.name
.
You should do it after adding all your
path operations
.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.routing
import
APIRoute
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
def
use_route_names_as_operation_ids
(
app
:
FastAPI
)
->
None
:
"""
Simplify operation IDs so that generated API clients have simpler function
names.
Should be called only after all routes have been added.
"""
for
route
in
app
.
routes
:
if
isinstance
(
route
,
APIRoute
):
route
.
operation_id
=
route
.
name
## in this case, 'read_items'
use_route_names_as_operation_ids
(
app
)
Tip
If you manually call
app.openapi()
, you should update the
operationId
s before that.
Warning
If you do this, you have to make sure each one of your
path operation functions
has a unique name.
Even if they are in different modules (Python files).
Exclude from OpenAPI
To exclude a
path operation
from the generated OpenAPI schema (and thus, from the automatic documentation systems), use the parameter
include_in_schema
and set it to
False
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
include_in_schema
=
False
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
Advanced description from docstring
You can limit the lines used from the docstring of a
path operation function
for OpenAPI.
Adding an
\f
(an escaped "form feed" character) causes
FastAPI
to truncate the output used for OpenAPI at this point.
It won't show up in the documentation, but other tools (such as Sphinx) will be able to use the rest.
Python 3.8+
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
\f
:param item: User input.
"""
return
item
Additional Responses
You probably have seen how to declare the
response_model
and
status_code
for a
path operation
.
That defines the metadata about the main response of a
path operation
.
You can also declare additional responses with their models, status codes, etc.
There's a whole chapter here in the documentation about it, you can read it at
Additional Responses in OpenAPI
.
OpenAPI Extra
When you declare a
path operation
in your application,
FastAPI
automatically generates the relevant metadata about that
path operation
to be included in the OpenAPI schema.
Technical details
In the OpenAPI specification it is called the
Operation Object
.
It has all the information about the
path operation
and is used to generate the automatic documentation.
It includes the
tags
,
parameters
,
requestBody
,
responses
, etc.
This
path operation
-specific OpenAPI schema is normally generated automatically by
FastAPI
, but you can also extend it.
Tip
This is a low level extension point.
If you only need to declare additional responses, a more convenient way to do it is with
Additional Responses in OpenAPI
.
You can extend the OpenAPI schema for a
path operation
using the parameter
openapi_extra
.
OpenAPI Extensions
This
openapi_extra
can be helpful, for example, to declare
OpenAPI Extensions
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
openapi_extra
=
{
"x-aperture-labs-portal"
:
"blue"
})
async
def
read_items
():
return
[{
"item_id"
:
"portal-gun"
}]
If you open the automatic API docs, your extension will show up at the bottom of the specific
path operation
.
And if you see the resulting OpenAPI (at
/openapi.json
in your API), you will see your extension as part of the specific
path operation
too:
{
"openapi"
:
"3.1.0"
,
"info"
:
{
"title"
:
"FastAPI"
,
"version"
:
"0.1.0"
},
"paths"
:
{
"/items/"
:
{
"get"
:
{
"summary"
:
"Read Items"
,
"operationId"
:
"read_items_items__get"
,
"responses"
:
{
"200"
:
{
"description"
:
"Successful Response"
,
"content"
:
{
"application/json"
:
{
"schema"
:
{}
}
}
}
},
"x-aperture-labs-portal"
:
"blue"
}
}
}
}
Custom OpenAPI
path operation
schema
The dictionary in
openapi_extra
will be deeply merged with the automatically generated OpenAPI schema for the
path operation
.
So, you could add additional data to the automatically generated schema.
For example, you could decide to read and validate the request with your own code, without using the automatic features of FastAPI with Pydantic, but you could still want to define the request in the OpenAPI schema.
You could do that with
openapi_extra
:
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
def
magic_data_reader
(
raw_body
:
bytes
):
return
{
"size"
:
len
(
raw_body
),
"content"
:
{
"name"
:
"Maaaagic"
,
"price"
:
42
,
"description"
:
"Just kiddin', no magic here. ‚ú®"
,
},
}
@app
.
post
(
"/items/"
,
openapi_extra
=
{
"requestBody"
:
{
"content"
:
{
"application/json"
:
{
"schema"
:
{
"required"
:
[
"name"
,
"price"
],
"type"
:
"object"
,
"properties"
:
{
"name"
:
{
"type"
:
"string"
},
"price"
:
{
"type"
:
"number"
},
"description"
:
{
"type"
:
"string"
},
},
}
}
},
"required"
:
True
,
},
},
)
async
def
create_item
(
request
:
Request
):
raw_body
=
await
request
.
body
()
data
=
magic_data_reader
(
raw_body
)
return
data
In this example, we didn't declare any Pydantic model. In fact, the request body is not even
parsed
as JSON, it is read directly as
bytes
, and the function
magic_data_reader()
would be in charge of parsing it in some way.
Nevertheless, we can declare the expected schema for the request body.
Custom OpenAPI content type
Using this same trick, you could use a Pydantic model to define the JSON Schema that is then included in the custom OpenAPI schema section for the
path operation
.
And you could do this even if the data type in the request is not JSON.
For example, in this application we don't use FastAPI's integrated functionality to extract the JSON Schema from Pydantic models nor the automatic validation for JSON. In fact, we are declaring the request content type as YAML, not JSON:
Pydantic v2
Pydantic v1
Python 3.8+
from
typing
import
List
import
yaml
from
fastapi
import
FastAPI
,
HTTPException
,
Request
from
pydantic
import
BaseModel
,
ValidationError
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
tags
:
List
[
str
]
@app
.
post
(
"/items/"
,
openapi_extra
=
{
"requestBody"
:
{
"content"
:
{
"application/x-yaml"
:
{
"schema"
:
Item
.
model_json_schema
()}},
"required"
:
True
,
},
},
)
async
def
create_item
(
request
:
Request
):
raw_body
=
await
request
.
body
()
try
:
data
=
yaml
.
safe_load
(
raw_body
)
except
yaml
.
YAMLError
:
raise
HTTPException
(
status_code
=
422
,
detail
=
"Invalid YAML"
)
try
:
item
=
Item
.
model_validate
(
data
)
except
ValidationError
as
e
:
raise
HTTPException
(
status_code
=
422
,
detail
=
e
.
errors
(
include_url
=
False
))
return
item
Python 3.8+
from
typing
import
List
import
yaml
from
fastapi
import
FastAPI
,
HTTPException
,
Request
from
pydantic
import
BaseModel
,
ValidationError
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
tags
:
List
[
str
]
@app
.
post
(
"/items/"
,
openapi_extra
=
{
"requestBody"
:
{
"content"
:
{
"application/x-yaml"
:
{
"schema"
:
Item
.
schema
()}},
"required"
:
True
,
},
},
)
async
def
create_item
(
request
:
Request
):
raw_body
=
await
request
.
body
()
try
:
data
=
yaml
.
safe_load
(
raw_body
)
except
yaml
.
YAMLError
:
raise
HTTPException
(
status_code
=
422
,
detail
=
"Invalid YAML"
)
try
:
item
=
Item
.
parse_obj
(
data
)
except
ValidationError
as
e
:
raise
HTTPException
(
status_code
=
422
,
detail
=
e
.
errors
())
return
item
Info
In Pydantic version 1 the method to get the JSON Schema for a model was called
Item.schema()
, in Pydantic version 2, the method is called
Item.model_json_schema()
.
Nevertheless, although we are not using the default integrated functionality, we are still using a Pydantic model to manually generate the JSON Schema for the data that we want to receive in YAML.
Then we use the request directly, and extract the body as
bytes
. This means that FastAPI won't even try to parse the request payload as JSON.
And then in our code, we parse that YAML content directly, and then we are again using the same Pydantic model to validate the YAML content:
Pydantic v2
Pydantic v1
Python 3.8+
from
typing
import
List
import
yaml
from
fastapi
import
FastAPI
,
HTTPException
,
Request
from
pydantic
import
BaseModel
,
ValidationError
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
tags
:
List
[
str
]
@app
.
post
(
"/items/"
,
openapi_extra
=
{
"requestBody"
:
{
"content"
:
{
"application/x-yaml"
:
{
"schema"
:
Item
.
model_json_schema
()}},
"required"
:
True
,
},
},
)
async
def
create_item
(
request
:
Request
):
raw_body
=
await
request
.
body
()
try
:
data
=
yaml
.
safe_load
(
raw_body
)
except
yaml
.
YAMLError
:
raise
HTTPException
(
status_code
=
422
,
detail
=
"Invalid YAML"
)
try
:
item
=
Item
.
model_validate
(
data
)
except
ValidationError
as
e
:
raise
HTTPException
(
status_code
=
422
,
detail
=
e
.
errors
(
include_url
=
False
))
return
item
Python 3.8+
from
typing
import
List
import
yaml
from
fastapi
import
FastAPI
,
HTTPException
,
Request
from
pydantic
import
BaseModel
,
ValidationError
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
tags
:
List
[
str
]
@app
.
post
(
"/items/"
,
openapi_extra
=
{
"requestBody"
:
{
"content"
:
{
"application/x-yaml"
:
{
"schema"
:
Item
.
schema
()}},
"required"
:
True
,
},
},
)
async
def
create_item
(
request
:
Request
):
raw_body
=
await
request
.
body
()
try
:
data
=
yaml
.
safe_load
(
raw_body
)
except
yaml
.
YAMLError
:
raise
HTTPException
(
status_code
=
422
,
detail
=
"Invalid YAML"
)
try
:
item
=
Item
.
parse_obj
(
data
)
except
ValidationError
as
e
:
raise
HTTPException
(
status_code
=
422
,
detail
=
e
.
errors
())
return
item
Info
In Pydantic version 1 the method to parse and validate an object was
Item.parse_obj()
, in Pydantic version 2, the method is called
Item.model_validate()
.
Tip
Here we reuse the same Pydantic model.
But the same way, we could have validated it in some other way.

## 016_ADVANCED_RESPONSE_CHANGE_STATUS_CODE
Response - Change Status Code¬∂
---

Response - Change Status Code
You probably read before that you can set a default
Response Status Code
.
But in some cases you need to return a different status code than the default.
Use case
For example, imagine that you want to return an HTTP status code of "OK"
200
by default.
But if the data didn't exist, you want to create it, and return an HTTP status code of "CREATED"
201
.
But you still want to be able to filter and convert the data you return with a
response_model
.
For those cases, you can use a
Response
parameter.
Use a
Response
parameter
You can declare a parameter of type
Response
in your
path operation function
(as you can do for cookies and headers).
And then you can set the
status_code
in that
temporal
response object.
Python 3.8+
from
fastapi
import
FastAPI
,
Response
,
status
app
=
FastAPI
()
tasks
=
{
"foo"
:
"Listen to the Bar Fighters"
}
@app
.
put
(
"/get-or-create-task/
{task_id}
"
,
status_code
=
200
)
def
get_or_create_task
(
task_id
:
str
,
response
:
Response
):
if
task_id
not
in
tasks
:
tasks
[
task_id
]
=
"This didn't exist before"
response
.
status_code
=
status
.
HTTP_201_CREATED
return
tasks
[
task_id
]
And then you can return any object you need, as you normally would (a
dict
, a database model, etc).
And if you declared a
response_model
, it will still be used to filter and convert the object you returned.
FastAPI
will use that
temporal
response to extract the status code (also cookies and headers), and will put them in the final response that contains the value you returned, filtered by any
response_model
.
You can also declare the
Response
parameter in dependencies, and set the status code in them. But keep in mind that the last one to be set will win.

## 017_ADVANCED_RESPONSE_COOKIES
Response Cookies¬∂
---

Response Cookies
Use a
Response
parameter
You can declare a parameter of type
Response
in your
path operation function
.
And then you can set cookies in that
temporal
response object.
Python 3.8+
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
@app
.
post
(
"/cookie-and-object/"
)
def
create_cookie
(
response
:
Response
):
response
.
set_cookie
(
key
=
"fakesession"
,
value
=
"fake-cookie-session-value"
)
return
{
"message"
:
"Come to the dark side, we have cookies"
}
And then you can return any object you need, as you normally would (a
dict
, a database model, etc).
And if you declared a
response_model
, it will still be used to filter and convert the object you returned.
FastAPI
will use that
temporal
response to extract the cookies (also headers and status code), and will put them in the final response that contains the value you returned, filtered by any
response_model
.
You can also declare the
Response
parameter in dependencies, and set cookies (and headers) in them.
Return a
Response
directly
You can also create cookies when returning a
Response
directly in your code.
To do that, you can create a response as described in
Return a Response Directly
.
Then set Cookies in it, and then return it:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
@app
.
post
(
"/cookie/"
)
def
create_cookie
():
content
=
{
"message"
:
"Come to the dark side, we have cookies"
}
response
=
JSONResponse
(
content
=
content
)
response
.
set_cookie
(
key
=
"fakesession"
,
value
=
"fake-cookie-session-value"
)
return
response
Tip
Keep in mind that if you return a response directly instead of using the
Response
parameter, FastAPI will return it directly.
So, you will have to make sure your data is of the correct type. E.g. it is compatible with JSON, if you are returning a
JSONResponse
.
And also that you are not sending any data that should have been filtered by a
response_model
.
More info
Technical Details
You could also use
from starlette.responses import Response
or
from starlette.responses import JSONResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
And as the
Response
can be used frequently to set headers and cookies,
FastAPI
also provides it at
fastapi.Response
.
To see all the available parameters and options, check the
documentation in Starlette
.

## 018_ADVANCED_RESPONSE_DIRECTLY
Return a Response Directly¬∂
---

Return a Response Directly
When you create a
FastAPI
path operation
you can normally return any data from it: a
dict
, a
list
, a Pydantic model, a database model, etc.
By default,
FastAPI
would automatically convert that return value to JSON using the
jsonable_encoder
explained in
JSON Compatible Encoder
.
Then, behind the scenes, it would put that JSON-compatible data (e.g. a
dict
) inside of a
JSONResponse
that would be used to send the response to the client.
But you can return a
JSONResponse
directly from your
path operations
.
It might be useful, for example, to return custom headers or cookies.
Return a
Response
In fact, you can return any
Response
or any sub-class of it.
Tip
JSONResponse
itself is a sub-class of
Response
.
And when you return a
Response
,
FastAPI
will pass it directly.
It won't do any data conversion with Pydantic models, it won't convert the contents to any type, etc.
This gives you a lot of flexibility. You can return any data type, override any data declaration or validation, etc.
Using the
jsonable_encoder
in a
Response
Because
FastAPI
doesn't make any changes to a
Response
you return, you have to make sure its contents are ready for it.
For example, you cannot put a Pydantic model in a
JSONResponse
without first converting it to a
dict
with all the data types (like
datetime
,
UUID
, etc) converted to JSON-compatible types.
For those cases, you can use the
jsonable_encoder
to convert your data before passing it to a response:
Python 3.8+
from
datetime
import
datetime
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
fastapi.responses
import
JSONResponse
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
title
:
str
timestamp
:
datetime
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{id}
"
)
def
update_item
(
id
:
str
,
item
:
Item
):
json_compatible_item_data
=
jsonable_encoder
(
item
)
return
JSONResponse
(
content
=
json_compatible_item_data
)
Technical Details
You could also use
from starlette.responses import JSONResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
Returning a custom
Response
The example above shows all the parts you need, but it's not very useful yet, as you could have just returned the
item
directly, and
FastAPI
would put it in a
JSONResponse
for you, converting it to a
dict
, etc. All that by default.
Now, let's see how you could use that to return a custom response.
Let's say that you want to return an
XML
response.
You could put your XML content in a string, put that in a
Response
, and return it:
Python 3.8+
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
@app
.
get
(
"/legacy/"
)
def
get_legacy_data
():
data
=
"""<?xml version="1.0"?>
<shampoo>
<Header>
Apply shampoo here.
</Header>
<Body>
You'll have to use soap here.
</Body>
</shampoo>
"""
return
Response
(
content
=
data
,
media_type
=
"application/xml"
)
Notes
When you return a
Response
directly its data is not validated, converted (serialized), or documented automatically.
But you can still document it as described in
Additional Responses in OpenAPI
.
You can see in later sections how to use/declare these custom
Response
s while still having automatic data conversion, documentation, etc.

## 019_ADVANCED_RESPONSE_HEADERS
Response Headers¬∂
---

Response Headers
Use a
Response
parameter
You can declare a parameter of type
Response
in your
path operation function
(as you can do for cookies).
And then you can set headers in that
temporal
response object.
Python 3.8+
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
@app
.
get
(
"/headers-and-object/"
)
def
get_headers
(
response
:
Response
):
response
.
headers
[
"X-Cat-Dog"
]
=
"alone in the world"
return
{
"message"
:
"Hello World"
}
And then you can return any object you need, as you normally would (a
dict
, a database model, etc).
And if you declared a
response_model
, it will still be used to filter and convert the object you returned.
FastAPI
will use that
temporal
response to extract the headers (also cookies and status code), and will put them in the final response that contains the value you returned, filtered by any
response_model
.
You can also declare the
Response
parameter in dependencies, and set headers (and cookies) in them.
Return a
Response
directly
You can also add headers when you return a
Response
directly.
Create a response as described in
Return a Response Directly
and pass the headers as an additional parameter:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
JSONResponse
app
=
FastAPI
()
@app
.
get
(
"/headers/"
)
def
get_headers
():
content
=
{
"message"
:
"Hello World"
}
headers
=
{
"X-Cat-Dog"
:
"alone in the world"
,
"Content-Language"
:
"en-US"
}
return
JSONResponse
(
content
=
content
,
headers
=
headers
)
Technical Details
You could also use
from starlette.responses import Response
or
from starlette.responses import JSONResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
And as the
Response
can be used frequently to set headers and cookies,
FastAPI
also provides it at
fastapi.Response
.
Custom Headers
Keep in mind that custom proprietary headers can be added
using the 'X-' prefix
.
But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (read more in
CORS (Cross-Origin Resource Sharing)
), using the parameter
expose_headers
documented in
Starlette's CORS docs
.

## 020_ADVANCED_SECURITY
Advanced Security¬∂
---

Advanced Security
Additional Features
There are some extra features to handle security apart from the ones covered in the
Tutorial - User Guide: Security
.
Tip
The next sections are
not necessarily "advanced"
.
And it's possible that for your use case, the solution is in one of them.
Read the Tutorial first
The next sections assume you already read the main
Tutorial - User Guide: Security
.
They are all based on the same concepts, but allow some extra functionalities.

## 021_ADVANCED_SECURITY_HTTP_BASIC_AUTH
HTTP Basic Auth¬∂
---

HTTP Basic Auth
For the simplest cases, you can use HTTP Basic Auth.
In HTTP Basic Auth, the application expects a header that contains a username and a password.
If it doesn't receive it, it returns an HTTP 401 "Unauthorized" error.
And returns a header
WWW-Authenticate
with a value of
Basic
, and an optional
realm
parameter.
That tells the browser to show the integrated prompt for a username and password.
Then, when you type that username and password, the browser sends them in the header automatically.
Simple HTTP Basic Auth
Import
HTTPBasic
and
HTTPBasicCredentials
.
Create a "
security
scheme" using
HTTPBasic
.
Use that
security
with a dependency in your
path operation
.
It returns an object of type
HTTPBasicCredentials
:
It contains the
username
and
password
sent.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)]):
return
{
"username"
:
credentials
.
username
,
"password"
:
credentials
.
password
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
from
typing_extensions
import
Annotated
app
=
FastAPI
()
security
=
HTTPBasic
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)]):
return
{
"username"
:
credentials
.
username
,
"password"
:
credentials
.
password
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
HTTPBasicCredentials
=
Depends
(
security
)):
return
{
"username"
:
credentials
.
username
,
"password"
:
credentials
.
password
}
When you try to open the URL for the first time (or click the "Execute" button in the docs) the browser will ask you for your username and password:
Check the username
Here's a more complete example.
Use a dependency to check if the username and password are correct.
For this, use the Python standard module
secrets
to check the username and password.
secrets.compare_digest()
needs to take
bytes
or a
str
that only contains ASCII characters (the ones in English), this means it wouldn't work with characters like
√°
, as in
Sebasti√°n
.
To handle that, we first convert the
username
and
password
to
bytes
encoding them with UTF-8.
Then we can use
secrets.compare_digest()
to ensure that
credentials.username
is
"stanleyjobson"
, and that
credentials.password
is
"swordfish"
.
Python 3.9+
import
secrets
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)],
):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
Annotated
[
str
,
Depends
(
get_current_username
)]):
return
{
"username"
:
username
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
import
secrets
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
from
typing_extensions
import
Annotated
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)],
):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
Annotated
[
str
,
Depends
(
get_current_username
)]):
return
{
"username"
:
username
}
Tip
Prefer to use the
Annotated
version if possible.
import
secrets
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
HTTPBasicCredentials
=
Depends
(
security
)):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
str
=
Depends
(
get_current_username
)):
return
{
"username"
:
username
}
This would be similar to:
if
not
(
credentials
.
username
==
"stanleyjobson"
)
or
not
(
credentials
.
password
==
"swordfish"
):
## Return some error
...
But by using the
secrets.compare_digest()
it will be secure against a type of attacks called "timing attacks".
Timing Attacks
But what's a "timing attack"?
Let's imagine some attackers are trying to guess the username and password.
And they send a request with a username
johndoe
and a password
love123
.
Then the Python code in your application would be equivalent to something like:
if
"johndoe"
==
"stanleyjobson"
and
"love123"
==
"swordfish"
:
...
But right at the moment Python compares the first
j
in
johndoe
to the first
s
in
stanleyjobson
, it will return
False
, because it already knows that those two strings are not the same, thinking that "there's no need to waste more computation comparing the rest of the letters". And your application will say "Incorrect username or password".
But then the attackers try with username
stanleyjobsox
and password
love123
.
And your application code does something like:
if
"stanleyjobsox"
==
"stanleyjobson"
and
"love123"
==
"swordfish"
:
...
Python will have to compare the whole
stanleyjobso
in both
stanleyjobsox
and
stanleyjobson
before realizing that both strings are not the same. So it will take some extra microseconds to reply back "Incorrect username or password".
The time to answer helps the attackers
At that point, by noticing that the server took some microseconds longer to send the "Incorrect username or password" response, the attackers will know that they got
something
right, some of the initial letters were right.
And then they can try again knowing that it's probably something more similar to
stanleyjobsox
than to
johndoe
.
A "professional" attack
Of course, the attackers would not try all this by hand, they would write a program to do it, possibly with thousands or millions of tests per second. And they would get just one extra correct letter at a time.
But doing that, in some minutes or hours the attackers would have guessed the correct username and password, with the "help" of our application, just using the time taken to answer.
Fix it with
secrets.compare_digest()
But in our code we are actually using
secrets.compare_digest()
.
In short, it will take the same time to compare
stanleyjobsox
to
stanleyjobson
than it takes to compare
johndoe
to
stanleyjobson
. And the same for the password.
That way, using
secrets.compare_digest()
in your application code, it will be safe against this whole range of security attacks.
Return the error
After detecting that the credentials are incorrect, return an
HTTPException
with a status code 401 (the same returned when no credentials are provided) and add the header
WWW-Authenticate
to make the browser show the login prompt again:
Python 3.9+
import
secrets
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)],
):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
Annotated
[
str
,
Depends
(
get_current_username
)]):
return
{
"username"
:
username
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
import
secrets
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
from
typing_extensions
import
Annotated
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)],
):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
Annotated
[
str
,
Depends
(
get_current_username
)]):
return
{
"username"
:
username
}
Tip
Prefer to use the
Annotated
version if possible.
import
secrets
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
def
get_current_username
(
credentials
:
HTTPBasicCredentials
=
Depends
(
security
)):
current_username_bytes
=
credentials
.
username
.
encode
(
"utf8"
)
correct_username_bytes
=
b
"stanleyjobson"
is_correct_username
=
secrets
.
compare_digest
(
current_username_bytes
,
correct_username_bytes
)
current_password_bytes
=
credentials
.
password
.
encode
(
"utf8"
)
correct_password_bytes
=
b
"swordfish"
is_correct_password
=
secrets
.
compare_digest
(
current_password_bytes
,
correct_password_bytes
)
if
not
(
is_correct_username
and
is_correct_password
):
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Basic"
},
)
return
credentials
.
username
@app
.
get
(
"/users/me"
)
def
read_current_user
(
username
:
str
=
Depends
(
get_current_username
)):
return
{
"username"
:
username
}

## 022_ADVANCED_SECURITY_OAUTH2_SCOPES
OAuth2 scopes¬∂
---

OAuth2 scopes
You can use OAuth2 scopes directly with
FastAPI
, they are integrated to work seamlessly.
This would allow you to have a more fine-grained permission system, following the OAuth2 standard, integrated into your OpenAPI application (and the API docs).
OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. They use it to provide specific permissions to users and applications.
Every time you "log in with" Facebook, Google, GitHub, Microsoft, Twitter, that application is using OAuth2 with scopes.
In this section you will see how to manage authentication and authorization with the same OAuth2 with scopes in your
FastAPI
application.
Warning
This is a more or less advanced section. If you are just starting, you can skip it.
You don't necessarily need OAuth2 scopes, and you can handle authentication and authorization however you want.
But OAuth2 with scopes can be nicely integrated into your API (with OpenAPI) and your API docs.
Nevertheless, you still enforce those scopes, or any other security/authorization requirement, however you need, in your code.
In many cases, OAuth2 with scopes can be an overkill.
But if you know you need it, or you are curious, keep reading.
OAuth2 scopes and OpenAPI
The OAuth2 specification defines "scopes" as a list of strings separated by spaces.
The content of each of these strings can have any format, but should not contain spaces.
These scopes represent "permissions".
In OpenAPI (e.g. the API docs), you can define "security schemes".
When one of these security schemes uses OAuth2, you can also declare and use scopes.
Each "scope" is just a string (without spaces).
They are normally used to declare specific security permissions, for example:
users:read
or
users:write
are common examples.
instagram_basic
is used by Facebook / Instagram.
https://www.googleapis.com/auth/drive
is used by Google.
Info
In OAuth2 a "scope" is just a string that declares a specific permission required.
It doesn't matter if it has other characters like
:
or if it is a URL.
Those details are implementation specific.
For OAuth2 they are just strings.
Global view
First, let's quickly see the parts that change from the examples in the main
Tutorial - User Guide
for
OAuth2 with Password (and hashing), Bearer with JWT tokens
. Now using OAuth2 scopes:
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Now let's review those changes step by step.
OAuth2 Security scheme
The first change is that now we are declaring the OAuth2 security scheme with two available scopes,
me
and
items
.
The
scopes
parameter receives a
dict
with each scope as a key and the description as the value:
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Because we are now declaring those scopes, they will show up in the API docs when you log-in/authorize.
And you will be able to select which scopes you want to give access to:
me
and
items
.
This is the same mechanism used when you give permissions while logging in with Facebook, Google, GitHub, etc:
JWT token with scopes
Now, modify the token
path operation
to return the scopes requested.
We are still using the same
OAuth2PasswordRequestForm
. It includes a property
scopes
with a
list
of
str
, with each scope it received in the request.
And we return the scopes as part of the JWT token.
Danger
For simplicity, here we are just adding the scopes received directly to the token.
But in your application, for security, you should make sure you only add the scopes that the user is actually able to have, or the ones you have predefined.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Declare scopes in
path operations
and dependencies
Now we declare that the
path operation
for
/users/me/items/
requires the scope
items
.
For this, we import and use
Security
from
fastapi
.
You can use
Security
to declare dependencies (just like
Depends
), but
Security
also receives a parameter
scopes
with a list of scopes (strings).
In this case, we pass a dependency function
get_current_active_user
to
Security
(the same way we would do with
Depends
).
But we also pass a
list
of scopes, in this case with just one scope:
items
(it could have more).
And the dependency function
get_current_active_user
can also declare sub-dependencies, not only with
Depends
but also with
Security
. Declaring its own sub-dependency function (
get_current_user
), and more scope requirements.
In this case, it requires the scope
me
(it could require more than one scope).
Note
You don't necessarily need to add different scopes in different places.
We are doing it here to demonstrate how
FastAPI
handles scopes declared at different levels.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Technical Details
Security
is actually a subclass of
Depends
, and it has just one extra parameter that we'll see later.
But by using
Security
instead of
Depends
,
FastAPI
will know that it can declare security scopes, use them internally, and document the API with OpenAPI.
But when you import
Query
,
Path
,
Depends
,
Security
and others from
fastapi
, those are actually functions that return special classes.
Use
SecurityScopes
Now update the dependency
get_current_user
.
This is the one used by the dependencies above.
Here's where we are using the same OAuth2 scheme we created before, declaring it as a dependency:
oauth2_scheme
.
Because this dependency function doesn't have any scope requirements itself, we can use
Depends
with
oauth2_scheme
, we don't have to use
Security
when we don't need to specify security scopes.
We also declare a special parameter of type
SecurityScopes
, imported from
fastapi.security
.
This
SecurityScopes
class is similar to
Request
(
Request
was used to get the request object directly).
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Use the
scopes
The parameter
security_scopes
will be of type
SecurityScopes
.
It will have a property
scopes
with a list containing all the scopes required by itself and all the dependencies that use this as a sub-dependency. That means, all the "dependants"... this might sound confusing, it is explained again later below.
The
security_scopes
object (of class
SecurityScopes
) also provides a
scope_str
attribute with a single string, containing those scopes separated by spaces (we are going to use it).
We create an
HTTPException
that we can reuse (
raise
) later at several points.
In this exception, we include the scopes required (if any) as a string separated by spaces (using
scope_str
). We put that string containing the scopes in the
WWW-Authenticate
header (this is part of the spec).
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Verify the
username
and data shape
We verify that we get a
username
, and extract the scopes.
And then we validate that data with the Pydantic model (catching the
ValidationError
exception), and if we get an error reading the JWT token or validating the data with Pydantic, we raise the
HTTPException
we created before.
For that, we update the Pydantic model
TokenData
with a new property
scopes
.
By validating the data with Pydantic we can make sure that we have, for example, exactly a
list
of
str
with the scopes and a
str
with the
username
.
Instead of, for example, a
dict
, or something else, as it could break the application at some point later, making it a security risk.
We also verify that we have a user with that username, and if not, we raise that same exception we created before.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Verify the
scopes
We now verify that all the scopes required, by this dependency and all the dependants (including
path operations
), are included in the scopes provided in the token received, otherwise raise an
HTTPException
.
For this, we use
security_scopes.scopes
, that contains a
list
with all these scopes as
str
.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Security
(
get_current_user
,
scopes
=
[
"me"
])],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
list
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
List
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Security
,
status
from
fastapi.security
import
(
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
SecurityScopes
,
)
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
,
ValidationError
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Chains"
,
"email"
:
"alicechains@example.com"
,
"hashed_password"
:
"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm"
,
"disabled"
:
True
,
},
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
scopes
:
List
[
str
]
=
[]
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
,
scopes
=
{
"me"
:
"Read information about the current user."
,
"items"
:
"Read items."
},
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
security_scopes
:
SecurityScopes
,
token
:
str
=
Depends
(
oauth2_scheme
)
):
if
security_scopes
.
scopes
:
authenticate_value
=
f
'Bearer scope="
{
security_scopes
.
scope_str
}
"'
else
:
authenticate_value
=
"Bearer"
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
:
str
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_scopes
=
payload
.
get
(
"scopes"
,
[])
token_data
=
TokenData
(
scopes
=
token_scopes
,
username
=
username
)
except
(
InvalidTokenError
,
ValidationError
):
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
for
scope
in
security_scopes
.
scopes
:
if
scope
not
in
token_data
.
scopes
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Not enough permissions"
,
headers
=
{
"WWW-Authenticate"
:
authenticate_value
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Security
(
get_current_user
,
scopes
=
[
"me"
]),
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
,
"scopes"
:
form_data
.
scopes
},
expires_delta
=
access_token_expires
,
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Security
(
get_current_active_user
,
scopes
=
[
"items"
]),
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
@app
.
get
(
"/status/"
)
async
def
read_system_status
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
{
"status"
:
"ok"
}
Dependency tree and scopes
Let's review again this dependency tree and the scopes.
As the
get_current_active_user
dependency has as a sub-dependency on
get_current_user
, the scope
"me"
declared at
get_current_active_user
will be included in the list of required scopes in the
security_scopes.scopes
passed to
get_current_user
.
The
path operation
itself also declares a scope,
"items"
, so this will also be in the list of
security_scopes.scopes
passed to
get_current_user
.
Here's how the hierarchy of dependencies and scopes looks like:
The
path operation
read_own_items
has:
Required scopes
["items"]
with the dependency:
get_current_active_user
:
The dependency function
get_current_active_user
has:
Required scopes
["me"]
with the dependency:
get_current_user
:
The dependency function
get_current_user
has:
No scopes required by itself.
A dependency using
oauth2_scheme
.
A
security_scopes
parameter of type
SecurityScopes
:
This
security_scopes
parameter has a property
scopes
with a
list
containing all these scopes declared above, so:
security_scopes.scopes
will contain
["me", "items"]
for the
path operation
read_own_items
.
security_scopes.scopes
will contain
["me"]
for the
path operation
read_users_me
, because it is declared in the dependency
get_current_active_user
.
security_scopes.scopes
will contain
[]
(nothing) for the
path operation
read_system_status
, because it didn't declare any
Security
with
scopes
, and its dependency,
get_current_user
, doesn't declare any
scopes
either.
Tip
The important and "magic" thing here is that
get_current_user
will have a different list of
scopes
to check for each
path operation
.
All depending on the
scopes
declared in each
path operation
and each dependency in the dependency tree for that specific
path operation
.
More details about
SecurityScopes
You can use
SecurityScopes
at any point, and in multiple places, it doesn't have to be at the "root" dependency.
It will always have the security scopes declared in the current
Security
dependencies and all the dependants for
that specific
path operation
and
that specific
dependency tree.
Because the
SecurityScopes
will have all the scopes declared by dependants, you can use it to verify that a token has the required scopes in a central dependency function, and then declare different scope requirements in different
path operations
.
They will be checked independently for each
path operation
.
Check it
If you open the API docs, you can authenticate and specify which scopes you want to authorize.
If you don't select any scope, you will be "authenticated", but when you try to access
/users/me/
or
/users/me/items/
you will get an error saying that you don't have enough permissions. You will still be able to access
/status/
.
And if you select the scope
me
but not the scope
items
, you will be able to access
/users/me/
but not
/users/me/items/
.
That's what would happen to a third party application that tried to access one of these
path operations
with a token provided by a user, depending on how many permissions the user gave the application.
About third party integrations
In this example we are using the OAuth2 "password" flow.
This is appropriate when we are logging in to our own application, probably with our own frontend.
Because we can trust it to receive the
username
and
password
, as we control it.
But if you are building an OAuth2 application that others would connect to (i.e., if you are building an authentication provider equivalent to Facebook, Google, GitHub, etc.) you should use one of the other flows.
The most common is the implicit flow.
The most secure is the code flow, but it's more complex to implement as it requires more steps. As it is more complex, many providers end up suggesting the implicit flow.
Note
It's common that each authentication provider names their flows in a different way, to make it part of their brand.
But in the end, they are implementing the same OAuth2 standard.
FastAPI
includes utilities for all these OAuth2 authentication flows in
fastapi.security.oauth2
.
Security
in decorator
dependencies
The same way you can define a
list
of
Depends
in the decorator's
dependencies
parameter (as explained in
Dependencies in path operation decorators
), you could also use
Security
with
scopes
there.

## 023_ADVANCED_SETTINGS
Settings and Environment Variables¬∂
---

Settings and Environment Variables
In many cases your application could need some external settings or configurations, for example secret keys, database credentials, credentials for email services, etc.
Most of these settings are variable (can change), like database URLs. And many could be sensitive, like secrets.
For this reason it's common to provide them in environment variables that are read by the application.
Tip
To understand environment variables you can read
Environment Variables
.
Types and validation
These environment variables can only handle text strings, as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS).
That means that any value read in Python from an environment variable will be a
str
, and any conversion to a different type or any validation has to be done in code.
Pydantic
Settings
Fortunately, Pydantic provides a great utility to handle these settings coming from environment variables with
Pydantic: Settings management
.
Install
pydantic-settings
First, make sure you create your
virtual environment
, activate it, and then install the
pydantic-settings
package:
fast ‚Üí
pip install pydantic-settings
restart ‚Üª
It also comes included when you install the
all
extras with:
fast ‚Üí
pip install "fastapi[all]"
restart ‚Üª
Info
In Pydantic v1 it came included with the main package. Now it is distributed as this independent package so that you can choose to install it or not if you don't need that functionality.
Create the
Settings
object
Import
BaseSettings
from Pydantic and create a sub-class, very much like with a Pydantic model.
The same way as with Pydantic models, you declare class attributes with type annotations, and possibly default values.
You can use all the same validation features and tools you use for Pydantic models, like different data types and additional validations with
Field()
.
Pydantic v2
Pydantic v1
Python 3.8+
from
fastapi
import
FastAPI
from
pydantic_settings
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
settings
=
Settings
()
app
=
FastAPI
()
@app
.
get
(
"/info"
)
async
def
info
():
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Info
In Pydantic v1 you would import
BaseSettings
directly from
pydantic
instead of from
pydantic_settings
.
Python 3.8+
from
fastapi
import
FastAPI
from
pydantic
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
settings
=
Settings
()
app
=
FastAPI
()
@app
.
get
(
"/info"
)
async
def
info
():
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Tip
If you want something quick to copy and paste, don't use this example, use the last one below.
Then, when you create an instance of that
Settings
class (in this case, in the
settings
object), Pydantic will read the environment variables in a case-insensitive way, so, an upper-case variable
APP_NAME
will still be read for the attribute
app_name
.
Next it will convert and validate the data. So, when you use that
settings
object, you will have data of the types you declared (e.g.
items_per_user
will be an
int
).
Use the
settings
Then you can use the new
settings
object in your application:
Python 3.8+
from
fastapi
import
FastAPI
from
pydantic_settings
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
settings
=
Settings
()
app
=
FastAPI
()
@app
.
get
(
"/info"
)
async
def
info
():
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Run the server
Next, you would run the server passing the configurations as environment variables, for example you could set an
ADMIN_EMAIL
and
APP_NAME
with:
fast ‚Üí
ADMIN_EMAIL="deadpool@example.com" APP_NAME="ChimichangApp" fastapi run main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
Tip
To set multiple env vars for a single command just separate them with a space, and put them all before the command.
And then the
admin_email
setting would be set to
"deadpool@example.com"
.
The
app_name
would be
"ChimichangApp"
.
And the
items_per_user
would keep its default value of
50
.
Settings in another module
You could put those settings in another module file as you saw in
Bigger Applications - Multiple Files
.
For example, you could have a file
config.py
with:
Python 3.8+
from
pydantic_settings
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
settings
=
Settings
()
And then use it in a file
main.py
:
Python 3.8+
from
fastapi
import
FastAPI
from
.config
import
settings
app
=
FastAPI
()
@app
.
get
(
"/info"
)
async
def
info
():
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Tip
You would also need a file
__init__.py
as you saw in
Bigger Applications - Multiple Files
.
Settings in a dependency
In some occasions it might be useful to provide the settings from a dependency, instead of having a global object with
settings
that is used everywhere.
This could be especially useful during testing, as it's very easy to override a dependency with your own custom settings.
The config file
Coming from the previous example, your
config.py
file could look like:
Python 3.8+
from
pydantic_settings
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
Notice that now we don't create a default instance
settings = Settings()
.
The main app file
Now we create a dependency that returns a new
config.Settings()
.
Python 3.8+
from
functools
import
lru_cache
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
.config
import
Settings
app
=
FastAPI
()
@lru_cache
def
get_settings
():
return
Settings
()
@app
.
get
(
"/info"
)
async
def
info
(
settings
:
Annotated
[
Settings
,
Depends
(
get_settings
)]):
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Tip
We'll discuss the
@lru_cache
in a bit.
For now you can assume
get_settings()
is a normal function.
And then we can require it from the
path operation function
as a dependency and use it anywhere we need it.
Python 3.8+
from
functools
import
lru_cache
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
.config
import
Settings
app
=
FastAPI
()
@lru_cache
def
get_settings
():
return
Settings
()
@app
.
get
(
"/info"
)
async
def
info
(
settings
:
Annotated
[
Settings
,
Depends
(
get_settings
)]):
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Settings and testing
Then it would be very easy to provide a different settings object during testing by creating a dependency override for
get_settings
:
Python 3.8+
from
fastapi.testclient
import
TestClient
from
.config
import
Settings
from
.main
import
app
,
get_settings
client
=
TestClient
(
app
)
def
get_settings_override
():
return
Settings
(
admin_email
=
"testing_admin@example.com"
)
app
.
dependency_overrides
[
get_settings
]
=
get_settings_override
def
test_app
():
response
=
client
.
get
(
"/info"
)
data
=
response
.
json
()
assert
data
==
{
"app_name"
:
"Awesome API"
,
"admin_email"
:
"testing_admin@example.com"
,
"items_per_user"
:
50
,
}
In the dependency override we set a new value for the
admin_email
when creating the new
Settings
object, and then we return that new object.
Then we can test that it is used.
Reading a
.env
file
If you have many settings that possibly change a lot, maybe in different environments, it might be useful to put them on a file and then read them from it as if they were environment variables.
This practice is common enough that it has a name, these environment variables are commonly placed in a file
.env
, and the file is called a "dotenv".
Tip
A file starting with a dot (
.
) is a hidden file in Unix-like systems, like Linux and macOS.
But a dotenv file doesn't really have to have that exact filename.
Pydantic has support for reading from these types of files using an external library. You can read more at
Pydantic Settings: Dotenv (.env) support
.
Tip
For this to work, you need to
pip install python-dotenv
.
The
.env
file
You could have a
.env
file with:
ADMIN_EMAIL
=
"deadpool@example.com"
APP_NAME
=
"ChimichangApp"
Read settings from
.env
And then update your
config.py
with:
Pydantic v2
Pydantic v1
Python 3.8+
from
pydantic_settings
import
BaseSettings
,
SettingsConfigDict
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
model_config
=
SettingsConfigDict
(
env_file
=
".env"
)
Tip
The
model_config
attribute is used just for Pydantic configuration. You can read more at
Pydantic: Concepts: Configuration
.
Python 3.8+
from
pydantic
import
BaseSettings
class
Settings
(
BaseSettings
):
app_name
:
str
=
"Awesome API"
admin_email
:
str
items_per_user
:
int
=
50
class
Config
:
env_file
=
".env"
Tip
The
Config
class is used just for Pydantic configuration. You can read more at
Pydantic Model Config
.
Info
In Pydantic version 1 the configuration was done in an internal class
Config
, in Pydantic version 2 it's done in an attribute
model_config
. This attribute takes a
dict
, and to get autocompletion and inline errors you can import and use
SettingsConfigDict
to define that
dict
.
Here we define the config
env_file
inside of your Pydantic
Settings
class, and set the value to the filename with the dotenv file we want to use.
Creating the
Settings
only once with
lru_cache
Reading a file from disk is normally a costly (slow) operation, so you probably want to do it only once and then reuse the same settings object, instead of reading it for each request.
But every time we do:
Settings
()
a new
Settings
object would be created, and at creation it would read the
.env
file again.
If the dependency function was just like:
def
get_settings
():
return
Settings
()
we would create that object for each request, and we would be reading the
.env
file for each request. ‚ö†Ô∏è
But as we are using the
@lru_cache
decorator on top, the
Settings
object will be created only once, the first time it's called. ‚úîÔ∏è
Python 3.8+
from
functools
import
lru_cache
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
from
.
import
config
app
=
FastAPI
()
@lru_cache
def
get_settings
():
return
config
.
Settings
()
@app
.
get
(
"/info"
)
async
def
info
(
settings
:
Annotated
[
config
.
Settings
,
Depends
(
get_settings
)]):
return
{
"app_name"
:
settings
.
app_name
,
"admin_email"
:
settings
.
admin_email
,
"items_per_user"
:
settings
.
items_per_user
,
}
Then for any subsequent call of
get_settings()
in the dependencies for the next requests, instead of executing the internal code of
get_settings()
and creating a new
Settings
object, it will return the same object that was returned on the first call, again and again.
lru_cache
Technical Details
@lru_cache
modifies the function it decorates to return the same value that was returned the first time, instead of computing it again, executing the code of the function every time.
So, the function below it will be executed once for each combination of arguments. And then the values returned by each of those combinations of arguments will be used again and again whenever the function is called with exactly the same combination of arguments.
For example, if you have a function:
@lru_cache
def
say_hi
(
name
:
str
,
salutation
:
str
=
"Ms."
):
return
f
"Hello
{
salutation
}
{
name
}
"
your program could execute like this:
In the case of our dependency
get_settings()
, the function doesn't even take any arguments, so it always returns the same value.
That way, it behaves almost as if it was just a global variable. But as it uses a dependency function, then we can override it easily for testing.
@lru_cache
is part of
functools
which is part of Python's standard library, you can read more about it in the
Python docs for
@lru_cache
.
Recap
You can use Pydantic Settings to handle the settings or configurations for your application, with all the power of Pydantic models.
By using a dependency you can simplify testing.
You can use
.env
files with it.
Using
@lru_cache
lets you avoid reading the dotenv file again and again for each request, while allowing you to override it during testing.

## 024_ADVANCED_SUB_APPLICATIONS
Sub Applications - Mounts¬∂
---

Sub Applications - Mounts
If you need to have two independent FastAPI applications, with their own independent OpenAPI and their own docs UIs, you can have a main app and "mount" one (or more) sub-application(s).
Mounting a
FastAPI
application
"Mounting" means adding a completely "independent" application in a specific path, that then takes care of handling everything under that path, with the
path operations
declared in that sub-application.
Top-level application
First, create the main, top-level,
FastAPI
application, and its
path operations
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/app"
)
def
read_main
():
return
{
"message"
:
"Hello World from main app"
}
subapi
=
FastAPI
()
@subapi
.
get
(
"/sub"
)
def
read_sub
():
return
{
"message"
:
"Hello World from sub API"
}
app
.
mount
(
"/subapi"
,
subapi
)
Sub-application
Then, create your sub-application, and its
path operations
.
This sub-application is just another standard FastAPI application, but this is the one that will be "mounted":
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/app"
)
def
read_main
():
return
{
"message"
:
"Hello World from main app"
}
subapi
=
FastAPI
()
@subapi
.
get
(
"/sub"
)
def
read_sub
():
return
{
"message"
:
"Hello World from sub API"
}
app
.
mount
(
"/subapi"
,
subapi
)
Mount the sub-application
In your top-level application,
app
, mount the sub-application,
subapi
.
In this case, it will be mounted at the path
/subapi
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/app"
)
def
read_main
():
return
{
"message"
:
"Hello World from main app"
}
subapi
=
FastAPI
()
@subapi
.
get
(
"/sub"
)
def
read_sub
():
return
{
"message"
:
"Hello World from sub API"
}
app
.
mount
(
"/subapi"
,
subapi
)
Check the automatic API docs
Now, run the
fastapi
command with your file:
fast ‚Üí
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
And open the docs at
http://127.0.0.1:8000/docs
.
You will see the automatic API docs for the main app, including only its own
path operations
:
And then, open the docs for the sub-application, at
http://127.0.0.1:8000/subapi/docs
.
You will see the automatic API docs for the sub-application, including only its own
path operations
, all under the correct sub-path prefix
/subapi
:
If you try interacting with any of the two user interfaces, they will work correctly, because the browser will be able to talk to each specific app or sub-app.
Technical Details:
root_path
When you mount a sub-application as described above, FastAPI will take care of communicating the mount path for the sub-application using a mechanism from the ASGI specification called a
root_path
.
That way, the sub-application will know to use that path prefix for the docs UI.
And the sub-application could also have its own mounted sub-applications and everything would work correctly, because FastAPI handles all these
root_path
s automatically.
You will learn more about the
root_path
and how to use it explicitly in the section about
Behind a Proxy
.

## 025_ADVANCED_TEMPLATES
Templates¬∂
---

Templates
You can use any template engine you want with
FastAPI
.
A common choice is Jinja2, the same one used by Flask and other tools.
There are utilities to configure it easily that you can use directly in your
FastAPI
application (provided by Starlette).
Install dependencies
Make sure you create a
virtual environment
, activate it, and install
jinja2
:
fast ‚Üí
pip install jinja2
‚ñà‚ñà‚ñà 8%
Using
Jinja2Templates
Import
Jinja2Templates
.
Create a
templates
object that you can reuse later.
Declare a
Request
parameter in the
path operation
that will return a template.
Use the
templates
you created to render and return a
TemplateResponse
, pass the name of the template, the request object, and a "context" dictionary with key-value pairs to be used inside of the Jinja2 template.
Python 3.8+
from
fastapi
import
FastAPI
,
Request
from
fastapi.responses
import
HTMLResponse
from
fastapi.staticfiles
import
StaticFiles
from
fastapi.templating
import
Jinja2Templates
app
=
FastAPI
()
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
templates
=
Jinja2Templates
(
directory
=
"templates"
)
@app
.
get
(
"/items/
{id}
"
,
response_class
=
HTMLResponse
)
async
def
read_item
(
request
:
Request
,
id
:
str
):
return
templates
.
TemplateResponse
(
request
=
request
,
name
=
"item.html"
,
context
=
{
"id"
:
id
}
)
Note
Before FastAPI 0.108.0, Starlette 0.29.0, the
name
was the first parameter.
Also, before that, in previous versions, the
request
object was passed as part of the key-value pairs in the context for Jinja2.
Tip
By declaring
response_class=HTMLResponse
the docs UI will be able to know that the response will be HTML.
Technical Details
You could also use
from starlette.templating import Jinja2Templates
.
FastAPI
provides the same
starlette.templating
as
fastapi.templating
just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with
Request
and
StaticFiles
.
Writing templates
Then you can write a template at
templates/item.html
with, for example:
<html>
<head>
<title>Item Details</title>
<link href="
{{
url_for
(
'static'
,
path
=
'/styles.css'
)
}}
" rel="stylesheet">
</head>
<body>
<h1><a href="
{{
url_for
(
'read_item'
,
id
=
id
)
}}
">Item ID:
{{
id
}}
</a></h1>
</body>
</html>
Template Context Values
In the HTML that contains:
Item ID:
{{
id
}}
...it will show the
id
taken from the "context"
dict
you passed:
{
"id"
:
id
}
For example, with an ID of
42
, this would render:
Item ID: 42
Template
url_for
Arguments
You can also use
url_for()
inside of the template, it takes as arguments the same arguments that would be used by your
path operation function
.
So, the section with:
<a href="
{{
url_for
(
'read_item'
,
id
=
id
)
}}
">
...will generate a link to the same URL that would be handled by the
path operation function
read_item(id=id)
.
For example, with an ID of
42
, this would render:
<
a
href
=
"/items/42"
>
Templates and static files
You can also use
url_for()
inside of the template, and use it, for example, with the
StaticFiles
you mounted with the
name="static"
.
<html>
<head>
<title>Item Details</title>
<link href="
{{
url_for
(
'static'
,
path
=
'/styles.css'
)
}}
" rel="stylesheet">
</head>
<body>
<h1><a href="
{{
url_for
(
'read_item'
,
id
=
id
)
}}
">Item ID:
{{
id
}}
</a></h1>
</body>
</html>
In this example, it would link to a CSS file at
static/styles.css
with:
h1
{
color
:
green
;
}
And because you are using
StaticFiles
, that CSS file would be served automatically by your
FastAPI
application at the URL
/static/styles.css
.
More details
For more details, including how to test templates, check
Starlette's docs on templates
.

## 026_ADVANCED_TESTING_DEPENDENCIES
Testing Dependencies with Overrides¬∂
---

Testing Dependencies with Overrides
Overriding dependencies during testing
There are some scenarios where you might want to override a dependency during testing.
You don't want the original dependency to run (nor any of the sub-dependencies it might have).
Instead, you want to provide a different dependency that will be used only during tests (possibly only some specific tests), and will provide a value that can be used where the value of the original dependency was used.
Use cases: external service
An example could be that you have an external authentication provider that you need to call.
You send it a token and it returns an authenticated user.
This provider might be charging you per request, and calling it might take some extra time than if you had a fixed mock user for tests.
You probably want to test the external provider once, but not necessarily call it for every test that runs.
In this case, you can override the dependency that calls that provider, and use a custom dependency that returns a mock user, only for your tests.
Use the
app.dependency_overrides
attribute
For these cases, your
FastAPI
application has an attribute
app.dependency_overrides
, it is a simple
dict
.
To override a dependency for testing, you put as a key the original dependency (a function), and as the value, your dependency override (another function).
And then
FastAPI
will call that override instead of the original dependency.
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Items!"
,
"params"
:
commons
}
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Users!"
,
"params"
:
commons
}
client
=
TestClient
(
app
)
async
def
override_dependency
(
q
:
str
|
None
=
None
):
return
{
"q"
:
q
,
"skip"
:
5
,
"limit"
:
10
}
app
.
dependency_overrides
[
common_parameters
]
=
override_dependency
def
test_override_in_items
():
response
=
client
.
get
(
"/items/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
None
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_q
():
response
=
client
.
get
(
"/items/?q=foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_params
():
response
=
client
.
get
(
"/items/?q=foo&skip=100&limit=200"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Items!"
,
"params"
:
commons
}
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Users!"
,
"params"
:
commons
}
client
=
TestClient
(
app
)
async
def
override_dependency
(
q
:
Union
[
str
,
None
]
=
None
):
return
{
"q"
:
q
,
"skip"
:
5
,
"limit"
:
10
}
app
.
dependency_overrides
[
common_parameters
]
=
override_dependency
def
test_override_in_items
():
response
=
client
.
get
(
"/items/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
None
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_q
():
response
=
client
.
get
(
"/items/?q=foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_params
():
response
=
client
.
get
(
"/items/?q=foo&skip=100&limit=200"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.testclient
import
TestClient
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Items!"
,
"params"
:
commons
}
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
{
"message"
:
"Hello Users!"
,
"params"
:
commons
}
client
=
TestClient
(
app
)
async
def
override_dependency
(
q
:
Union
[
str
,
None
]
=
None
):
return
{
"q"
:
q
,
"skip"
:
5
,
"limit"
:
10
}
app
.
dependency_overrides
[
common_parameters
]
=
override_dependency
def
test_override_in_items
():
response
=
client
.
get
(
"/items/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
None
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_q
():
response
=
client
.
get
(
"/items/?q=foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_params
():
response
=
client
.
get
(
"/items/?q=foo&skip=100&limit=200"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
{
"message"
:
"Hello Items!"
,
"params"
:
commons
}
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
{
"message"
:
"Hello Users!"
,
"params"
:
commons
}
client
=
TestClient
(
app
)
async
def
override_dependency
(
q
:
str
|
None
=
None
):
return
{
"q"
:
q
,
"skip"
:
5
,
"limit"
:
10
}
app
.
dependency_overrides
[
common_parameters
]
=
override_dependency
def
test_override_in_items
():
response
=
client
.
get
(
"/items/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
None
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_q
():
response
=
client
.
get
(
"/items/?q=foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_params
():
response
=
client
.
get
(
"/items/?q=foo&skip=100&limit=200"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
{
"message"
:
"Hello Items!"
,
"params"
:
commons
}
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
{
"message"
:
"Hello Users!"
,
"params"
:
commons
}
client
=
TestClient
(
app
)
async
def
override_dependency
(
q
:
Union
[
str
,
None
]
=
None
):
return
{
"q"
:
q
,
"skip"
:
5
,
"limit"
:
10
}
app
.
dependency_overrides
[
common_parameters
]
=
override_dependency
def
test_override_in_items
():
response
=
client
.
get
(
"/items/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
None
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_q
():
response
=
client
.
get
(
"/items/?q=foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
def
test_override_in_items_with_params
():
response
=
client
.
get
(
"/items/?q=foo&skip=100&limit=200"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"message"
:
"Hello Items!"
,
"params"
:
{
"q"
:
"foo"
,
"skip"
:
5
,
"limit"
:
10
},
}
Tip
You can set a dependency override for a dependency used anywhere in your
FastAPI
application.
The original dependency could be used in a
path operation function
, a
path operation decorator
(when you don't use the return value), a
.include_router()
call, etc.
FastAPI will still be able to override it.
Then you can reset your overrides (remove them) by setting
app.dependency_overrides
to be an empty
dict
:
app
.
dependency_overrides
=
{}
Tip
If you want to override a dependency only during some tests, you can set the override at the beginning of the test (inside the test function) and reset it at the end (at the end of the test function).

## 027_ADVANCED_TESTING_EVENTS
Testing Events: startup - shutdown¬∂
---

Testing Events: startup - shutdown
When you need your event handlers (
startup
and
shutdown
) to run in your tests, you can use the
TestClient
with a
with
statement:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
items
=
{}
@app
.
on_event
(
"startup"
)
async
def
startup_event
():
items
[
"foo"
]
=
{
"name"
:
"Fighters"
}
items
[
"bar"
]
=
{
"name"
:
"Tenders"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
str
):
return
items
[
item_id
]
def
test_read_items
():
with
TestClient
(
app
)
as
client
:
response
=
client
.
get
(
"/items/foo"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"name"
:
"Fighters"
}

## 028_ADVANCED_TESTING_WEBSOCKETS
Testing WebSockets¬∂
---

Testing WebSockets
You can use the same
TestClient
to test WebSockets.
For this, you use the
TestClient
in a
with
statement, connecting to the WebSocket:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.testclient
import
TestClient
from
fastapi.websockets
import
WebSocket
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_main
():
return
{
"msg"
:
"Hello World"
}
@app
.
websocket
(
"/ws"
)
async
def
websocket
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
await
websocket
.
send_json
({
"msg"
:
"Hello WebSocket"
})
await
websocket
.
close
()
def
test_read_main
():
client
=
TestClient
(
app
)
response
=
client
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"msg"
:
"Hello World"
}
def
test_websocket
():
client
=
TestClient
(
app
)
with
client
.
websocket_connect
(
"/ws"
)
as
websocket
:
data
=
websocket
.
receive_json
()
assert
data
==
{
"msg"
:
"Hello WebSocket"
}
Note
For more details, check Starlette's documentation for
testing WebSockets
.

## 029_ADVANCED_USING_REQUEST_DIRECTLY
Using the Request Directly¬∂
---

Using the Request Directly
Up to now, you have been declaring the parts of the request that you need with their types.
Taking data from:
The path as parameters.
Headers.
Cookies.
etc.
And by doing so,
FastAPI
is validating that data, converting it and generating documentation for your API automatically.
But there are situations where you might need to access the
Request
object directly.
Details about the
Request
object
As
FastAPI
is actually
Starlette
underneath, with a layer of several tools on top, you can use Starlette's
Request
object directly when you need to.
It would also mean that if you get data from the
Request
object directly (for example, read the body) it won't be validated, converted or documented (with OpenAPI, for the automatic API user interface) by FastAPI.
Although any other parameter declared normally (for example, the body with a Pydantic model) would still be validated, converted, annotated, etc.
But there are specific cases where it's useful to get the
Request
object.
Use the
Request
object directly
Let's imagine you want to get the client's IP address/host inside of your
path operation function
.
For that you need to access the request directly.
Python 3.8+
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
def
read_root
(
item_id
:
str
,
request
:
Request
):
client_host
=
request
.
client
.
host
return
{
"client_host"
:
client_host
,
"item_id"
:
item_id
}
By declaring a
path operation function
parameter with the type being the
Request
FastAPI
will know to pass the
Request
in that parameter.
Tip
Note that in this case, we are declaring a path parameter beside the request parameter.
So, the path parameter will be extracted, validated, converted to the specified type and annotated with OpenAPI.
The same way, you can declare any other parameter as normally, and additionally, get the
Request
too.
Request
documentation
You can read more details about the
Request
object in the official Starlette documentation site
.
Technical Details
You could also use
from starlette.requests import Request
.
FastAPI
provides it directly just as a convenience for you, the developer. But it comes directly from Starlette.

## 030_ADVANCED_WEBSOCKETS
WebSockets¬∂
---

WebSockets
You can use
WebSockets
with
FastAPI
.
Install
WebSockets
Make sure you create a
virtual environment
, activate it, and install
websockets
:
fast ‚Üí
pip install websockets
WebSockets client
In production
In your production system, you probably have a frontend created with a modern framework like React, Vue.js or Angular.
And to communicate using WebSockets with your backend you would probably use your frontend's utilities.
Or you might have a native mobile application that communicates with your WebSocket backend directly, in native code.
Or you might have any other way to communicate with the WebSocket endpoint.
But for this example, we'll use a very simple HTML document with some JavaScript, all inside a long string.
This, of course, is not optimal and you wouldn't use it for production.
In production you would have one of the options above.
But it's the simplest way to focus on the server-side of WebSockets and have a working example:
Python 3.8+
from
fastapi
import
FastAPI
,
WebSocket
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<input type="text" id="messageText" autocomplete="off"/>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = new WebSocket("ws://localhost:8000/ws");
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
@app
.
websocket
(
"/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
"
)
Create a
websocket
In your
FastAPI
application, create a
websocket
:
Python 3.8+
from
fastapi
import
FastAPI
,
WebSocket
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<input type="text" id="messageText" autocomplete="off"/>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = new WebSocket("ws://localhost:8000/ws");
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
@app
.
websocket
(
"/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
"
)
Technical Details
You could also use
from starlette.websockets import WebSocket
.
FastAPI
provides the same
WebSocket
directly just as a convenience for you, the developer. But it comes directly from Starlette.
Await for messages and send messages
In your WebSocket route you can
await
for messages and send messages.
Python 3.8+
from
fastapi
import
FastAPI
,
WebSocket
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<input type="text" id="messageText" autocomplete="off"/>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = new WebSocket("ws://localhost:8000/ws");
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
@app
.
websocket
(
"/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
"
)
You can receive and send binary, text, and JSON data.
Try it
If your file is named
main.py
, run your application with:
fast ‚Üí
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
Open your browser at
http://127.0.0.1:8000
.
You will see a simple page like:
You can type messages in the input box, and send them:
And your
FastAPI
application with WebSockets will respond back:
You can send (and receive) many messages:
And all of them will use the same WebSocket connection.
Using
Depends
and others
In WebSocket endpoints you can import from
fastapi
and use:
Depends
Security
Cookie
Header
Path
Query
They work the same way as for other FastAPI endpoints/
path operations
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
(
Cookie
,
Depends
,
FastAPI
,
Query
,
WebSocket
,
WebSocketException
,
status
,
)
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
<label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
<button onclick="connect(event)">Connect</button>
<hr>
<label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = null;
function connect(event) {
var itemId = document.getElementById("itemId")
var token = document.getElementById("token")
ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
event.preventDefault()
}
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
async
def
get_cookie_or_token
(
websocket
:
WebSocket
,
session
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
,
token
:
Annotated
[
str
|
None
,
Query
()]
=
None
,
):
if
session
is
None
and
token
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
return
session
or
token
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
*
,
websocket
:
WebSocket
,
item_id
:
str
,
q
:
int
|
None
=
None
,
cookie_or_token
:
Annotated
[
str
,
Depends
(
get_cookie_or_token
)],
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie or query token value is:
{
cookie_or_token
}
"
)
if
q
is
not
None
:
await
websocket
.
send_text
(
f
"Query parameter q is:
{
q
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
(
Cookie
,
Depends
,
FastAPI
,
Query
,
WebSocket
,
WebSocketException
,
status
,
)
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
<label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
<button onclick="connect(event)">Connect</button>
<hr>
<label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = null;
function connect(event) {
var itemId = document.getElementById("itemId")
var token = document.getElementById("token")
ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
event.preventDefault()
}
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
async
def
get_cookie_or_token
(
websocket
:
WebSocket
,
session
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
token
:
Annotated
[
Union
[
str
,
None
],
Query
()]
=
None
,
):
if
session
is
None
and
token
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
return
session
or
token
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
*
,
websocket
:
WebSocket
,
item_id
:
str
,
q
:
Union
[
int
,
None
]
=
None
,
cookie_or_token
:
Annotated
[
str
,
Depends
(
get_cookie_or_token
)],
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie or query token value is:
{
cookie_or_token
}
"
)
if
q
is
not
None
:
await
websocket
.
send_text
(
f
"Query parameter q is:
{
q
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
from
typing
import
Union
from
fastapi
import
(
Cookie
,
Depends
,
FastAPI
,
Query
,
WebSocket
,
WebSocketException
,
status
,
)
from
fastapi.responses
import
HTMLResponse
from
typing_extensions
import
Annotated
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
<label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
<button onclick="connect(event)">Connect</button>
<hr>
<label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = null;
function connect(event) {
var itemId = document.getElementById("itemId")
var token = document.getElementById("token")
ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
event.preventDefault()
}
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
async
def
get_cookie_or_token
(
websocket
:
WebSocket
,
session
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
token
:
Annotated
[
Union
[
str
,
None
],
Query
()]
=
None
,
):
if
session
is
None
and
token
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
return
session
or
token
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
*
,
websocket
:
WebSocket
,
item_id
:
str
,
q
:
Union
[
int
,
None
]
=
None
,
cookie_or_token
:
Annotated
[
str
,
Depends
(
get_cookie_or_token
)],
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie or query token value is:
{
cookie_or_token
}
"
)
if
q
is
not
None
:
await
websocket
.
send_text
(
f
"Query parameter q is:
{
q
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
(
Cookie
,
Depends
,
FastAPI
,
Query
,
WebSocket
,
WebSocketException
,
status
,
)
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
<label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
<button onclick="connect(event)">Connect</button>
<hr>
<label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = null;
function connect(event) {
var itemId = document.getElementById("itemId")
var token = document.getElementById("token")
ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
event.preventDefault()
}
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
async
def
get_cookie_or_token
(
websocket
:
WebSocket
,
session
:
str
|
None
=
Cookie
(
default
=
None
),
token
:
str
|
None
=
Query
(
default
=
None
),
):
if
session
is
None
and
token
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
return
session
or
token
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
,
item_id
:
str
,
q
:
int
|
None
=
None
,
cookie_or_token
:
str
=
Depends
(
get_cookie_or_token
),
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie or query token value is:
{
cookie_or_token
}
"
)
if
q
is
not
None
:
await
websocket
.
send_text
(
f
"Query parameter q is:
{
q
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
(
Cookie
,
Depends
,
FastAPI
,
Query
,
WebSocket
,
WebSocketException
,
status
,
)
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<form action="" onsubmit="sendMessage(event)">
<label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
<label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
<button onclick="connect(event)">Connect</button>
<hr>
<label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var ws = null;
function connect(event) {
var itemId = document.getElementById("itemId")
var token = document.getElementById("token")
ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
event.preventDefault()
}
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
async
def
get_cookie_or_token
(
websocket
:
WebSocket
,
session
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
),
token
:
Union
[
str
,
None
]
=
Query
(
default
=
None
),
):
if
session
is
None
and
token
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
return
session
or
token
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
,
item_id
:
str
,
q
:
Union
[
int
,
None
]
=
None
,
cookie_or_token
:
str
=
Depends
(
get_cookie_or_token
),
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie or query token value is:
{
cookie_or_token
}
"
)
if
q
is
not
None
:
await
websocket
.
send_text
(
f
"Query parameter q is:
{
q
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
Info
As this is a WebSocket it doesn't really make sense to raise an
HTTPException
, instead we raise a
WebSocketException
.
You can use a closing code from the
valid codes defined in the specification
.
Try the WebSockets with dependencies
If your file is named
main.py
, run your application with:
fast ‚Üí
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
Open your browser at
http://127.0.0.1:8000
.
There you can set:
The "Item ID", used in the path.
The "Token" used as a query parameter.
Tip
Notice that the query
token
will be handled by a dependency.
With that you can connect the WebSocket and then send and receive messages:
Handling disconnections and multiple clients
When a WebSocket connection is closed, the
await websocket.receive_text()
will raise a
WebSocketDisconnect
exception, which you can then catch and handle like in this example.
Python 3.9+
from
fastapi
import
FastAPI
,
WebSocket
,
WebSocketDisconnect
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<h2>Your ID: <span id="ws-id"></span></h2>
<form action="" onsubmit="sendMessage(event)">
<input type="text" id="messageText" autocomplete="off"/>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var client_id = Date.now()
document.querySelector("#ws-id").textContent = client_id;
var ws = new WebSocket(`ws://localhost:8000/ws/$
{client_id}
`);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
class
ConnectionManager
:
def
__init__
(
self
):
self
.
active_connections
:
list
[
WebSocket
]
=
[]
async
def
connect
(
self
,
websocket
:
WebSocket
):
await
websocket
.
accept
()
self
.
active_connections
.
append
(
websocket
)
def
disconnect
(
self
,
websocket
:
WebSocket
):
self
.
active_connections
.
remove
(
websocket
)
async
def
send_personal_message
(
self
,
message
:
str
,
websocket
:
WebSocket
):
await
websocket
.
send_text
(
message
)
async
def
broadcast
(
self
,
message
:
str
):
for
connection
in
self
.
active_connections
:
await
connection
.
send_text
(
message
)
manager
=
ConnectionManager
()
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
@app
.
websocket
(
"/ws/
{client_id}
"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
,
client_id
:
int
):
await
manager
.
connect
(
websocket
)
try
:
while
True
:
data
=
await
websocket
.
receive_text
()
await
manager
.
send_personal_message
(
f
"You wrote:
{
data
}
"
,
websocket
)
await
manager
.
broadcast
(
f
"Client #
{
client_id
}
says:
{
data
}
"
)
except
WebSocketDisconnect
:
manager
.
disconnect
(
websocket
)
await
manager
.
broadcast
(
f
"Client #
{
client_id
}
left the chat"
)
ü§ì Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
,
WebSocket
,
WebSocketDisconnect
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
html
=
"""
<!DOCTYPE html>
<html>
<head>
<title>Chat</title>
</head>
<body>
<h1>WebSocket Chat</h1>
<h2>Your ID: <span id="ws-id"></span></h2>
<form action="" onsubmit="sendMessage(event)">
<input type="text" id="messageText" autocomplete="off"/>
<button>Send</button>
</form>
<ul id='messages'>
</ul>
<script>
var client_id = Date.now()
document.querySelector("#ws-id").textContent = client_id;
var ws = new WebSocket(`ws://localhost:8000/ws/$
{client_id}
`);
ws.onmessage = function(event) {
var messages = document.getElementById('messages')
var message = document.createElement('li')
var content = document.createTextNode(event.data)
message.appendChild(content)
messages.appendChild(message)
};
function sendMessage(event) {
var input = document.getElementById("messageText")
ws.send(input.value)
input.value = ''
event.preventDefault()
}
</script>
</body>
</html>
"""
class
ConnectionManager
:
def
__init__
(
self
):
self
.
active_connections
:
List
[
WebSocket
]
=
[]
async
def
connect
(
self
,
websocket
:
WebSocket
):
await
websocket
.
accept
()
self
.
active_connections
.
append
(
websocket
)
def
disconnect
(
self
,
websocket
:
WebSocket
):
self
.
active_connections
.
remove
(
websocket
)
async
def
send_personal_message
(
self
,
message
:
str
,
websocket
:
WebSocket
):
await
websocket
.
send_text
(
message
)
async
def
broadcast
(
self
,
message
:
str
):
for
connection
in
self
.
active_connections
:
await
connection
.
send_text
(
message
)
manager
=
ConnectionManager
()
@app
.
get
(
"/"
)
async
def
get
():
return
HTMLResponse
(
html
)
@app
.
websocket
(
"/ws/
{client_id}
"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
,
client_id
:
int
):
await
manager
.
connect
(
websocket
)
try
:
while
True
:
data
=
await
websocket
.
receive_text
()
await
manager
.
send_personal_message
(
f
"You wrote:
{
data
}
"
,
websocket
)
await
manager
.
broadcast
(
f
"Client #
{
client_id
}
says:
{
data
}
"
)
except
WebSocketDisconnect
:
manager
.
disconnect
(
websocket
)
await
manager
.
broadcast
(
f
"Client #
{
client_id
}
left the chat"
)
To try it out:
Open the app with several browser tabs.
Write messages from them.
Then close one of the tabs.
That will raise the
WebSocketDisconnect
exception, and all the other clients will receive a message like:
Client #1596980209979 left the chat
Tip
The app above is a minimal and simple example to demonstrate how to handle and broadcast messages to several WebSocket connections.
But keep in mind that, as everything is handled in memory, in a single list, it will only work while the process is running, and will only work with a single process.
If you need something easy to integrate with FastAPI but that is more robust, supported by Redis, PostgreSQL or others, check
encode/broadcaster
.
More info
To learn more about the options, check Starlette's documentation for:
The
WebSocket
class
.
Class-based WebSocket handling
.

## 031_ADVANCED_WSGI
Including WSGI - Flask, Django, others¬∂
---

Including WSGI - Flask, Django, others
You can mount WSGI applications as you saw with
Sub Applications - Mounts
,
Behind a Proxy
.
For that, you can use the
WSGIMiddleware
and use it to wrap your WSGI application, for example, Flask, Django, etc.
Using
WSGIMiddleware
You need to import
WSGIMiddleware
.
Then wrap the WSGI (e.g. Flask) app with the middleware.
And then mount that under a path.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.middleware.wsgi
import
WSGIMiddleware
from
flask
import
Flask
,
request
from
markupsafe
import
escape
flask_app
=
Flask
(
__name__
)
@flask_app
.
route
(
"/"
)
def
flask_main
():
name
=
request
.
args
.
get
(
"name"
,
"World"
)
return
f
"Hello,
{
escape
(
name
)
}
from Flask!"
app
=
FastAPI
()
@app
.
get
(
"/v2"
)
def
read_main
():
return
{
"message"
:
"Hello World"
}
app
.
mount
(
"/v1"
,
WSGIMiddleware
(
flask_app
))
Check it
Now, every request under the path
/v1/
will be handled by the Flask application.
And the rest will be handled by
FastAPI
.
If you run it and go to
http://localhost:8000/v1/
you will see the response from Flask:
Hello, World from Flask!
And if you go to
http://localhost:8000/v2
you will see the response from FastAPI:
{
"message"
:
"Hello World"
}

## 032_ALTERNATIVES
Alternatives, Inspiration and Comparisons¬∂
---

Alternatives, Inspiration and Comparisons
What inspired
FastAPI
, how it compares to alternatives and what it learned from them.
Intro
FastAPI
wouldn't exist if not for the previous work of others.
There have been many tools created before that have helped inspire its creation.
I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by
FastAPI
using many different frameworks, plug-ins, and tools.
But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints).
Previous tools
Django
It's the most popular Python framework and is widely trusted. It is used to build systems like Instagram.
It's relatively tightly coupled with relational databases (like MySQL or PostgreSQL), so, having a NoSQL database (like Couchbase, MongoDB, Cassandra, etc) as the main store engine is not very easy.
It was created to generate the HTML in the backend, not to create APIs used by a modern frontend (like React, Vue.js and Angular) or by other systems (like
IoT
devices) communicating with it.
Django REST Framework
Django REST framework was created to be a flexible toolkit for building Web APIs using Django underneath, to improve its API capabilities.
It is used by many companies including Mozilla, Red Hat and Eventbrite.
It was one of the first examples of
automatic API documentation
, and this was specifically one of the first ideas that inspired "the search for"
FastAPI
.
Note
Django REST Framework was created by Tom Christie. The same creator of Starlette and Uvicorn, on which
FastAPI
is based.
Inspired
FastAPI
to
Have an automatic API documentation web user interface.
Flask
Flask is a "microframework", it doesn't include database integrations nor many of the things that come by default in Django.
This simplicity and flexibility allow doing things like using NoSQL databases as the main data storage system.
As it is very simple, it's relatively intuitive to learn, although the documentation gets somewhat technical at some points.
It is also commonly used for other applications that don't necessarily need a database, user management, or any of the many features that come pre-built in Django. Although many of these features can be added with plug-ins.
This decoupling of parts, and being a "microframework" that could be extended to cover exactly what is needed was a key feature that I wanted to keep.
Given the simplicity of Flask, it seemed like a good match for building APIs. The next thing to find was a "Django REST Framework" for Flask.
Inspired
FastAPI
to
Be a micro-framework. Making it easy to mix and match the tools and parts needed.
Have a simple and easy to use routing system.
Requests
FastAPI
is not actually an alternative to
Requests
. Their scope is very different.
It would actually be common to use Requests
inside
of a FastAPI application.
But still, FastAPI got quite some inspiration from Requests.
Requests
is a library to
interact
with APIs (as a client), while
FastAPI
is a library to
build
APIs (as a server).
They are, more or less, at opposite ends, complementing each other.
Requests has a very simple and intuitive design, it's very easy to use, with sensible defaults. But at the same time, it's very powerful and customizable.
That's why, as said in the official website:
Requests is one of the most downloaded Python packages of all time
The way you use it is very simple. For example, to do a
GET
request, you would write:
response
=
requests
.
get
(
"http://example.com/some/url"
)
The FastAPI counterpart API
path operation
could look like:
@app
.
get
(
"/some/url"
)
def
read_url
():
return
{
"message"
:
"Hello World"
}
See the similarities in
requests.get(...)
and
@app.get(...)
.
Inspired
FastAPI
to
Have a simple and intuitive API.
Use HTTP method names (operations) directly, in a straightforward and intuitive way.
Have sensible defaults, but powerful customizations.
Swagger
/
OpenAPI
The main feature I wanted from Django REST Framework was the automatic API documentation.
Then I found that there was a standard to document APIs, using JSON (or YAML, an extension of JSON) called Swagger.
And there was a web user interface for Swagger APIs already created. So, being able to generate Swagger documentation for an API would allow using this web user interface automatically.
At some point, Swagger was given to the Linux Foundation, to be renamed OpenAPI.
That's why when talking about version 2.0 it's common to say "Swagger", and for version 3+ "OpenAPI".
Inspired
FastAPI
to
Adopt and use an open standard for API specifications, instead of a custom schema.
And integrate standards-based user interface tools:
Swagger UI
ReDoc
These two were chosen for being fairly popular and stable, but doing a quick search, you could find dozens of alternative user interfaces for OpenAPI (that you can use with
FastAPI
).
Flask REST frameworks
There are several Flask REST frameworks, but after investing the time and work into investigating them, I found that many are discontinued or abandoned, with several standing issues that made them unfit.
Marshmallow
One of the main features needed by API systems is data "
serialization
" which is taking data from the code (Python) and converting it into something that can be sent through the network. For example, converting an object containing data from a database into a JSON object. Converting
datetime
objects into strings, etc.
Another big feature needed by APIs is data validation, making sure that the data is valid, given certain parameters. For example, that some field is an
int
, and not some random string. This is especially useful for incoming data.
Without a data validation system, you would have to do all the checks by hand, in code.
These features are what Marshmallow was built to provide. It is a great library, and I have used it a lot before.
But it was created before there existed Python type hints. So, to define every
schema
you need to use specific utils and classes provided by Marshmallow.
Inspired
FastAPI
to
Use code to define "schemas" that provide data types and validation, automatically.
Webargs
Another big feature required by APIs is
parsing
data from incoming requests.
Webargs is a tool that was made to provide that on top of several frameworks, including Flask.
It uses Marshmallow underneath to do the data validation. And it was created by the same developers.
It's a great tool and I have used it a lot too, before having
FastAPI
.
Info
Webargs was created by the same Marshmallow developers.
Inspired
FastAPI
to
Have automatic validation of incoming request data.
APISpec
Marshmallow and Webargs provide validation, parsing and serialization as plug-ins.
But documentation is still missing. Then APISpec was created.
It is a plug-in for many frameworks (and there's a plug-in for Starlette too).
The way it works is that you write the definition of the schema using YAML format inside the docstring of each function handling a route.
And it generates OpenAPI schemas.
That's how it works in Flask, Starlette, Responder, etc.
But then, we have again the problem of having a micro-syntax, inside of a Python string (a big YAML).
The editor can't help much with that. And if we modify parameters or Marshmallow schemas and forget to also modify that YAML docstring, the generated schema would be obsolete.
Info
APISpec was created by the same Marshmallow developers.
Inspired
FastAPI
to
Support the open standard for APIs, OpenAPI.
Flask-apispec
It's a Flask plug-in, that ties together Webargs, Marshmallow and APISpec.
It uses the information from Webargs and Marshmallow to automatically generate OpenAPI schemas, using APISpec.
It's a great tool, very underrated. It should be way more popular than many Flask plug-ins out there. It might be due to its documentation being too concise and abstract.
This solved having to write YAML (another syntax) inside of Python docstrings.
This combination of Flask, Flask-apispec with Marshmallow and Webargs was my favorite backend stack until building
FastAPI
.
Using it led to the creation of several Flask full-stack generators. These are the main stacks I (and several external teams) have been using up to now:
https://github.com/tiangolo/full-stack
https://github.com/tiangolo/full-stack-flask-couchbase
https://github.com/tiangolo/full-stack-flask-couchdb
And these same full-stack generators were the base of the
FastAPI
Project Generators
.
Info
Flask-apispec was created by the same Marshmallow developers.
Inspired
FastAPI
to
Generate the OpenAPI schema automatically, from the same code that defines serialization and validation.
NestJS
(and
Angular
)
This isn't even Python, NestJS is a JavaScript (TypeScript) NodeJS framework inspired by Angular.
It achieves something somewhat similar to what can be done with Flask-apispec.
It has an integrated dependency injection system, inspired by Angular 2. It requires pre-registering the "injectables" (like all the other dependency injection systems I know), so, it adds to the verbosity and code repetition.
As the parameters are described with TypeScript types (similar to Python type hints), editor support is quite good.
But as TypeScript data is not preserved after compilation to JavaScript, it cannot rely on the types to define validation, serialization and documentation at the same time. Due to this and some design decisions, to get validation, serialization and automatic schema generation, it's needed to add decorators in many places. So, it becomes quite verbose.
It can't handle nested models very well. So, if the JSON body in the request is a JSON object that has inner fields that in turn are nested JSON objects, it cannot be properly documented and validated.
Inspired
FastAPI
to
Use Python types to have great editor support.
Have a powerful dependency injection system. Find a way to minimize code repetition.
Sanic
It was one of the first extremely fast Python frameworks based on
asyncio
. It was made to be very similar to Flask.
Technical Details
It used
uvloop
instead of the default Python
asyncio
loop. That's what made it so fast.
It clearly inspired Uvicorn and Starlette, that are currently faster than Sanic in open benchmarks.
Inspired
FastAPI
to
Find a way to have a crazy performance.
That's why
FastAPI
is based on Starlette, as it is the fastest framework available (tested by third-party benchmarks).
Falcon
Falcon is another high performance Python framework, it is designed to be minimal, and work as the foundation of other frameworks like Hug.
It is designed to have functions that receive two parameters, one "request" and one "response". Then you "read" parts from the request, and "write" parts to the response. Because of this design, it is not possible to declare request parameters and bodies with standard Python type hints as function parameters.
So, data validation, serialization, and documentation, have to be done in code, not automatically. Or they have to be implemented as a framework on top of Falcon, like Hug. This same distinction happens in other frameworks that are inspired by Falcon's design, of having one request object and one response object as parameters.
Inspired
FastAPI
to
Find ways to get great performance.
Along with Hug (as Hug is based on Falcon) inspired
FastAPI
to declare a
response
parameter in functions.
Although in FastAPI it's optional, and is used mainly to set headers, cookies, and alternative status codes.
Molten
I discovered Molten in the first stages of building
FastAPI
. And it has quite similar ideas:
Based on Python type hints.
Validation and documentation from these types.
Dependency Injection system.
It doesn't use a data validation, serialization and documentation third-party library like Pydantic, it has its own. So, these data type definitions would not be reusable as easily.
It requires a little bit more verbose configurations. And as it is based on WSGI (instead of ASGI), it is not designed to take advantage of the high performance provided by tools like Uvicorn, Starlette and Sanic.
The dependency injection system requires pre-registration of the dependencies and the dependencies are solved based on the declared types. So, it's not possible to declare more than one "component" that provides a certain type.
Routes are declared in a single place, using functions declared in other places (instead of using decorators that can be placed right on top of the function that handles the endpoint). This is closer to how Django does it than to how Flask (and Starlette) does it. It separates in the code things that are relatively tightly coupled.
Inspired
FastAPI
to
Define extra validations for data types using the "default" value of model attributes. This improves editor support, and it was not available in Pydantic before.
This actually inspired updating parts of Pydantic, to support the same validation declaration style (all this functionality is now already available in Pydantic).
Hug
Hug was one of the first frameworks to implement the declaration of API parameter types using Python type hints. This was a great idea that inspired other tools to do the same.
It used custom types in its declarations instead of standard Python types, but it was still a huge step forward.
It also was one of the first frameworks to generate a custom schema declaring the whole API in JSON.
It was not based on a standard like OpenAPI and JSON Schema. So it wouldn't be straightforward to integrate it with other tools, like Swagger UI. But again, it was a very innovative idea.
It has an interesting, uncommon feature: using the same framework, it's possible to create APIs and also CLIs.
As it is based on the previous standard for synchronous Python web frameworks (WSGI), it can't handle Websockets and other things, although it still has high performance too.
Info
Hug was created by Timothy Crosley, the same creator of
isort
, a great tool to automatically sort imports in Python files.
Ideas inspiring
FastAPI
Hug inspired parts of APIStar, and was one of the tools I found most promising, alongside APIStar.
Hug helped inspiring
FastAPI
to use Python type hints to declare parameters, and to generate a schema defining the API automatically.
Hug inspired
FastAPI
to declare a
response
parameter in functions to set headers and cookies.
APIStar
(<= 0.5)
Right before deciding to build
FastAPI
I found
APIStar
server. It had almost everything I was looking for and had a great design.
It was one of the first implementations of a framework using Python type hints to declare parameters and requests that I ever saw (before NestJS and Molten). I found it more or less at the same time as Hug. But APIStar used the OpenAPI standard.
It had automatic data validation, data serialization and OpenAPI schema generation based on the same type hints in several places.
Body schema definitions didn't use the same Python type hints like Pydantic, it was a bit more similar to Marshmallow, so, editor support wouldn't be as good, but still, APIStar was the best available option.
It had the best performance benchmarks at the time (only surpassed by Starlette).
At first, it didn't have an automatic API documentation web UI, but I knew I could add Swagger UI to it.
It had a dependency injection system. It required pre-registration of components, as other tools discussed above. But still, it was a great feature.
I was never able to use it in a full project, as it didn't have security integration, so, I couldn't replace all the features I was having with the full-stack generators based on Flask-apispec. I had in my backlog of projects to create a pull request adding that functionality.
But then, the project's focus shifted.
It was no longer an API web framework, as the creator needed to focus on Starlette.
Now APIStar is a set of tools to validate OpenAPI specifications, not a web framework.
Info
APIStar was created by Tom Christie. The same guy that created:
Django REST Framework
Starlette (in which
FastAPI
is based)
Uvicorn (used by Starlette and
FastAPI
)
Inspired
FastAPI
to
Exist.
The idea of declaring multiple things (data validation, serialization and documentation) with the same Python types, that at the same time provided great editor support, was something I considered a brilliant idea.
And after searching for a long time for a similar framework and testing many different alternatives, APIStar was the best option available.
Then APIStar stopped to exist as a server and Starlette was created, and was a new better foundation for such a system. That was the final inspiration to build
FastAPI
.
I consider
FastAPI
a "spiritual successor" to APIStar, while improving and increasing the features, typing system, and other parts, based on the learnings from all these previous tools.
Used by
FastAPI
Pydantic
Pydantic is a library to define data validation, serialization and documentation (using JSON Schema) based on Python type hints.
That makes it extremely intuitive.
It is comparable to Marshmallow. Although it's faster than Marshmallow in benchmarks. And as it is based on the same Python type hints, the editor support is great.
FastAPI
uses it to
Handle all the data validation, data serialization and automatic model documentation (based on JSON Schema).
FastAPI
then takes that JSON Schema data and puts it in OpenAPI, apart from all the other things it does.
Starlette
Starlette is a lightweight
ASGI
framework/toolkit, which is ideal for building high-performance asyncio services.
It is very simple and intuitive. It's designed to be easily extensible, and have modular components.
It has:
Seriously impressive performance.
WebSocket support.
In-process background tasks.
Startup and shutdown events.
Test client built on HTTPX.
CORS, GZip, Static Files, Streaming responses.
Session and Cookie support.
100% test coverage.
100% type annotated codebase.
Few hard dependencies.
Starlette is currently the fastest Python framework tested. Only surpassed by Uvicorn, which is not a framework, but a server.
Starlette provides all the basic web microframework functionality.
But it doesn't provide automatic data validation, serialization or documentation.
That's one of the main things that
FastAPI
adds on top, all based on Python type hints (using Pydantic). That, plus the dependency injection system, security utilities, OpenAPI schema generation, etc.
Technical Details
ASGI is a new "standard" being developed by Django core team members. It is still not a "Python standard" (a PEP), although they are in the process of doing that.
Nevertheless, it is already being used as a "standard" by several tools. This greatly improves interoperability, as you could switch Uvicorn for any other ASGI server (like Daphne or Hypercorn), or you could add ASGI compatible tools, like
python-socketio
.
FastAPI
uses it to
Handle all the core web parts. Adding features on top.
The class
FastAPI
itself inherits directly from the class
Starlette
.
So, anything that you can do with Starlette, you can do it directly with
FastAPI
, as it is basically Starlette on steroids.
Uvicorn
Uvicorn is a lightning-fast ASGI server, built on uvloop and httptools.
It is not a web framework, but a server. For example, it doesn't provide tools for routing by paths. That's something that a framework like Starlette (or
FastAPI
) would provide on top.
It is the recommended server for Starlette and
FastAPI
.
FastAPI
recommends it as
The main web server to run
FastAPI
applications.
You can also use the
--workers
command line option to have an asynchronous multi-process server.
Check more details in the
Deployment
section.
Benchmarks and speed
To understand, compare, and see the difference between Uvicorn, Starlette and FastAPI, check the section about
Benchmarks
.

## 033_ASYNC
Concurrency and async / await¬∂
---

Concurrency and async / await
Details about the
async def
syntax for
path operation functions
and some background about asynchronous code, concurrency, and parallelism.
In a hurry?
TL;DR:
If you are using third party libraries that tell you to call them with
await
, like:
results
=
await
some_library
()
Then, declare your
path operation functions
with
async def
like:
@app
.
get
(
'/'
)
async
def
read_results
():
results
=
await
some_library
()
return
results
Note
You can only use
await
inside of functions created with
async def
.
If you are using a third party library that communicates with something (a database, an API, the file system, etc.) and doesn't have support for using
await
, (this is currently the case for most database libraries), then declare your
path operation functions
as normally, with just
def
, like:
@app
.
get
(
'/'
)
def
results
():
results
=
some_library
()
return
results
If your application (somehow) doesn't have to communicate with anything else and wait for it to respond, use
async def
, even if you don't need to use
await
inside.
If you just don't know, use normal
def
.
Note
: You can mix
def
and
async def
in your
path operation functions
as much as you need and define each one using the best option for you. FastAPI will do the right thing with them.
Anyway, in any of the cases above, FastAPI will still work asynchronously and be extremely fast.
But by following the steps above, it will be able to do some performance optimizations.
Technical Details
Modern versions of Python have support for
"asynchronous code"
using something called
"coroutines"
, with
async
and
await
syntax.
Let's see that phrase by parts in the sections below:
Asynchronous Code
async
and
await
Coroutines
Asynchronous Code
Asynchronous code just means that the language üí¨ has a way to tell the computer / program ü§ñ that at some point in the code, it ü§ñ will have to wait for
something else
to finish somewhere else. Let's say that
something else
is called "slow-file" üìù.
So, during that time, the computer can go and do some other work, while "slow-file" üìù finishes.
Then the computer / program ü§ñ will come back every time it has a chance because it's waiting again, or whenever it ü§ñ finished all the work it had at that point. And it ü§ñ will see if any of the tasks it was waiting for have already finished, doing whatever it had to do.
Next, it ü§ñ takes the first task to finish (let's say, our "slow-file" üìù) and continues whatever it had to do with it.
That "wait for something else" normally refers to
I/O
operations that are relatively "slow" (compared to the speed of the processor and the RAM memory), like waiting for:
the data from the client to be sent through the network
the data sent by your program to be received by the client through the network
the contents of a file in the disk to be read by the system and given to your program
the contents your program gave to the system to be written to disk
a remote API operation
a database operation to finish
a database query to return the results
etc.
As the execution time is consumed mostly by waiting for
I/O
operations, they call them "I/O bound" operations.
It's called "asynchronous" because the computer / program doesn't have to be "synchronized" with the slow task, waiting for the exact moment that the task finishes, while doing nothing, to be able to take the task result and continue the work.
Instead of that, by being an "asynchronous" system, once finished, the task can wait in line a little bit (some microseconds) for the computer / program to finish whatever it went to do, and then come back to take the results and continue working with them.
For "synchronous" (contrary to "asynchronous") they commonly also use the term "sequential", because the computer / program follows all the steps in sequence before switching to a different task, even if those steps involve waiting.
Concurrency and Burgers
This idea of
asynchronous
code described above is also sometimes called
"concurrency"
. It is different from
"parallelism"
.
Concurrency
and
parallelism
both relate to "different things happening more or less at the same time".
But the details between
concurrency
and
parallelism
are quite different.
To see the difference, imagine the following story about burgers:
Concurrent Burgers
You go with your crush to get fast food, you stand in line while the cashier takes the orders from the people in front of you. üòç
Then it's your turn, you place your order of 2 very fancy burgers for your crush and you. üçîüçî
The cashier says something to the cook in the kitchen so they know they have to prepare your burgers (even though they are currently preparing the ones for the previous clients).
You pay. üí∏
The cashier gives you the number of your turn.
While you are waiting, you go with your crush and pick a table, you sit and talk with your crush for a long time (as your burgers are very fancy and take some time to prepare).
As you are sitting at the table with your crush, while you wait for the burgers, you can spend that time admiring how awesome, cute and smart your crush is ‚ú®üòç‚ú®.
While waiting and talking to your crush, from time to time, you check the number displayed on the counter to see if it's your turn already.
Then at some point, it finally is your turn. You go to the counter, get your burgers and come back to the table.
You and your crush eat the burgers and have a nice time. ‚ú®
Info
Beautiful illustrations by
Ketrina Thompson
. üé®
Imagine you are the computer / program ü§ñ in that story.
While you are at the line, you are just idle üò¥, waiting for your turn, not doing anything very "productive". But the line is fast because the cashier is only taking the orders (not preparing them), so that's fine.
Then, when it's your turn, you do actual "productive" work, you process the menu, decide what you want, get your crush's choice, pay, check that you give the correct bill or card, check that you are charged correctly, check that the order has the correct items, etc.
But then, even though you still don't have your burgers, your work with the cashier is "on pause" ‚è∏, because you have to wait üïô for your burgers to be ready.
But as you go away from the counter and sit at the table with a number for your turn, you can switch üîÄ your attention to your crush, and "work" ‚èØ ü§ì on that. Then you are again doing something very "productive" as is flirting with your crush üòç.
Then the cashier üíÅ says "I'm finished with doing the burgers" by putting your number on the counter's display, but you don't jump like crazy immediately when the displayed number changes to your turn number. You know no one will steal your burgers because you have the number of your turn, and they have theirs.
So you wait for your crush to finish the story (finish the current work ‚èØ / task being processed ü§ì), smile gently and say that you are going for the burgers ‚è∏.
Then you go to the counter üîÄ, to the initial task that is now finished ‚èØ, pick the burgers, say thanks and take them to the table. That finishes that step / task of interaction with the counter ‚èπ. That in turn, creates a new task, of "eating burgers" üîÄ ‚èØ, but the previous one of "getting burgers" is finished ‚èπ.
Parallel Burgers
Now let's imagine these aren't "Concurrent Burgers", but "Parallel Burgers".
You go with your crush to get parallel fast food.
You stand in line while several (let's say 8) cashiers that at the same time are cooks take the orders from the people in front of you.
Everyone before you is waiting for their burgers to be ready before leaving the counter because each of the 8 cashiers goes and prepares the burger right away before getting the next order.
Then it's finally your turn, you place your order of 2 very fancy burgers for your crush and you.
You pay üí∏.
The cashier goes to the kitchen.
You wait, standing in front of the counter üïô, so that no one else takes your burgers before you do, as there are no numbers for turns.
As you and your crush are busy not letting anyone get in front of you and take your burgers whenever they arrive, you cannot pay attention to your crush. üòû
This is "synchronous" work, you are "synchronized" with the cashier/cook üë®‚Äçüç≥. You have to wait üïô and be there at the exact moment that the cashier/cook üë®‚Äçüç≥ finishes the burgers and gives them to you, or otherwise, someone else might take them.
Then your cashier/cook üë®‚Äçüç≥ finally comes back with your burgers, after a long time waiting üïô there in front of the counter.
You take your burgers and go to the table with your crush.
You just eat them, and you are done. ‚èπ
There was not much talk or flirting as most of the time was spent waiting üïô in front of the counter. üòû
Info
Beautiful illustrations by
Ketrina Thompson
. üé®
In this scenario of the parallel burgers, you are a computer / program ü§ñ with two processors (you and your crush), both waiting üïô and dedicating their attention ‚èØ to be "waiting on the counter" üïô for a long time.
The fast food store has 8 processors (cashiers/cooks). While the concurrent burgers store might have had only 2 (one cashier and one cook).
But still, the final experience is not the best. üòû
This would be the parallel equivalent story for burgers. üçî
For a more "real life" example of this, imagine a bank.
Up to recently, most of the banks had multiple cashiers üë®‚Äçüíºüë®‚Äçüíºüë®‚Äçüíºüë®‚Äçüíº and a big line üïôüïôüïôüïôüïôüïôüïôüïô.
All of the cashiers doing all the work with one client after the other üë®‚Äçüíº‚èØ.
And you have to wait üïô in the line for a long time or you lose your turn.
You probably wouldn't want to take your crush üòç with you to run errands at the bank üè¶.
Burger Conclusion
In this scenario of "fast food burgers with your crush", as there is a lot of waiting üïô, it makes a lot more sense to have a concurrent system ‚è∏üîÄ‚èØ.
This is the case for most of the web applications.
Many, many users, but your server is waiting üïô for their not-so-good connection to send their requests.
And then waiting üïô again for the responses to come back.
This "waiting" üïô is measured in microseconds, but still, summing it all, it's a lot of waiting in the end.
That's why it makes a lot of sense to use asynchronous ‚è∏üîÄ‚èØ code for web APIs.
This kind of asynchronicity is what made NodeJS popular (even though NodeJS is not parallel) and that's the strength of Go as a programming language.
And that's the same level of performance you get with
FastAPI
.
And as you can have parallelism and asynchronicity at the same time, you get higher performance than most of the tested NodeJS frameworks and on par with Go, which is a compiled language closer to C
(all thanks to Starlette)
.
Is concurrency better than parallelism?
Nope! That's not the moral of the story.
Concurrency is different than parallelism. And it is better on
specific
scenarios that involve a lot of waiting. Because of that, it generally is a lot better than parallelism for web application development. But not for everything.
So, to balance that out, imagine the following short story:
You have to clean a big, dirty house.
Yep, that's the whole story
.
There's no waiting üïô anywhere, just a lot of work to be done, on multiple places of the house.
You could have turns as in the burgers example, first the living room, then the kitchen, but as you are not waiting üïô for anything, just cleaning and cleaning, the turns wouldn't affect anything.
It would take the same amount of time to finish with or without turns (concurrency) and you would have done the same amount of work.
But in this case, if you could bring the 8 ex-cashier/cooks/now-cleaners, and each one of them (plus you) could take a zone of the house to clean it, you could do all the work in
parallel
, with the extra help, and finish much sooner.
In this scenario, each one of the cleaners (including you) would be a processor, doing their part of the job.
And as most of the execution time is taken by actual work (instead of waiting), and the work in a computer is done by a
CPU
, they call these problems "CPU bound".
Common examples of CPU bound operations are things that require complex math processing.
For example:
Audio
or
image processing
.
Computer vision
: an image is composed of millions of pixels, each pixel has 3 values / colors, processing that normally requires computing something on those pixels, all at the same time.
Machine Learning
: it normally requires lots of "matrix" and "vector" multiplications. Think of a huge spreadsheet with numbers and multiplying all of them together at the same time.
Deep Learning
: this is a sub-field of Machine Learning, so, the same applies. It's just that there is not a single spreadsheet of numbers to multiply, but a huge set of them, and in many cases, you use a special processor to build and / or use those models.
Concurrency + Parallelism: Web + Machine Learning
With
FastAPI
you can take advantage of concurrency that is very common for web development (the same main attraction of NodeJS).
But you can also exploit the benefits of parallelism and multiprocessing (having multiple processes running in parallel) for
CPU bound
workloads like those in Machine Learning systems.
That, plus the simple fact that Python is the main language for
Data Science
, Machine Learning and especially Deep Learning, make FastAPI a very good match for Data Science / Machine Learning web APIs and applications (among many others).
To see how to achieve this parallelism in production see the section about
Deployment
.
async
and
await
Modern versions of Python have a very intuitive way to define asynchronous code. This makes it look just like normal "sequential" code and do the "awaiting" for you at the right moments.
When there is an operation that will require waiting before giving the results and has support for these new Python features, you can code it like:
burgers
=
await
get_burgers
(
2
)
The key here is the
await
. It tells Python that it has to wait ‚è∏ for
get_burgers(2)
to finish doing its thing üïô before storing the results in
burgers
. With that, Python will know that it can go and do something else üîÄ ‚èØ in the meanwhile (like receiving another request).
For
await
to work, it has to be inside a function that supports this asynchronicity. To do that, you just declare it with
async def
:
async
def
get_burgers
(
number
:
int
):
## Do some asynchronous stuff to create the burgers
return
burgers
...instead of
def
:
## This is not asynchronous
def
get_sequential_burgers
(
number
:
int
):
## Do some sequential stuff to create the burgers
return
burgers
With
async def
, Python knows that, inside that function, it has to be aware of
await
expressions, and that it can "pause" ‚è∏ the execution of that function and go do something else üîÄ before coming back.
When you want to call an
async def
function, you have to "await" it. So, this won't work:
## This won't work, because get_burgers was defined with: async def
burgers
=
get_burgers
(
2
)
So, if you are using a library that tells you that you can call it with
await
, you need to create the
path operation functions
that uses it with
async def
, like in:
@app
.
get
(
'/burgers'
)
async
def
read_burgers
():
burgers
=
await
get_burgers
(
2
)
return
burgers
More technical details
You might have noticed that
await
can only be used inside of functions defined with
async def
.
But at the same time, functions defined with
async def
have to be "awaited". So, functions with
async def
can only be called inside of functions defined with
async def
too.
So, about the egg and the chicken, how do you call the first
async
function?
If you are working with
FastAPI
you don't have to worry about that, because that "first" function will be your
path operation function
, and FastAPI will know how to do the right thing.
But if you want to use
async
/
await
without FastAPI, you can do it as well.
Write your own async code
Starlette (and
FastAPI
) are based on
AnyIO
, which makes it compatible with both Python's standard library
asyncio
and
Trio
.
In particular, you can directly use
AnyIO
for your advanced concurrency use cases that require more advanced patterns in your own code.
And even if you were not using FastAPI, you could also write your own async applications with
AnyIO
to be highly compatible and get its benefits (e.g.
structured concurrency
).
I created another library on top of AnyIO, as a thin layer on top, to improve a bit the type annotations and get better
autocompletion
,
inline errors
, etc. It also has a friendly introduction and tutorial to help you
understand
and write
your own async code
:
Asyncer
. It would be particularly useful if you need to
combine async code with regular
(blocking/synchronous) code.
Other forms of asynchronous code
This style of using
async
and
await
is relatively new in the language.
But it makes working with asynchronous code a lot easier.
This same syntax (or almost identical) was also included recently in modern versions of JavaScript (in Browser and NodeJS).
But before that, handling asynchronous code was quite more complex and difficult.
In previous versions of Python, you could have used threads or
Gevent
. But the code is way more complex to understand, debug, and think about.
In previous versions of NodeJS / Browser JavaScript, you would have used "callbacks". Which leads to
callback hell
.
Coroutines
Coroutine
is just the very fancy term for the thing returned by an
async def
function. Python knows that it is something like a function, that it can start and that it will end at some point, but that it might be paused ‚è∏ internally too, whenever there is an
await
inside of it.
But all this functionality of using asynchronous code with
async
and
await
is many times summarized as using "coroutines". It is comparable to the main key feature of Go, the "Goroutines".
Conclusion
Let's see the same phrase from above:
Modern versions of Python have support for
"asynchronous code"
using something called
"coroutines"
, with
async
and
await
syntax.
That should make more sense now. ‚ú®
All that is what powers FastAPI (through Starlette) and what makes it have such an impressive performance.
Very Technical Details
Warning
You can probably skip this.
These are very technical details of how
FastAPI
works underneath.
If you have quite some technical knowledge (coroutines, threads, blocking, etc.) and are curious about how FastAPI handles
async def
vs normal
def
, go ahead.
Path operation functions
When you declare a
path operation function
with normal
def
instead of
async def
, it is run in an external threadpool that is then awaited, instead of being called directly (as it would block the server).
If you are coming from another async framework that does not work in the way described above and you are used to defining trivial compute-only
path operation functions
with plain
def
for a tiny performance gain (about 100 nanoseconds), please note that in
FastAPI
the effect would be quite opposite. In these cases, it's better to use
async def
unless your
path operation functions
use code that performs blocking
I/O
.
Still, in both situations, chances are that
FastAPI
will
still be faster
than (or at least comparable to) your previous framework.
Dependencies
The same applies for
dependencies
. If a dependency is a standard
def
function instead of
async def
, it is run in the external threadpool.
Sub-dependencies
You can have multiple dependencies and
sub-dependencies
requiring each other (as parameters of the function definitions), some of them might be created with
async def
and some with normal
def
. It would still work, and the ones created with normal
def
would be called on an external thread (from the threadpool) instead of being "awaited".
Other utility functions
Any other utility function that you call directly can be created with normal
def
or
async def
and FastAPI won't affect the way you call it.
This is in contrast to the functions that FastAPI calls for you:
path operation functions
and dependencies.
If your utility function is a normal function with
def
, it will be called directly (as you write it in your code), not in a threadpool, if the function is created with
async def
then you should
await
for that function when you call it in your code.
Again, these are very technical details that would probably be useful if you came searching for them.
Otherwise, you should be good with the guidelines from the section above:
In a hurry?
.

## 034_AZ
FastAPI
FastAPI framework, y√ºks…ôk m…ôshuldarlƒ±, √∂yr…ônm…ôsi asan, √ßevik kodlama, istifad…ôy…ô hazƒ±rdƒ±r
S…ôn…ôdl…ôr
:
https://fastapi.tiangolo.com
Qaynaq Kodu
:
https://github.com/fastapi/fastapi
FastAPI Python il…ô API yaratmaq √º√ß√ºn standart Python
tip m…ôsl…ôh…ôtl…ôrin…ô
…ôsaslanan, m√ºasir, s√ºr…ôtli (y√ºks…ôk performanslƒ±) framework-d√ºr.
∆èsas x√ºsusiyy…ôtl…ôri bunlardƒ±r:
S√ºr…ôtli
: √áox y√ºks…ôk performans,
NodeJS
v…ô
Go
s…ôviyy…ôsind…ô (Starlette v…ô Pydantic-…ô t…ô≈ü…ôkk√ºrl…ôr).
∆èn s√ºr…ôtli Python frameworkl…ôrind…ôn biridir
.
√áevik kodlama
: Funksiyanallƒ±qlarƒ± inki≈üaf etdirm…ôk s√ºr…ôtini t…ôxmin…ôn 200%-d…ôn 300%-…ô q…ôd…ôr artƒ±rƒ±n. *
Daha az x…ôta
: ƒ∞nsan (developer) t…ôr…ôfind…ôn t√∂r…ôdil…ôn s…ôhvl…ôrin t…ôxmin…ôn 40% -ni azaldƒ±n. *
ƒ∞ntuitiv
: ∆èla redaktor d…ôst…ôyi. H…ôr yerd…ô
otomatik tamamlama
. X…ôtalarƒ± m√º…ôyy…ônl…ô≈üdirm…ôy…ô daha az vaxt s…ôrf ed…ôc…ôksiniz.
Asan
: ƒ∞stifad…ôsi v…ô √∂yr…ônilm…ôsi asan olmasƒ± √º√ß√ºn n…ôz…ôrd…ô tutulmu≈üdur. S…ôn…ôdl…ôri oxumaq √º√ß√ºn daha az vaxt ayƒ±racaqsƒ±nƒ±z.
Qƒ±sa
: Kod t…ôkrarlanmasƒ±nƒ± minimuma endirin. H…ôr bir parametr t…ôrifind…ô bird…ôn √ßox x√ºsusiyy…ôt il…ô v…ô daha az s…ôhvl…ô qar≈üƒ±la≈üacaqsƒ±nƒ±z.
G√ºcl√º
: Avtomatik v…ô interaktiv s…ôn…ôdl…ôrl…ô birlikd…ô istifad…ôy…ô hazƒ±r kod …ôld…ô ed…ô bil…ôrsiniz.
Standartlara …ôsaslanan
: API-lar √º√ß√ºn a√ßƒ±q standartlara …ôsaslanƒ±r (v…ô tam uyƒüun g…ôlir):
OpenAPI
(…ôvv…ôlki adƒ± il…ô Swagger) v…ô
JSON Schema
.
* Bu fikirl…ôr daxili development komandasƒ±nƒ±n hazƒ±rladƒ±qlarƒ± m…ôhsullarƒ±n sƒ±naqlarƒ±na …ôsaslanƒ±r.
Sponsorlar
`
Dig…ôr sponsorlar
R…ôyl…ôr
"
[...] Son g√ºnl…ôrd…ô
FastAPI
-ƒ± √ßox istifad…ô edir…ôm. [...] ∆èslind…ô onu komandamƒ±n b√ºt√ºn
Microsoftda ML sevisl…ôrind…ô
istifad…ô etm…ôyi planlayƒ±ram. Onlarƒ±n b…ôzil…ôri
windows
-un …ôsas m…ôhsuluna v…ô b…ôzi
Office
m…ôhsullarƒ±na inteqrasiya olunurlar.
"
Kabir Khan -
Microsoft
(ref)
"
FastAPI
kitabxanasƒ±nƒ±
Proqnozlar
…ôld…ô etm…ôk √º√ß√ºn sorƒüulana bil…ôn
REST
serverini yaratmaqda istifad…ô etdik.
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
b√∂hran idar…ô√ßiliyi
orkestrl…ô≈üm…ô framework-n√ºn a√ßƒ±q qaynaqlƒ± buraxƒ±lƒ±≈üƒ±nƒ± elan etm…ôkd…ôn m…ômnundur:
Dispatch
! [
FastAPI
il…ô quruldu]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
FastAPI
√º√ß√ºn h…ôy…ôcanlƒ±yam. √áox …ôyl…ônc…ôlidir!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
D√ºz√ºn√º des…ôm, sizin qurduƒüunuz ≈üey h…ôqiq…ôt…ôn m√∂hk…ôm v…ô pe≈ü…ôkar g√∂r√ºn√ºr. Bir √ßox c…ôh…ôtd…ôn
Hug
-un olmasƒ±nƒ± ist…ôdiyim kimdir - kimins…ô bel…ô bir ≈üey qurduƒüunu g√∂rm…ôk h…ôqiq…ôt…ôn ruhlandƒ±rƒ±cƒ±dƒ±r.
"
Timothy Crosley -
Hug
creator
(ref)
"
∆èg…ôr REST API-l…ôr yaratmaq √º√ß√ºn
m√ºasir framework
√∂yr…ônm…ôk ist…ôyirsinizs…ô,
FastAPI
-a baxƒ±n [...] S√ºr…ôtli, istifad…ôsi v…ô √∂yr…ônm…ôsi asandƒ±r. [...]
"
"
API
xidm…ôtl…ôrimizi
FastAPI
-a k√∂√ß√ºrd√ºk [...] Sizin d…ô b…ôy…ôn…ôc…ôyinizi d√º≈ü√ºn√ºr√ºk.
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
Python il…ô istifad…ôy…ô hazƒ±r API qurmaq ist…ôy…ôn h…ôr k…ôs…ô
FastAPI
-ƒ± t√∂vsiy…ô edir…ôm.
M√∂ht…ô≈ü…ôm ≈ü…ôkild…ô dizayn edilmi≈ü
,
istifad…ôsi asan
v…ô
y√ºks…ôk d…ôr…ôc…ôd…ô geni≈ül…ôn…ô bil…ôn
-dir, API …ôsaslƒ± inki≈üaf strategiyamƒ±zƒ±n
…ôsas komponentin…ô
√ßevrilib v…ô Virtual TAC Engineer kimi bir √ßox avtomatla≈üdƒ±rma v…ô servisl…ôri idar…ô edir.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, CLI-larƒ±n FastAPI-ƒ±
∆èg…ôr siz veb API …ôv…ôzin…ô terminalda istifad…ô edil…ôc…ôk
CLI
proqramƒ± qurursunuzsa,
Typer
-a baxa bil…ôrsiniz.
Typer
FastAPI-ƒ±n ki√ßik qarda≈üƒ±dƒ±r. V…ô o, CLI-l…ôrin
FastAPI
-ƒ± olmaq √º√ß√ºn n…ôz…ôrd…ô tutulub. ‚å®Ô∏è üöÄ
T…ôl…ôbl…ôr
FastAPI n…ôh…ôngl…ôrin √ßiyinl…ôrind…ô dayanƒ±r:
Web t…ôr…ôfi √º√ß√ºn
Starlette
.
Data t…ôr…ôfi √º√ß√ºn
Pydantic
.
Qura≈üdƒ±rma
fast ‚Üí
pip install fastapi
restart ‚Üª
T…ôtbiqimizi …ôl√ßatan etm…ôk √º√ß√ºn biz…ô
Uvicorn
v…ô ya
Hypercorn
kimi ASGI server lazƒ±mdƒ±r.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
N√ºmun…ô
Kodu yaradaq
main.py
adlƒ± fayl yaradaq v…ô ona a≈üaƒüƒ±dakƒ± kodu yerl…ô≈üdir…ôk:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
V…ô ya
async def
...
∆èg…ôr kodunuzda
async
v…ô ya
await
vardƒ±rsa
async def
istifad…ô ed…ô bil…ôrik:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Qeyd
:
∆èg…ôr bu m√∂vzu haqqƒ±nda m…ôlumatƒ±nƒ±z yoxdursa
async
v…ô
await
s…ôn…ôdind…ôki
"T…ôl…ôsirs…ôn?"
b√∂lm…ôsin…ô baxa bil…ôrsiniz.
Kodu i≈ü…ô salaq
Serveri a≈üaƒüƒ±dakƒ± …ômr il…ô i≈ü…ô salaq:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
uvicorn main:app --reload
…ômri haqqƒ±nda...
uvicorn main:app
…ômri a≈üaƒüƒ±dakƒ±lara instinad edir:
main
:
main.py
faylƒ± (y…ôni Python "modulu").
app
:
main.py
faylƒ±nda
app = FastAPI()
s…ôtrind…ô yaratdƒ±ƒüƒ±mƒ±z
FastAPI
obyektidir.
--reload
: kod d…ôyi≈üikliyind…ôn sonra avtomatik olaraq serveri yenid…ôn i≈ü…ô salƒ±r. Bu parametrd…ôn yalnƒ±z development m…ôrh…ôl…ôsind…ô istifad…ô etm…ôliyik.
ƒ∞ndi yoxlayaq
Bu linki brauzerimizd…ô a√ßaq
http://127.0.0.1:8000/items/5?q=somequery
.
A≈üaƒüƒ±dakƒ± kimi bir JSON cavabƒ± g√∂r…ôc…ôksiniz:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Siz artƒ±q bir API yaratmƒ±sƒ±nƒ±z, hansƒ± ki:
/
v…ô
/items/{item_id}
yollarƒ±nda
HTTP sorƒüularƒ±nƒ± q…ôbul edir.
H…ôr iki
yolda
GET
…ôm…ôliyyatlarƒ±nƒ±
(h…ôm√ßinin HTTP
metodlarƒ±
kimi bilinir) aparƒ±r.
/items/{item_id}
yolu
item_id
adlƒ±
int
qiym…ôti almalƒ± olan
yol parametrin…ô
sahibdir.
/items/{item_id}
yolunun
q
adlƒ± yol parametri var v…ô bu parametr ist…ôy…ô baƒülƒ± olsa da,
str
qiym…ôtini almalƒ±dƒ±r.
ƒ∞nteraktiv API S…ôn…ôdl…ôri
ƒ∞ndi
http://127.0.0.1:8000/docs
√ºnvanƒ±na daxil olun.
Avtomatik interaktiv API s…ôn…ôdl…ôrini g√∂r…ôc…ôksiniz (
Swagger UI
t…ôr…ôfind…ôn t…ômin edilir):
Alternativ API s…ôn…ôdl…ôri
ƒ∞ndi is…ô
http://127.0.0.1:8000/redoc
√ºnvanƒ±na daxil olun.
ReDoc
t…ôr…ôfind…ôn t…ôqdim edil…ôn avtomatik s…ôn…ôdl…ôri g√∂r…ôc…ôksiniz:
N√ºmun…ôni Yenil…ôy…ôk
ƒ∞ndi g…ôlin
main.py
faylƒ±nƒ±
PUT
sorƒüusu il…ô birlikd…ô
g√∂vd…ô
q…ôbul ed…ôc…ôk ≈ü…ôkild…ô d…ôyi≈üdir…ôk.
Pydantic say…ôsind…ô standart Python tipl…ôrind…ôn istifad…ô ed…ôr…ôk
g√∂vd…ô
ni m√º…ôyy…ôn ed…ôk.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Server avtomatik olaraq yenid…ôn i≈ü…ô salƒ±nmalƒ± idi (√ß√ºnki biz yuxarƒ±da
uvicorn
…ômri il…ô
--reload
parametrind…ôn istifad…ô etmi≈üik).
ƒ∞nteraktiv API s…ôn…ôdl…ôrind…ôki d…ôyi≈üikliy…ô baxaq
Yenid…ôn
http://127.0.0.1:8000/docs
√ºnvanƒ±na daxil olun.
ƒ∞nteraktiv API s…ôn…ôdl…ôri yeni g√∂vd…ô d…ô daxil olmaq il…ô avtomatik olaraq yenil…ôn…ôc…ôk:
"Try it out" d√ºym…ôsini klikl…ôyin, bu, parametrl…ôri doldurmaƒüa v…ô API il…ô birba≈üa …ôlaq…ô saxlamaƒüa imkan verir:
Sonra "Execute" d√ºym…ôsini klikl…ôyin, istifad…ô√ßi interfeysi API il…ô …ôlaq…ô quracaq, parametrl…ôri g√∂nd…ôr…ôc…ôk, n…ôtic…ôl…ôri …ôld…ô ed…ôc…ôk v…ô onlarƒ± ekranda g√∂st…ôr…ôc…ôk:
Alternativ API S…ôn…ôdl…ôrind…ôki D…ôyi≈üikliy…ô Baxaq
ƒ∞ndi is…ô yenid…ôn
http://127.0.0.1:8000/redoc
√ºnvanƒ±na daxil olun.
Alternativ s…ôn…ôdl…ôr h…ôm d…ô yeni sorƒüu parametri v…ô g√∂vd…ôsini …ôks etdir…ôc…ôk:
X√ºlas…ô
√úmumil…ô≈üdirs…ôk, parametrl…ôr, g√∂vd…ô v…ô s. Biz m…ôlumat n√∂vl…ôrini
bir d…ôf…ô
funksiya parametrl…ôri kimi t…ôyin edirik.
Bunu standart m√ºasir Python tipl…ôri il…ô edirsiniz.
Yeni sintaksis, m√º…ôyy…ôn bir kitabxananƒ±n metodlarƒ±nƒ± v…ô ya sinifl…ôrini v…ô s. √∂yr…ônm…ôk m…ôcburiyy…ôtind…ô deyilsiniz.
Sad…ôc…ô standart
Python
.
M…ôs…ôl…ôn,
int
√º√ß√ºn:
item_id
:
int
v…ô ya daha m√ºr…ôkk…ôb
Item
modeli √º√ß√ºn:
item
:
Item
...v…ô yalnƒ±z parametr tipini t…ôyin etm…ôkl…ô bunlarƒ± …ôld…ô edirsiniz:
Redaktor d…ôst…ôyi il…ô:
Avtomatik tamamlama.
Tip yoxlanmasƒ±.
M…ôlumatlarƒ±n T…ôsdiql…ônm…ôsi:
M…ôlumat etibarsƒ±z olduqda avtomatik olaraq aydƒ±n x…ôtalar g√∂st…ôrir.
H…ôtta √ßox d…ôrin JSON obyektl…ôrind…ô bel…ô doƒürulama aparƒ±r.
Daxil olan m…ôlumatlarƒ±
√ßevirm…ôk
√º√ß√ºn a≈üaƒüƒ±dakƒ± m…ôlumat n√∂vl…ôrind…ôn istifad…ô edilir:
JSON.
Yol
parametrl…ôri.
Sorƒüu
parametrl…ôri.
√á…ôr…ôzl…ôr
.
Ba≈ülƒ±qlaq
.
Formalar
.
Fayllar.
Daxil olan m…ôlumatlarƒ±
√ßevirm…ôk
√º√ß√ºn a≈üaƒüƒ±dakƒ± m…ôlumat n√∂vl…ôrind…ôn istifad…ô edilir (JSON olaraq):
Python tipl…ôrinin (
str
,
int
,
float
,
bool
,
list
, v…ô s) √ßevrilm…ôsi.
datetime
obyektl…ôri.
UUID
obyektl…ôri.
Veril…ônl…ôr bazasƒ± modell…ôri.
v…ô daha √ßoxu...
2 alternativ istifad…ô√ßi interfeysi daxil olmaqla avtomatik interaktiv API s…ôn…ôdl…ôrini t…ômin edir:
Swagger UI.
ReDoc.
G…ôlin …ôvv…ôlki n√ºmun…ôy…ô qayƒ±daq v…ô
FastAPI
-nin n…ôl…ôr ed…ôc…ôyin…ô n…ôz…ôr salaq:
GET
v…ô
PUT
sorƒüularƒ± √º√ß√ºn
item_id
-nin
yolda
olub-olmadƒ±ƒüƒ±nƒ± yoxlayacaq.
item_id
-nin
GET
v…ô
PUT
sorƒüularƒ± √º√ß√ºn n√∂v√ºn√ºn
int
olduƒüunu yoxlayacaq.
∆èg…ôr
int
deyils…ô, s…ôb…ôbini g√∂st…ôr…ôn bir x…ôta mesajƒ± g√∂st…ôr…ôc…ôkdir.
m…ôcburi olmayan
q
parametrinin
GET
(
http://127.0.0.1:8000/items/foo?q=somequery
burdakƒ± kimi) sorƒüusu i√ß…ôrisind…ô olub olmadƒ±ƒüƒ±nƒ± yoxlayacaq.
q
parametrini
= None
il…ô yaratdƒ±ƒüƒ±mƒ±z √º√ß√ºn,
m…ôcburi olmayan
parametr olacaq.
∆èg…ôr
None
olmasaydƒ±, bu m…ôcburi parametr olardƒ± (
PUT
metodunun g√∂vd…ôsind…ô olduƒüu kimi).
PUT
sorƒüusu √º√ß√ºn,
/items/{item_id}
g√∂vd…ôsini JSON olaraq oxuyacaq:
name
adƒ±nda m…ôcburi bir parametr olub olmadƒ±ƒüƒ±nƒ± v…ô …ôg…ôr varsa, tipinin
str
olub olmadƒ±ƒüƒ±nƒ± yoxlayacaq.
price
adƒ±nda m…ôcburi bir parametr olub olmadƒ±ƒüƒ±nƒ± v…ô …ôg…ôr varsa, tipinin
float
olub olmadƒ±ƒüƒ±nƒ± yoxlayacaq.
is_offer
adƒ±nda
m…ôcburi olmayan
bir parametr olub olmadƒ±ƒüƒ±nƒ± v…ô …ôg…ôr varsa, tipinin
float
olub olmadƒ±ƒüƒ±nƒ± yoxlayacaq.
B√ºt√ºn bunlar …ôn d…ôrin JSON obyektl…ôrind…ô bel…ô i≈ül…ôy…ôc…ôk.
M…ôlumatlarƒ±n JSON-a v…ô JSON-un Python obyektin…ô √ßevrilm…ôsi avtomatik h…ôyata ke√ßiril…ôc…ôk.
H…ôr ≈üeyi OpenAPI il…ô uyƒüun olacaq ≈ü…ôkild…ô avtomatik olaraq s…ôn…ôdl…ô≈üdir…ôc…ôk v…ô onlarƒ± a≈üaƒüƒ±dakƒ± kimi istifad…ô ed…ô bil…ôc…ôk:
ƒ∞nteraktiv s…ôn…ôdl…ô≈üm…ô sisteml…ôri.
Bir √ßox proqramla≈üdƒ±rma dill…ôri √º√ß√ºn avtomatla≈üdƒ±rƒ±lmƒ±≈ü
m√º≈üt…ôri
kodu yaratma sisteml…ôri.
2 interaktiv s…ôn…ôdl…ô≈üm…ô veb interfeysini birba≈üa t…ômin ed…ôc…ôk.
Yeni ba≈ülamƒ±≈üƒ±q, amma siz artƒ±q i≈üin m…ôntiqini ba≈üa d√º≈üm√ºs√ºn√ºz.
ƒ∞ndi a≈üaƒüƒ±dakƒ± s…ôtri d…ôyi≈üdirm…ôy…ô √ßalƒ±≈üƒ±n:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...bundan:
...
"item_name"
:
item
.
name
...
...buna:
...
"item_price"
:
item
.
price
...
...v…ô redaktorun m…ôlumat tipl…ôrini bildiyini v…ô avtomatik tamaladƒ±ƒüƒ±nƒ± g√∂r…ôc…ôksiniz:
Daha √ßox funksiyaya malik daha dolƒüun n√ºmun…ô √º√ß√ºn
√ñyr…ôdici - ƒ∞stifad…ô√ßi T…ôlimatƒ±
s…ôhif…ôsin…ô baxa bil…ôrsiniz.
Spoiler x…ôb…ôrdarlƒ±ƒüƒ±
: √ñyr…ôdici - istifad…ô√ßi t…ôlimatƒ±na bunlar daxildir:
Parametrl…ôrin
,
ba≈ülƒ±qlar
,
√ß…ôr…ôzl…ôr
,
forma sah…ôl…ôri
v…ô
fayllar
olaraq m√º…ôyy…ôn edilm…ôsi.
maximum_length
v…ô ya
regex
kimi
doƒürulama m…ôhdudiyy…ôtl…ôrinin
nec…ô t…ôyin edil…ôc…ôyi.
√áox g√ºcl√º v…ô istifad…ôsi asan
Dependency Injection
sistemi.
T…ôhl√ºk…ôsizlik v…ô autentifikasiya,
JWT tokenl…ôri
il…ô
OAuth2
d…ôst…ôyi v…ô
HTTP Basic
autentifikasiyasƒ±.
√ßox d…ôrin JSON modell…ôrini
m√º…ôyy…ôn etm…ôk √º√ß√ºn daha ir…ôli s…ôviyy…ô (lakin eyni d…ôr…ôc…ôd…ô asan) √ºsullar (Pydantic say…ôsind…ô).
Strawberry
v…ô dig…ôr kitabxanalar il…ô
GraphQL
inteqrasiyasƒ±.
Dig…ôr …ôlav…ô x√ºsusiyy…ôtl…ôr (Starlette say…ôsind…ô):
WebSockets
HTTPX v…ô
pytest
say…ôsind…ô √ßox asan testl…ôr
CORS
Cookie Sessions
...v…ô daha √ßoxu.
Performans
M√ºst…ôqil TechEmpower meyarlarƒ± g√∂st…ôrir ki, Uvicorn √ºz…ôrind…ô i≈ül…ôy…ôn
FastAPI
proqramlarƒ±
…ôn s√ºr…ôtli Python kitabxanalarƒ±ndan biridir
, yalnƒ±z Starlette v…ô Uvicorn-un √∂z√ºnd…ôn yava≈üdƒ±r, ki FastAPI bunlarƒ±n √ºz…ôrin…ô qurulmu≈ü bir framework-d√ºr. (*)
∆ètraflƒ± m…ôlumat √º√ß√ºn bu b√∂lm…ôy…ô n…ôz…ôr salƒ±n
M√ºqayis…ôl…ôr
.
M…ôcburi Olmayan T…ôl…ôbl…ôr
Pydantic t…ôr…ôfind…ôn istifad…ô olunanlar:
email-validator
- e-po√ßtun yoxlanƒ±lmasƒ± √º√ß√ºn.
pydantic-settings
- parametrl…ôrin idar…ô edilm…ôsi √º√ß√ºn.
pydantic-extra-types
- Pydantic il…ô istifad…ô edil…ô bil…ôn …ôlav…ô tipl…ôr √º√ß√ºn.
Starlette t…ôr…ôfind…ôn istifad…ô olunanlar:
httpx
- ∆èg…ôr
TestClient
strukturundan istifad…ô ed…ôc…ôksinizs…ô, t…ôl…ôb olunur.
jinja2
- Standart
≈üablon
konfiqurasiyasƒ±ndan istifad…ô etm…ôk ist…ôyirsinizs…ô, t…ôl…ôb olunur.
python-multipart
-
request.form()
il…ô forma
"√ßevirm…ô"
d…ôst…ôyind…ôn istifad…ô etm…ôk ist…ôyirsinizs…ô, t…ôl…ôb olunur.
itsdangerous
-
SessionMiddleware
d…ôst…ôyi √º√ß√ºn t…ôl…ôb olunur.
pyyaml
-
SchemaGenerator
d…ôst…ôyi √º√ß√ºn t…ôl…ôb olunur (√áox g√ºman ki, FastAPI istifad…ô ed…ôrk…ôn buna ehtiyacƒ±nƒ±z olmayacaq).
ujson
-
UJSONResponse
istifad…ô etm…ôk ist…ôyirsinizs…ô, t…ôl…ôb olunur.
H…ôm FastAPI, h…ôm d…ô Starlette t…ôr…ôfind…ôn istifad…ô olunur:
uvicorn
- Yaratdƒ±ƒüƒ±mƒ±z proqramƒ± servis ed…ôc…ôk veb server kimi f…ôaliyy…ôt g√∂st…ôrir.
orjson
-
ORJSONResponse
istifad…ô ed…ôc…ôksinizs…ô t…ôl…ôb olunur.
B√ºt√ºn bunlarƒ±
pip install fastapi[all]
il…ô qura≈üdƒ±ra bil…ôrsiniz.
Lisenziya
Bu layih…ô MIT lisenziyasƒ±nƒ±n ≈ü…ôrtl…ôrin…ô …ôsas…ôn lisenziyala≈üdƒ±rƒ±lƒ±b.

## 035_BENCHMARKS
Benchmarks¬∂
---

Benchmarks
Independent TechEmpower benchmarks show
FastAPI
applications running under Uvicorn as
one of the fastest Python frameworks available
, only below Starlette and Uvicorn themselves (used internally by FastAPI).
But when checking benchmarks and comparisons you should keep the following in mind.
Benchmarks and speed
When you check the benchmarks, it is common to see several tools of different types compared as equivalent.
Specifically, to see Uvicorn, Starlette and FastAPI compared together (among many other tools).
The simpler the problem solved by the tool, the better performance it will get. And most of the benchmarks don't test the additional features provided by the tool.
The hierarchy is like:
Uvicorn
: an ASGI server
Starlette
: (uses Uvicorn) a web microframework
FastAPI
: (uses Starlette) an API microframework with several additional features for building APIs, with data validation, etc.
Uvicorn
:
Will have the best performance, as it doesn't have much extra code apart from the server itself.
You wouldn't write an application in Uvicorn directly. That would mean that your code would have to include more or less, at least, all the code provided by Starlette (or
FastAPI
). And if you did that, your final application would have the same overhead as having used a framework and minimizing your app code and bugs.
If you are comparing Uvicorn, compare it against Daphne, Hypercorn, uWSGI, etc. Application servers.
Starlette
:
Will have the next best performance, after Uvicorn. In fact, Starlette uses Uvicorn to run. So, it probably can only get "slower" than Uvicorn by having to execute more code.
But it provides you the tools to build simple web applications, with routing based on paths, etc.
If you are comparing Starlette, compare it against Sanic, Flask, Django, etc. Web frameworks (or microframeworks).
FastAPI
:
The same way that Starlette uses Uvicorn and cannot be faster than it,
FastAPI
uses Starlette, so it cannot be faster than it.
FastAPI provides more features on top of Starlette. Features that you almost always need when building APIs, like data validation and serialization. And by using it, you get automatic documentation for free (the automatic documentation doesn't even add overhead to running applications, it is generated on startup).
If you didn't use FastAPI and used Starlette directly (or another tool, like Sanic, Flask, Responder, etc) you would have to implement all the data validation and serialization yourself. So, your final application would still have the same overhead as if it was built using FastAPI. And in many cases, this data validation and serialization is the biggest amount of code written in applications.
So, by using FastAPI you are saving development time, bugs, lines of code, and you would probably get the same performance (or better) you would if you didn't use it (as you would have to implement it all in your code).
If you are comparing FastAPI, compare it against a web application framework (or set of tools) that provides data validation, serialization and documentation, like Flask-apispec, NestJS, Molten, etc. Frameworks with integrated automatic data validation, serialization and documentation.

## 036_BN
FastAPI
FastAPI ‡¶â‡¶ö‡ßç‡¶ö‡¶ï‡ßç‡¶∑‡¶Æ‡¶§‡¶æ ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®, ‡¶∏‡¶π‡¶ú‡ßá ‡¶∂‡ßá‡¶ñ‡¶æ‡¶∞ ‡¶è‡¶¨‡¶Ç ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡ßã‡¶° ‡¶ï‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡¶∂‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶´‡ßç‡¶∞‡¶æ‡¶Æ‡¶ì‡ßü‡¶æ‡¶∞‡ßç‡¶ï‡•§
‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø
:
https://fastapi.tiangolo.com
‡¶∏‡ßã‡¶∞‡ßç‡¶∏ ‡¶ï‡ßã‡¶°
:
https://github.com/fastapi/fastapi
FastAPI ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï, ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ( ‡¶¨‡ßá‡¶∂‡¶ø ‡¶ï‡ßç‡¶∑‡¶Æ‡¶§‡¶æ ) ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®, Python 3.6+ ‡¶¶‡¶ø‡ßü‡ßá API ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶æ‡¶∞‡ßç‡¶° ‡¶™‡¶æ‡¶á‡¶•‡¶® ‡¶ü‡¶æ‡¶á‡¶™ ‡¶á‡¶ô‡ßç‡¶ó‡¶ø‡¶§ ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶ì‡¶Ø‡¶º‡ßá‡¶¨ ‡¶´‡ßç‡¶∞‡ßá‡¶Æ‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï‡•§
‡¶è‡¶∞ ‡¶Æ‡ßÇ‡¶≤ ‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡ßç‡¶ü‡ßç‡¶Ø ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶π‡¶≤‡¶É
‡¶ó‡¶§‡¶ø
: ‡¶è‡¶ü‡¶ø
NodeJS
‡¶è‡¶¨‡¶Ç
Go
‡¶è‡¶∞ ‡¶Æ‡¶§ ‡¶ï‡¶æ‡¶∞‡ßç‡¶Ø‡¶ï‡ßç‡¶∑‡¶Æ‡¶§‡¶æ ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® (Starlette ‡¶è‡¶¨‡¶Ç Pydantic ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø‡ßá)‡•§
‡¶™‡¶æ‡¶á‡¶•‡¶® ‡¶è‡¶∞ ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§‡¶§‡¶Æ ‡¶´‡ßç‡¶∞‡ßá‡¶Æ‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶è‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø
‡•§
‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ï‡ßã‡¶° ‡¶ï‡¶∞‡¶æ
:‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡ßç‡¶ü‡ßç‡¶Ø ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶ó‡¶§‡¶ø ‡ß®‡ß¶‡ß¶% ‡¶•‡ßá‡¶ï‡ßá ‡ß©‡ß¶‡ß¶% ‡¶¨‡ßÉ‡¶¶‡ßç‡¶ß‡¶ø ‡¶ï‡¶∞‡ßá‡ß∑ *
‡¶∏‡ßç‡¶¨‡¶≤‡ßç‡¶™ bugs
: ‡¶Æ‡¶æ‡¶®‡ßÅ‡¶¨ (‡¶°‡ßá‡¶≠‡ßá‡¶≤‡¶™‡¶æ‡¶∞) ‡¶∏‡ßÉ‡¶∑‡ßç‡¶ü ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø‡¶∞ ‡¶™‡ßç‡¶∞‡¶æ‡¶Ø‡¶º ‡ß™‡ß¶% ‡¶π‡ßç‡¶∞‡¶æ‡¶∏ ‡¶ï‡¶∞‡ßá‡•§ *
‡¶∏‡ßç‡¶¨‡¶ú‡ßç‡¶û‡¶æ‡¶§
: ‡¶¶‡ßÅ‡¶∞‡ßç‡¶¶‡¶æ‡¶®‡ßç‡¶§ ‡¶è‡¶°‡¶ø‡¶ü‡¶∞ ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø
Completion
‡¶®‡¶æ‡¶Æ‡ßá‡¶ì ‡¶™‡¶∞‡¶ø‡¶ö‡¶ø‡¶§‡•§ ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶°‡¶ø‡¶¨‡¶æ‡¶ó ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§
‡¶∏‡¶π‡¶ú
: ‡¶è‡¶ü‡¶ø ‡¶è‡¶Æ‡¶® ‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶ú‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶Ø‡ßá‡¶® ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø ‡¶™‡ßú‡ßá ‡¶∏‡¶π‡¶ú‡ßá ‡¶∂‡ßá‡¶ñ‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§
‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§
: ‡¶ï‡ßã‡¶° ‡¶™‡ßÅ‡¶®‡¶∞‡¶æ‡¶¨‡ßÉ‡¶§‡ßç‡¶§‡¶ø ‡¶ï‡¶Æ‡¶æ‡¶®‡ßã‡¶∞ ‡¶™‡¶æ‡¶∂‡¶æ‡¶™‡¶æ‡¶∂‡¶ø, bug ‡¶ï‡¶Æ‡¶æ‡ßü ‡¶è‡¶¨‡¶Ç ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶ò‡ßã‡¶∑‡¶£‡¶æ ‡¶•‡ßá‡¶ï‡ßá ‡¶è‡¶ï‡¶æ‡¶ß‡¶ø‡¶ï ‡¶´‡¶ø‡¶ö‡¶æ‡¶∞ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü ‡•§
‡¶ú‡ßã‡¶∞‡¶æ‡¶≤‡ßã
: ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶≠‡¶æ‡¶¨‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ‡¶∂‡ßÄ‡¶≤ ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶®‡¶æ ‡¶®‡¶•‡¶ø (documentation) ‡¶∏‡¶π ‡¶â‡ßé‡¶™‡¶æ‡¶¶‡¶® ‡¶â‡¶™‡¶Ø‡ßã‡¶ó‡¶ø (Production-ready) ‡¶ï‡ßã‡¶° ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡•§
‡¶Æ‡¶æ‡¶®-‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï
: ‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø
OpenAPI
(‡¶Ø‡¶æ ‡¶™‡ßÅ‡¶∞‡ßç‡¶¨‡ßá Swagger ‡¶®‡¶æ‡¶Æ‡ßá ‡¶™‡¶∞‡¶ø‡¶ö‡¶ø‡¶§ ‡¶õ‡¶ø‡¶≤) ‡¶è‡¶¨‡¶Ç
JSON Schema
‡¶è‡¶∞ ‡¶Ü‡¶¶‡¶∞‡ßç‡¶∂‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶®‡ßá‡¶∞ ‡¶ì‡¶™‡¶∞
* ‡¶â‡ßé‡¶™‡¶æ‡¶¶‡¶®‡¶Æ‡ßÅ‡¶ñ‡¶ø ‡¶è‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶¨‡¶æ‡¶®‡¶æ‡¶®‡ßã‡¶∞ ‡¶è‡¶ï ‡¶¶‡¶≤ ‡¶°‡ßá‡¶≠‡ßá‡¶≤‡¶™‡¶æ‡¶∞ ‡¶è‡¶∞ ‡¶Æ‡¶§‡¶æ‡¶Æ‡¶§ ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶´‡¶≤‡¶æ‡¶´‡¶≤‡•§
‡¶∏‡ßç‡¶™‡¶®‡¶∏‡¶∞ ‡¶ó‡¶£
‡¶Ö‡¶®‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶Ø ‡¶∏‡ßç‡¶™‡¶®‡¶∏‡¶∞ ‡¶ó‡¶£
‡¶Æ‡¶§‡¶æ‡¶Æ‡¶§ ‡¶∏‡¶Æ‡ßÇ‡¶π
"
‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶ú‡¶ï‡¶æ‡¶≤
FastAPI
‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶õ‡¶ø‡•§ [...] ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶≠‡¶æ‡¶¨‡¶õ‡¶ø ‡¶Æ‡¶æ‡¶á‡¶ï‡ßç‡¶∞‡ßã‡¶∏‡¶´‡ßç‡¶ü‡ßá
ML ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏
‡¶è ‡¶∏‡¶ï‡¶≤ ‡¶¶‡¶≤‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡•§ ‡¶Ø‡¶æ‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶™‡¶£‡ßç‡¶Ø
Windows
‡¶è ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶Ø‡¶® ‡¶π‡ßü ‡¶è‡¶¨‡¶Ç ‡¶ï‡¶ø‡¶õ‡ßÅ
Office
‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶Ø‡¶® ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§
"
‡¶ï‡¶¨‡¶ø‡¶∞ ‡¶ñ‡¶æ‡¶® -
‡¶Æ‡¶æ‡¶á‡¶ï‡ßç‡¶∞‡ßã‡¶∏‡¶´‡ßç‡¶ü‡ßá
(ref)
"
‡¶Ü‡¶Æ‡¶∞‡¶æ
FastAPI
‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡¶ø ‡¶ó‡ßç‡¶∞‡¶π‡¶£ ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø
REST
‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶§‡ßá, ‡¶Ø‡¶æ
‡¶≠‡¶¨‡¶ø‡¶∑‡ßç‡¶Ø‡¶¶‡ßç‡¶¨‡¶æ‡¶£‡ßÄ
‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ï‡ßÅ‡ßü‡ßá‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶Ø‡ßá‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§ [‡¶≤‡ßÅ‡¶°‡¶â‡¶á‡¶ó‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø]
"
‡¶™‡¶ø‡¶Ø‡¶º‡ßá‡¶∞‡ßã ‡¶Æ‡ßã‡¶≤‡¶ø‡¶®‡ßã, ‡¶á‡¶Ø‡¶º‡¶æ‡¶∞‡ßã‡¶∏‡ßç‡¶≤‡¶æ‡¶≠ ‡¶¶‡ßÅ‡¶¶‡¶ø‡¶®, ‡¶è‡¶¨‡¶Ç ‡¶∏‡¶æ‡¶á ‡¶∏‡ßÅ‡¶Æ‡¶®‡ßç‡¶• ‡¶Æ‡¶ø‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶≤‡¶æ -
‡¶â‡¶¨‡¶æ‡¶∞
(ref)
"
Netflix
‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞
‡¶ï‡ßç‡¶∞‡¶æ‡¶á‡¶∏‡¶ø‡¶∏ ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶ú‡¶Æ‡ßá‡¶®‡ßç‡¶ü
‡¶Ö‡¶∞‡ßç‡¶ï‡ßá‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡ßá‡¶∂‡¶® ‡¶´‡ßç‡¶∞‡ßá‡¶Æ‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï:
‡¶°‡¶ø‡¶∏‡¶™‡ßç‡¶Ø‡¶æ‡¶ö
‡¶è‡¶∞ ‡¶ì‡¶™‡ßá‡¶® ‡¶∏‡ßã‡¶∞‡ßç‡¶∏ ‡¶∞‡¶ø‡¶≤‡¶ø‡¶ú ‡¶ò‡ßã‡¶∑‡¶£‡¶æ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡ßá‡¶∞‡ßá ‡¶Ü‡¶®‡¶®‡ßç‡¶¶‡¶ø‡¶§! [‡¶Ø‡¶æ‡¶ï‡¶ø‡¶®‡¶æ
FastAPI
‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶®‡¶ø‡¶∞‡ßç‡¶Æ‡¶ø‡¶§]
"
‡¶ï‡ßá‡¶≠‡¶ø‡¶® ‡¶ó‡ßç‡¶≤‡¶ø‡¶∏‡¶®, ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ï ‡¶≠‡¶ø‡¶≤‡¶æ‡¶®‡ßã‡¶≠‡¶æ, ‡¶´‡¶∞‡ßá‡¶∏‡ßç‡¶ü ‡¶Æ‡¶®‡¶∏‡ßá‡¶® -
‡¶®‡ßá‡¶ü‡¶´‡ßç‡¶≤‡¶ø‡¶ï‡ßç‡¶∏
(ref)
"
‡¶Ü‡¶Æ‡¶ø
FastAPI
‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶ö‡¶æ‡¶Å‡¶¶‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶æ‡¶® ‡¶â‡ßé‡¶∏‡¶æ‡¶π‡¶ø‡¶§‡•§ ‡¶è‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶¨‡¶á ‡¶Æ‡¶ú‡¶æ‡¶∞!
"
‡¶¨‡ßç‡¶∞‡¶æ‡¶Ø‡¶º‡¶æ‡¶® ‡¶ì‡¶ï‡ßá‡¶® -
‡¶™‡¶æ‡¶á‡¶•‡¶® ‡¶¨‡¶æ‡¶á‡¶ü‡¶∏
‡¶™‡¶°‡¶ï‡¶æ‡¶∏‡ßç‡¶ü ‡¶π‡ßã‡¶∏‡ßç‡¶ü
(ref)
"_‡¶∏‡¶§‡ßç‡¶Ø‡¶ø‡¶á, ‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡¶æ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‡¶® ‡¶§‡¶æ ‡¶ñ‡ßÅ‡¶¨ ‡¶Æ‡¶ú‡¶¨‡ßÅ‡¶§ ‡¶è‡¶¨‡¶Ç ‡¶™‡¶∞‡¶ø‡¶™‡ßÇ‡¶∞‡ßç‡¶®‡ß∑ ‡¶Ö‡¶®‡ßá‡¶ï ‡¶â‡¶™‡¶æ‡¶Ø‡¶º‡ßá, ‡¶Ü‡¶Æ‡¶ø ‡¶Ø‡¶æ
Hug
‡¶è ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡ßá‡ßü‡ßá‡¶õ‡¶ø‡¶≤‡¶æ‡¶Æ - ‡¶§‡¶æ ‡¶ï‡¶æ‡¶â‡¶ï‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶¶‡ßá‡¶ñ‡ßá ‡¶Ü‡¶Æ‡¶ø ‡¶∏‡¶§‡ßç‡¶Ø‡¶ø‡¶á ‡¶Ö‡¶®‡ßÅ‡¶™‡ßç‡¶∞‡¶æ‡¶®‡¶ø‡¶§‡ß∑_"
‡¶ü‡¶ø‡¶Æ‡ßã‡¶•‡¶ø ‡¶ï‡ßç‡¶∞‡¶∏‡¶≤‡ßá -
Hug
‡¶∏‡ßç‡¶∞‡¶∑‡ßç‡¶ü‡¶æ
(ref)
"‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡¶¶‡¶ø REST API ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø
‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï ‡¶´‡ßç‡¶∞‡ßá‡¶Æ‡¶ì‡ßü‡¶æ‡¶∞‡ßç‡¶ï
‡¶∂‡¶ø‡¶ñ‡¶§‡ßá ‡¶ö‡¶æ‡¶®, ‡¶§‡¶æ‡¶π‡¶≤‡ßá
FastAPI
‡¶¶‡ßá‡¶ñ‡ßÅ‡¶® [...] ‡¶è‡¶ü‡¶ø ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§, ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶∏‡¶π‡¶ú ‡¶è‡¶¨‡¶Ç ‡¶∂‡¶ø‡¶ñ‡¶§‡ßá‡¶ì ‡¶∏‡¶π‡¶ú [...]_"
"
‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞
APIs
[...] ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
FastAPI
- ‡¶§‡ßá ‡¶è‡¶∏‡ßá‡¶õ‡¶ø [...] ‡¶Ü‡¶Æ‡¶ø ‡¶Æ‡¶®‡ßá ‡¶ï‡¶∞‡¶ø ‡¶Ü‡¶™‡¶®‡¶ø‡¶ì ‡¶è‡¶ü‡¶ø ‡¶™‡¶õ‡¶®‡ßç‡¶¶ ‡¶ï‡¶∞‡¶¨‡ßá‡¶® [...]
"
‡¶á‡¶®‡ßá‡¶∏ ‡¶Æ‡¶®‡ßç‡¶ü‡¶æ‡¶®‡¶ø - ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶•‡¶ø‡¶â ‡¶π‡ßã‡¶®‡¶ø‡¶¨‡¶æ‡¶≤ -
Explosion AI
‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶∑‡ßç‡¶†‡¶æ‡¶§‡¶æ -
spaCy
‡¶∏‡ßç‡¶∞‡¶∑‡ßç‡¶ü‡¶æ
(ref)
-
(ref)
Typer
, CLI ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø FastAPI
‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡¶¶‡¶ø
CLI
‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ ‡¶¨‡¶æ‡¶®‡¶æ‡¶§‡ßá ‡¶ö‡¶æ‡¶®, ‡¶Ø‡¶æ ‡¶ï‡¶ø‡¶®‡¶æ ‡¶ì‡ßü‡ßá‡¶¨ API ‡¶è‡¶∞ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡ßá ‡¶ü‡¶æ‡¶∞‡ßç‡¶Æ‡¶ø‡¶®‡¶æ‡¶≤‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡¶¨‡ßá, ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®
Typer
.
‡¶ü‡¶æ‡¶á‡¶™‡¶æ‡¶∞
‡¶π‡¶≤ FastAPI ‡¶è‡¶∞ ‡¶õ‡ßã‡¶ü ‡¶≠‡¶æ‡¶á‡ßü‡ßá‡¶∞ ‡¶Æ‡¶§‡•§ ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ü‡¶ø‡¶∞ ‡¶â‡¶¶‡ßç‡¶¶‡ßá‡¶∂‡ßç‡¶Ø ‡¶õ‡¶ø‡¶≤
CLIs ‡¶è‡¶∞ FastAPI
‡¶π‡¶ì‡ßü‡¶æ‡•§ ‚å®Ô∏è üöÄ
‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡ßÄ‡¶Ø‡¶º‡¶§‡¶æ ‡¶ó‡ßÅ‡¶≤‡ßã
Python 3.7+
FastAPI ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶¶‡¶æ‡¶®‡¶¨‡ßá‡¶¶‡ßá‡¶∞ ‡¶ï‡¶æ‡¶Å‡¶ß‡ßá ‡¶¶‡¶æ‡¶Å‡¶°‡¶º‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ü‡¶õ‡ßá:
Starlette
‡¶ì‡¶Ø‡¶º‡ßá‡¶¨ ‡¶Ö‡¶Ç‡¶∂‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø.
Pydantic
‡¶°‡ßá‡¶ü‡¶æ ‡¶Ö‡¶Ç‡¶∂‡¶ó‡ßÅ‡¶≤‡¶ø‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø.
‡¶á‡¶®‡¶∏‡ßç‡¶ü‡¶≤‡ßá‡¶∂‡¶® ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ
fast ‚Üí
pip install fastapi
restart ‚Üª
‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ASGI ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞‡ßá‡¶∞‡¶ì ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶® ‡¶π‡¶¨‡ßá, ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡¶∂‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
Uvicorn
‡¶Ö‡¶•‡¶¨‡¶æ
Hypercorn
.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£
‡¶§‡ßà‡¶∞‡¶ø
main.py
‡¶®‡¶æ‡¶Æ‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶´‡¶æ‡¶á‡¶≤ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
‡¶Ö‡¶•‡¶¨‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®
async def
...
‡¶Ø‡¶¶‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßã‡¶°
async
/
await
, ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶§‡¶æ‡¶π‡¶≤‡ßá
async def
‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
‡¶ü‡ßÄ‡¶ï‡¶æ
:
‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡¶¶‡¶ø ‡¶®‡¶æ ‡¶ú‡¶æ‡¶®‡ßá‡¶®,
"‡¶§‡¶æ‡¶°‡¶º‡¶æ‡¶π‡ßÅ‡¶°‡¶º‡ßã?"
‡¶¨‡¶ø‡¶≠‡¶æ‡¶ó‡¶ü‡¶ø ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®
async
‡¶è‡¶¨‡¶Ç
await
‡¶®‡¶•‡¶ø‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®
.
‡¶è‡¶ü‡¶ø ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®
‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶®‡¶æ ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá
uvicorn main:app --reload
...
uvicorn main:app
‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶®‡¶æ‡¶ü‡¶ø ‡¶¶‡ßç‡¶¨‡¶æ‡¶∞‡¶æ ‡¶¨‡ßã‡¶ù‡¶æ‡¶Ø‡¶º:
main
: ‡¶´‡¶æ‡¶á‡¶≤
main.py
(‡¶™‡¶æ‡¶á‡¶•‡¶® "‡¶Æ‡¶°‡¶ø‡¶â‡¶≤")‡•§
app
:
app = FastAPI()
‡¶≤‡¶æ‡¶á‡¶® ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá
main.py
‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡¶∞‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶Ö‡¶¨‡¶ú‡ßá‡¶ï‡ßç‡¶ü‡•§
--reload
: ‡¶ï‡ßã‡¶° ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®‡ßá‡¶∞ ‡¶™‡¶∞‡ßá ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶™‡ßÅ‡¶®‡¶∞‡¶æ‡¶Ø‡¶º ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶è‡¶ü‡¶ø ‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶°‡ßá‡¶≠‡ßá‡¶≤‡¶™‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶è‡¶∞ ‡¶∏‡¶Æ‡ßü ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§
‡¶è‡¶ü‡¶æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®
‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡ßç‡¶∞‡¶æ‡¶â‡¶ú‡¶æ‡¶∞ ‡¶ñ‡ßÅ‡¶≤‡ßÅ‡¶®
http://127.0.0.1:8000/items/5?q=somequery
‡¶è‡•§
‡¶Ü‡¶™‡¶®‡¶ø JSON ‡¶∞‡ßá‡¶∏‡¶™‡¶®‡ßç‡¶∏ ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶¨‡ßá‡¶®:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
‡¶Ü‡¶™‡¶®‡¶ø ‡¶á‡¶§‡¶ø‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶è‡¶ï‡¶ü‡¶ø API ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‡¶® ‡¶Ø‡¶æ:
/
‡¶è‡¶¨‡¶Ç
/items/{item_id}
paths
‡¶è HTTP ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶ó‡ßç‡¶∞‡¶π‡¶£ ‡¶ï‡¶∞‡ßá‡•§
‡¶â‡¶≠‡¶Ø‡¶º
path
‡¶á
GET
‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶®
‡¶®‡ßá‡¶Ø‡¶º ( ‡¶Ø‡¶æ HTTP
methods
‡¶®‡¶æ‡¶Æ‡ßá‡¶ì ‡¶™‡¶∞‡¶ø‡¶ö‡¶ø‡¶§)‡•§
path
/items/{item_id}
-‡¶è ‡¶è‡¶ï‡¶ü‡¶ø
path ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞
item_id
‡¶Ü‡¶õ‡ßá ‡¶Ø‡¶æ ‡¶ï‡¶ø‡¶®‡¶æ
int
‡¶π‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§
path
/items/{item_id}
-‡¶è‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ê‡¶ö‡ßç‡¶õ‡¶ø‡¶ï
str
query ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞
q
‡¶Ü‡¶õ‡ßá‡•§
‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ‡¶∂‡ßÄ‡¶≤ API ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø
‡¶è‡¶ñ‡¶® ‡¶Ø‡¶æ‡¶®
http://127.0.0.1:8000/docs
.
‡¶Ü‡¶™‡¶®‡¶ø ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶≠‡¶æ‡¶¨‡ßá ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§ ‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ‡¶∂‡ßÄ‡¶≤ API ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶¨‡ßá‡¶® (
Swagger UI
‡¶™‡ßç‡¶∞‡¶¶‡¶§‡ßç‡¶§):
‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ API ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø
‡¶è‡¶¨‡¶Ç ‡¶è‡¶ñ‡¶®
http://127.0.0.1:8000/redoc
‡¶è ‡¶Ø‡¶æ‡¶®.
‡¶Ü‡¶™‡¶®‡¶ø ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶≠‡¶æ‡¶¨‡ßá ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§ ‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶¨‡ßá‡¶® (
ReDoc
‡¶™‡ßç‡¶∞‡¶¶‡¶§‡ßç‡¶§):
‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶∏‡ßç‡¶¨‡¶∞‡ßÇ‡¶™ ‡¶Ü‡¶™‡¶ó‡ßç‡¶∞‡ßá‡¶°
‡¶è‡¶ñ‡¶®
main.py
‡¶´‡¶æ‡¶á‡¶≤‡¶ü‡¶ø ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶Ø‡ßá‡¶® ‡¶è‡¶ü‡¶ø
PUT
‡¶∞‡¶ø‡¶ï‡ßÅ‡ßü‡ßá‡¶∏‡ßç‡¶ü ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡¶°‡¶ø ‡¶™‡ßá‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§
Python ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶æ‡¶∞‡ßç‡¶° ‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡¶ø, Pydantic ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø‡ßá ‡¶¨‡¶°‡¶ø ‡¶ò‡ßã‡¶∑‡¶£‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞‡¶ü‡¶ø ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶≠‡¶æ‡¶¨‡ßá ‡¶™‡ßÅ‡¶®‡¶∞‡¶æ‡¶Ø‡¶º ‡¶≤‡ßã‡¶° ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ ‡¶â‡¶ö‡¶ø‡¶§ (‡¶ï‡¶æ‡¶∞‡¶£ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶â‡¶™‡¶∞‡ßá‡¶∞
uvicorn
‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶°‡ßá
--reload
‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‡¶®)‡•§
‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ‡¶∂‡ßÄ‡¶≤ API ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø ‡¶â‡¶®‡ßç‡¶®‡ßÄ‡¶§‡¶ï‡¶∞‡¶£
‡¶è‡¶ñ‡¶®
http://127.0.0.1:8000/docs
‡¶è‡¶°‡¶°‡ßç‡¶∞‡ßá‡¶∏‡ßá ‡¶Ø‡¶æ‡¶®.
‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ‡¶∂‡ßÄ‡¶≤ API ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø‡¶ü‡¶ø ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶≠‡¶æ‡¶¨‡ßá ‡¶â‡¶®‡ßç‡¶®‡ßÄ‡¶§ ‡¶π‡¶Ø‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá, ‡¶®‡¶§‡ßÅ‡¶® ‡¶¨‡¶°‡¶ø ‡¶∏‡¶π:
"Try it out" ‡¶¨‡¶æ‡¶ü‡¶®‡ßá ‡¶ö‡¶æ‡¶™‡ßÅ‡¶®, ‡¶è‡¶ü‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶™‡ßá‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞‡¶ó‡ßÅ‡¶≤‡ßã ‡¶™‡ßÇ‡¶∞‡¶£ ‡¶ï‡¶∞‡¶§‡ßá ‡¶è‡¶¨‡¶Ç API ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ-‡¶ï‡¶≤‡¶æ‡¶™ ‡¶ï‡¶∞‡¶§‡ßá ‡¶¶‡¶ø‡¶¨‡ßá:
‡¶§‡¶æ‡¶∞‡¶™‡¶∞‡ßá "Execute" ‡¶¨‡¶æ‡¶ü‡¶®‡ßá ‡¶ö‡¶æ‡¶™‡ßÅ‡¶®, ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞ ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶´‡ßá‡¶∏ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ API ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶¨‡ßá, ‡¶™‡ßá‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶™‡¶æ‡¶†‡¶æ‡¶¨‡ßá, ‡¶´‡¶≤‡¶æ‡¶´‡¶≤‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶™‡¶æ‡¶¨‡ßá ‡¶è‡¶¨‡¶Ç ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶™‡¶∞‡ßç‡¶∞‡¶¶‡¶æ‡ßü ‡¶¶‡ßá‡¶ñ‡¶æ‡¶¨‡ßá:
‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ API ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø ‡¶Ü‡¶™‡¶ó‡ßç‡¶∞‡ßá‡¶°
‡¶è‡¶¨‡¶Ç ‡¶è‡¶ñ‡¶®
http://127.0.0.1:8000/redoc
‡¶è ‡¶Ø‡¶æ‡¶®‡•§
‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø‡¶§‡ßá‡¶ì ‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡ßÅ‡ßü‡ßá‡¶∞‡¶ø ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶è‡¶¨‡¶Ç ‡¶¨‡¶°‡¶ø ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶´‡¶≤‡¶ø‡¶§ ‡¶π‡¶¨‡ßá:
‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§‡¶ï‡¶∞‡¶£
‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™‡ßá, ‡¶Ü‡¶™‡¶®‡¶ø
‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶è‡¶ï‡¶¨‡¶æ‡¶∞
‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ß‡¶∞‡¶®, ‡¶¨‡¶°‡¶ø ‡¶á‡¶§‡ßç‡¶Ø‡¶æ‡¶¶‡¶ø ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶ò‡ßã‡¶∑‡¶£‡¶æ ‡¶ï‡¶∞‡ßá‡¶®‡•§
‡¶Ü‡¶™‡¶®‡¶ø ‡¶∏‡ßá‡¶ü‡¶ø ‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï ‡¶™‡¶æ‡¶á‡¶•‡¶®‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶ï‡¶∞‡ßá‡¶®‡•§
‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡¶∞‡ßá ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü ‡¶ï‡ßã‡¶® ‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡¶ø‡¶∞ ‡¶¨‡¶æ‡¶ï‡ßç‡¶Ø ‡¶ó‡¶†‡¶®, ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶¨‡¶æ ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏ ‡¶ï‡¶ø‡¶õ‡ßÅ‡¶á ‡¶∂‡¶ø‡¶ñ‡¶§‡ßá ‡¶π‡¶ö‡ßç‡¶õ‡ßá ‡¶®‡¶æ‡•§
‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶á ‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï
Python 3.6+
‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶∏‡ßç‡¶¨‡¶∞‡ßÇ‡¶™,
int
‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø:
item_id
:
int
‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ü‡¶∞‡¶ì ‡¶ú‡¶ü‡¶ø‡¶≤
Item
‡¶Æ‡¶°‡ßá‡¶≤‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø:
item
:
Item
...‡¶è‡¶¨‡¶Ç ‡¶∏‡ßá‡¶á ‡¶è‡¶ï‡¶á ‡¶ò‡ßã‡¶∑‡¶£‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ü‡¶™‡¶®‡¶ø ‡¶™‡¶æ‡¶¨‡ßá‡¶®:
‡¶è‡¶°‡¶ø‡¶ü‡¶∞ ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø, ‡¶Ø‡ßá‡¶Æ‡¶®
‡¶∏‡¶Æ‡¶æ‡¶™‡ßç‡¶§‡¶ø‡•§
‡¶ß‡¶∞‡¶£ ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á
‡¶§‡¶•‡ßç‡¶Ø ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á‡¶ï‡¶∞‡¶£:
‡¶°‡ßá‡¶ü‡¶æ ‡¶Ö‡¶¨‡ßà‡¶ß ‡¶π‡¶≤‡ßá ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶è‡¶¨‡¶Ç ‡¶™‡¶∞‡¶ø‡¶∑‡ßç‡¶ï‡¶æ‡¶∞ ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø‡¶∞ ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶®‡¶æ‡•§
‡¶è‡¶Æ‡¶®‡¶ï‡¶ø ‡¶ó‡¶≠‡ßÄ‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶®‡ßá‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ JSON ‡¶Ö‡¶¨‡¶ú‡ßá‡¶ï‡ßç‡¶ü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßà‡¶ß‡¶§‡¶æ‡•§
‡¶™‡ßç‡¶∞‡ßá‡¶∞‡¶ø‡¶§ ‡¶§‡¶•‡ßç‡¶Ø
‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞
: ‡¶Ø‡¶æ ‡¶®‡ßá‡¶ü‡¶ì‡ßü‡¶æ‡¶∞‡ßç‡¶ï ‡¶•‡ßá‡¶ï‡ßá ‡¶™‡¶æ‡¶á‡¶•‡¶®‡ßá‡¶∞ ‡¶§‡¶•‡ßç‡¶Ø ‡¶è‡¶¨‡¶Ç ‡¶ß‡¶∞‡¶®‡ßá ‡¶Ü‡¶∏‡ßá, ‡¶è‡¶¨‡¶Ç ‡¶∏‡ßá‡¶ñ‡¶æ‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶™‡ßú‡¶æ:
JSON‡•§
‡¶™‡¶æ‡¶• ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞‡•§
‡¶ï‡ßÅ‡ßü‡ßá‡¶∞‡¶ø ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞‡•§
‡¶ï‡ßÅ‡¶ï‡¶ø‡¶ú
‡¶π‡ßá‡¶°‡¶æ‡¶∞
‡¶´‡¶∞‡ßç‡¶Æ
‡¶´‡¶æ‡¶á‡¶≤
‡¶Ü‡¶â‡¶ü‡¶™‡ßÅ‡¶ü ‡¶°‡ßá‡¶ü‡¶æ‡¶∞
‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞
: ‡¶™‡¶æ‡¶á‡¶•‡¶® ‡¶°‡ßá‡¶ü‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶ü‡¶æ‡¶á‡¶™ ‡¶•‡ßá‡¶ï‡ßá ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï ‡¶°‡ßá‡¶ü‡¶æ‡¶§‡ßá ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞ ‡¶ï‡¶∞‡¶æ (JSON ‡¶π‡¶ø‡¶∏‡¶æ‡¶¨‡ßá):
-‡¶™‡¶æ‡¶á‡¶•‡¶® ‡¶ü‡¶æ‡¶á‡¶™‡ßá ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® (
str
,
int
,
float
,
bool
,
list
, ‡¶á‡¶§‡ßç‡¶Ø‡¶æ‡¶¶‡¶ø)‡•§
datetime
‡¶Ö‡¶¨‡¶ú‡ßá‡¶ï‡ßç‡¶ü‡•§
UUID
obje‡¶Ö‡¶¨‡¶ú‡ßá‡¶ï‡ßç‡¶ücts‡•§
‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶Æ‡¶°‡ßá‡¶≤‡•§
...‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶∞‡ßã ‡¶Ö‡¶®‡ßá‡¶ï‡•§
‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ‡¶∂‡ßÄ‡¶≤ API ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø, 2‡¶ü‡¶ø ‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞ ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶´‡ßá‡¶∏ ‡¶∏‡¶π:
‡¶∏‡ßã‡¶Ø‡¶º‡¶æ‡¶ó‡¶æ‡¶∞ ‡¶á‡¶â ‡¶Ü‡¶á (Swagger UI)‡•§
‡¶∞‡¶ø‡¶°‡¶ï (ReDoc)‡•§
‡¶™‡ßÇ‡¶∞‡ßç‡¶¨‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶ï‡ßã‡¶° ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡ßá ‡¶´‡¶ø‡¶∞‡ßá ‡¶Ü‡¶∏‡¶æ ‡¶Ø‡¶æ‡¶ï,
FastAPI
‡¶Ø‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá:
GET
‡¶è‡¶¨‡¶Ç
PUT
‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡¶•‡ßá
item_id
‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ ‡¶§‡¶æ ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡¶¨‡ßá‡•§
GET
‡¶è‡¶¨‡¶Ç
PUT
‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
item_id
‡¶ü‡¶æ‡¶á‡¶™
int
‡¶è‡¶∞ ‡¶π‡¶§‡ßá ‡¶π‡¶¨‡ßá ‡¶§‡¶æ ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡¶¨‡ßá‡•§
‡¶Ø‡¶¶‡¶ø ‡¶®‡¶æ ‡¶π‡¶Ø‡¶º ‡¶§‡¶¨‡ßá ‡¶ï‡ßç‡¶≤‡¶æ‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü ‡¶è‡¶ï‡¶ü‡¶ø ‡¶â‡¶™‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§, ‡¶™‡¶∞‡¶ø‡¶∑‡ßç‡¶ï‡¶æ‡¶∞ ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶¨‡ßá‡¶®‡•§
GET
‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ê‡¶ö‡ßç‡¶õ‡¶ø‡¶ï ‡¶ï‡ßç‡¶Ø‡ßÅ‡¶Ø‡¶º‡ßá‡¶∞‡¶ø ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶®‡¶æ‡¶Æ‡¶ï
q
(‡¶Ø‡ßá‡¶Æ‡¶®
http://127.0.0.1:8000/items/foo?q=somequery
) ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø ‡¶§‡¶æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶¨‡ßá‡•§
‡¶Ø‡ßá‡¶π‡ßá‡¶§‡ßÅ
q
‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞‡¶ü‡¶ø
= None
‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶ò‡ßã‡¶∑‡¶£‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá, ‡¶§‡¶æ‡¶á ‡¶è‡¶ü‡¶ø ‡¶ê‡¶ö‡ßç‡¶õ‡¶ø‡¶ï‡•§
None
‡¶õ‡¶æ‡¶°‡¶º‡¶æ ‡¶è‡¶ü‡¶ø ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡ßÄ‡¶Ø‡¶º ‡¶π‡¶§‡ßã (‡¶Ø‡ßá‡¶Æ‡¶®
PUT
‡¶è‡¶∞ ‡¶ï‡ßç‡¶∑‡ßá‡¶§‡ßç‡¶∞‡ßá ‡¶π‡ßü‡ßá‡¶õ‡ßá)‡•§
/items/{item_id}
‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
PUT
‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß‡ßá‡¶∞ ‡¶¨‡¶°‡¶ø JSON ‡¶π‡¶ø‡¶∏‡¶æ‡¶¨‡ßá ‡¶™‡¶°‡¶º‡ßÅ‡¶®:
‡¶≤‡¶ï‡ßç‡¶∑ ‡¶ï‡¶∞‡ßÅ‡¶®,
name
‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡ßÄ‡¶Ø‡¶º ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ü‡ßç‡¶∞‡¶ø‡¶¨‡¶ø‡¶â‡¶ü ‡¶π‡¶ø‡¶∏‡¶æ‡¶¨‡ßá ‡¶¨‡¶ø‡¶¨‡ßá‡¶ö‡¶®‡¶æ ‡¶ï‡¶∞‡ßá‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ü‡¶ø
str
‡¶π‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§
‡¶≤‡¶ï‡ßç‡¶∑ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶è‡¶ñ‡¶æ‡¶®‡ßá,
price
‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ü‡ßç‡¶∞‡¶ø‡¶¨‡¶ø‡¶â‡¶ü‡¶ü‡¶ø ‡¶Ü‡¶¨‡¶∂‡ßç‡¶Ø‡¶ï ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ü‡¶ø
float
‡¶π‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§
‡¶≤‡¶ï‡ßç‡¶∑ ‡¶ï‡¶∞‡ßÅ‡¶®
is_offer
‡¶è‡¶ï‡¶ü‡¶ø ‡¶ê‡¶ö‡ßç‡¶õ‡¶ø‡¶ï ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ü‡ßç‡¶∞‡¶ø‡¶¨‡¶ø‡¶â‡¶ü ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ü‡¶ø
bool
‡¶π‡¶§‡ßá ‡¶π‡¶¨‡ßá ‡¶Ø‡¶¶‡¶ø ‡¶â‡¶™‡¶∏‡ßç‡¶•‡¶ø‡¶§ ‡¶•‡¶æ‡¶ï‡ßá‡•§
‡¶è‡¶á ‡¶∏‡¶¨‡¶ü‡¶ø ‡¶ó‡¶≠‡ßÄ‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶®‡¶∞‡¶§ JSON ‡¶Ö‡¶¨‡¶ú‡ßá‡¶ï‡ßç‡¶ü‡¶ó‡ßÅ‡¶≤‡¶ø‡¶§‡ßá‡¶ì ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶¨‡ßá‡•§
‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶≠‡¶æ‡¶¨‡ßá JSON ‡¶π‡¶§‡ßá ‡¶è‡¶¨‡¶Ç JSON ‡¶•‡ßá‡¶ï‡ßá ‡¶ï‡¶®‡¶≠‡¶æ‡¶∞‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®‡•§
OpenAPI ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶∏‡¶¨‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®, ‡¶Ø‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡ßá‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá:
‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ‡¶∂‡ßÄ‡¶≤ ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø‡•§
‡¶Ö‡¶®‡ßá‡¶ï ‡¶≠‡¶æ‡¶∑‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∏‡ßç‡¶¨‡¶Ø‡¶º‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶ï‡ßç‡¶≤‡¶æ‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü ‡¶ï‡ßã‡¶° ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡•§
‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø 2‡¶ü‡¶ø ‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ‡¶∂‡ßÄ‡¶≤ ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶ø‡¶ï‡¶æ ‡¶®‡¶•‡¶ø ‡¶ì‡¶Ø‡¶º‡ßá‡¶¨ ‡¶™‡ßÉ‡¶∑‡ßç‡¶† ‡¶™‡ßç‡¶∞‡¶¶‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§
‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶§‡¶ï‡ßç‡¶∑‡¶® ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶è‡¶∞ ‡¶™‡ßÉ‡¶∑‡ßç‡¶† ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶á‡¶§‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá‡¶á ‡¶è‡¶ü‡¶ø ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá ‡¶§‡¶æ‡¶∞ ‡¶ß‡¶æ‡¶∞‡¶£‡¶æ‡¶ì ‡¶™‡ßá‡ßü‡ßá ‡¶ó‡¶ø‡ßü‡ßá‡¶õ‡ßá‡¶®‡•§
‡¶®‡¶ø‡¶Æ‡ßç‡¶®‡ßã‡¶ï‡ßç‡¶§ ‡¶≤‡¶æ‡¶á‡¶® ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...‡¶™‡ßÅ‡¶∞‡ßç‡¶¨‡ßá:
...
"item_name"
:
item
.
name
...
...‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ‡¶§‡ßá:
...
"item_price"
:
item
.
price
...
...‡¶è‡¶¨‡¶Ç ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶® ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶è‡¶°‡¶ø‡¶ü‡¶∞ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡ßã‡¶ï‡ßá ‡¶∏‡ßü‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶≠‡¶æ‡¶¨‡ßá-‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶ï‡¶∞‡¶¨‡ßá ‡¶è‡¶¨‡¶Ç ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶ß‡¶∞‡¶® ‡¶ú‡¶æ‡¶®‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá:
‡¶Ü‡¶∞‡¶ì ‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡ßç‡¶ü‡ßç‡¶Ø ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø, ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®
‡¶ü‡¶ø‡¶â‡¶ü‡ßã‡¶∞‡¶ø‡ßü‡¶æ‡¶≤ - ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞ ‡¶ó‡¶æ‡¶á‡¶°
.
‡¶∏‡ßç‡¶™‡ßü‡¶≤‡¶æ‡¶∞ ‡¶∏‡¶§‡¶∞‡ßç‡¶ï‡¶§‡¶æ
: ‡¶ü‡¶ø‡¶â‡¶ü‡ßã‡¶∞‡¶ø‡ßü‡¶æ‡¶≤ - ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞ ‡¶ó‡¶æ‡¶á‡¶° ‡¶®‡¶ø‡¶Æ‡ßç‡¶®‡ßã‡¶ï‡ßç‡¶§ ‡¶¨‡¶ø‡¶∑‡ßü‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶Ö‡¶®‡ßç‡¶§‡¶∞‡ßç‡¶≠‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡ßá:
‡¶π‡ßá‡¶°‡¶æ‡¶∞
,
‡¶ï‡ßÅ‡¶ï‡¶ø‡¶ú
,
‡¶´‡¶∞‡ßç‡¶Æ ‡¶´‡¶ø‡¶≤‡ßç‡¶°
‡¶è‡¶¨‡¶Ç
‡¶´‡¶æ‡¶á‡¶≤‡¶ó‡ßÅ‡¶≤‡¶ø
‡¶è‡¶Æ‡¶® ‡¶Ö‡¶®‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶Ø ‡¶ú‡¶æ‡ßü‡¶ó‡¶æ ‡¶•‡ßá‡¶ï‡ßá ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶ò‡ßã‡¶∑‡¶£‡¶æ ‡¶ï‡¶∞‡¶æ‡•§
maximum_length
‡¶¨‡¶æ
regex
‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã
‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á‡¶ï‡¶∞‡¶£ ‡¶¨‡¶æ‡¶ß‡¶æ‡¶Æ‡ßÅ‡¶ï‡ßç‡¶§‡¶ø
‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá, ‡¶§‡¶æ ‡¶®‡¶ø‡ßü‡ßá ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶¨‡ßá‡•§
‡¶è‡¶ï‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶¨ ‡¶∂‡¶ï‡ßç‡¶§‡¶ø‡¶∂‡¶æ‡¶≤‡ßÄ ‡¶è‡¶¨‡¶Ç ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶∏‡¶π‡¶ú
‡¶°‡¶ø‡¶™‡ßá‡¶®‡ßç‡¶°‡ßá‡¶®‡ßç‡¶∏‡¶ø ‡¶á‡¶®‡¶ú‡ßá‡¶ï‡¶∂‡¶®
‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø
OAuth2
‡¶è‡¶¨‡¶Ç
JWT ‡¶ü‡ßã‡¶ï‡ßá‡¶®
‡¶è‡¶¨‡¶Ç
HTTP Basic
auth ‡¶∏‡¶π ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶§‡ßç‡¶§‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶Ö‡¶®‡ßÅ‡¶Æ‡ßã‡¶¶‡¶®‡¶™‡ßç‡¶∞‡¶æ‡¶™‡ßç‡¶§‡¶ø ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡¶ø‡¶§ ‡¶¨‡¶ø‡¶∑‡ßü‡¶∏‡¶Æ‡ßÇ‡¶π‡ßá‡¶∞ ‡¶â‡¶™‡¶∞‡•§
‡¶ó‡¶≠‡ßÄ‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶®‡¶∞‡¶§ JSON ‡¶Æ‡¶°‡ßá‡¶≤
‡¶ò‡ßã‡¶∑‡¶£‡¶æ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶∞‡¶ì ‡¶â‡¶®‡ßç‡¶®‡¶§ (‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶∏‡¶Æ‡¶æ‡¶® ‡¶∏‡¶π‡¶ú) ‡¶ï‡ßå‡¶∂‡¶≤ (Pydantic ‡¶ï‡ßá ‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶)‡•§
‡¶Ü‡¶∞‡ßã ‡¶Ö‡¶§‡¶ø‡¶∞‡¶ø‡¶ï‡ßç‡¶§ ‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡ßç‡¶ü‡ßç‡¶Ø (‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡¶≤‡ßá‡¶ü‡¶ï‡ßá ‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶) ‡¶π‡¶ø‡¶∏‡¶æ‡¶¨‡ßá:
WebSockets
GraphQL
HTTPX ‡¶è‡¶¨‡¶Ç
pytest
‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶Ö‡¶§‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶∏‡¶π‡¶ú ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ
CORS
Cookie Sessions
...‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶∞‡ßã‡•§
‡¶ï‡¶∞‡ßç‡¶Æ‡¶ï‡ßç‡¶∑‡¶Æ‡¶§‡¶æ
‡¶∏‡ßç‡¶¨‡¶æ‡¶ß‡ßÄ‡¶® TechEmpower Benchmarks ‡¶¶‡ßá‡¶ñ‡¶æ‡¶Ø‡¶º ‡¶Ø‡ßá
FastAPI
‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶®‡¶ó‡ßÅ‡¶≤‡¶ø Uvicorn-‡¶è‡¶∞ ‡¶Ö‡¶ß‡ßÄ‡¶®‡ßá ‡¶ö‡¶≤‡¶Æ‡¶æ‡¶® ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§‡¶§‡¶Æ
‡¶™‡¶æ‡¶á‡¶•‡¶® ‡¶´‡ßç‡¶∞‡ßá‡¶Æ‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï‡¶ó‡ßÅ‡¶≤‡¶ø‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶è‡¶ï‡¶ü‡¶ø,
‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ Starlette ‡¶è‡¶¨‡¶Ç Uvicorn-‡¶è‡¶∞ ‡¶™‡¶∞ (FastAPI ‡¶¶‡ßç‡¶¨‡¶æ‡¶∞‡¶æ ‡¶Ö‡¶≠‡ßç‡¶Ø‡¶®‡ßç‡¶§‡¶∞‡ßÄ‡¶£‡¶≠‡¶æ‡¶¨‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§)‡•§ (*)
‡¶è‡¶ü‡¶ø ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶Ü‡¶∞‡¶ì ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá, ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®
Benchmarks
.
‡¶ê‡¶ö‡ßç‡¶õ‡¶ø‡¶ï ‡¶®‡¶ø‡¶∞‡ßç‡¶≠‡¶∞‡¶∂‡ßÄ‡¶≤‡¶§‡¶æ
Pydantic ‡¶¶‡ßç‡¶¨‡¶æ‡¶∞‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§:
email-validator
- ‡¶á‡¶Æ‡ßá‡¶≤ ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á‡¶ï‡¶∞‡¶£‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§
‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡¶≤‡ßá‡¶ü ‡¶¶‡ßç‡¶¨‡¶æ‡¶∞‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§:
httpx
- ‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡¶¶‡¶ø
TestClient
‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶® ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶Ü‡¶¨‡¶∂‡ßç‡¶Ø‡¶ï‡•§
jinja2
- ‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡¶¶‡¶ø ‡¶™‡ßç‡¶∞‡¶¶‡¶§‡ßç‡¶§ ‡¶ü‡ßá‡¶Æ‡¶™‡ßç‡¶≤‡ßá‡¶ü ‡¶∞‡ßÇ‡¶™‡¶∞‡ßá‡¶ñ‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶® ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡•§
python-multipart
- ‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡¶¶‡¶ø ‡¶´‡¶∞‡ßç‡¶Æ ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶§‡¶æ ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶® ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®
"parsing"
,
request.form()
‡¶∏‡¶π‡•§
itsdangerous
-
SessionMiddleware
‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶§‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡•§
pyyaml
- ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡¶≤‡ßá‡¶ü‡ßá‡¶∞ SchemaGenerator ‡¶∏‡¶æ‡¶™‡ßã‡¶∞‡ßç‡¶ü ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶® (‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡¶Æ‡ßç‡¶≠‡¶æ‡¶¨‡¶§ FastAPI ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶® ‡¶®‡ßá‡¶á)‡•§
graphene
-
GraphQLApp
‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶§‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶®‡•§
FastAPI / Starlette ‡¶¶‡ßç‡¶¨‡¶æ‡¶∞‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§:
uvicorn
- ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ø‡¶æ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡ßá ‡¶è‡¶¨‡¶Ç ‡¶™‡¶∞‡¶ø‡¶¨‡ßá‡¶∂‡¶® ‡¶ï‡¶∞‡ßá‡•§
orjson
- ‡¶Ü‡¶™‡¶®‡¶ø
ORJSONResponse
‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶á‡¶≤‡ßá ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡•§
ujson
- ‡¶Ü‡¶™‡¶®‡¶ø
UJSONResponse
‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶á‡¶≤‡ßá ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡•§
‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶á ‡¶∏‡¶¨ ‡¶á‡¶®‡¶∏‡ßç‡¶ü‡¶≤ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®
pip install fastapi[all]
‡¶¶‡¶ø‡ßü‡ßá.
‡¶≤‡¶æ‡¶á‡¶∏‡ßá‡¶®‡ßç‡¶∏
‡¶è‡¶á ‡¶™‡ßç‡¶∞‡¶ú‡ßá‡¶ï‡ßç‡¶ü MIT ‡¶≤‡¶æ‡¶á‡¶∏‡ßá‡¶®‡ßç‡¶∏ ‡¶®‡ßÄ‡¶§‡¶ø‡¶Æ‡¶æ‡¶≤‡¶æ‡¶∞ ‡¶Ö‡¶ß‡ßÄ‡¶®‡ßá ‡¶∂‡¶∞‡ßç‡¶§‡¶æ‡ßü‡¶ø‡¶§‡•§

## 037_CONTRIBUTING
Development - Contributing¬∂
---

Development - Contributing
First, you might want to see the basic ways to
help FastAPI and get help
.
Developing
If you already cloned the
fastapi repository
and you want to deep dive in the code, here are some guidelines to set up your environment.
Virtual environment
Follow the instructions to create and activate a
virtual environment
for the internal code of
fastapi
.
Install requirements using pip
After activating the environment, install the required packages:
fast ‚Üí
pip install -r requirement
It will install all the dependencies and your local FastAPI in your local environment.
Using your local FastAPI
If you create a Python file that imports and uses FastAPI, and run it with the Python from your local environment, it will use your cloned local FastAPI source code.
And if you update that local FastAPI source code when you run that Python file again, it will use the fresh version of FastAPI you just edited.
That way, you don't have to "install" your local version to be able to test every change.
Technical Details
This only happens when you install using this included
requirements.txt
instead of running
pip install fastapi
directly.
That is because inside the
requirements.txt
file, the local version of FastAPI is marked to be installed in "editable" mode, with the
-e
option.
Format the code
There is a script that you can run that will format and clean all your code:
fast ‚Üí
bash scripts/format.sh
restart ‚Üª
It will also auto-sort all your imports.
Tests
There is a script that you can run locally to test all the code and generate coverage reports in HTML:
fast ‚Üí
bash scripts/test-cov-html.sh
restart ‚Üª
This command generates a directory
./htmlcov/
, if you open the file
./htmlcov/index.html
in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.
Docs
First, make sure you set up your environment as described above, that will install all the requirements.
Docs live
During local development, there is a script that builds the site and checks for any changes, live-reloading:
fast ‚Üí
python ./scripts/docs.py live
[INFO]
Serving on http://127.0.0.1:8008
[INFO]
Start watching changes
[INFO]
Start detecting changes
restart ‚Üª
It will serve the documentation on
http://127.0.0.1:8008
.
That way, you can edit the documentation/source files and see the changes live.
Tip
Alternatively, you can perform the same steps that scripts does manually.
Go into the language directory, for the main docs in English it's at
docs/en/
:
$
cd
docs/en/
Then run
mkdocs
in that directory:
$
mkdocs
serve
--dev-addr
127
.0.0.1:8008
Typer CLI (optional)
The instructions here show you how to use the script at
./scripts/docs.py
with the
python
program directly.
But you can also use
Typer CLI
, and you will get autocompletion in your terminal for the commands after installing completion.
If you install Typer CLI, you can install completion with:
fast ‚Üí
typer --install-completion
zsh completion installed in /home/user/.bashrc.
Completion will take effect once you restart the terminal.
restart ‚Üª
Docs Structure
The documentation uses
MkDocs
.
And there are extra tools/scripts in place to handle translations in
./scripts/docs.py
.
Tip
You don't need to see the code in
./scripts/docs.py
, you just use it in the command line.
All the documentation is in Markdown format in the directory
./docs/en/
.
Many of the tutorials have blocks of code.
In most of the cases, these blocks of code are actual complete applications that can be run as is.
In fact, those blocks of code are not written inside the Markdown, they are Python files in the
./docs_src/
directory.
And those Python files are included/injected in the documentation when generating the site.
Docs for tests
Most of the tests actually run against the example source files in the documentation.
This helps to make sure that:
The documentation is up-to-date.
The documentation examples can be run as is.
Most of the features are covered by the documentation, ensured by test coverage.
Apps and docs at the same time
If you run the examples with, e.g.:
fast ‚Üí
fastapi dev tutorial001.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
as Uvicorn by default will use the port
8000
, the documentation on port
8008
won't clash.
Translations
Help with translations is VERY MUCH appreciated! And it can't be done without the help from the community. üåé üöÄ
Here are the steps to help with translations.
Tips and guidelines
Check the currently
existing pull requests
for your language. You can filter the pull requests by the ones with the label for your language. For example, for Spanish, the label is
lang-es
.
Review those pull requests, requesting changes or approving them. For the languages I don't speak, I'll wait for several others to review the translation before merging.
Tip
You can
add comments with change suggestions
to existing pull requests.
Check the docs about
adding a pull request review
to approve it or request changes.
Check if there's a
GitHub Discussion
to coordinate translations for your language. You can subscribe to it, and when there's a new pull request to review, an automatic comment will be added to the discussion.
If you translate pages, add a single pull request per page translated. That will make it much easier for others to review it.
To check the 2-letter code for the language you want to translate, you can use the table
List of ISO 639-1 codes
.
Existing language
Let's say you want to translate a page for a language that already has translations for some pages, like Spanish.
In the case of Spanish, the 2-letter code is
es
. So, the directory for Spanish translations is located at
docs/es/
.
Tip
The main ("official") language is English, located at
docs/en/
.
Now run the live server for the docs in Spanish:
fast ‚Üí
üí¨ Use the command "live" and pass the language code as a CLI argument
python ./scripts/docs.py live es
[INFO]
Serving on http://127.0.0.1:8008
[INFO]
Start watching changes
[INFO]
Start detecting changes
restart ‚Üª
Tip
Alternatively, you can perform the same steps that scripts does manually.
Go into the language directory, for the Spanish translations it's at
docs/es/
:
$
cd
docs/es/
Then run
mkdocs
in that directory:
$
mkdocs
serve
--dev-addr
127
.0.0.1:8008
Now you can go to
http://127.0.0.1:8008
and see your changes live.
You will see that every language has all the pages. But some pages are not translated and have an info box at the top, about the missing translation.
Now let's say that you want to add a translation for the section
Features
.
Copy the file at:
docs/en/docs/features.md
Paste it in exactly the same location but for the language you want to translate, e.g.:
docs/es/docs/features.md
Tip
Notice that the only change in the path and file name is the language code, from
en
to
es
.
If you go to your browser you will see that now the docs show your new section (the info box at the top is gone). üéâ
Now you can translate it all and see how it looks as you save the file.
Don't Translate these Pages
üö® Don't translate:
Files under
reference/
release-notes.md
fastapi-people.md
external-links.md
newsletter.md
management-tasks.md
management.md
contributing.md
Some of these files are updated very frequently and a translation would always be behind, or they include the main content from English source files, etc.
New Language
Let's say that you want to add translations for a language that is not yet translated, not even some pages.
Let's say you want to add translations for Creole, and it's not yet there in the docs.
Checking the link from above, the code for "Creole" is
ht
.
The next step is to run the script to generate a new translation directory:
fast ‚Üí
üí¨ Use the command new-lang, pass the language code as a CLI argument
python ./scripts/docs.py new-lang ht
Successfully initialized: docs/ht
restart ‚Üª
Now you can check in your code editor the newly created directory
docs/ht/
.
That command created a file
docs/ht/mkdocs.yml
with a simple config that inherits everything from the
en
version:
INHERIT
:
../en/mkdocs.yml
Tip
You could also simply create that file with those contents manually.
That command also created a dummy file
docs/ht/index.md
for the main page, you can start by translating that one.
You can continue with the previous instructions for an "Existing Language" for that process.
You can make the first pull request with those two files,
docs/ht/mkdocs.yml
and
docs/ht/index.md
. üéâ
Preview the result
As already mentioned above, you can use the
./scripts/docs.py
with the
live
command to preview the results (or
mkdocs serve
).
Once you are done, you can also test it all as it would look online, including all the other languages.
To do that, first build all the docs:
fast ‚Üí
üí¨ Use the command "build-all", this will take a bit
python ./scripts/docs.py build-all
Building docs for: en
Building docs for: es
Successfully built docs for: es
restart ‚Üª
This builds all those independent MkDocs sites for each language, combines them, and generates the final output at
./site/
.
Then you can serve that with the command
serve
:
fast ‚Üí
üí¨ Use the command "serve" after running "build-all"
python ./scripts/docs.py serve
Warning: this is a very simple server. For development, use mkdocs serve instead.
This is here only to preview a site with translations already built.
Make sure you run the build-all command first.
Serving at: http://127.0.0.1:8008
restart ‚Üª
Translation specific tips and guidelines
Translate only the Markdown documents (
.md
). Do not translate the code examples at
./docs_src
.
In code blocks within the Markdown document, translate comments (
## a comment
), but leave the rest unchanged.
Do not change anything enclosed in "``" (inline code).
In lines starting with
///
translate only the text part after
|
. Leave the rest unchanged.
You can translate info boxes like
/// warning
with for example
/// warning | Achtung
. But do not change the word immediately after the
///
, it determines the color of the info box.
Do not change the paths in links to images, code files, Markdown documents.
However, when a Markdown document is translated, the
## hash-parts
in links to its headings may change. Update these links if possible.
Search for such links in the translated document using the regex
## [^# ]
.
Search in all documents already translated into your language for
your-translated-document.md
. For example VS Code has an option "Edit" -> "Find in Files".
When translating a document, do not "pre-translate"
## hash-parts
that link to headings in untranslated documents.

## 038_DE
FastAPI¬∂
---

FastAPI
FastAPI Framework, hochperformant, leicht zu erlernen, schnell zu programmieren, einsatzbereit
Dokumentation
:
https://fastapi.tiangolo.com
Quellcode
:
https://github.com/fastapi/fastapi
FastAPI ist ein modernes, schnelles (hoch performantes) Webframework zur Erstellung von APIs mit Python auf Basis von Standard-Python-Typhinweisen.
Seine Schl√ºssel-Merkmale sind:
Schnell
: Sehr hohe Leistung, auf Augenh√∂he mit
NodeJS
und
Go
(Dank Starlette und Pydantic).
Eines der schnellsten verf√ºgbaren Python-Frameworks
.
Schnell zu programmieren
: Erh√∂hen Sie die Geschwindigkeit bei der Entwicklung von Funktionen um etwa 200 % bis 300 %. *
Weniger Bugs
: Verringern Sie die von Menschen (Entwicklern) verursachten Fehler um etwa 40 %. *
Intuitiv
: Exzellente Editor-Unterst√ºtzung.
Code-Vervollst√§ndigung
√ºberall. Weniger Debuggen.
Einfach
: So konzipiert, dass es einfach zu benutzen und zu erlernen ist. Weniger Zeit f√ºr das Lesen der Dokumentation.
Kurz
: Minimieren Sie die Verdoppelung von Code. Mehrere Funktionen aus jeder Parameterdeklaration. Weniger Bugs.
Robust
: Erhalten Sie produktionsreifen Code. Mit automatischer, interaktiver Dokumentation.
Standards-basiert
: Basierend auf (und vollst√§ndig kompatibel mit) den offenen Standards f√ºr APIs:
OpenAPI
(fr√ºher bekannt als Swagger) und
JSON Schema
.
* Sch√§tzung auf Basis von Tests in einem internen Entwicklungsteam, das Produktionsanwendungen erstellt.
Sponsoren
Andere Sponsoren
Meinungen
‚Äû
[...] Ich verwende
FastAPI
heutzutage sehr oft. [...] Ich habe tats√§chlich vor, es f√ºr alle
ML-Dienste meines Teams bei Microsoft
zu verwenden. Einige davon werden in das Kernprodukt
Windows
und einige
Office
-Produkte integriert.
‚Äú
Kabir Khan -
Microsoft
(Ref)
‚Äû
Wir haben die
FastAPI
-Bibliothek genommen, um einen
REST
-Server zu erstellen, der abgefragt werden kann, um
Vorhersagen
zu erhalten. [f√ºr Ludwig]
‚Äú
Piero Molino, Yaroslav Dudin, und Sai Sumanth Miryala -
Uber
(Ref)
‚Äû
Netflix
freut sich, die Open-Source-Ver√∂ffentlichung unseres
Krisenmanagement
-Orchestrierung-Frameworks bekannt zu geben:
Dispatch
! [erstellt mit
FastAPI
]
‚Äú
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(Ref)
‚Äû
Ich bin √ºbergl√ºcklich mit
FastAPI
. Es macht so viel Spa√ü!
‚Äú
Brian Okken -
Host des
Python Bytes
Podcast
(Ref)
‚Äû
Ehrlich, was Du gebaut hast, sieht super solide und poliert aus. In vielerlei Hinsicht ist es so, wie ich
Hug
haben wollte ‚Äì es ist wirklich inspirierend, jemanden so etwas bauen zu sehen.
‚Äú
Timothy Crosley -
Autor von
Hug
(Ref)
‚Äû
Wenn Sie ein
modernes Framework
zum Erstellen von REST-APIs erlernen m√∂chten, schauen Sie sich
FastAPI
an. [...] Es ist schnell, einfach zu verwenden und leicht zu erlernen [...]
‚Äú
‚Äû
Wir haben zu
FastAPI
f√ºr unsere
APIs
gewechselt [...] Ich denke, es wird Ihnen gefallen [...]
‚Äú
Ines Montani - Matthew Honnibal -
Gr√ºnder von
Explosion AI
- Autoren von
spaCy
(Ref)
-
(Ref)
‚Äû
Falls irgendjemand eine Produktions-Python-API erstellen m√∂chte, kann ich
FastAPI
w√§rmstens empfehlen. Es ist
wundersch√∂n konzipiert
,
einfach zu verwenden
und
hoch skalierbar
; es ist zu einer
Schl√ºsselkomponente
in unserer API-First-Entwicklungsstrategie geworden und treibt viele Automatisierungen und Dienste an, wie etwa unseren virtuellen TAC-Ingenieur.
‚Äú
Deon Pillsbury -
Cisco
(Ref)
Typer
, das FastAPI der CLIs
Wenn Sie eine
CLI
-Anwendung f√ºr das Terminal erstellen, anstelle einer Web-API, schauen Sie sich
Typer
an.
Typer
ist die kleine Schwester von FastAPI. Und es soll das
FastAPI der CLIs
sein. ‚å®Ô∏è üöÄ
Anforderungen
FastAPI steht auf den Schultern von Giganten:
Starlette
f√ºr die Webanteile.
Pydantic
f√ºr die Datenanteile.
Installation
fast ‚Üí
pip install fastapi
restart ‚Üª
Sie ben√∂tigen au√üerdem einen
ASGI
-Server. F√ºr die Produktumgebung beispielsweise
Uvicorn
oder
Hypercorn
.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
Beispiel
Erstellung
Erstellen Sie eine Datei
main.py
mit:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Oder verwenden Sie
async def
...
Wenn Ihr Code
async
/
await
verwendet, benutzen Sie
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Anmerkung
:
Wenn Sie das nicht kennen, schauen Sie sich den Abschnitt
‚ÄûIn Eile?‚Äú
√ºber
async
und
await
in der Dokumentation
an.
Starten
F√ºhren Sie den Server aus:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
Was macht der Befehl
uvicorn main:app --reload
...
Der Befehl
uvicorn main:app
bezieht sich auf:
main
: die Datei
main.py
(das Python-‚ÄûModul‚Äú).
app
: das Objekt, das innerhalb von
main.py
mit der Zeile
app = FastAPI()
erzeugt wurde.
--reload
: l√§sst den Server nach Code√§nderungen neu starten. Tun Sie das nur w√§hrend der Entwicklung.
Testen
√ñffnen Sie Ihren Browser unter
http://127.0.0.1:8000/items/5?q=somequery
.
Sie erhalten die JSON-Response:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Damit haben Sie bereits eine API erstellt, welche:
HTTP-Anfragen auf den
Pfaden
/
und
/items/{item_id}
entgegennimmt.
Beide
Pfade
erhalten
GET
Operationen
(auch bekannt als HTTP
Methoden
).
Der
Pfad
/items/{item_id}
hat einen
Pfadparameter
item_id
, der ein
int
sein sollte.
Der
Pfad
/items/{item_id}
hat einen optionalen
str
Query Parameter
q
.
Interaktive API-Dokumentation
Gehen Sie nun auf
http://127.0.0.1:8000/docs
.
Sie sehen die automatische interaktive API-Dokumentation (bereitgestellt von
Swagger UI
):
Alternative API-Dokumentation
Gehen Sie jetzt auf
http://127.0.0.1:8000/redoc
.
Sie sehen die alternative automatische Dokumentation (bereitgestellt von
ReDoc
):
Beispiel Aktualisierung
√Ñndern Sie jetzt die Datei
main.py
, um den
Body
einer
PUT
-Anfrage zu empfangen.
Deklarieren Sie den Body mithilfe von Standard-Python-Typen, dank Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Der Server sollte automatisch neu geladen werden (weil Sie oben
--reload
zum Befehl
uvicorn
hinzugef√ºgt haben).
Aktualisierung der interaktiven API-Dokumentation
Gehen Sie jetzt auf
http://127.0.0.1:8000/docs
.
Die interaktive API-Dokumentation wird automatisch aktualisiert, einschlie√ülich des neuen Bodys:
Klicken Sie auf die Taste ‚ÄûTry it out‚Äú, damit k√∂nnen Sie die Parameter ausf√ºllen und direkt mit der API interagieren:
Klicken Sie dann auf die Taste ‚ÄûExecute‚Äú, die Benutzeroberfl√§che wird mit Ihrer API kommunizieren, sendet die Parameter, holt die Ergebnisse und zeigt sie auf dem Bildschirm an:
Aktualisierung der alternativen API-Dokumentation
Und nun gehen Sie auf
http://127.0.0.1:8000/redoc
.
Die alternative Dokumentation wird ebenfalls den neuen Abfrageparameter und -inhalt widerspiegeln:
Zusammenfassung
Zusammengefasst deklarieren Sie
einmal
die Typen von Parametern, Body, etc. als Funktionsparameter.
Das machen Sie mit modernen Standard-Python-Typen.
Sie m√ºssen keine neue Syntax, Methoden oder Klassen einer bestimmten Bibliothek usw. lernen.
Nur Standard-
Python+
.
Zum Beispiel f√ºr ein
int
:
item_id
:
int
oder f√ºr ein komplexeres
Item
-Modell:
item
:
Item
... und mit dieser einen Deklaration erhalten Sie:
Editor-Unterst√ºtzung, einschlie√ülich:
Code-Vervollst√§ndigung.
Typpr√ºfungen.
Validierung von Daten:
Automatische und eindeutige Fehler, wenn die Daten ung√ºltig sind.
Validierung auch f√ºr tief verschachtelte JSON-Objekte.
Konvertierung
von Eingabedaten: Aus dem Netzwerk kommend, zu Python-Daten und -Typen. Lesen von:
JSON.
Pfad-Parametern.
Abfrage-Parametern.
Cookies.
Header-Feldern.
Formularen.
Dateien.
Konvertierung
von Ausgabedaten: Konvertierung von Python-Daten und -Typen zu Netzwerkdaten (als JSON):
Konvertieren von Python-Typen (
str
,
int
,
float
,
bool
,
list
, usw.).
Datetime
-Objekte.
UUID
-Objekte.
Datenbankmodelle.
... und viele mehr.
Automatische interaktive API-Dokumentation, einschlie√ülich 2 alternativer Benutzeroberfl√§chen:
Swagger UI.
ReDoc.
Um auf das vorherige Codebeispiel zur√ºckzukommen,
FastAPI
wird:
√úberpr√ºfen, dass es eine
item_id
im Pfad f√ºr
GET
- und
PUT
-Anfragen gibt.
√úberpr√ºfen, ob die
item_id
vom Typ
int
f√ºr
GET
- und
PUT
-Anfragen ist.
Falls nicht, wird dem Client ein n√ºtzlicher, eindeutiger Fehler angezeigt.
Pr√ºfen, ob es einen optionalen Abfrageparameter namens
q
(wie in
http://127.0.0.1:8000/items/foo?q=somequery
) f√ºr
GET
-Anfragen gibt.
Da der
q
-Parameter mit
= None
deklariert ist, ist er optional.
Ohne das
None
w√§re er erforderlich (wie der Body im Fall von
PUT
).
Bei
PUT
-Anfragen an
/items/{item_id}
den Body als JSON lesen:
Pr√ºfen, ob er ein erforderliches Attribut
name
hat, das ein
str
sein muss.
Pr√ºfen, ob er ein erforderliches Attribut
price
hat, das ein
float
sein muss.
Pr√ºfen, ob er ein optionales Attribut
is_offer
hat, das ein
bool
sein muss, falls vorhanden.
All dies w√ºrde auch f√ºr tief verschachtelte JSON-Objekte funktionieren.
Automatisch von und nach JSON konvertieren.
Alles mit OpenAPI dokumentieren, welches verwendet werden kann von:
Interaktiven Dokumentationssystemen.
Automatisch Client-Code generierenden Systemen f√ºr viele Sprachen.
Zwei interaktive Dokumentation-Webschnittstellen direkt zur Verf√ºgung stellen.
Wir haben nur an der Oberfl√§che gekratzt, aber Sie bekommen schon eine Vorstellung davon, wie das Ganze funktioniert.
Versuchen Sie, diese Zeile zu √§ndern:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
... von:
...
"item_name"
:
item
.
name
...
... zu:
...
"item_price"
:
item
.
price
...
... und sehen Sie, wie Ihr Editor die Attribute automatisch ausf√ºllt und ihre Typen kennt:
F√ºr ein vollst√§ndigeres Beispiel, mit weiteren Funktionen, siehe das
Tutorial - Benutzerhandbuch
.
Spoiler-Alarm
: Das Tutorial - Benutzerhandbuch enth√§lt:
Deklaration von
Parametern
von anderen verschiedenen Stellen wie:
Header-Felder
,
Cookies
,
Formularfelder
und
Dateien
.
Wie man
Validierungseinschr√§nkungen
wie
maximum_length
oder
regex
setzt.
Ein sehr leistungsf√§higes und einfach zu bedienendes System f√ºr
Dependency Injection
.
Sicherheit und Authentifizierung, einschlie√ülich Unterst√ºtzung f√ºr
OAuth2
mit
JWT-Tokens
und
HTTP-Basic
-Authentifizierung.
Fortgeschrittenere (aber ebenso einfache) Techniken zur Deklaration
tief verschachtelter JSON-Modelle
(dank Pydantic).
GraphQL
Integration mit
Strawberry
und anderen Bibliotheken.
Viele zus√§tzliche Funktionen (dank Starlette) wie:
WebSockets
extrem einfache Tests auf Basis von
httpx
und
pytest
CORS
Cookie Sessions
... und mehr.
Performanz
Unabh√§ngige TechEmpower-Benchmarks zeigen
FastAPI
-Anwendungen, die unter Uvicorn laufen, als
eines der schnellsten verf√ºgbaren Python-Frameworks
, nur noch hinter Starlette und Uvicorn selbst (intern von FastAPI verwendet).
Um mehr dar√ºber zu erfahren, siehe den Abschnitt
Benchmarks
.
Optionale Abh√§ngigkeiten
Wird von Pydantic verwendet:
email-validator
- f√ºr E-Mail-Validierung.
pydantic-settings
- f√ºr die Verwaltung von Einstellungen.
pydantic-extra-types
- f√ºr zus√§tzliche Typen, mit Pydantic zu verwenden.
Wird von Starlette verwendet:
httpx
- erforderlich, wenn Sie den
TestClient
verwenden m√∂chten.
jinja2
- erforderlich, wenn Sie die Standardkonfiguration f√ºr Templates verwenden m√∂chten.
python-multipart
- erforderlich, wenn Sie Formulare mittels
request.form()
‚Äûparsen‚Äú
m√∂chten.
itsdangerous
- erforderlich f√ºr
SessionMiddleware
Unterst√ºtzung.
pyyaml
- erforderlich f√ºr Starlette's
SchemaGenerator
Unterst√ºtzung (Sie brauchen das wahrscheinlich nicht mit FastAPI).
ujson
- erforderlich, wenn Sie
UJSONResponse
verwenden m√∂chten.
Wird von FastAPI / Starlette verwendet:
uvicorn
- f√ºr den Server, der Ihre Anwendung l√§dt und serviert.
orjson
- erforderlich, wenn Sie
ORJSONResponse
verwenden m√∂chten.
Sie k√∂nnen diese alle mit
pip install "fastapi[all]"
installieren.
Lizenz
Dieses Projekt ist unter den Bedingungen der MIT-Lizenz lizenziert.

## 039_DEPLOYMENT
Deployment¬∂
---

Deployment
Deploying a
FastAPI
application is relatively easy.
What Does Deployment Mean
To
deploy
an application means to perform the necessary steps to make it
available to the users
.
For a
web API
, it normally involves putting it in a
remote machine
, with a
server program
that provides good performance, stability, etc, so that your
users
can
access
the application efficiently and without interruptions or problems.
This is in contrast to the
development
stages, where you are constantly changing the code, breaking it and fixing it, stopping and restarting the development server, etc.
Deployment Strategies
There are several ways to do it depending on your specific use case and the tools that you use.
You could
deploy a server
yourself using a combination of tools, you could use a
cloud service
that does part of the work for you, or other possible options.
I will show you some of the main concepts you should probably keep in mind when deploying a
FastAPI
application (although most of it applies to any other type of web application).
You will see more details to keep in mind and some of the techniques to do it in the next sections. ‚ú®

## 040_DEPLOYMENT_CLOUD
Deploy FastAPI on Cloud Providers¬∂
---

Deploy FastAPI on Cloud Providers
You can use virtually
any cloud provider
to deploy your FastAPI application.
In most of the cases, the main cloud providers have guides to deploy FastAPI with them.
Cloud Providers - Sponsors
Some cloud providers ‚ú®
sponsor FastAPI
‚ú®, this ensures the continued and healthy
development
of FastAPI and its
ecosystem
.
And it shows their true commitment to FastAPI and its
community
(you), as they not only want to provide you a
good service
but also want to make sure you have a
good and healthy framework
, FastAPI. üôá
You might want to try their services and follow their guides:
Platform.sh
Porter
Render

## 041_DEPLOYMENT_CONCEPTS
Deployments Concepts¬∂
---

Deployments Concepts
When deploying a
FastAPI
application, or actually, any type of web API, there are several concepts that you probably care about, and using them you can find the
most appropriate
way to
deploy your application
.
Some of the important concepts are:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
We'll see how they would affect
deployments
.
In the end, the ultimate objective is to be able to
serve your API clients
in a way that is
secure
, to
avoid disruptions
, and to use the
compute resources
(for example remote servers/virtual machines) as efficiently as possible. üöÄ
I'll tell you a bit more about these
concepts
here, and that would hopefully give you the
intuition
you would need to decide how to deploy your API in very different environments, possibly even in
future
ones that don't exist yet.
By considering these concepts, you will be able to
evaluate and design
the best way to deploy
your own APIs
.
In the next chapters, I'll give you more
concrete recipes
to deploy FastAPI applications.
But for now, let's check these important
conceptual ideas
. These concepts also apply to any other type of web API. üí°
Security - HTTPS
In the
previous chapter about HTTPS
we learned about how HTTPS provides encryption for your API.
We also saw that HTTPS is normally provided by a component
external
to your application server, a
TLS Termination Proxy
.
And there has to be something in charge of
renewing the HTTPS certificates
, it could be the same component or it could be something different.
Example Tools for HTTPS
Some of the tools you could use as a TLS Termination Proxy are:
Traefik
Automatically handles certificates renewals ‚ú®
Caddy
Automatically handles certificates renewals ‚ú®
Nginx
With an external component like Certbot for certificate renewals
HAProxy
With an external component like Certbot for certificate renewals
Kubernetes with an Ingress Controller like Nginx
With an external component like cert-manager for certificate renewals
Handled internally by a cloud provider as part of their services (read below üëá)
Another option is that you could use a
cloud service
that does more of the work including setting up HTTPS. It could have some restrictions or charge you more, etc. But in that case, you wouldn't have to set up a TLS Termination Proxy yourself.
I'll show you some concrete examples in the next chapters.
Then the next concepts to consider are all about the program running your actual API (e.g. Uvicorn).
Program and Process
We will talk a lot about the running "
process
", so it's useful to have clarity about what it means, and what's the difference with the word "
program
".
What is a Program
The word
program
is commonly used to describe many things:
The
code
that you write, the
Python files
.
The
file
that can be
executed
by the operating system, for example:
python
,
python.exe
or
uvicorn
.
A particular program while it is
running
on the operating system, using the CPU, and storing things in memory. This is also called a
process
.
What is a Process
The word
process
is normally used in a more specific way, only referring to the thing that is running in the operating system (like in the last point above):
A particular program while it is
running
on the operating system.
This doesn't refer to the file, nor to the code, it refers
specifically
to the thing that is being
executed
and managed by the operating system.
Any program, any code,
can only do things
when it is being
executed
. So, when there's a
process running
.
The process can be
terminated
(or "killed") by you, or by the operating system. At that point, it stops running/being executed, and it can
no longer do things
.
Each application that you have running on your computer has some process behind it, each running program, each window, etc. And there are normally many processes running
at the same time
while a computer is on.
There can be
multiple processes
of the
same program
running at the same time.
If you check out the "task manager" or "system monitor" (or similar tools) in your operating system, you will be able to see many of those processes running.
And, for example, you will probably see that there are multiple processes running the same browser program (Firefox, Chrome, Edge, etc). They normally run one process per tab, plus some other extra processes.
Now that we know the difference between the terms
process
and
program
, let's continue talking about deployments.
Running on Startup
In most cases, when you create a web API, you want it to be
always running
, uninterrupted, so that your clients can always access it. This is of course, unless you have a specific reason why you want it to run only in certain situations, but most of the time you want it constantly running and
available
.
In a Remote Server
When you set up a remote server (a cloud server, a virtual machine, etc.) the simplest thing you can do is use
fastapi run
(which uses Uvicorn) or something similar, manually, the same way you do when developing locally.
And it will work and will be useful
during development
.
But if your connection to the server is lost, the
running process
will probably die.
And if the server is restarted (for example after updates, or migrations from the cloud provider) you probably
won't notice it
. And because of that, you won't even know that you have to restart the process manually. So, your API will just stay dead. üò±
Run Automatically on Startup
In general, you will probably want the server program (e.g. Uvicorn) to be started automatically on server startup, and without needing any
human intervention
, to have a process always running with your API (e.g. Uvicorn running your FastAPI app).
Separate Program
To achieve this, you will normally have a
separate program
that would make sure your application is run on startup. And in many cases, it would also make sure other components or applications are also run, for example, a database.
Example Tools to Run at Startup
Some examples of the tools that can do this job are:
Docker
Kubernetes
Docker Compose
Docker in Swarm Mode
Systemd
Supervisor
Handled internally by a cloud provider as part of their services
Others...
I'll give you more concrete examples in the next chapters.
Restarts
Similar to making sure your application is run on startup, you probably also want to make sure it is
restarted
after failures.
We Make Mistakes
We, as humans, make
mistakes
, all the time. Software almost
always
has
bugs
hidden in different places. üêõ
And we as developers keep improving the code as we find those bugs and as we implement new features (possibly adding new bugs too üòÖ).
Small Errors Automatically Handled
When building web APIs with FastAPI, if there's an error in our code, FastAPI will normally contain it to the single request that triggered the error. üõ°
The client will get a
500 Internal Server Error
for that request, but the application will continue working for the next requests instead of just crashing completely.
Bigger Errors - Crashes
Nevertheless, there might be cases where we write some code that
crashes the entire application
making Uvicorn and Python crash. üí•
And still, you would probably not want the application to stay dead because there was an error in one place, you probably want it to
continue running
at least for the
path operations
that are not broken.
Restart After Crash
But in those cases with really bad errors that crash the running
process
, you would want an external component that is in charge of
restarting
the process, at least a couple of times...
Tip
...Although if the whole application is just
crashing immediately
it probably doesn't make sense to keep restarting it forever. But in those cases, you will probably notice it during development, or at least right after deployment.
So let's focus on the main cases, where it could crash entirely in some particular cases
in the future
, and it still makes sense to restart it.
You would probably want to have the thing in charge of restarting your application as an
external component
, because by that point, the same application with Uvicorn and Python already crashed, so there's nothing in the same code of the same app that could do anything about it.
Example Tools to Restart Automatically
In most cases, the same tool that is used to
run the program on startup
is also used to handle automatic
restarts
.
For example, this could be handled by:
Docker
Kubernetes
Docker Compose
Docker in Swarm Mode
Systemd
Supervisor
Handled internally by a cloud provider as part of their services
Others...
Replication - Processes and Memory
With a FastAPI application, using a server program like the
fastapi
command that runs Uvicorn, running it once in
one process
can serve multiple clients concurrently.
But in many cases, you will want to run several worker processes at the same time.
Multiple Processes - Workers
If you have more clients than what a single process can handle (for example if the virtual machine is not too big) and you have
multiple cores
in the server's CPU, then you could have
multiple processes
running with the same application at the same time, and distribute all the requests among them.
When you run
multiple processes
of the same API program, they are commonly called
workers
.
Worker Processes and Ports
Remember from the docs
About HTTPS
that only one process can be listening on one combination of port and IP address in a server?
This is still true.
So, to be able to have
multiple processes
at the same time, there has to be a
single process listening on a port
that then transmits the communication to each worker process in some way.
Memory per Process
Now, when the program loads things in memory, for example, a machine learning model in a variable, or the contents of a large file in a variable, all that
consumes a bit of the memory (RAM)
of the server.
And multiple processes normally
don't share any memory
. This means that each running process has its own things, variables, and memory. And if you are consuming a large amount of memory in your code,
each process
will consume an equivalent amount of memory.
Server Memory
For example, if your code loads a Machine Learning model with
1 GB in size
, when you run one process with your API, it will consume at least 1 GB of RAM. And if you start
4 processes
(4 workers), each will consume 1 GB of RAM. So in total, your API will consume
4 GB of RAM
.
And if your remote server or virtual machine only has 3 GB of RAM, trying to load more than 4 GB of RAM will cause problems. üö®
Multiple Processes - An Example
In this example, there's a
Manager Process
that starts and controls two
Worker Processes
.
This Manager Process would probably be the one listening on the
port
in the IP. And it would transmit all the communication to the worker processes.
Those worker processes would be the ones running your application, they would perform the main computations to receive a
request
and return a
response
, and they would load anything you put in variables in RAM.
And of course, the same machine would probably have
other processes
running as well, apart from your application.
An interesting detail is that the percentage of the
CPU used
by each process can
vary
a lot over time, but the
memory (RAM)
normally stays more or less
stable
.
If you have an API that does a comparable amount of computations every time and you have a lot of clients, then the
CPU utilization
will probably
also be stable
(instead of constantly going up and down quickly).
Examples of Replication Tools and Strategies
There can be several approaches to achieve this, and I'll tell you more about specific strategies in the next chapters, for example when talking about Docker and containers.
The main constraint to consider is that there has to be a
single
component handling the
port
in the
public IP
. And then it has to have a way to
transmit
the communication to the replicated
processes/workers
.
Here are some possible combinations and strategies:
Uvicorn
with
--workers
One Uvicorn
process manager
would listen on the
IP
and
port
, and it would start
multiple Uvicorn worker processes
.
Kubernetes
and other distributed
container systems
Something in the
Kubernetes
layer would listen on the
IP
and
port
. The replication would be by having
multiple containers
, each with
one Uvicorn process
running.
Cloud services
that handle this for you
The cloud service will probably
handle replication for you
. It would possibly let you define
a process to run
, or a
container image
to use, in any case, it would most probably be
a single Uvicorn process
, and the cloud service would be in charge of replicating it.
Tip
Don't worry if some of these items about
containers
, Docker, or Kubernetes don't make a lot of sense yet.
I'll tell you more about container images, Docker, Kubernetes, etc. in a future chapter:
FastAPI in Containers - Docker
.
Previous Steps Before Starting
There are many cases where you want to perform some steps
before starting
your application.
For example, you might want to run
database migrations
.
But in most cases, you will want to perform these steps only
once
.
So, you will want to have a
single process
to perform those
previous steps
, before starting the application.
And you will have to make sure that it's a single process running those previous steps
even
if afterwards, you start
multiple processes
(multiple workers) for the application itself. If those steps were run by
multiple processes
, they would
duplicate
the work by running it in
parallel
, and if the steps were something delicate like a database migration, they could cause conflicts with each other.
Of course, there are some cases where there's no problem in running the previous steps multiple times, in that case, it's a lot easier to handle.
Tip
Also, keep in mind that depending on your setup, in some cases you
might not even need any previous steps
before starting your application.
In that case, you wouldn't have to worry about any of this. ü§∑
Examples of Previous Steps Strategies
This will
depend heavily
on the way you
deploy your system
, and it would probably be connected to the way you start programs, handling restarts, etc.
Here are some possible ideas:
An "Init Container" in Kubernetes that runs before your app container
A bash script that runs the previous steps and then starts your application
You would still need a way to start/restart
that
bash script, detect errors, etc.
Tip
I'll give you more concrete examples for doing this with containers in a future chapter:
FastAPI in Containers - Docker
.
Resource Utilization
Your server(s) is (are) a
resource
, you can consume or
utilize
, with your programs, the computation time on the CPUs, and the RAM memory available.
How much of the system resources do you want to be consuming/utilizing? It might be easy to think "not much", but in reality, you will probably want to consume
as much as possible without crashing
.
If you are paying for 3 servers but you are using only a little bit of their RAM and CPU, you are probably
wasting money
üí∏, and probably
wasting server electric power
üåé, etc.
In that case, it could be better to have only 2 servers and use a higher percentage of their resources (CPU, memory, disk, network bandwidth, etc).
On the other hand, if you have 2 servers and you are using
100% of their CPU and RAM
, at some point one process will ask for more memory, and the server will have to use the disk as "memory" (which can be thousands of times slower), or even
crash
. Or one process might need to do some computation and would have to wait until the CPU is free again.
In this case, it would be better to get
one extra server
and run some processes on it so that they all have
enough RAM and CPU time
.
There's also the chance that for some reason you have a
spike
of usage of your API. Maybe it went viral, or maybe some other services or bots start using it. And you might want to have extra resources to be safe in those cases.
You could put an
arbitrary number
to target, for example, something
between 50% to 90%
of resource utilization. The point is that those are probably the main things you will want to measure and use to tweak your deployments.
You can use simple tools like
htop
to see the CPU and RAM used in your server or the amount used by each process. Or you can use more complex monitoring tools, which may be distributed across servers, etc.
Recap
You have been reading here some of the main concepts that you would probably need to keep in mind when deciding how to deploy your application:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
Understanding these ideas and how to apply them should give you the intuition necessary to take any decisions when configuring and tweaking your deployments. ü§ì
In the next sections, I'll give you more concrete examples of possible strategies you can follow. üöÄ

## 042_DEPLOYMENT_DOCKER
FastAPI in Containers - Docker¬∂
---

FastAPI in Containers - Docker
When deploying FastAPI applications a common approach is to build a
Linux container image
. It's normally done using
Docker
. You can then deploy that container image in one of a few possible ways.
Using Linux containers has several advantages including
security
,
replicability
,
simplicity
, and others.
Tip
In a hurry and already know this stuff? Jump to the
Dockerfile
below üëá
.
Dockerfile Preview üëÄ
FROM
python:3.9
WORKDIR
/code
COPY
./requirements.txt
/code/requirements.txt
RUN
pip
install
--no-cache-dir
--upgrade
-r
/code/requirements.txt
COPY
./app
/code/app
CMD
[
"fastapi"
,
"run"
,
"app/main.py"
,
"--port"
,
"80"
]
## If running behind a proxy like Nginx or Traefik add --proxy-headers
## CMD ["fastapi", "run", "app/main.py", "--port", "80", "--proxy-headers"]
What is a Container
Containers (mainly Linux containers) are a very
lightweight
way to package applications including all their dependencies and necessary files while keeping them isolated from other containers (other applications or components) in the same system.
Linux containers run using the same Linux kernel of the host (machine, virtual machine, cloud server, etc). This just means that they are very lightweight (compared to full virtual machines emulating an entire operating system).
This way, containers consume
little resources
, an amount comparable to running the processes directly (a virtual machine would consume much more).
Containers also have their own
isolated
running processes (commonly just one process), file system, and network, simplifying deployment, security, development, etc.
What is a Container Image
A
container
is run from a
container image
.
A container image is a
static
version of all the files, environment variables, and the default command/program that should be present in a container.
Static
here means that the container
image
is not running, it's not being executed, it's only the packaged files and metadata.
In contrast to a "
container image
" that is the stored static contents, a "
container
" normally refers to the running instance, the thing that is being
executed
.
When the
container
is started and running (started from a
container image
) it could create or change files, environment variables, etc. Those changes will exist only in that container, but would not persist in the underlying container image (would not be saved to disk).
A container image is comparable to the
program
file and contents, e.g.
python
and some file
main.py
.
And the
container
itself (in contrast to the
container image
) is the actual running instance of the image, comparable to a
process
. In fact, a container is running only when it has a
process running
(and normally it's only a single process). The container stops when there's no process running in it.
Container Images
Docker has been one of the main tools to create and manage
container images
and
containers
.
And there's a public
Docker Hub
with pre-made
official container images
for many tools, environments, databases, and applications.
For example, there's an official
Python Image
.
And there are many other images for different things like databases, for example for:
PostgreSQL
MySQL
MongoDB
Redis
, etc.
By using a pre-made container image it's very easy to
combine
and use different tools. For example, to try out a new database. In most cases, you can use the
official images
, and just configure them with environment variables.
That way, in many cases you can learn about containers and Docker and reuse that knowledge with many different tools and components.
So, you would run
multiple containers
with different things, like a database, a Python application, a web server with a React frontend application, and connect them together via their internal network.
All the container management systems (like Docker or Kubernetes) have these networking features integrated into them.
Containers and Processes
A
container image
normally includes in its metadata the default program or command that should be run when the
container
is started and the parameters to be passed to that program. Very similar to what would be if it was in the command line.
When a
container
is started, it will run that command/program (although you can override it and make it run a different command/program).
A container is running as long as the
main process
(command or program) is running.
A container normally has a
single process
, but it's also possible to start subprocesses from the main process, and that way you will have
multiple processes
in the same container.
But it's not possible to have a running container without
at least one running process
. If the main process stops, the container stops.
Build a Docker Image for FastAPI
Okay, let's build something now! üöÄ
I'll show you how to build a
Docker image
for FastAPI
from scratch
, based on the
official Python
image.
This is what you would want to do in
most cases
, for example:
Using
Kubernetes
or similar tools
When running on a
Raspberry Pi
Using a cloud service that would run a container image for you, etc.
Package Requirements
You would normally have the
package requirements
for your application in some file.
It would depend mainly on the tool you use to
install
those requirements.
The most common way to do it is to have a file
requirements.txt
with the package names and their versions, one per line.
You would of course use the same ideas you read in
About FastAPI versions
to set the ranges of versions.
For example, your
requirements.txt
could look like:
fastapi[standard]>=0.113.0,<0.114.0
pydantic>=2.7.0,<3.0.0
And you would normally install those package dependencies with
pip
, for example:
fast ‚Üí
pip install -r requirements.txt
Successfully installed fastapi pydantic
restart ‚Üª
Info
There are other formats and tools to define and install package dependencies.
Create the
FastAPI
Code
Create an
app
directory and enter it.
Create an empty file
__init__.py
.
Create a
main.py
file with:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Dockerfile
Now in the same project directory create a file
Dockerfile
with:
FROM
python:3.9
WORKDIR
/code
COPY
./requirements.txt
/code/requirements.txt
RUN
pip
install
--no-cache-dir
--upgrade
-r
/code/requirements.txt
COPY
./app
/code/app
CMD
[
"fastapi"
,
"run"
,
"app/main.py"
,
"--port"
,
"80"
]
Tip
Review what each line does by clicking each number bubble in the code. üëÜ
Warning
Make sure to
always
use the
exec form
of the
CMD
instruction, as explained below.
Use
CMD
- Exec Form
The
CMD
Docker instruction can be written using two forms:
‚úÖ
Exec
form:
## ‚úÖ Do this
CMD
[
"fastapi"
,
"run"
,
"app/main.py"
,
"--port"
,
"80"
]
‚õîÔ∏è
Shell
form:
## ‚õîÔ∏è Don't do this
CMD
fastapi
run
app/main.py
--port
80
Make sure to always use the
exec
form to ensure that FastAPI can shutdown gracefully and
lifespan events
are triggered.
You can read more about it in the
Docker docs for shell and exec form
.
This can be quite noticeable when using
docker compose
. See this Docker Compose FAQ section for more technical details:
Why do my services take 10 seconds to recreate or stop?
.
Directory Structure
You should now have a directory structure like:
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ ‚îî‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ Dockerfile
‚îî‚îÄ‚îÄ requirements.txt
Behind a TLS Termination Proxy
If you are running your container behind a TLS Termination Proxy (load balancer) like Nginx or Traefik, add the option
--proxy-headers
, this will tell Uvicorn (through the FastAPI CLI) to trust the headers sent by that proxy telling it that the application is running behind HTTPS, etc.
CMD
[
"fastapi"
,
"run"
,
"app/main.py"
,
"--proxy-headers"
,
"--port"
,
"80"
]
Docker Cache
There's an important trick in this
Dockerfile
, we first copy the
file with the dependencies alone
, not the rest of the code. Let me tell you why is that.
COPY
./requirements.txt
/code/requirements.txt
Docker and other tools
build
these container images
incrementally
, adding
one layer on top of the other
, starting from the top of the
Dockerfile
and adding any files created by each of the instructions of the
Dockerfile
.
Docker and similar tools also use an
internal cache
when building the image, if a file hasn't changed since the last time building the container image, then it will
reuse the same layer
created the last time, instead of copying the file again and creating a new layer from scratch.
Just avoiding the copy of files doesn't necessarily improve things too much, but because it used the cache for that step, it can
use the cache for the next step
. For example, it could use the cache for the instruction that installs dependencies with:
RUN
pip
install
--no-cache-dir
--upgrade
-r
/code/requirements.txt
The file with the package requirements
won't change frequently
. So, by copying only that file, Docker will be able to
use the cache
for that step.
And then, Docker will be able to
use the cache for the next step
that downloads and install those dependencies. And here's where we
save a lot of time
. ‚ú® ...and avoid boredom waiting. üò™üòÜ
Downloading and installing the package dependencies
could take minutes
, but using the
cache
would
take seconds
at most.
And as you would be building the container image again and again during development to check that your code changes are working, there's a lot of accumulated time this would save.
Then, near the end of the
Dockerfile
, we copy all the code. As this is what
changes most frequently
, we put it near the end, because almost always, anything after this step will not be able to use the cache.
COPY
./app
/code/app
Build the Docker Image
Now that all the files are in place, let's build the container image.
Go to the project directory (in where your
Dockerfile
is, containing your
app
directory).
Build your FastAPI image:
fast ‚Üí
docker build -t myimage .
restart ‚Üª
Tip
Notice the
.
at the end, it's equivalent to
./
, it tells Docker the directory to use to build the container image.
In this case, it's the same current directory (
.
).
Start the Docker Container
Run a container based on your image:
fast ‚Üí
docker run -d --name mycontainer -p 80:80 myimage
restart ‚Üª
Check it
You should be able to check it in your Docker container's URL, for example:
http://192.168.99.100/items/5?q=somequery
or
http://127.0.0.1/items/5?q=somequery
(or equivalent, using your Docker host).
You will see something like:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Interactive API docs
Now you can go to
http://192.168.99.100/docs
or
http://127.0.0.1/docs
(or equivalent, using your Docker host).
You will see the automatic interactive API documentation (provided by
Swagger UI
):
Alternative API docs
And you can also go to
http://192.168.99.100/redoc
or
http://127.0.0.1/redoc
(or equivalent, using your Docker host).
You will see the alternative automatic documentation (provided by
ReDoc
):
Build a Docker Image with a Single-File FastAPI
If your FastAPI is a single file, for example,
main.py
without an
./app
directory, your file structure could look like this:
.
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ main.py
‚îî‚îÄ‚îÄ requirements.txt
Then you would just have to change the corresponding paths to copy the file inside the
Dockerfile
:
FROM
python:3.9
WORKDIR
/code
COPY
./requirements.txt
/code/requirements.txt
RUN
pip
install
--no-cache-dir
--upgrade
-r
/code/requirements.txt
COPY
./main.py
/code/
CMD
[
"fastapi"
,
"run"
,
"main.py"
,
"--port"
,
"80"
]
When you pass the file to
fastapi run
it will detect automatically that it is a single file and not part of a package and will know how to import it and serve your FastAPI app. üòé
Deployment Concepts
Let's talk again about some of the same
Deployment Concepts
in terms of containers.
Containers are mainly a tool to simplify the process of
building and deploying
an application, but they don't enforce a particular approach to handle these
deployment concepts
, and there are several possible strategies.
The
good news
is that with each different strategy there's a way to cover all of the deployment concepts. üéâ
Let's review these
deployment concepts
in terms of containers:
HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
HTTPS
If we focus just on the
container image
for a FastAPI application (and later the running
container
), HTTPS normally would be handled
externally
by another tool.
It could be another container, for example with
Traefik
, handling
HTTPS
and
automatic
acquisition of
certificates
.
Tip
Traefik has integrations with Docker, Kubernetes, and others, so it's very easy to set up and configure HTTPS for your containers with it.
Alternatively, HTTPS could be handled by a cloud provider as one of their services (while still running the application in a container).
Running on Startup and Restarts
There is normally another tool in charge of
starting and running
your container.
It could be
Docker
directly,
Docker Compose
,
Kubernetes
, a
cloud service
, etc.
In most (or all) cases, there's a simple option to enable running the container on startup and enabling restarts on failures. For example, in Docker, it's the command line option
--restart
.
Without using containers, making applications run on startup and with restarts can be cumbersome and difficult. But when
working with containers
in most cases that functionality is included by default. ‚ú®
Replication - Number of Processes
If you have a
cluster
of machines with
Kubernetes
, Docker Swarm Mode, Nomad, or another similar complex system to manage distributed containers on multiple machines, then you will probably want to
handle replication
at the
cluster level
instead of using a
process manager
(like Uvicorn with workers) in each container.
One of those distributed container management systems like Kubernetes normally has some integrated way of handling
replication of containers
while still supporting
load balancing
for the incoming requests. All at the
cluster level
.
In those cases, you would probably want to build a
Docker image from scratch
as
explained above
, installing your dependencies, and running
a single Uvicorn process
instead of using multiple Uvicorn workers.
Load Balancer
When using containers, you would normally have some component
listening on the main port
. It could possibly be another container that is also a
TLS Termination Proxy
to handle
HTTPS
or some similar tool.
As this component would take the
load
of requests and distribute that among the workers in a (hopefully)
balanced
way, it is also commonly called a
Load Balancer
.
Tip
The same
TLS Termination Proxy
component used for HTTPS would probably also be a
Load Balancer
.
And when working with containers, the same system you use to start and manage them would already have internal tools to transmit the
network communication
(e.g. HTTP requests) from that
load balancer
(that could also be a
TLS Termination Proxy
) to the container(s) with your app.
One Load Balancer - Multiple Worker Containers
When working with
Kubernetes
or similar distributed container management systems, using their internal networking mechanisms would allow the single
load balancer
that is listening on the main
port
to transmit communication (requests) to possibly
multiple containers
running your app.
Each of these containers running your app would normally have
just one process
(e.g. a Uvicorn process running your FastAPI application). They would all be
identical containers
, running the same thing, but each with its own process, memory, etc. That way you would take advantage of
parallelization
in
different cores
of the CPU, or even in
different machines
.
And the distributed container system with the
load balancer
would
distribute the requests
to each one of the containers with your app
in turns
. So, each request could be handled by one of the multiple
replicated containers
running your app.
And normally this
load balancer
would be able to handle requests that go to
other
apps in your cluster (e.g. to a different domain, or under a different URL path prefix), and would transmit that communication to the right containers for
that other
application running in your cluster.
One Process per Container
In this type of scenario, you probably would want to have
a single (Uvicorn) process per container
, as you would already be handling replication at the cluster level.
So, in this case, you
would not
want to have a multiple workers in the container, for example with the
--workers
command line option.You would want to have just a
single Uvicorn process
per container (but probably multiple containers).
Having another process manager inside the container (as would be with multiple workers) would only add
unnecessary complexity
that you are most probably already taking care of with your cluster system.
Containers with Multiple Processes and Special Cases
Of course, there are
special cases
where you could want to have
a container
with several
Uvicorn worker processes
inside.
In those cases, you can use the
--workers
command line option to set the number of workers that you want to run:
FROM
python:3.9
WORKDIR
/code
COPY
./requirements.txt
/code/requirements.txt
RUN
pip
install
--no-cache-dir
--upgrade
-r
/code/requirements.txt
COPY
./app
/code/app
CMD
[
"fastapi"
,
"run"
,
"app/main.py"
,
"--port"
,
"80"
,
"--workers"
,
"4"
]
Here are some examples of when that could make sense:
A Simple App
You could want a process manager in the container if your application is
simple enough
that can run it on a
single server
, not a cluster.
Docker Compose
You could be deploying to a
single server
(not a cluster) with
Docker Compose
, so you wouldn't have an easy way to manage replication of containers (with Docker Compose) while preserving the shared network and
load balancing
.
Then you could want to have
a single container
with a
process manager
starting
several worker processes
inside.
The main point is,
none
of these are
rules written in stone
that you have to blindly follow. You can use these ideas to
evaluate your own use case
and decide what is the best approach for your system, checking out how to manage the concepts of:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
Memory
If you run
a single process per container
you will have a more or less well-defined, stable, and limited amount of memory consumed by each of those containers (more than one if they are replicated).
And then you can set those same memory limits and requirements in your configurations for your container management system (for example in
Kubernetes
). That way it will be able to
replicate the containers
in the
available machines
taking into account the amount of memory needed by them, and the amount available in the machines in the cluster.
If your application is
simple
, this will probably
not be a problem
, and you might not need to specify hard memory limits. But if you are
using a lot of memory
(for example with
machine learning
models), you should check how much memory you are consuming and adjust the
number of containers
that runs in
each machine
(and maybe add more machines to your cluster).
If you run
multiple processes per container
you will have to make sure that the number of processes started doesn't
consume more memory
than what is available.
Previous Steps Before Starting and Containers
If you are using containers (e.g. Docker, Kubernetes), then there are two main approaches you can use.
Multiple Containers
If you have
multiple containers
, probably each one running a
single process
(for example, in a
Kubernetes
cluster), then you would probably want to have a
separate container
doing the work of the
previous steps
in a single container, running a single process,
before
running the replicated worker containers.
Info
If you are using Kubernetes, this would probably be an
Init Container
.
If in your use case there's no problem in running those previous steps
multiple times in parallel
(for example if you are not running database migrations, but just checking if the database is ready yet), then you could also just put them in each container right before starting the main process.
Single Container
If you have a simple setup, with a
single container
that then starts multiple
worker processes
(or also just one process), then you could run those previous steps in the same container, right before starting the process with the app.
Base Docker Image
There used to be an official FastAPI Docker image:
tiangolo/uvicorn-gunicorn-fastapi
. But it is now deprecated. ‚õîÔ∏è
You should probably
not
use this base Docker image (or any other similar one).
If you are using
Kubernetes
(or others) and you are already setting
replication
at the cluster level, with multiple
containers
. In those cases, you are better off
building an image from scratch
as described above:
Build a Docker Image for FastAPI
.
And if you need to have multiple workers, you can simply use the
--workers
command line option.
Technical Details
The Docker image was created when Uvicorn didn't support managing and restarting dead workers, so it was needed to use Gunicorn with Uvicorn, which added quite some complexity, just to have Gunicorn manage and restart the Uvicorn worker processes.
But now that Uvicorn (and the
fastapi
command) support using
--workers
, there's no reason to use a base Docker image instead of building your own (it's pretty much the same amount of code üòÖ).
Deploy the Container Image
After having a Container (Docker) Image there are several ways to deploy it.
For example:
With
Docker Compose
in a single server
With a
Kubernetes
cluster
With a Docker Swarm Mode cluster
With another tool like Nomad
With a cloud service that takes your container image and deploys it
Docker Image with
uv
If you are using
uv
to install and manage your project, you can follow their
uv Docker guide
.
Recap
Using container systems (e.g. with
Docker
and
Kubernetes
) it becomes fairly straightforward to handle all the
deployment concepts
:
HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
In most cases, you probably won't want to use any base image, and instead
build a container image from scratch
based on the official Python Docker image.
Taking care of the
order
of instructions in the
Dockerfile
and the
Docker cache
you can
minimize build times
, to maximize your productivity (and avoid boredom). üòé

## 043_DEPLOYMENT_HTTPS
About HTTPS¬∂
---

About HTTPS
It is easy to assume that HTTPS is something that is just "enabled" or not.
But it is way more complex than that.
Tip
If you are in a hurry or don't care, continue with the next sections for step by step instructions to set everything up with different techniques.
To
learn the basics of HTTPS
, from a consumer perspective, check
https://howhttps.works/
.
Now, from a
developer's perspective
, here are several things to keep in mind while thinking about HTTPS:
For HTTPS,
the server
needs to
have "certificates"
generated by a
third party
.
Those certificates are actually
acquired
from the third party, not "generated".
Certificates have a
lifetime
.
They
expire
.
And then they need to be
renewed
,
acquired again
from the third party.
The encryption of the connection happens at the
TCP level
.
That's one layer
below HTTP
.
So, the
certificate and encryption
handling is done
before HTTP
.
TCP doesn't know about "domains"
. Only about IP addresses.
The information about the
specific domain
requested goes in the
HTTP data
.
The
HTTPS certificates
"certify" a
certain domain
, but the protocol and encryption happen at the TCP level,
before knowing
which domain is being dealt with.
By default
, that would mean that you can only have
one HTTPS certificate per IP address
.
No matter how big your server is or how small each application you have on it might be.
There is a
solution
to this, however.
There's an
extension
to the
TLS
protocol (the one handling the encryption at the TCP level, before HTTP) called
SNI
.
This SNI extension allows one single server (with a
single IP address
) to have
several HTTPS certificates
and serve
multiple HTTPS domains/applications
.
For this to work, a
single
component (program) running on the server, listening on the
public IP address
, must have
all the HTTPS certificates
in the server.
After
obtaining a secure connection, the communication protocol is
still HTTP
.
The contents are
encrypted
, even though they are being sent with the
HTTP protocol
.
It is a common practice to have
one program/HTTP server
running on the server (the machine, host, etc.) and
managing all the HTTPS parts
: receiving the
encrypted HTTPS requests
, sending the
decrypted HTTP requests
to the actual HTTP application running in the same server (the
FastAPI
application, in this case), take the
HTTP response
from the application,
encrypt it
using the appropriate
HTTPS certificate
and sending it back to the client using
HTTPS
. This server is often called a
TLS Termination Proxy
.
Some of the options you could use as a TLS Termination Proxy are:
Traefik (that can also handle certificate renewals)
Caddy (that can also handle certificate renewals)
Nginx
HAProxy
Let's Encrypt
Before Let's Encrypt, these
HTTPS certificates
were sold by trusted third parties.
The process to acquire one of these certificates used to be cumbersome, require quite some paperwork and the certificates were quite expensive.
But then
Let's Encrypt
was created.
It is a project from the Linux Foundation. It provides
HTTPS certificates for free
, in an automated way. These certificates use all the standard cryptographic security, and are short-lived (about 3 months), so the
security is actually better
because of their reduced lifespan.
The domains are securely verified and the certificates are generated automatically. This also allows automating the renewal of these certificates.
The idea is to automate the acquisition and renewal of these certificates so that you can have
secure HTTPS, for free, forever
.
HTTPS for Developers
Here's an example of how an HTTPS API could look like, step by step, paying attention mainly to the ideas important for developers.
Domain Name
It would probably all start by you
acquiring
some
domain name
. Then, you would configure it in a DNS server (possibly your same cloud provider).
You would probably get a cloud server (a virtual machine) or something similar, and it would have a
fixed
public IP address
.
In the DNS server(s) you would configure a record (an "
A record
") to point
your domain
to the public
IP address of your server
.
You would probably do this just once, the first time, when setting everything up.
Tip
This Domain Name part is way before HTTPS, but as everything depends on the domain and the IP address, it's worth mentioning it here.
DNS
Now let's focus on all the actual HTTPS parts.
First, the browser would check with the
DNS servers
what is the
IP for the domain
, in this case,
someapp.example.com
.
The DNS servers would tell the browser to use some specific
IP address
. That would be the public IP address used by your server, that you configured in the DNS servers.
TLS Handshake Start
The browser would then communicate with that IP address on
port 443
(the HTTPS port).
The first part of the communication is just to establish the connection between the client and the server and to decide the cryptographic keys they will use, etc.
This interaction between the client and the server to establish the TLS connection is called the
TLS handshake
.
TLS with SNI Extension
Only one process
in the server can be listening on a specific
port
in a specific
IP address
. There could be other processes listening on other ports in the same IP address, but only one for each combination of IP address and port.
TLS (HTTPS) uses the specific port
443
by default. So that's the port we would need.
As only one process can be listening on this port, the process that would do it would be the
TLS Termination Proxy
.
The TLS Termination Proxy would have access to one or more
TLS certificates
(HTTPS certificates).
Using the
SNI extension
discussed above, the TLS Termination Proxy would check which of the TLS (HTTPS) certificates available it should use for this connection, using the one that matches the domain expected by the client.
In this case, it would use the certificate for
someapp.example.com
.
The client already
trusts
the entity that generated that TLS certificate (in this case Let's Encrypt, but we'll see about that later), so it can
verify
that the certificate is valid.
Then, using the certificate, the client and the TLS Termination Proxy
decide how to encrypt
the rest of the
TCP communication
. This completes the
TLS Handshake
part.
After this, the client and the server have an
encrypted TCP connection
, this is what TLS provides. And then they can use that connection to start the actual
HTTP communication
.
And that's what
HTTPS
is, it's just plain
HTTP
inside a
secure TLS connection
instead of a pure (unencrypted) TCP connection.
Tip
Notice that the encryption of the communication happens at the
TCP level
, not at the HTTP level.
HTTPS Request
Now that the client and server (specifically the browser and the TLS Termination Proxy) have an
encrypted TCP connection
, they can start the
HTTP communication
.
So, the client sends an
HTTPS request
. This is just an HTTP request through an encrypted TLS connection.
Decrypt the Request
The TLS Termination Proxy would use the encryption agreed to
decrypt the request
, and would transmit the
plain (decrypted) HTTP request
to the process running the application (for example a process with Uvicorn running the FastAPI application).
HTTP Response
The application would process the request and send a
plain (unencrypted) HTTP response
to the TLS Termination Proxy.
HTTPS Response
The TLS Termination Proxy would then
encrypt the response
using the cryptography agreed before (that started with the certificate for
someapp.example.com
), and send it back to the browser.
Next, the browser would verify that the response is valid and encrypted with the right cryptographic key, etc. It would then
decrypt the response
and process it.
The client (browser) will know that the response comes from the correct server because it is using the cryptography they agreed using the
HTTPS certificate
before.
Multiple Applications
In the same server (or servers), there could be
multiple applications
, for example, other API programs or a database.
Only one process can be handling the specific IP and port (the TLS Termination Proxy in our example) but the other applications/processes can be running on the server(s) too, as long as they don't try to use the same
combination of public IP and port
.
That way, the TLS Termination Proxy could handle HTTPS and certificates for
multiple domains
, for multiple applications, and then transmit the requests to the right application in each case.
Certificate Renewal
At some point in the future, each certificate would
expire
(about 3 months after acquiring it).
And then, there would be another program (in some cases it's another program, in some cases it could be the same TLS Termination Proxy) that would talk to Let's Encrypt, and renew the certificate(s).
The
TLS certificates
are
associated with a domain name
, not with an IP address.
So, to renew the certificates, the renewal program needs to
prove
to the authority (Let's Encrypt) that it indeed
"owns" and controls that domain
.
To do that, and to accommodate different application needs, there are several ways it can do it. Some popular ways are:
Modify some DNS records
.
For this, the renewal program needs to support the APIs of the DNS provider, so, depending on the DNS provider you are using, this might or might not be an option.
Run as a server
(at least during the certificate acquisition process) on the public IP address associated with the domain.
As we said above, only one process can be listening on a specific IP and port.
This is one of the reasons why it's very useful when the same TLS Termination Proxy also takes care of the certificate renewal process.
Otherwise, you might have to stop the TLS Termination Proxy momentarily, start the renewal program to acquire the certificates, then configure them with the TLS Termination Proxy, and then restart the TLS Termination Proxy. This is not ideal, as your app(s) will not be available during the time that the TLS Termination Proxy is off.
All this renewal process, while still serving the app, is one of the main reasons why you would want to have a
separate system to handle HTTPS
with a TLS Termination Proxy instead of just using the TLS certificates with the application server directly (e.g. Uvicorn).
Recap
Having
HTTPS
is very important, and quite
critical
in most cases. Most of the effort you as a developer have to put around HTTPS is just about
understanding these concepts
and how they work.
But once you know the basic information of
HTTPS for developers
you can easily combine and configure different tools to help you manage everything in a simple way.
In some of the next chapters, I'll show you several concrete examples of how to set up
HTTPS
for
FastAPI
applications. üîí

## 044_DEPLOYMENT_MANUALLY
Run a Server Manually¬∂
---

Run a Server Manually
Use the
fastapi run
Command
In short, use
fastapi run
to serve your FastAPI application:
fast ‚Üí
fastapi run main.py
FastAPI
Starting production server üöÄ
Searching for package file structure from directories
with
__init__.py
files
Importing from
/home/user/code/
awesomeapp
module
üêç main.py
code
Importing the FastAPI app object from the module with
the following code:
from
main
import
app
app
Using import string:
main:app
server
Server started at
http://0.0.0.0:8000
server
Documentation at
http://0.0.0.0:8000/docs
Logs:
INFO
Started server process
[
2306215
]
INFO
Waiting for application startup.
INFO
Application startup complete.
INFO
Uvicorn running on
http://0.0.0.0:8000
(
Press CTRL+C
to quit
)
That would work for most of the cases. üòé
You could use that command for example to start your
FastAPI
app in a container, in a server, etc.
ASGI Servers
Let's go a little deeper into the details.
FastAPI uses a standard for building Python web frameworks and servers called
ASGI
. FastAPI is an ASGI web framework.
The main thing you need to run a
FastAPI
application (or any other ASGI application) in a remote server machine is an ASGI server program like
Uvicorn
, this is the one that comes by default in the
fastapi
command.
There are several alternatives, including:
Uvicorn
: a high performance ASGI server.
Hypercorn
: an ASGI server compatible with HTTP/2 and Trio among other features.
Daphne
: the ASGI server built for Django Channels.
Granian
: A Rust HTTP server for Python applications.
NGINX Unit
: NGINX Unit is a lightweight and versatile web application runtime.
Server Machine and Server Program
There's a small detail about names to keep in mind. üí°
The word "
server
" is commonly used to refer to both the remote/cloud computer (the physical or virtual machine) and also the program that is running on that machine (e.g. Uvicorn).
Just keep in mind that when you read "server" in general, it could refer to one of those two things.
When referring to the remote machine, it's common to call it
server
, but also
machine
,
VM
(virtual machine),
node
. Those all refer to some type of remote machine, normally running Linux, where you run programs.
Install the Server Program
When you install FastAPI, it comes with a production server, Uvicorn, and you can start it with the
fastapi run
command.
But you can also install an ASGI server manually.
Make sure you create a
virtual environment
, activate it, and then you can install the server application.
For example, to install Uvicorn:
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
A similar process would apply to any other ASGI server program.
Tip
By adding the
standard
, Uvicorn will install and use some recommended extra dependencies.
That including
uvloop
, the high-performance drop-in replacement for
asyncio
, that provides the big concurrency performance boost.
When you install FastAPI with something like
pip install "fastapi[standard]"
you already get
uvicorn[standard]
as well.
Run the Server Program
If you installed an ASGI server manually, you would normally need to pass an import string in a special format for it to import your FastAPI application:
fast ‚Üí
uvicorn main:app --host 0.0.0.0 --port 80
INFO
: Uvicorn running on http://0.0.0.0:80 (Press CTRL+C to quit)
restart ‚Üª
Note
The command
uvicorn main:app
refers to:
main
: the file
main.py
(the Python "module").
app
: the object created inside of
main.py
with the line
app = FastAPI()
.
It is equivalent to:
from
main
import
app
Each alternative ASGI server program would have a similar command, you can read more in their respective documentation.
Warning
Uvicorn and other servers support a
--reload
option that is useful during development.
The
--reload
option consumes much more resources, is more unstable, etc.
It helps a lot during
development
, but you
shouldn't
use it in
production
.
Deployment Concepts
These examples run the server program (e.g Uvicorn), starting
a single process
, listening on all the IPs (
0.0.0.0
) on a predefined port (e.g.
80
).
This is the basic idea. But you will probably want to take care of some additional things, like:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
I'll tell you more about each of these concepts, how to think about them, and some concrete examples with strategies to handle them in the next chapters. üöÄ

## 045_DEPLOYMENT_SERVER_WORKERS
Server Workers - Uvicorn with Workers¬∂
---

Server Workers - Uvicorn with Workers
Let's check back those deployment concepts from before:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
Up to this point, with all the tutorials in the docs, you have probably been running a
server program
, for example, using the
fastapi
command, that runs Uvicorn, running a
single process
.
When deploying applications you will probably want to have some
replication of processes
to take advantage of
multiple cores
and to be able to handle more requests.
As you saw in the previous chapter about
Deployment Concepts
, there are multiple strategies you can use.
Here I'll show you how to use
Uvicorn
with
worker processes
using the
fastapi
command or the
uvicorn
command directly.
Info
If you are using containers, for example with Docker or Kubernetes, I'll tell you more about that in the next chapter:
FastAPI in Containers - Docker
.
In particular, when running on
Kubernetes
you will probably
not
want to use workers and instead run
a single Uvicorn process per container
, but I'll tell you about it later in that chapter.
Multiple Workers
You can start multiple workers with the
--workers
command line option:
fastapi
uvicorn
If you use the
fastapi
command:
fast ‚Üí
fastapi
run --workers 4
main.py
FastAPI
Starting production server üöÄ
Searching for package file structure from directories with
__init__.py
files
Importing from
/home/user/code/
awesomeapp
module
üêç main.py
code
Importing the FastAPI app object from the module with the
following code:
from
main
import
app
app
Using import string:
main:app
server
Server started at
http://0.0.0.0:8000
server
Documentation at
http://0.0.0.0:8000/docs
Logs:
INFO
Uvicorn running on
http://0.0.0.0:8000
(
Press CTRL+C to
quit
)
INFO
Started parent process
[
27365
]
INFO
Started server process
[
27368
]
INFO
Started server process
[
27369
]
INFO
Started server process
[
27370
]
INFO
Started server process
[
27367
]
INFO
Waiting for application startup.
INFO
Waiting for application startup.
INFO
Waiting for application startup.
INFO
Waiting for application startup.
INFO
Application startup complete.
INFO
Application startup complete.
INFO
Application startup complete.
INFO
Application startup complete.
restart ‚Üª
If you prefer to use the
uvicorn
command directly:
fast ‚Üí
uvicorn main:app --host 0.
The only new option here is
--workers
telling Uvicorn to start 4 worker processes.
You can also see that it shows the
PID
of each process,
27365
for the parent process (this is the
process manager
) and one for each worker process:
27368
,
27369
,
27370
, and
27367
.
Deployment Concepts
Here you saw how to use multiple
workers
to
parallelize
the execution of the application, take advantage of
multiple cores
in the CPU, and be able to serve
more requests
.
From the list of deployment concepts from above, using workers would mainly help with the
replication
part, and a little bit with the
restarts
, but you still need to take care of the others:
Security - HTTPS
Running on startup
Restarts
Replication (the number of processes running)
Memory
Previous steps before starting
Containers and Docker
In the next chapter about
FastAPI in Containers - Docker
I'll explain some strategies you could use to handle the other
deployment concepts
.
I'll show you how to
build your own image from scratch
to run a single Uvicorn process. It is a simple process and is probably what you would want to do when using a distributed container management system like
Kubernetes
.
Recap
You can use multiple worker processes with the
--workers
CLI option with the
fastapi
or
uvicorn
commands to take advantage of
multi-core CPUs
, to run
multiple processes in parallel
.
You could use these tools and ideas if you are setting up
your own deployment system
while taking care of the other deployment concepts yourself.
Check out the next chapter to learn about
FastAPI
with containers (e.g. Docker and Kubernetes). You will see that those tools have simple ways to solve the other
deployment concepts
as well. ‚ú®

## 046_DEPLOYMENT_VERSIONS
About FastAPI versions¬∂
---

About FastAPI versions
FastAPI
is already being used in production in many applications and systems. And the test coverage is kept at 100%. But its development is still moving quickly.
New features are added frequently, bugs are fixed regularly, and the code is still continuously improving.
That's why the current versions are still
0.x.x
, this reflects that each version could potentially have breaking changes. This follows the
Semantic Versioning
conventions.
You can create production applications with
FastAPI
right now (and you have probably been doing it for some time), you just have to make sure that you use a version that works correctly with the rest of your code.
Pin your
fastapi
version
The first thing you should do is to "pin" the version of
FastAPI
you are using to the specific latest version that you know works correctly for your application.
For example, let's say you are using version
0.112.0
in your app.
If you use a
requirements.txt
file you could specify the version with:
fastapi[standard]==0.112.0
that would mean that you would use exactly the version
0.112.0
.
Or you could also pin it with:
fastapi[standard]>=0.112.0,<0.113.0
that would mean that you would use the versions
0.112.0
or above, but less than
0.113.0
, for example, a version
0.112.2
would still be accepted.
If you use any other tool to manage your installations, like
uv
, Poetry, Pipenv, or others, they all have a way that you can use to define specific versions for your packages.
Available versions
You can see the available versions (e.g. to check what is the current latest) in the
Release Notes
.
About versions
Following the Semantic Versioning conventions, any version below
1.0.0
could potentially add breaking changes.
FastAPI also follows the convention that any "PATCH" version change is for bug fixes and non-breaking changes.
Tip
The "PATCH" is the last number, for example, in
0.2.3
, the PATCH version is
3
.
So, you should be able to pin to a version like:
fastapi>=0.45.0,<0.46.0
Breaking changes and new features are added in "MINOR" versions.
Tip
The "MINOR" is the number in the middle, for example, in
0.2.3
, the MINOR version is
2
.
Upgrading the FastAPI versions
You should add tests for your app.
With
FastAPI
it's very easy (thanks to Starlette), check the docs:
Testing
After you have tests, then you can upgrade the
FastAPI
version to a more recent one, and make sure that all your code is working correctly by running your tests.
If everything is working, or after you make the necessary changes, and all your tests are passing, then you can pin your
fastapi
to that new recent version.
About Starlette
You shouldn't pin the version of
starlette
.
Different versions of
FastAPI
will use a specific newer version of Starlette.
So, you can just let
FastAPI
use the correct Starlette version.
About Pydantic
Pydantic includes the tests for
FastAPI
with its own tests, so new versions of Pydantic (above
1.0.0
) are always compatible with FastAPI.
You can pin Pydantic to any version above
1.0.0
that works for you.
For example:
pydantic>=2.7.0,<3.0.0

## 047_EM
FastAPI¬∂
---

FastAPI
FastAPI üõ†Ô∏è, ‚Üï üé≠, ‚è© üí°, ‚è© üìü, üîú üè≠
üßæ
:
https://fastapi.tiangolo.com
‚Ñπ üìü
:
https://github.com/fastapi/fastapi
FastAPI üèõ, ‚è© (‚Üï-üé≠), üï∏ üõ†Ô∏è üèó üõ†Ô∏è ‚èÆÔ∏è üêç 3Ô∏è‚É£.8Ô∏è‚É£ ‚ûï ‚öìÔ∏è üîõ üê© üêç üÜé üîë.
üîë ‚öí:
‚è©
: üì∂ ‚Üï üé≠, üîõ üá∑üá™ ‚èÆÔ∏è
‚ú≥
&
üö∂
(üëè üíÉ & Pydantic).
1Ô∏è‚É£ ‚è© üêç üõ†Ô∏è üí™
.
‚è© üìü
: üìà üöÖ üõ†Ô∏è ‚öí üîÉ 2Ô∏è‚É£0Ô∏è‚É£0Ô∏è‚É£ üíØ 3Ô∏è‚É£0Ô∏è‚É£0Ô∏è‚É£ üíØ. *
üë©‚Äç‚ù§‚Äçüë® üêõ
: üìâ üîÉ 4Ô∏è‚É£0Ô∏è‚É£ üíØ üóø (üë©‚Äçüíª) üìâ ‚ùå. *
üèãÔ∏è
: üëë üë®‚Äçüé® üêï‚Äçü¶∫.
üõ†Ô∏è
üåê. üåò üï∞ üõ†Ô∏è.
‚è©
: üîß ‚è© ‚öôÔ∏è & üí°. üåò üï∞ üëÇ ü©∫.
üìè
: üìâ üìü ‚ùé. üíó ‚öí ‚ö™Ô∏è‚û°Ô∏è üî† üî¢ üìÑ. üë©‚Äç‚ù§‚Äçüë® üêõ.
üèãÔ∏è
: ü§ö üè≠-üîú üìü. ‚èÆÔ∏è üèß üéì üßæ.
üê©-‚öìÔ∏è
: ‚öìÔ∏è üîõ (& üçï üîó ‚èÆÔ∏è) üìÇ üê© üîó:
üóÑ
(‚è™ üí≠ ü¶Å) &
üéª üîó
.
* ‚öñ ‚öìÔ∏è üîõ üíØ üîõ üîó üõ†Ô∏è üèâ, üèó üè≠ üà∏.
üí∞
üéè üí∞
ü§î
"
[...] üë§ ‚öôÔ∏è
FastAPI
üìö üë´ üìÜ. [...] üë§ ü§ô üìÜ ‚öôÔ∏è ‚ö´Ô∏è üåê üëá üèâ
‚öó üêï‚Äçü¶∫ ü§∏‚Äç‚ôÇ
. üë´ üíÜ‚Äç‚ôÇ üõ†Ô∏è üîò üêö
üñ•
üè¨ &
üì†
üè¨.
"
üßø üáµüá∞ -
ü§∏‚Äç‚ôÇ
(üá¶üá™)
"
üë• üõ†Ô∏è
FastAPI
üóÉ ü§ñ
üéÇ
üíΩ üëà üí™ üî¢ üöö
üîÆ
. [üë®üìõ]
"
üáÆüáπ üá∏üáª, üë®üìõ üë®üìõ, & üá±üá∞ üïâ üïâ -
üôÉ
(üá¶üá™)
"
üì∫
üôè üì£ üìÇ-‚Ñπ üöÄ üëÜ
‚öî üßæ
üé∂ üõ†Ô∏è:
üì®
‚ùó [üèó ‚èÆÔ∏è
FastAPI
]
"
‚ú° üçè, üëñ üá™üá∏, üå≤ üçè -
üì∫
(üá¶üá™)
"
üë§ ü§≠ üåï üòÑ üîÉ
FastAPI
. ‚ö´Ô∏è üéä ‚ùó
"
‚ú° üá≠üá∞ -
üêç üî¢
üìª ü¶†
(üá¶üá™)
"
ü§ô, ‚ö´Ô∏è‚ùî üëÜ ‚úîÔ∏è üèó üëÄ üíé üí† & üáµüá±. üìö üåå, ‚ö´Ô∏è ‚ö´Ô∏è‚ùî üë§ üíö
ü§ó
- ‚ö´Ô∏è ü§ô üòç üëÄ üë± üèó üëà.
"
‚ú° üóÑ -
ü§ó
üëº
(üá¶üá™)
"
üö• üëÜ üëÄ üí° 1Ô∏è‚É£
üèõ üõ†Ô∏è
üèó üéÇ üîó, ‚úÖ üëÖ
FastAPI
[...] ‚ö´Ô∏è ‚è©, ‚è© ‚öôÔ∏è & ‚è© üí° [...]
"
"
üë• ‚úîÔ∏è üéõ ü§≠
FastAPI
üëÜ
üîó
[...] üë§ üí≠ üëÜ üîú üíñ ‚ö´Ô∏è [...]
"
üá±üá® üá∏üá≤ - ‚ú° Honnibal -
üí• üë≤
üï¥ -
üåà
üëº
(üá¶üá™)
-
(üá¶üá™)
"
üö• üôÜ üëÄ üèó üè≠ üêç üõ†Ô∏è, üë§ üîú üèÜ üëç
FastAPI
. ‚ö´Ô∏è
üíé üèó
,
üôÖ ‚öôÔ∏è
&
üèÜ üõ†Ô∏è
, ‚ö´Ô∏è ‚úîÔ∏è ‚ñ∂Ô∏èÔ∏è
üîë ü¶≤
üëÜ üõ†Ô∏è ü•á üõ†Ô∏è üéõ & üöò üìö üèß & üêï‚Äçü¶∫ ‚úÖ üëÜ üïπ üî´ üë®‚Äçüíª.
"
üáπüá¶ üç∞ -
üìª
(üá¶üá™)
üèé
, FastAPI üá≥üá®
üö• üëÜ üèó
‚ú≥
üì± ‚öôÔ∏è üì∂ ‚Ü©Ô∏è üï∏ üõ†Ô∏è, ‚úÖ üëÖ
üèé
.
üèé
FastAPI üê• üë™. & ‚ö´Ô∏è üéØ
FastAPI üá≥üá®
. üë∂ üë∂ üë∂
üìÑ
üêç 3Ô∏è‚É£.7Ô∏è‚É£ ‚ûï
FastAPI üßç üîõ ‚åö üêò:
üíÉ
üï∏ üçï.
Pydantic
üìä üçï.
üë∑‚Äç‚ôÇ
fast ‚Üí
pip install "fastapi[standard]"
restart ‚Üª
üëÜ üîú üí™ üî´ üíΩ, üè≠ ‚úÖ
Uvicorn
‚öñÔ∏è
Hypercorn
.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
üñº
‚úç ‚ö´Ô∏è
‚úç üìÅ
main.py
‚èÆÔ∏è:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
‚öñÔ∏è ‚öôÔ∏è
async def
...
üö• üëÜ üìü ‚öôÔ∏è
async
/
await
, ‚öôÔ∏è
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
üóí
:
üö• üëÜ üö´ üí≠, ‚úÖ _"üèÉ ‚ùì" _ üìÑ üîÉ
async
&
await
ü©∫
.
üèÉ ‚ö´Ô∏è
üèÉ üíΩ ‚èÆÔ∏è:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
üîÉ üìã
uvicorn main:app --reload
...
üìã
uvicorn main:app
üîó:
main
: üìÅ
main.py
(üêç "üïπ").
app
: üéö ‚úç üîò
main.py
‚èÆÔ∏è ‚è∏
app = FastAPI()
.
--reload
: ‚öí üíΩ ‚èè ‚èÆÔ∏è üìü üîÄ. üï¥ üëâ üõ†Ô∏è.
‚úÖ ‚ö´Ô∏è
üìÇ üëÜ üñ•
http://127.0.0.1:8000/items/5?q=somequery
.
üëÜ üîú üëÄ üéª üì®:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
üëÜ ‚è™ ‚úç üõ†Ô∏è üëà:
üì® üá∫üá∏üîç üì®
‚û°
/
&
/items/{item_id}
.
üëØ‚Äç‚ôÇÔ∏è
‚û°
‚úä
GET
üõ†Ô∏è
(üí≠ üá∫üá∏üîç
üë©‚Äçüî¨
).
‚û°
/items/{item_id}
‚úîÔ∏è
‚û° üî¢
item_id
üëà üîú
int
.
‚û°
/items/{item_id}
‚úîÔ∏è üì¶
str
_üî¢ =
q
.
üéì üõ†Ô∏è ü©∫
üîú üö∂
http://127.0.0.1:8000/docs
.
üëÜ üîú üëÄ üèß üéì üõ†Ô∏è üßæ (üöö
ü¶Å üéö
):
üéõ üõ†Ô∏è ü©∫
& üîú, üö∂
http://127.0.0.1:8000/redoc
.
üëÜ üîú üëÄ üéõ üèß üßæ (üöö
üìÑ
):
üñº ‚ôª
üîú üîÄ üìÅ
main.py
üì® üí™ ‚ö™Ô∏è‚û°Ô∏è
PUT
üì®.
üì£ üí™ ‚öôÔ∏è üê© üêç üÜé, üëè Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
üíΩ üîú üîÉ üîÅ (‚Ü©Ô∏è üëÜ üöÆ
--reload
uvicorn
üìã üîõ).
üéì üõ†Ô∏è ü©∫ ‚ôª
üîú üö∂
http://127.0.0.1:8000/docs
.
üéì üõ†Ô∏è üßæ üîú üîÅ ‚Ñπ, üîå üÜï üí™:
üñä üîõ üîº "üîÑ ‚ö´Ô∏è üëÖ", ‚ö´Ô∏è ‚úî üëÜ ü•ß üî¢ & üîó üîó ‚èÆÔ∏è üõ†Ô∏è:
‚§¥Ô∏è üñä üîõ "üõ†Ô∏è" üîº, üë©‚Äçüíª üî¢ üîú üîó ‚èÆÔ∏è üëÜ üõ†Ô∏è, üì® üî¢, ü§ö üèÅ & üé¶ üë´ üîõ üñ•:
üéõ üõ†Ô∏è ü©∫ ‚ôª
& üîú, üö∂
http://127.0.0.1:8000/redoc
.
üéõ üßæ üîú üé® üÜï üî¢ üî¢ & üí™:
üåÉ
üìÑ, üëÜ üì£
üïê
üÜé üî¢, üí™, ‚ôíÔ∏è. üî¢ üî¢.
üëÜ üëà ‚èÆÔ∏è üê© üèõ üêç üÜé.
üëÜ üö´ ‚úîÔ∏è üí° üÜï ‚ùï, üë©‚Äçüî¨ ‚öñÔ∏è üéì üéØ üóÉ, ‚ôíÔ∏è.
üê©
üêç 3Ô∏è‚É£.7Ô∏è‚É£ ‚ûï
.
üñº,
int
:
item_id
:
int
‚öñÔ∏è üåñ üèó
Item
üè∑:
item
:
Item
...& ‚èÆÔ∏è üëà üëÅ üìÑ üëÜ ü§ö:
üë®‚Äçüé® üêï‚Äçü¶∫, üîå:
üõ†Ô∏è.
üÜé ‚úÖ.
üî¨ üíΩ:
üèß & üÜë ‚ùå üïê‚ùî üìä ‚ùå.
üî¨ üôá üê¶ üéª üéö.
üõ†Ô∏è
üî¢ üíΩ: üëü ‚ö™Ô∏è‚û°Ô∏è üï∏ üêç üíΩ & üÜé. üëÇ ‚ö™Ô∏è‚û°Ô∏è:
üéª.
‚û° üî¢.
üî¢ üî¢.
üç™.
üéö.
üì®.
üìÅ.
üõ†Ô∏è
üî¢ üìä: üóú ‚ö™Ô∏è‚û°Ô∏è üêç üíΩ & üÜé üï∏ üíΩ (üéª):
üóú üêç üÜé (
str
,
int
,
float
,
bool
,
list
, ‚ôíÔ∏è).
datetime
üéö.
UUID
üéö.
üíΩ üè∑.
...& üìö üåñ.
üèß üéì üõ†Ô∏è üßæ, üîå 2Ô∏è‚É£ üéõ üë©‚Äçüíª üî¢:
ü¶Å üéö.
üìÑ.
üëü üîô ‚èÆÔ∏è üìü üñº,
FastAPI
üîú:
‚úî üëà üì§
item_id
‚û°
GET
&
PUT
üì®.
‚úî üëà
item_id
üÜé
int
GET
&
PUT
üì®.
üö• ‚ö´Ô∏è üö´, üë©‚Äçüíª üîú üëÄ ‚ö†, üÜë ‚ùå.
‚úÖ üö• üì§ üì¶ üî¢ üî¢ üìõ
q
(
http://127.0.0.1:8000/items/foo?q=somequery
)
GET
üì®.
q
üî¢ üì£ ‚èÆÔ∏è
= None
, ‚ö´Ô∏è üì¶.
üçµ
None
‚ö´Ô∏è üîú üöö (üí™ üíº ‚èÆÔ∏è
PUT
).
PUT
üì®
/items/{item_id}
, ‚úç üí™ üéª:
‚úÖ üëà ‚ö´Ô∏è ‚úîÔ∏è ‚úî üî¢
name
üëà üîú
str
.
‚úÖ üëà ‚ö´Ô∏è ‚úîÔ∏è ‚úî üî¢
price
üëà ‚úîÔ∏è
float
.
‚úÖ üëà ‚ö´Ô∏è ‚úîÔ∏è üì¶ üî¢
is_offer
, üëà üîú
bool
, üö• üéÅ.
üåê üëâ üîú üë∑ üôá üê¶ üéª üéö.
üóú ‚ö™Ô∏è‚û°Ô∏è & üéª üîÅ.
üìÑ üåê ‚èÆÔ∏è üóÑ, üëà üí™ ‚öôÔ∏è:
üéì üßæ ‚öôÔ∏è.
üèß üë©‚Äçüíª üìü ‚ö° ‚öôÔ∏è, üìö üá™üá∏.
üöö 2Ô∏è‚É£ üéì üßæ üï∏ üî¢ üîó.
üë• üñå üßΩ, ‚úãÔ∏è üëÜ ‚è™ ü§ö üí≠ ‚ùî ‚ö´Ô∏è üåê üë∑.
üîÑ üîÄ ‚è∏ ‚èÆÔ∏è:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...‚ö™Ô∏è‚û°Ô∏è:
...
"item_name"
:
item
.
name
...
...:
...
"item_price"
:
item
.
price
...
...& üëÄ ‚ùî üëÜ üë®‚Äçüé® üîú üöò-üèÅ üî¢ & üí≠ üë´ üÜé:
üåÖ üèÅ üñº üîå üåÖ ‚öí, üëÄ
üî∞ - üë©‚Äçüíª ü¶Æ
.
üöò üö®
: üî∞ - üë©‚Äçüíª ü¶Æ üîå:
üìÑ
üî¢
‚ö™Ô∏è‚û°Ô∏è üéè üéè ü•â:
üéö
,
üç™
,
üì® üèë
&
üìÅ
.
‚ùî ‚öí
üî¨ ‚öõ
maximum_length
‚öñÔ∏è
regex
.
üì∂ üèãÔ∏è & ‚è© ‚öôÔ∏è
üîó üíâ
‚öôÔ∏è.
üíÇ‚Äç‚ôÇ & ü§ù, ‚úÖ üêï‚Äçü¶∫
Oauth2Ô∏è‚É£
‚èÆÔ∏è
ü•ô ü§ù
&
üá∫üá∏üîç üî∞
üîê.
üåÖ üèß (‚úãÔ∏è üò® ‚è©) ‚öí üì£
üôá üê¶ üéª üè∑
(üëè Pydantic).
üïπ
üõ†Ô∏è ‚èÆÔ∏è
üçì
& üéè üóÉ.
üìö ‚ûï ‚öí (üëè üíÉ):
** *Ô∏è‚É£ **
üì∂ ‚è© üíØ ‚öìÔ∏è üîõ üá∏üá≤ &
pytest
‚öú
üç™ üéâ
...& üåñ.
üé≠
üî¨ üá∏üá≤ üìá üé¶
FastAPI
üà∏ üèÉ‚Äç‚ôÇ üîΩ Uvicorn
1Ô∏è‚É£ ‚è© üêç üõ†Ô∏è üí™
, üï¥ üîõ üíÉ & Uvicorn üë´ (‚öôÔ∏è üîò FastAPI). (*)
ü§î üåñ üîÉ ‚ö´Ô∏è, üëÄ üìÑ
üìá
.
üì¶ üîó
‚öôÔ∏è Pydantic:
email-validator
- üìß üî¨.
‚öôÔ∏è üíÉ:
httpx
- ‚úî üö• üëÜ üíö ‚öôÔ∏è
TestClient
.
jinja2
- ‚úî üö• üëÜ üíö ‚öôÔ∏è üî¢ üìÑ üì≥.
python-multipart
- ‚úî üö• üëÜ üíö üêï‚Äçü¶∫ üì®
"‚úç"
, ‚èÆÔ∏è
request.form()
.
itsdangerous
- ‚úî
SessionMiddleware
üêï‚Äçü¶∫.
pyyaml
- ‚úî üíÉ
SchemaGenerator
üêï‚Äçü¶∫ (üëÜ üé≤ üö´ üí™ ‚ö´Ô∏è ‚èÆÔ∏è FastAPI).
‚öôÔ∏è FastAPI / üíÉ:
uvicorn
- üíΩ üëà üìê & üç¶ üëÜ üà∏.
orjson
- ‚úî üö• üëÜ üíö ‚öôÔ∏è
ORJSONResponse
.
ujson
- ‚úî üö• üëÜ üíö ‚öôÔ∏è
UJSONResponse
.
üëÜ üí™ ‚ùé üåê üë´ ‚èÆÔ∏è
pip install "fastapi[all]"
.
üõÇ
üëâ üèó ¬Æ üîΩ ‚öñ üá©üá™ üõÇ.

## 048_ENVIRONMENT_VARIABLES
Environment Variables¬∂
---

Environment Variables
Tip
If you already know what "environment variables" are and how to use them, feel free to skip this.
An environment variable (also known as "
env var
") is a variable that lives
outside
of the Python code, in the
operating system
, and could be read by your Python code (or by other programs as well).
Environment variables could be useful for handling application
settings
, as part of the
installation
of Python, etc.
Create and Use Env Vars
You can
create
and use environment variables in the
shell (terminal)
, without needing Python:
Linux, macOS, Windows Bash
Windows PowerShell
fast ‚Üí
üí¨ You could create an env var MY_NAME with
export MY_NAME="Wade Wilso
fast ‚Üí
üí¨ Create an env var MY_NAME
$Env:MY_NAME = "Wade Wilso
Read env vars in Python
You could also create environment variables
outside
of Python, in the terminal (or with any other method), and then
read them in Python
.
For example you could have a file
main.py
with:
import
os
name
=
os
.
getenv
(
"MY_NAME"
,
"World"
)
print
(
f
"Hello
{
name
}
from Python"
)
Tip
The second argument to
os.getenv()
is the default value to return.
If not provided, it's
None
by default, here we provide
"World"
as the default value to use.
Then you could call that Python program:
Linux, macOS, Windows Bash
Windows PowerShell
fast ‚Üí
üí¨ Here we don't set the env var yet
python main.py
üí¨ As we didn't set the env var, we get the default value
Hello World from Python
üí¨ But if we create an environment variable first
export MY_NAME="Wade Wilson"
üí¨ And then call the program again
python main.py
üí¨ Now it can read the environment variable
Hello Wade Wilson from Python
restart ‚Üª
fast ‚Üí
üí¨ Here we don't set the env var yet
python main.py
üí¨ As we didn't set the env var, we get the default value
Hello World from Python
üí¨ But if we create an environment variable first
$
As environment variables can be set outside of the code, but can be read by the code, and don't have to be stored (committed to
git
) with the rest of the files, it's common to use them for configurations or
settings
.
You can also create an environment variable only for a
specific program invocation
, that is only available to that program, and only for its duration.
To do that, create it right before the program itself, on the same line:
fast ‚Üí
üí¨ Create an env var MY_NAME in line for this program call
MY_NAME="Wade Wilson" python main.py
üí¨ Now it can read the environment variable
Hello Wade Wilson from Python
üí¨ The env var no longer exists afterwards
python main.py
Hello World from Python
restart ‚Üª
Tip
You can read more about it at
The Twelve-Factor App: Config
.
Types and Validation
These environment variables can only handle
text strings
, as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS).
That means that
any value
read in Python from an environment variable
will be a
str
, and any conversion to a different type or any validation has to be done in code.
You will learn more about using environment variables for handling
application settings
in the
Advanced User Guide - Settings and Environment Variables
.
PATH
Environment Variable
There is a
special
environment variable called
PATH
that is used by the operating systems (Linux, macOS, Windows) to find programs to run.
The value of the variable
PATH
is a long string that is made of directories separated by a colon
:
on Linux and macOS, and by a semicolon
;
on Windows.
For example, the
PATH
environment variable could look like this:
Linux, macOS
Windows
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
This means that the system should look for programs in the directories:
/usr/local/bin
/usr/bin
/bin
/usr/sbin
/sbin
C:\Program Files\Python312\Scripts;C:\Program Files\Python312;C:\Windows\System32
This means that the system should look for programs in the directories:
C:\Program Files\Python312\Scripts
C:\Program Files\Python312
C:\Windows\System32
When you type a
command
in the terminal, the operating system
looks for
the program in
each of those directories
listed in the
PATH
environment variable.
For example, when you type
python
in the terminal, the operating system looks for a program called
python
in the
first directory
in that list.
If it finds it, then it will
use it
. Otherwise it keeps looking in the
other directories
.
Installing Python and Updating the
PATH
When you install Python, you might be asked if you want to update the
PATH
environment variable.
Linux, macOS
Windows
Let's say you install Python and it ends up in a directory
/opt/custompython/bin
.
If you say yes to update the
PATH
environment variable, then the installer will add
/opt/custompython/bin
to the
PATH
environment variable.
It could look like this:
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/custompython/bin
This way, when you type
python
in the terminal, the system will find the Python program in
/opt/custompython/bin
(the last directory) and use that one.
Let's say you install Python and it ends up in a directory
C:\opt\custompython\bin
.
If you say yes to update the
PATH
environment variable, then the installer will add
C:\opt\custompython\bin
to the
PATH
environment variable.
C:\Program Files\Python312\Scripts;C:\Program Files\Python312;C:\Windows\System32;C:\opt\custompython\bin
This way, when you type
python
in the terminal, the system will find the Python program in
C:\opt\custompython\bin
(the last directory) and use that one.
So, if you type:
fast ‚Üí
python
restart ‚Üª
Linux, macOS
Windows
The system will
find
the
python
program in
/opt/custompython/bin
and run it.
It would be roughly equivalent to typing:
fast ‚Üí
/opt/custompython/bin/python
restart ‚Üª
The system will
find
the
python
program in
C:\opt\custompython\bin\python
and run it.
It would be roughly equivalent to typing:
fast ‚Üí
C:\opt\custompython\bin\py
This information will be useful when learning about
Virtual Environments
.
Conclusion
With this you should have a basic understanding of what
environment variables
are and how to use them in Python.
You can also read more about them in the
Wikipedia for Environment Variable
.
In many cases it's not very obvious how environment variables would be useful and applicable right away. But they keep showing up in many different scenarios when you are developing, so it's good to know about them.
For example, you will need this information in the next section, about
Virtual Environments
.

## 049_ES
FastAPI¬∂
---

FastAPI
FastAPI framework, alto rendimiento, f√°cil de aprender, r√°pido de programar, listo para producci√≥n
Documentaci√≥n
:
https://fastapi.tiangolo.com
C√≥digo Fuente
:
https://github.com/fastapi/fastapi
FastAPI es un framework web moderno, r√°pido (de alto rendimiento), para construir APIs con Python basado en las anotaciones de tipos est√°ndar de Python.
Las caracter√≠sticas clave son:
R√°pido
: Muy alto rendimiento, a la par con
NodeJS
y
Go
(gracias a Starlette y Pydantic).
Uno de los frameworks Python m√°s r√°pidos disponibles
.
R√°pido de programar
: Aumenta la velocidad para desarrollar funcionalidades en aproximadamente un 200% a 300%. *
Menos bugs
: Reduce en aproximadamente un 40% los errores inducidos por humanos (desarrolladores). *
Intuitivo
: Gran soporte para editores.
Autocompletado
en todas partes. Menos tiempo depurando.
F√°cil
: Dise√±ado para ser f√°cil de usar y aprender. Menos tiempo leyendo documentaci√≥n.
Corto
: Minimiza la duplicaci√≥n de c√≥digo. M√∫ltiples funcionalidades desde cada declaraci√≥n de par√°metro. Menos bugs.
Robusto
: Obt√©n c√≥digo listo para producci√≥n. Con documentaci√≥n interactiva autom√°tica.
Basado en est√°ndares
: Basado (y completamente compatible) con los est√°ndares abiertos para APIs:
OpenAPI
(anteriormente conocido como Swagger) y
JSON Schema
.
* estimaci√≥n basada en pruebas con un equipo de desarrollo interno, construyendo aplicaciones de producci√≥n.
Sponsors
Otros sponsors
Opiniones
"
[...] Estoy usando
FastAPI
un mont√≥n estos d√≠as. [...] De hecho, estoy planeando usarlo para todos los servicios de
ML de mi equipo en Microsoft
. Algunos de ellos se est√°n integrando en el n√∫cleo del producto
Windows
y algunos productos de
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
Adoptamos el paquete
FastAPI
para crear un servidor
REST
que pueda ser consultado para obtener
predicciones
. [para Ludwig]
"
Piero Molino, Yaroslav Dudin, y Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
se complace en anunciar el lanzamiento de c√≥digo abierto de nuestro framework de orquestaci√≥n de
gesti√≥n de crisis
:
Dispatch
! [construido con
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Estoy s√∫per emocionado con
FastAPI
. ¬°Es tan divertido!
"
Brian Okken -
host del podcast Python Bytes
(ref)
"
Honestamente, lo que has construido parece s√∫per s√≥lido y pulido. En muchos aspectos, es lo que quer√≠a que
Hug
fuera; es realmente inspirador ver a alguien construir eso.
"
Timothy Crosley -
creador de Hug
(ref)
"
Si est√°s buscando aprender un
framework moderno
para construir APIs REST, √©chale un vistazo a
FastAPI
[...] Es r√°pido, f√°cil de usar y f√°cil de aprender [...]
"
"
Nos hemos cambiado a
FastAPI
para nuestras
APIs
[...] Creo que te gustar√° [...]
"
Ines Montani - Matthew Honnibal -
fundadores de Explosion AI
-
creadores de spaCy
(ref)
-
(ref)
"
Si alguien est√° buscando construir una API de Python para producci√≥n, altamente recomendar√≠a
FastAPI
. Est√°
hermosamente dise√±ado
, es
simple de usar
y
altamente escalable
, se ha convertido en un
componente clave
en nuestra estrategia de desarrollo API primero y est√° impulsando muchas automatizaciones y servicios como nuestro Ingeniero Virtual TAC.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, el FastAPI de las CLIs
Si est√°s construyendo una aplicaci√≥n de
CLI
para ser usada en el terminal en lugar de una API web, revisa
Typer
.
Typer
es el hermano peque√±o de FastAPI. Y est√° destinado a ser el
FastAPI de las CLIs
. ‚å®Ô∏è üöÄ
Requisitos
FastAPI se apoya en hombros de gigantes:
Starlette
para las partes web.
Pydantic
para las partes de datos.
Instalaci√≥n
Crea y activa un
entorno virtual
y luego instala FastAPI:
fast ‚Üí
pip install "fastapi[standard]"
restart ‚Üª
Nota
: Aseg√∫rate de poner
"fastapi[standard]"
entre comillas para asegurar que funcione en todas las terminales.
Ejemplo
Cr√©alo
Crea un archivo
main.py
con:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
O usa
async def
...
Si tu c√≥digo usa
async
/
await
, usa
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Nota
:
Si no lo sabes, revisa la secci√≥n
"¬øCon prisa?"
sobre
async
y
await
en la documentaci√≥n
.
C√≥rrelo
Corre el servidor con:
fast ‚Üí
fastapi dev main.py
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FastAPI CLI - Development mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ ‚îÇ
‚îÇ Serving at: http://127.0.0.1:8000 ‚îÇ
‚îÇ ‚îÇ
‚îÇ API docs: http://127.0.0.1:8000/docs ‚îÇ
‚îÇ ‚îÇ
‚îÇ Running in development mode, for production use: ‚îÇ
‚îÇ ‚îÇ
‚îÇ fastapi run ‚îÇ
‚îÇ ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
Acerca del comando
fastapi dev main.py
...
El comando
fastapi dev
lee tu archivo
main.py
, detecta la app
FastAPI
en √©l y arranca un servidor usando
Uvicorn
.
Por defecto,
fastapi dev
comenzar√° con auto-recarga habilitada para el desarrollo local.
Puedes leer m√°s sobre esto en la
documentaci√≥n del CLI de FastAPI
.
Rev√≠salo
Abre tu navegador en
http://127.0.0.1:8000/items/5?q=somequery
.
Ver√°s el response JSON como:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Ya creaste una API que:
Recibe requests HTTP en los
paths
/
y
/items/{item_id}
.
Ambos
paths
toman
operaciones
GET
(tambi√©n conocidas como m√©todos HTTP).
El
path
/items/{item_id}
tiene un
par√°metro de path
item_id
que debe ser un
int
.
El
path
/items/{item_id}
tiene un
par√°metro de query
q
opcional que es un
str
.
Documentaci√≥n interactiva de la API
Ahora ve a
http://127.0.0.1:8000/docs
.
Ver√°s la documentaci√≥n interactiva autom√°tica de la API (proporcionada por
Swagger UI
):
Documentaci√≥n de API Alternativa
Y ahora, ve a
http://127.0.0.1:8000/redoc
.
Ver√°s la documentaci√≥n alternativa autom√°tica (proporcionada por
ReDoc
):
Actualizaci√≥n del Ejemplo
Ahora modifica el archivo
main.py
para recibir un body desde un request
PUT
.
Declara el body usando tipos est√°ndar de Python, gracias a Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
El servidor
fastapi dev
deber√≠a recargarse autom√°ticamente.
Actualizaci√≥n de la Documentaci√≥n Interactiva de la API
Ahora ve a
http://127.0.0.1:8000/docs
.
La documentaci√≥n interactiva de la API se actualizar√° autom√°ticamente, incluyendo el nuevo body:
Haz clic en el bot√≥n "Try it out", te permite llenar los par√°metros e interactuar directamente con la API:
Luego haz clic en el bot√≥n "Execute", la interfaz de usuario se comunicar√° con tu API, enviar√° los par√°metros, obtendr√° los resultados y los mostrar√° en la pantalla:
Actualizaci√≥n de la Documentaci√≥n Alternativa de la API
Y ahora, ve a
http://127.0.0.1:8000/redoc
.
La documentaci√≥n alternativa tambi√©n reflejar√° el nuevo par√°metro de query y body:
Resumen
En resumen, declaras
una vez
los tipos de par√°metros, body, etc. como par√°metros de funci√≥n.
Lo haces con tipos est√°ndar modernos de Python.
No tienes que aprender una nueva sintaxis, los m√©todos o clases de un paquete espec√≠fico, etc.
Solo
Python
est√°ndar.
Por ejemplo, para un
int
:
item_id
:
int
o para un modelo
Item
m√°s complejo:
item
:
Item
...y con esa √∫nica declaraci√≥n obtienes:
Soporte para editores, incluyendo:
Autocompletado.
Chequeo de tipos.
Validaci√≥n de datos:
Errores autom√°ticos y claros cuando los datos son inv√°lidos.
Validaci√≥n incluso para objetos JSON profundamente anidados.
Conversi√≥n
de datos de entrada: de la red a los datos y tipos de Python. Leyendo desde:
JSON.
Par√°metros de path.
Par√°metros de query.
Cookies.
Headers.
Forms.
Archivos.
Conversi√≥n
de datos de salida: convirtiendo de datos y tipos de Python a datos de red (como JSON):
Convertir tipos de Python (
str
,
int
,
float
,
bool
,
list
, etc).
Objetos
datetime
.
Objetos
UUID
.
Modelos de base de datos.
...y muchos m√°s.
Documentaci√≥n interactiva autom√°tica de la API, incluyendo 2 interfaces de usuario alternativas:
Swagger UI.
ReDoc.
Volviendo al ejemplo de c√≥digo anterior,
FastAPI
:
Validar√° que haya un
item_id
en el path para requests
GET
y
PUT
.
Validar√° que el
item_id
sea del tipo
int
para requests
GET
y
PUT
.
Si no lo es, el cliente ver√° un error √∫til y claro.
Comprobar√° si hay un par√°metro de query opcional llamado
q
(como en
http://127.0.0.1:8000/items/foo?q=somequery
) para requests
GET
.
Como el par√°metro
q
est√° declarado con
= None
, es opcional.
Sin el
None
ser√≠a requerido (como lo es el body en el caso con
PUT
).
Para requests
PUT
a
/items/{item_id}
, leer√° el body como JSON:
Comprobar√° que tiene un atributo requerido
name
que debe ser un
str
.
Comprobar√° que tiene un atributo requerido
price
que debe ser un
float
.
Comprobar√° que tiene un atributo opcional
is_offer
, que debe ser un
bool
, si est√° presente.
Todo esto tambi√©n funcionar√≠a para objetos JSON profundamente anidados.
Convertir√° de y a JSON autom√°ticamente.
Documentar√° todo con OpenAPI, que puede ser usado por:
Sistemas de documentaci√≥n interactiva.
Sistemas de generaci√≥n autom√°tica de c√≥digo cliente, para muchos lenguajes.
Proporcionar√° 2 interfaces web de documentaci√≥n interactiva directamente.
Solo tocamos los conceptos b√°sicos, pero ya te haces una idea de c√≥mo funciona todo.
Intenta cambiar la l√≠nea con:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...desde:
...
"item_name"
:
item
.
name
...
...a:
...
"item_price"
:
item
.
price
...
...y observa c√≥mo tu editor autocompleta los atributos y conoce sus tipos:
Para un ejemplo m√°s completo incluyendo m√°s funcionalidades, ve al
Tutorial - Gu√≠a del Usuario
.
Alerta de spoilers
: el tutorial - gu√≠a del usuario incluye:
Declaraci√≥n de
par√°metros
desde otros lugares diferentes como:
headers
,
cookies
,
campos de formulario
y
archivos
.
C√≥mo establecer
restricciones de validaci√≥n
como
maximum_length
o
regex
.
Un sistema de
Inyecci√≥n de Dependencias
muy poderoso y f√°cil de usar.
Seguridad y autenticaci√≥n, incluyendo soporte para
OAuth2
con
tokens JWT
y autenticaci√≥n
HTTP Basic
.
T√©cnicas m√°s avanzadas (pero igualmente f√°ciles) para declarar
modelos JSON profundamente anidados
(gracias a Pydantic).
Integraci√≥n con
GraphQL
usando
Strawberry
y otros paquetes.
Muchas funcionalidades extra (gracias a Starlette) como:
WebSockets
pruebas extremadamente f√°ciles basadas en HTTPX y
pytest
CORS
Sesiones de Cookies
...y m√°s.
Rendimiento
Benchmarks independientes de TechEmpower muestran aplicaciones
FastAPI
ejecut√°ndose bajo Uvicorn como
uno de los frameworks Python m√°s r√°pidos disponibles
, solo por debajo de Starlette y Uvicorn (usados internamente por FastAPI). (*)
Para entender m√°s sobre esto, ve la secci√≥n
Benchmarks
.
Dependencias
FastAPI depende de Pydantic y Starlette.
Dependencias
standard
Cuando instalas FastAPI con
pip install "fastapi[standard]"
viene con el grupo
standard
de dependencias opcionales:
Usadas por Pydantic:
email-validator
- para validaci√≥n de correos electr√≥nicos.
Usadas por Starlette:
httpx
- Requerido si deseas usar el
TestClient
.
jinja2
- Requerido si deseas usar la configuraci√≥n de plantilla predeterminada.
python-multipart
- Requerido si deseas soportar
"parsing"
de forms, con
request.form()
.
Usadas por FastAPI / Starlette:
uvicorn
- para el servidor que carga y sirve tu aplicaci√≥n. Esto incluye
uvicorn[standard]
, que incluye algunas dependencias (por ejemplo,
uvloop
) necesarias para servir con alto rendimiento.
fastapi-cli
- para proporcionar el comando
fastapi
.
Sin Dependencias
standard
Si no deseas incluir las dependencias opcionales
standard
, puedes instalar con
pip install fastapi
en lugar de
pip install "fastapi[standard]"
.
Dependencias Opcionales Adicionales
Existen algunas dependencias adicionales que podr√≠as querer instalar.
Dependencias opcionales adicionales de Pydantic:
pydantic-settings
- para la gesti√≥n de configuraciones.
pydantic-extra-types
- para tipos extra para ser usados con Pydantic.
Dependencias opcionales adicionales de FastAPI:
orjson
- Requerido si deseas usar
ORJSONResponse
.
ujson
- Requerido si deseas usar
UJSONResponse
.
Licencia
Este proyecto tiene licencia bajo los t√©rminos de la licencia MIT.

## 050_EXTERNAL_LINKS
External Links and Articles¬∂
---

External Links and Articles
FastAPI
has a great community constantly growing.
There are many posts, articles, tools, and projects, related to
FastAPI
.
Here's an incomplete list of some of them.
Tip
If you have an article, project, tool, or anything related to
FastAPI
that is not yet listed here, create a
Pull Request adding it
.
Articles
English
How to profile a FastAPI asynchronous request
by
Balthazar Rouberol
.
Deploy a Serverless FastAPI App with Neon Postgres and AWS App Runner at any scale
by
Stephen Siegert - Neon
.
Building a Machine Learning Microservice with FastAPI
by
Kurtis Pykes - NVIDIA
.
Booking Appointments with Twilio, Notion, and FastAPI
by
Ravgeet Dhillon - Twilio
.
Write a Python data layer with Azure Cosmos DB and FastAPI
by
Abhinav Tripathi - Microsoft Blogs
.
10 Tips for adding SQLAlchemy to FastAPI
by
Donny Peeters
.
Tips on migrating from Flask to FastAPI and vice-versa
by
Jessica Temporal
.
Explore How to Effectively Use JWT With FastAPI
by
Ankit Anchlia
.
Instrument FastAPI with OpenTelemetry tracing and visualize traces in Grafana Tempo.
by
Nicol√≥ Lino
.
ML serving and monitoring with FastAPI and Evidently
by
Mikhail Rozhkov, Elena Samuylova
.
FastAPI Tutorial in Visual Studio Code
by
Visual Studio Code Team
.
FastAPI application monitoring made easy
by
Apitally
.
Building a RESTful API with FastAPI: Secure Signup and Login Functionality Included
by
John Philip
.
Building a CRUD API with FastAPI and Supabase
by
Keshav Malik
.
Build an SMS Spam Classifier Serverless Database with FaunaDB and FastAPI
by
Adejumo Ridwan Suleiman
.
FastAPI lambda container: serverless simplified
by
Raf Rasenberg
.
Authorization on FastAPI with Casbin
by
Teresa N. Fontanella De Santis
.
How to monitor FastAPI application performance using Python agent
by
New Relic
.
Building the Poll App From Django Tutorial With FastAPI And React
by
Jean-Baptiste Rocher
.
Seamless FastAPI Configuration with ConfZ
by
Silvan Melchior
.
5 Advanced Features of FastAPI You Should Try
by
Kaustubh Gupta
.
Deploying ML Models as API Using FastAPI and Heroku
by
Kaustubh Gupta
.
Using GitHub Actions to Deploy a FastAPI Project to Heroku
by
Somraj Saha
.
How to Create A Fake Certificate Authority And Generate TLS Certs for FastAPI
by
@pystar
.
Building a realtime ticket booking solution with Kafka, FastAPI, and Ably
by
Ben Gamble
.
Building simple E-Commerce with NuxtJS and FastAPI
by
Shahriyar(Shako) Rzayev
.
Serve a machine learning model using Sklearn, FastAPI and Docker
by
Rodrigo Arenas
.
Building an API with FastAPI and Supabase and Deploying on Deta
by
Yashasvi Singh
.
Deploy FastAPI on Ubuntu and Serve using Caddy 2 Web Server
by
Navule Pavan Kumar Rao
.
Python Facebook messenger webhook with FastAPI on Glitch
by
Patrick Ladon
.
Deploy a dockerized FastAPI application to AWS
by
Valon Januzaj
.
FastAPI for Flask Users
by
Amit Chaudhary
.
How to monitor your FastAPI service
by
Louis Guitton
.
Creating a CRUD App with FastAPI (Part one)
by
Precious Ndubueze
.
Build And Host Fast Data Science Applications Using FastAPI
by
Farhad Malik
.
Deploy FastAPI on Azure App Service
by
Navule Pavan Kumar Rao
.
Machine learning model serving in Python using FastAPI and streamlit
by
Davide Fiocco
.
Introducing Dispatch
by
Netflix
.
Using FastAPI with Django
by
Stavros Korokithakis
.
Build a Secure Twilio Webhook with Python and FastAPI
by
Twilio
.
Build a web API from scratch with FastAPI - the workshop
by
Sebasti√°n Ram√≠rez (tiangolo)
.
FastAPI + Zeit.co = üöÄ
by
Paul Sec
.
Build simple API service with Python FastAPI ‚Äî Part 1
by
cuongld2
.
Microservice in Python using FastAPI
by
Paurakh Sharma Humagain
.
Real-time Notifications with Python and Postgres
by
Guillermo Cruz
.
Create and Deploy FastAPI app to Heroku without using Docker
by
Navule Pavan Kumar Rao
.
Another Boilerplate to FastAPI: Azure Pipeline CI + Pytest
by
Arthur Henrique
.
Deploy Machine Learning Models with Keras, FastAPI, Redis and Docker
by
Shane Soh
.
Towards Data Science: Deploying Iris Classifications with FastAPI and Docker
by
Mandy Gu
.
TestDriven.io: Developing and Testing an Asynchronous API with FastAPI and Pytest
by
Michael Herman
.
How To Deploy Tensorflow 2.0 Models As An API Service With FastAPI & Docker
by
Bernard Brenyah
.
Why I'm Leaving Flask
by
Dylan Anthony
.
Using Docker Compose to deploy a lightweight Python REST API with a job queue
by
Mike Moritz
.
A FastAPI and Swagger UI visual cheatsheet
by
@euri10
.
Uber: Ludwig v0.2 Adds New Features and Other Improvements to its Deep Learning Toolbox [including a FastAPI server]
by
Uber Engineering
.
How to Deploy a Machine Learning Model
by
Maarten Grootendorst
.
JWT Authentication with FastAPI and AWS Cognito
by
Johannes Gontrum
.
Top 5 Asynchronous Web Frameworks for Python
by
Ankush Thakur
.
Deploying a scikit-learn model with ONNX and FastAPI
by
Nico Axtmann
.
FastAPI authentication revisited: Enabling API key authentication
by
Nils de Bruin
.
FastAPI and Scikit-Learn: Easily Deploy Models
by
Nick Cortale
.
Introduction to the fastapi python framework
by
Errieta Kostala
.
FastAPI‚Ää‚Äî‚ÄäHow to add basic and cookie authentication
by
Nils de Bruin
.
FastAPI‚Ää‚Äî‚ÄäGoogle as an external authentication provider
by
Nils de Bruin
.
FastAPI/Starlette debug vs prod
by
William Hayes
.
Developing FastAPI Application using K8s & AWS
by
Mukul Mantosh
.
Fastapi, Docker(Docker compose) and Postgres
by
KrishNa
.
Deployment using Docker, Lambda, Aurora, CDK & GH Actions
by
Devon Ray
.
Mastering Soft Delete: Advanced SQLAlchemy Techniques
by
Shubhendra Kushwaha
.
Role based row filtering: Advanced SQLAlchemy Techniques
by
Shubhendra Kushwaha
.
German
Domain-driven Design mit Python und FastAPI
by
Marcel Sander (actidoo)
.
Inbetriebnahme eines scikit-learn-Modells mit ONNX und FastAPI
by
Nico Axtmann
.
REST-API Programmieren mittels Python und dem FastAPI Modul
by
Felix Sch√ºrmeyer
.
Japanese
[FastAPI] PythonË£Ω„ÅÆASGI Web „Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ FastAPI„Å´ÂÖ•ÈñÄ„Åô„Çã
by
@bee2
.
Python„ÅÆWeb framework„ÅÆ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊØîËºÉ (Django, Flask, responder, FastAPI, japronto)
by
@bee2
.
„ÄêÁ¨¨4Âõû„ÄëFastAPI„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´: toDo„Ç¢„Éó„É™„Çí‰Ωú„Å£„Å¶„Åø„Çà„ÅÜ„ÄêÁÆ°ÁêÜËÄÖ„Éö„Éº„Ç∏ÊîπËâØÁ∑®„Äë
by
„É©„Ç§„Éà„Ç≥„Éº„Éâ„É°„Éá„Ç£„Ç¢Á∑®ÈõÜÈÉ®
.
„ÄêÁ¨¨3Âõû„ÄëFastAPI„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´: toDo„Ç¢„Éó„É™„Çí‰Ωú„Å£„Å¶„Åø„Çà„ÅÜ„ÄêË™çË®º„Éª„É¶„Éº„Ç∂ÁôªÈå≤Á∑®„Äë
by
„É©„Ç§„Éà„Ç≥„Éº„Éâ„É°„Éá„Ç£„Ç¢Á∑®ÈõÜÈÉ®
.
„ÄêÁ¨¨2Âõû„ÄëFastAPI„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´: ToDo„Ç¢„Éó„É™„Çí‰Ωú„Å£„Å¶„Åø„Çà„ÅÜ„Äê„É¢„Éá„É´ÊßãÁØâÁ∑®„Äë
by
„É©„Ç§„Éà„Ç≥„Éº„Éâ„É°„Éá„Ç£„Ç¢Á∑®ÈõÜÈÉ®
.
„ÄêÁ¨¨1Âõû„ÄëFastAPI„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´: ToDo„Ç¢„Éó„É™„Çí‰Ωú„Å£„Å¶„Åø„Çà„ÅÜ„ÄêÁí∞Â¢ÉÊßãÁØâÁ∑®„Äë
by
„É©„Ç§„Éà„Ç≥„Éº„Éâ„É°„Éá„Ç£„Ç¢Á∑®ÈõÜÈÉ®
.
„Éï„É≠„É≥„Éà„Ç®„É≥„ÉâÈñãÁô∫ËÄÖÂêë„Åë„ÅÆDocker„Å´„Çà„ÇãPythonÈñãÁô∫Áí∞Â¢ÉÊßãÁØâ
by
Hikaru Takahashi
.
FastAPI„ÅßPOST„Åï„Çå„ÅüJSON„ÅÆ„É¨„Çπ„Éù„É≥„Çπbody„ÇíÂèó„ÅëÂèñ„Çã
by
@angel_katayoku
.
FastAPI„ÇíMySQL„Å®Êé•Á∂ö„Åó„Å¶Docker„ÅßÁÆ°ÁêÜ„Åó„Å¶„Åø„Çã
by
@angel_katayoku
.
FastAPI„ÅßCORS„ÇíÂõûÈÅø
by
@angel_katayoku
.
pythonË£Ω„ÅÆÊúÄÊñ∞API„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ FastAPI „ÇíËß¶„Å£„Å¶„Åø„Åü
by
@ryoryomaru
.
FastAPIÔΩúDBÊé•Á∂ö„Åó„Å¶CRUD„Åô„ÇãPythonË£ΩAPI„Çµ„Éº„Éê„Éº„ÇíÊßãÁØâ
by
@mtitg
.
Portuguese
FastAPI do ZERO
by
Eduardo Mendes
.
Dicas para migrar uma aplica√ß√£o de Flask para FastAPI e vice-versa
by
Jessica Temporal
.
Russian
FastAPI: –∑–Ω–∞–∫–æ–º–∏–º—Å—è —Å —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–æ–º
by
Troy K√∂hler
.
–ü–æ—á–µ–º—É –í—ã –¥–æ–ª–∂–Ω—ã –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å FastAPI?
by
prostomarkeloff
.
–ú–µ–ª–∫–∞—è –ø–∏—Ç–æ–Ω—è—á–∞—è —Ä–∞–¥–æ—Å—Ç—å #2: Starlette - –°–æ–ª–∏–¥–Ω–∞—è –ø—Ä–∏–º–æ—á–∫–∞ ‚Äì FastAPI
by
Andrey Korchak
.
Vietnamese
FASTAPI: TRI·ªÇN KHAI B·∫∞NG DOCKER
by
Nguy·ªÖn Nh√¢n
.
Taiwanese
Tortoise ORM / FastAPI Êï¥ÂêàÂø´ÈÄüÁ≠ÜË®ò
by
Leon
.
Spanish
Tutorial de FastAPI, ¬øel mejor framework de Python?
by
Eduardo Zepeda
.
Podcasts
English
Starting With FastAPI and Examining Python's Import System - Episode 72
by
Real Python
.
Do you dare to press "."? - Episode 247 - Dan #6: SQLModel - use the same models for SQL and FastAPI
by
Python Bytes FM
.
Build The Next Generation Of Python Web Applications With FastAPI - Episode 259 - interview to Sebast√≠an Ram√≠rez (tiangolo)
by
Podcast.
__init__
.
FastAPI on PythonBytes
by
Python Bytes FM
.
Talks
English
PyCon AU 2023: Testing asynchronous applications with FastAPI and pytest
by
Jeny Sadadia
.
[VIRTUAL] Py.Amsterdam's flying Software Circus: Intro to FastAPI
by
Sebasti√°n Ram√≠rez (tiangolo)
.
PyConBY 2020: Serve ML models easily with FastAPI
by
Sebasti√°n Ram√≠rez (tiangolo)
.
PyCon UK 2019: FastAPI from the ground up
by
Chris Withers
.
Taiwanese
PyCon TW 2024: ÂÖ®Êñπ‰ΩçÂº∑Âåñ Python ÊúçÂãôÂèØËßÄÊ∏¨ÊÄßÔºö‰ª• FastAPI Âíå Grafana Stack ÁÇ∫‰æã
by
Blueswen
.
GitHub Repositories
Most starred GitHub repositories with the topic
fastapi
:
‚òÖ 33079 - full-stack-fastapi-template
by
@fastapi
.
‚òÖ 30350 - Hello-Python
by
@mouredev
.
‚òÖ 21593 - serve
by
@jina-ai
.
‚òÖ 17229 - HivisionIDPhotos
by
@Zeyi-Lin
.
‚òÖ 16068 - sqlmodel
by
@fastapi
.
‚òÖ 12689 - Douyin_TikTok_Download_API
by
@Evil0ctal
.
‚òÖ 11965 - fastapi-best-practices
by
@zhanymkanov
.
‚òÖ 9773 - awesome-fastapi
by
@mjhea0
.
‚òÖ 8829 - FastUI
by
@pydantic
.
‚òÖ 6779 - nonebot2
by
@nonebot
.
‚òÖ 6652 - FileCodeBox
by
@vastsa
.
‚òÖ 5722 - serge
by
@serge-chat
.
‚òÖ 5607 - hatchet
by
@hatchet-dev
.
‚òÖ 5327 - polar
by
@polarsource
.
‚òÖ 5235 - fastapi-users
by
@fastapi-users
.
‚òÖ 5193 - fastapi_mcp
by
@tadata-org
.
‚òÖ 4833 - SurfSense
by
@MODSetter
.
‚òÖ 4307 - chatgpt-web-share
by
@chatpire
.
‚òÖ 4281 - strawberry
by
@strawberry-graphql
.
‚òÖ 4110 - atrilabs-engine
by
@Atri-Labs
.
‚òÖ 4008 - dynaconf
by
@dynaconf
.
‚òÖ 3977 - poem
by
@poem-web
.
‚òÖ 3317 - farfalle
by
@rashadphz
.
‚òÖ 3253 - fastapi-admin
by
@fastapi-admin
.
‚òÖ 3228 - datamodel-code-generator
by
@koxudaxi
.
‚òÖ 3175 - LitServe
by
@Lightning-AI
.
‚òÖ 3172 - logfire
by
@pydantic
.
‚òÖ 3122 - opyrator
by
@ml-tooling
.
‚òÖ 3110 - huma
by
@danielgtaylor
.
‚òÖ 3068 - docarray
by
@docarray
.
‚òÖ 2892 - fastapi-realworld-example-app
by
@nsidnev
.
‚òÖ 2883 - Kokoro-FastAPI
by
@remsky
.
‚òÖ 2770 - uvicorn-gunicorn-fastapi-docker
by
@tiangolo
.
‚òÖ 2740 - tracecat
by
@TracecatHQ
.
‚òÖ 2517 - best-of-web-python
by
@ml-tooling
.
‚òÖ 2423 - RasaGPT
by
@paulpierre
.
‚òÖ 2376 - fastapi-react
by
@Buuntu
.
‚òÖ 2301 - FastAPI-template
by
@s3rius
.
‚òÖ 2289 - nextpy
by
@dot-agent
.
‚òÖ 2196 - sqladmin
by
@aminalaee
.
‚òÖ 2179 - 30-Days-of-Python
by
@codingforentrepreneurs
.
‚òÖ 2098 - langserve
by
@langchain-ai
.
‚òÖ 2077 - fastapi-utils
by
@fastapiutils
.
‚òÖ 2047 - supabase-py
by
@supabase
.
‚òÖ 2044 - solara
by
@widgetti
.
‚òÖ 1905 - mangum
by
@Kludex
.
‚òÖ 1823 - python-week-2022
by
@rochacbruno
.
‚òÖ 1754 - manage-fastapi
by
@ycd
.
‚òÖ 1746 - agentkit
by
@BCG-X-Official
.
‚òÖ 1742 - ormar
by
@collerek
.
‚òÖ 1630 - langchain-serve
by
@jina-ai
.
‚òÖ 1611 - termpair
by
@cs01
.
‚òÖ 1609 - piccolo
by
@piccolo-orm
.
‚òÖ 1587 - coronavirus-tracker-api
by
@ExpDev07
.
‚òÖ 1575 - fastapi-cache
by
@long2ice
.
‚òÖ 1568 - openapi-python-client
by
@openapi-generators
.
‚òÖ 1508 - fastapi-crudrouter
by
@awtkns
.
‚òÖ 1501 - slowapi
by
@laurentS
.
‚òÖ 1453 - awesome-fastapi-projects
by
@Kludex
.
‚òÖ 1390 - awesome-python-resources
by
@DjangoEx
.
‚òÖ 1353 - fastapi-pagination
by
@uriyyo
.
‚òÖ 1342 - budgetml
by
@ebhy
.
‚òÖ 1325 - fastapi-boilerplate
by
@teamhide
.
‚òÖ 1306 - vue-fastapi-admin
by
@mizhexiaoxiao
.
‚òÖ 1256 - fastapi-amis-admin
by
@amisadmin
.
‚òÖ 1245 - fastapi-tutorial
by
@liaogx
.
‚òÖ 1201 - fastapi-code-generator
by
@koxudaxi
.
‚òÖ 1201 - bracket
by
@evroon
.
‚òÖ 1179 - bolt-python
by
@slackapi
.
‚òÖ 1147 - fastapi_production_template
by
@zhanymkanov
.
‚òÖ 1145 - prometheus-fastapi-instrumentator
by
@trallnag
.
‚òÖ 1143 - bedrock-chat
by
@aws-samples
.
‚òÖ 1134 - langchain-extract
by
@langchain-ai
.
‚òÖ 1118 - odmantic
by
@art049
.
‚òÖ 1110 - fastapi-alembic-sqlmodel-async
by
@jonra1993
.
‚òÖ 1080 - fastcrud
by
@benavlabs
.
‚òÖ 1056 - restish
by
@rest-sh
.
‚òÖ 1050 - fastapi_best_architecture
by
@fastapi-practices
.
‚òÖ 1034 - runhouse
by
@run-house
.
‚òÖ 992 - autollm
by
@viddexa
.
‚òÖ 990 - lanarky
by
@ajndkr
.
‚òÖ 985 - FastAPI-boilerplate
by
@benavlabs
.
‚òÖ 938 - authx
by
@yezz123
.
‚òÖ 935 - secure
by
@TypeError
.
‚òÖ 925 - langcorn
by
@msoedov
.
‚òÖ 913 - energy-forecasting
by
@iusztinpaul
.
‚òÖ 886 - titiler
by
@developmentseed
.
‚òÖ 866 - flock
by
@Onelevenvy
.
‚òÖ 863 - httpdbg
by
@cle-b
.
‚òÖ 859 - marker-api
by
@adithya-s-k
.
‚òÖ 845 - ludic
by
@getludic
.
‚òÖ 827 - fastapi-do-zero
by
@dunossauro
.
‚òÖ 823 - fastapi-observability
by
@blueswen
.
‚òÖ 803 - fastapi-langgraph-agent-production-ready-template
by
@wassim249
.
‚òÖ 798 - fastapi-mail
by
@sabuhish
.
‚òÖ 785 - starlette-admin
by
@jowilf
.
‚òÖ 767 - lccn_predictor
by
@baoliay2008
.
‚òÖ 759 - aktools
by
@akfamily
.
‚òÖ 748 - KonomiTV
by
@tsukumijima
.

## 051_FA
FastAPI¬∂
---

FastAPI
ŸÅÿ±€åŸÖ‚ÄåŸàÿ±⁄© FastAPIÿå ⁄©ÿßÿ±ÿß€å€å ÿ®ÿßŸÑÿßÿå €åÿßÿØ⁄Ø€åÿ±€å ÿ¢ÿ≥ÿßŸÜÿå ⁄©ÿØŸÜŸà€åÿ≥€å ÿ≥ÿ±€åÿπÿå ÿ¢ŸÖÿßÿØŸá ÿ®ÿ±ÿß€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿØÿ± ŸÖÿ≠€åÿ∑ Ÿæÿ±ŸàÿØÿß⁄©ÿ¥ŸÜ
ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™
:
https://fastapi.tiangolo.com
⁄©ÿØ ŸÖŸÜÿ®ÿπ
:
https://github.com/fastapi/fastapi
FastAPI €å⁄© Ÿàÿ® ŸÅÿ±€åŸÖ‚ÄåŸàÿ±⁄© ŸÖÿØÿ±ŸÜ Ÿà ÿ≥ÿ±€åÿπ (ÿ®ÿß ⁄©ÿßÿ±ÿß€å€å ÿ®ÿßŸÑÿß) ÿ®ÿ±ÿß€å ÿß€åÿ¨ÿßÿØ APIŸáÿß€å ŸÖÿ™ŸÜŸàÿπ (Ÿàÿ®ÿå Ÿàÿ®‚Äåÿ≥Ÿà⁄©ÿ™ Ÿà ÿ∫ÿ®ÿ±Ÿá) ÿ®ÿß ÿ≤ÿ®ÿßŸÜ Ÿæÿß€åÿ™ŸàŸÜ ŸÜÿ≥ÿÆŸá +€≥.€∂ ÿßÿ≥ÿ™. ÿß€åŸÜ ŸÅÿ±€åŸÖ‚ÄåŸàÿ±⁄© ÿ®ÿß ÿ±ÿπÿß€åÿ™ ⁄©ÿßŸÖŸÑ ÿ±ÿßŸáŸÜŸÖÿß€å ŸÜŸàÿπ ÿØÿßÿØŸá (Type Hint) ÿß€åÿ¨ÿßÿØ ÿ¥ÿØŸá ÿßÿ≥ÿ™.
Ÿà€å⁄ò⁄Ø€å‚ÄåŸáÿß€å ⁄©ŸÑ€åÿØ€å ÿß€åŸÜ ŸÅÿ±€åŸÖ‚ÄåŸàÿ±⁄© ÿπÿ®ÿßÿ±ÿ™ŸÜÿØ ÿßÿ≤:
ÿ≥ÿ±ÿπÿ™
: ⁄©ÿßÿ±ÿß€å€å ÿ®ÿ≥€åÿßÿ± ÿ®ÿßŸÑÿß Ÿà ŸÇÿßÿ®ŸÑ ŸÖŸÇÿß€åÿ≥Ÿá ÿ®ÿß
NodeJS
Ÿà
Go
(ÿ®ÿß ÿ™ÿ¥⁄©ÿ± ÿßÿ≤ Starlette Ÿà Pydantic).
€å⁄©€å ÿßÿ≤ ÿ≥ÿ±€åÿπ‚Äåÿ™ÿ±€åŸÜ ŸÅÿ±€åŸÖ‚ÄåŸàÿ±⁄©‚ÄåŸáÿß€å Ÿæÿß€åÿ™ŸàŸÜ€å ŸÖŸàÿ¨ŸàÿØ
.
⁄©ÿØŸÜŸà€åÿ≥€å ÿ≥ÿ±€åÿπ
: ÿßŸÅÿ≤ÿß€åÿ¥ €≤€∞€∞ ÿ™ÿß €≥€∞€∞ ÿØÿ±ÿµÿØ€å ÿ≥ÿ±ÿπÿ™ ÿ™Ÿàÿ≥ÿπŸá ŸÇÿßÿ®ŸÑ€åÿ™‚ÄåŸáÿß€å ÿ¨ÿØ€åÿØ. *
ÿ®ÿß⁄Ø ⁄©ŸÖÿ™ÿ±
: ⁄©ÿßŸáÿ¥ €¥€∞ ÿØÿ±ÿµÿØ€å ÿÆÿ∑ÿßŸáÿß€å ÿßŸÜÿ≥ÿßŸÜ€å (ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å). *
ŸáŸàÿ¥ŸÖŸÜÿØÿßŸÜŸá
: Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ŸÅŸàŸÇ‚ÄåÿßŸÑÿπÿßÿØŸá ÿØÿ± ŸÖÿ≠€åÿ∑‚ÄåŸáÿß€å ÿ™Ÿàÿ≥ÿπŸá €å⁄©Ÿæÿßÿ±⁄ÜŸá (IDE).
ÿ™⁄©ŸÖ€åŸÑ
ÿØÿ± ŸáŸÖŸá ÿ®ÿÆÿ¥‚ÄåŸáÿß€å ⁄©ÿØ. ⁄©ÿßŸáÿ¥ ÿ≤ŸÖÿßŸÜ ÿ±ŸÅÿπ ÿ®ÿß⁄Ø.
ÿ¢ÿ≥ÿßŸÜ
: ÿ∑ÿ±ÿßÿ≠€å ÿ¥ÿØŸá ÿ®ÿ±ÿß€å €åÿßÿØ⁄Ø€åÿ±€å Ÿà ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿ¢ÿ≥ÿßŸÜ. ⁄©ÿßŸáÿ¥ ÿ≤ŸÖÿßŸÜ ŸÖŸàÿ±ÿØ ŸÜ€åÿßÿ≤ ÿ®ÿ±ÿß€å ŸÖÿ±ÿßÿ¨ÿπŸá ÿ®Ÿá ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™.
⁄©Ÿà⁄Ü⁄©
: ⁄©ÿßŸáÿ¥ ÿ™⁄©ÿ±ÿßÿ± ÿØÿ± ⁄©ÿØ. ⁄ÜŸÜÿØ€åŸÜ ŸÇÿßÿ®ŸÑ€åÿ™ ÿ®ÿ±ÿß€å Ÿáÿ± Ÿæÿßÿ±ÿßŸÖÿ™ÿ± (ŸÖŸÜÿ∏Ÿàÿ± Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß€å Ÿàÿ±ŸàÿØ€å ÿ™ÿßÿ®ÿπ ŸáŸÜÿØŸÑÿ± ŸÖ€å‚Äåÿ®ÿßÿ¥ÿØÿå ÿ®Ÿá ÿ®ÿÆÿ¥
ÿÆŸÑÿßÿµŸá
ÿØÿ± ŸáŸÖ€åŸÜ ÿµŸÅÿ≠Ÿá ŸÖÿ±ÿßÿ¨ÿπŸá ÿ¥ŸàÿØ). ÿ®ÿß⁄Ø ⁄©ŸÖÿ™ÿ±.
ÿßÿ≥ÿ™Ÿàÿßÿ±
: ÿß€åÿ¨ÿßÿØ ⁄©ÿØ€å ÿ¢ŸÖÿßÿØŸá ÿ®ÿ±ÿß€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿØÿ± ŸÖÿ≠€åÿ∑ Ÿæÿ±ŸàÿØÿß⁄©ÿ¥ŸÜ Ÿà ÿ™ŸàŸÑ€åÿØ ÿÆŸàÿØ⁄©ÿßÿ±
ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ ÿ™ÿπÿßŸÖŸÑ€å
ŸÖÿ®ÿ™ŸÜ€å ÿ®ÿ± ÿßÿ≥ÿ™ÿßŸÜÿØÿßÿ±ÿØŸáÿß
: ŸÖÿ®ÿ™ŸÜ€å ÿ®ÿ± (Ÿà ŸÖŸÜÿ∑ÿ®ŸÇ ÿ®ÿß) ÿßÿ≥ÿ™ÿßŸÜÿØÿßÿ±ÿØŸáÿß€å ŸÖÿ™ŸÜ ÿ®ÿßÿ≤ ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá API:
OpenAPI
(ÿ≥Ÿà⁄Øÿ± ÿ≥ÿßÿ®ŸÇ) Ÿà
JSON Schema
.
* ÿ™ÿÆŸÖ€åŸÜ‚ÄåŸáÿß ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ™ÿ≥ÿ™‚ÄåŸáÿß€å ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØŸá ÿØÿ± €å⁄© ÿ™€åŸÖ ÿ™Ÿàÿ≥ÿπŸá ÿØÿßÿÆŸÑ€å ⁄©Ÿá ŸÖÿ¥ÿ∫ŸàŸÑ ÿß€åÿ¨ÿßÿØ ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸáÿß€å ⁄©ÿßÿ±ÿ®ÿ±ÿØ€å ŸàÿßŸÇÿπ€å ÿ®ŸàÿØŸÜÿØ ÿµŸàÿ±ÿ™ ⁄Øÿ±ŸÅÿ™Ÿá ÿßÿ≥ÿ™.
ÿßÿ≥ŸæÿßŸÜÿ≥ÿ±Ÿáÿß€å ÿ∑ŸÑÿß€å€å
ÿØ€å⁄Øÿ± ÿßÿ≥ŸæÿßŸÜÿ≥ÿ±Ÿáÿß
ŸÜÿ∏ÿ± ÿØ€å⁄Øÿ±ÿßŸÜ ÿØÿ± ŸÖŸàÿ±ÿØ FastAPI
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products."
Kabir Khan -
Microsoft
(ref)
"We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I‚Äôm over the moon excited about
FastAPI
. It‚Äôs so fun!"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that."
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, ŸÅÿ±€åŸÖ‚ÄåŸàÿ±⁄©€å ŸÖÿπÿßÿØŸÑ FastAPI ÿ®ÿ±ÿß€å ⁄©ÿßÿ± ÿ®ÿß
Ÿàÿßÿ≥ÿ∑ ÿÆÿ∑ ŸÅÿ±ŸÖÿßŸÜ
ÿß⁄Øÿ± ÿØÿ± ÿ≠ÿßŸÑ ÿ≥ÿßÿÆÿ™ŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá‚Äåÿß€å ÿ®ÿ±ÿß€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿØÿ±
CLI
(ÿ®Ÿá ÿ¨ÿß€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿØÿ± Ÿàÿ®) Ÿáÿ≥ÿ™€åÿØÿå ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ÿßÿ≤
Typer
. ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.
Typer
ÿØŸàŸÇŸÑŸà€å ⁄©Ÿà⁄Ü⁄©ÿ™ÿ± FastAPI ÿßÿ≥ÿ™ Ÿà ŸÇÿ±ÿßÿ± ÿßÿ≥ÿ™ ŸÖÿπÿßÿØŸÑ€å ÿ®ÿ±ÿß€å FastAPI ÿØÿ± ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸáÿß€å CLI ÿ®ÿßÿ¥ÿØ.Ô∏è üöÄ
ŸÜ€åÿßÿ≤ŸÖŸÜÿØ€å‚ÄåŸáÿß
Ÿæÿß€åÿ™ŸàŸÜ +€≥.€∂
FastAPI ŸÖÿ®ÿ™ŸÜ€å ÿ®ÿ± ÿßÿ®ÿ≤ÿßÿ±Ÿáÿß€å ŸÇÿØÿ±ÿ™ŸÖŸÜÿØ ÿ≤€åÿ± ÿßÿ≥ÿ™:
ŸÅÿ±€åŸÖ‚ÄåŸàÿ±⁄©
Starlette
ÿ®ÿ±ÿß€å ÿ®ÿÆÿ¥ Ÿàÿ®.
⁄©ÿ™ÿßÿ®ÿÆÿßŸÜŸá
Pydantic
ÿ®ÿ±ÿß€å ÿ®ÿÆÿ¥ ÿØÿßÿØŸá‚Äå.
ŸÜÿµÿ®
fast ‚Üí
pip install fastapi
restart ‚Üª
ŸÜÿµÿ® €å⁄© ÿ≥ÿ±Ÿàÿ± Ÿæÿ±ŸàÿØÿß⁄©ÿ¥ŸÜ ŸÜÿ∏€åÿ±
Uvicorn
€åÿß
Hypercorn
ŸÜ€åÿ≤ ÿ¨ÿ≤ÿ° ŸÜ€åÿßÿ≤ŸÖŸÜÿØ€å‚ÄåŸáÿßÿ≥ÿ™.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
ŸÖÿ´ÿßŸÑ
ÿß€åÿ¨ÿßÿØ ⁄©ŸÜ€åÿØ
ŸÅÿß€åŸÑ€å ÿ®Ÿá ŸÜÿßŸÖ
main.py
ÿ®ÿß ŸÖÿ≠ÿ™Ÿàÿß€å ÿ≤€åÿ± ÿß€åÿ¨ÿßÿØ ⁄©ŸÜ€åÿØ:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
ŸáŸÖ⁄ÜŸÜ€åŸÜ ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ÿßÿ≤
async def
... ŸÜ€åÿ≤ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ
ÿß⁄Øÿ± ÿØÿ± ⁄©ÿØÿ™ÿßŸÜ ÿßÿ≤
async
/
await
ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äå⁄©ŸÜ€åÿØÿå ÿßÿ≤
async def
ÿ®ÿ±ÿß€å ÿ™ÿπÿ±€åŸÅ ÿ™ÿßÿ®ÿπ ÿÆŸàÿØ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ:
from
typing
import
Optional
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Optional
[
str
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
ÿ™Ÿàÿ¨Ÿá
:
ÿß⁄Øÿ± ÿ®ÿß
async / await
ÿ¢ÿ¥ŸÜÿß ŸÜ€åÿ≥ÿ™€åÿØÿå ÿ®Ÿá ÿ®ÿÆÿ¥
"ÿπÿ¨ŸÑŸá‚Äå ÿØÿßÿ±€åÿØ?"
ÿØÿ± ÿµŸÅÿ≠Ÿá ÿØÿ±ÿ®ÿßÿ±Ÿá
async
Ÿà
await
ÿØÿ± ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™
ŸÖÿ±ÿßÿ¨ÿπŸá ⁄©ŸÜ€åÿØ.
ÿßÿ¨ÿ±ÿß ⁄©ŸÜ€åÿØ
ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ÿØÿ≥ÿ™Ÿàÿ± ÿ≤€åÿ± ÿ≥ÿ±Ÿàÿ± ÿ±ÿß ÿßÿ¨ÿ±ÿß ⁄©ŸÜ€åÿØ:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
ÿØÿ±ÿ®ÿßÿ±Ÿá ÿØÿ≥ÿ™Ÿàÿ±
uvicorn main:app --reload
...
ÿØÿ≥ÿ™Ÿàÿ±
uvicorn main:app
ÿ¥ÿßŸÖŸÑ ŸÖŸàÿßÿ±ÿØ ÿ≤€åÿ± ÿßÿ≥ÿ™:
main
: ŸÅÿß€åŸÑ
main.py
(ŸÖÿß⁄òŸàŸÑ Ÿæÿß€åÿ™ŸàŸÜ ÿß€åÿ¨ÿßÿØ ÿ¥ÿØŸá).
app
: ÿ¥€åÿ° ÿß€åÿ¨ÿßÿØ ÿ¥ÿØŸá ÿØÿ± ŸÅÿß€åŸÑ
main.py
ÿØÿ± ÿÆÿ∑
app = FastAPI()
.
--reload
: ÿ±€åÿ≥ÿ™ÿßÿ±ÿ™ ⁄©ÿ±ÿØŸÜ ÿ≥ÿ±Ÿàÿ± ÿ®ÿß ÿ™ÿ∫€å€åÿ± ⁄©ÿØ. ÿ™ŸÜŸáÿß ÿØÿ± ŸáŸÜ⁄ØÿßŸÖ ÿ™Ÿàÿ≥ÿπŸá ÿßÿ≤ ÿß€åŸÜ ⁄Øÿ≤€åŸÜŸá ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿ¥ŸàÿØ..
ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜ€åÿØ
ÿ¢ÿØÿ±ÿ≥
http://127.0.0.1:8000/items/5?q=somequery
ÿ±ÿß ÿØÿ± ŸÖÿ±Ÿàÿ±⁄Øÿ± ÿÆŸàÿØ ÿ®ÿßÿ≤ ⁄©ŸÜ€åÿØ.
Ÿæÿßÿ≥ÿÆ JSON ÿ≤€åÿ± ÿ±ÿß ŸÖÿ¥ÿßŸáÿØŸá ÿÆŸàÿßŸá€åÿØ ⁄©ÿ±ÿØ:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
ÿ™ÿß ÿß€åŸÜÿ¨ÿß ÿ¥ŸÖÿß APIÿß€å ÿ≥ÿßÿÆÿ™€åÿØ ⁄©Ÿá:
ÿØÿ±ÿÆŸàÿßÿ≥ÿ™‚ÄåŸáÿß€å HTTP ÿ®Ÿá
ŸÖÿ≥€åÿ±Ÿáÿß€å
/
Ÿà
/items/{item_id}
ÿ±ÿß ÿØÿ±€åÿßŸÅÿ™ ŸÖ€å‚Äå⁄©ŸÜÿØ.
Ÿáÿ±ÿØŸà
ŸÖÿ≥€åÿ±
ÿπŸÖŸÑ€åÿßÿ™
(€åÿß HTTP
ŸÖÿ™ÿØ
)
GET
ÿ±ÿß Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ŸÖ€å‚Äå⁄©ŸÜÿØ.
ŸÖÿ≥€åÿ±
/items/{item_id}
ÿ¥ÿßŸÖŸÑ
Ÿæÿßÿ±ÿßŸÖÿ™ÿ± ŸÖÿ≥€åÿ±
item_id
ÿßÿ≤ ŸÜŸàÿπ
int
ÿßÿ≥ÿ™.
ŸÖÿ≥€åÿ±
/items/{item_id}
ÿ¥ÿßŸÖŸÑ
Ÿæÿßÿ±ÿßŸÖÿ™ÿ± Ÿæÿ±ÿ≥ŸÖÿßŸÜ
ÿßÿÆÿ™€åÿßÿ±€å
q
ÿßÿ≤ ŸÜŸàÿπ
str
ÿßÿ≥ÿ™.
ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ API ÿ™ÿπÿßŸÖŸÑ€å
ÿ≠ÿßŸÑ ÿ®Ÿá ÿ¢ÿØÿ±ÿ≥
http://127.0.0.1:8000/docs
ÿ®ÿ±Ÿà€åÿØ.
ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ API ÿ™ÿπÿßŸÖŸÑ€å (ÿß€åÿ¨ÿßÿØ ÿ¥ÿØŸá ÿ®Ÿá ⁄©ŸÖ⁄©
Swagger UI
) ÿ±ÿß ŸÖÿ¥ÿßŸáÿØŸá ÿÆŸàÿßŸá€åÿØ ⁄©ÿ±ÿØ:
ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ API ÿ¨ÿß€å⁄Øÿ≤€åŸÜ
ÿ≠ÿßŸÑ ÿ®Ÿá ÿ¢ÿØÿ±ÿ≥
http://127.0.0.1:8000/redoc
ÿ®ÿ±Ÿà€åÿØ.
ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ ÿÆŸàÿØ⁄©ÿßÿ± ÿØ€å⁄Øÿ±€å ÿ±ÿß ŸÖÿ¥ÿßŸáÿØŸá ÿÆŸàÿßŸá€åÿØ ⁄©ÿ±ÿØ ⁄©Ÿá ÿ®Ÿá ⁄©ŸÖ⁄©
ReDoc
ÿß€åÿ¨ÿßÿØ ŸÖ€å‚Äåÿ¥ŸàÿØ:
ÿ™ÿ∫€å€åÿ± ŸÖÿ´ÿßŸÑ
ÿ≠ÿßŸÑ ŸÅÿß€åŸÑ
main.py
ÿ±ÿß ŸÖÿ∑ÿßÿ®ŸÇ ÿ≤€åÿ± Ÿà€åÿ±ÿß€åÿ¥ ⁄©ŸÜ€åÿØ ÿ™ÿß ÿ®ÿ™ŸàÿßŸÜ€åÿØ
ÿ®ÿØŸÜŸá
€å⁄© ÿØÿ±ÿÆŸàÿßÿ≥ÿ™
PUT
ÿ±ÿß ÿØÿ±€åÿßŸÅÿ™ ⁄©ŸÜ€åÿØ.
ÿ®Ÿá ⁄©ŸÖ⁄© Pydantic ÿ®ÿØŸÜŸá ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ±ÿß ÿ®ÿß
ÿßŸÜŸàÿßÿπ
ÿßÿ≥ÿ™ÿßŸÜÿØÿßÿ±ÿØ Ÿæÿß€åÿ™ŸàŸÜ ÿ™ÿπÿ±€åŸÅ ⁄©ŸÜ€åÿØ.
from
typing
import
Optional
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
ÿ≥ÿ±Ÿàÿ± ÿ®Ÿá ÿµŸàÿ±ÿ™ ÿÆŸàÿØ⁄©ÿßÿ± ÿ±€å‚Äåÿßÿ≥ÿ™ÿßÿ±ÿ™ ŸÖ€å‚Äåÿ¥ŸàÿØ (ÿ≤€åÿ±ÿß Ÿæ€åÿ¥ÿ™ÿ± ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá
--reload
ÿØÿ± ÿØÿ≥ÿ™Ÿàÿ±
uvicorn
ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ÿ±ÿØ€åŸÖ).
ÿ™ÿ∫€å€åÿ± ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ API ÿ™ÿπÿßŸÖŸÑ€å
ŸÖÿ¨ÿØÿØÿß ÿ®Ÿá ÿ¢ÿØÿ±ÿ≥
http://127.0.0.1:8000/docs
ÿ®ÿ±Ÿà€åÿØ.
ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ API ÿ™ÿπÿßŸÖŸÑ€å ÿ®Ÿá ÿµŸàÿ±ÿ™ ÿÆŸàÿØ⁄©ÿßÿ± ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ÿ¥ÿØŸá ÿßÿ≥ÿ™ Ÿà ÿ¥ÿßŸÖŸÑ ÿ®ÿØŸÜŸá ÿ™ÿπÿ±€åŸÅ ÿ¥ÿØŸá ÿØÿ± ŸÖÿ±ÿ≠ŸÑŸá ŸÇÿ®ŸÑ ÿßÿ≥ÿ™:
ÿ±Ÿà€å ÿØ⁄©ŸÖŸá "Try it out" ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØÿå ÿß⁄©ŸÜŸàŸÜ ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß€å ŸÖŸàÿ±ÿØ ŸÜ€åÿßÿ≤ Ÿáÿ± API ÿ±ÿß ŸÖÿ¥ÿÆÿµ ⁄©ÿ±ÿØŸá Ÿà ÿ®Ÿá ÿµŸàÿ±ÿ™ ŸÖÿ≥ÿ™ŸÇ€åŸÖ ÿ®ÿß ÿ¢ŸÜŸáÿß ÿ™ÿπÿßŸÖŸÑ ⁄©ŸÜ€åÿØ:
ÿ≥Ÿæÿ≥ ÿ±Ÿà€å ÿØ⁄©ŸÖŸá "Execute" ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØÿå ÿÆŸàÿßŸá€åÿØ ÿØ€åÿØ ⁄©Ÿá Ÿàÿßÿ≥ÿ∑ ⁄©ÿßÿ±ÿ®ÿ±€å ÿ®ÿß APIŸáÿß€å ÿ™ÿπÿ±€åŸÅ ÿ¥ÿØŸá ÿßÿ±ÿ™ÿ®ÿßÿ∑ ÿ®ÿ±ŸÇÿ±ÿßÿ± ⁄©ÿ±ÿØŸáÿå Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß€å ŸÖŸàÿ±ÿØ ŸÜ€åÿßÿ≤ ÿ±ÿß ÿ®Ÿá ÿ¢ŸÜ‚ÄåŸáÿß ÿßÿ±ÿ≥ÿßŸÑ ŸÖ€å‚Äå⁄©ŸÜÿØÿå ÿ≥Ÿæÿ≥ ŸÜÿ™ÿß€åÿ¨ ÿ±ÿß ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿ±ÿØŸá Ÿà ÿØÿ± ÿµŸÅÿ≠Ÿá ŸÜÿ¥ÿßŸÜ ŸÖ€å‚ÄåÿØŸáÿØ:
ÿ™ÿ∫€å€åÿ± ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ API ÿ¨ÿß€å⁄Øÿ≤€åŸÜ
ÿ≠ÿßŸÑ ÿ®Ÿá ÿ¢ÿØÿ±ÿ≥
http://127.0.0.1:8000/redoc
ÿ®ÿ±Ÿà€åÿØ.
ÿÆŸàÿßŸá€åÿØ ÿØ€åÿØ ⁄©Ÿá ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ ÿ¨ÿß€å⁄Øÿ≤€åŸÜ ŸÜ€åÿ≤ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØŸá Ÿà ÿ¥ÿßŸÖŸÑ Ÿæÿßÿ±ÿßŸÖÿ™ÿ± Ÿæÿ±ÿ≥ŸÖÿßŸÜ Ÿà ÿ®ÿØŸÜŸá ÿ™ÿπÿ±€åŸÅ ÿ¥ÿØŸá ŸÖ€å‚Äåÿ®ÿßÿ¥ÿØ:
ÿÆŸÑÿßÿµŸá
ÿ®Ÿá ÿ∑Ÿàÿ± ÿÆŸÑÿßÿµŸá ÿ¥ŸÖÿß
€å⁄© ÿ®ÿßÿ±
ÿßŸÜŸàÿßÿπ Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿßÿå ÿ®ÿØŸÜŸá Ÿà ÿ∫€åÿ±Ÿá ÿ±ÿß ÿ®Ÿá ÿπŸÜŸàÿßŸÜ Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß€å Ÿàÿ±ŸàÿØ€å ÿ™ÿßÿ®ÿπ ÿÆŸàÿØ ÿ™ÿπÿ±€åŸÅ ŸÖ€å‚Äå⁄©ŸÜ€åÿØ.
ÿß€åŸÜ ⁄©ÿßÿ± ÿ±ÿß ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ÿßŸÜŸàÿßÿπ ÿßÿ≥ÿ™ÿßŸÜÿØÿßÿ±ÿØ Ÿà ŸÖÿØÿ±ŸÜ ŸÖŸàÿ¨ŸàÿØ ÿØÿ± Ÿæÿß€åÿ™ŸàŸÜ ÿßŸÜÿ¨ÿßŸÖ ŸÖ€å‚ÄåÿØŸá€åÿØ.
ŸÜ€åÿßÿ≤€å ÿ®Ÿá €åÿßÿØ⁄Ø€åÿ±€å
ŸÜÿ≠Ÿà
ÿ¨ÿØ€åÿØ €åÿß ŸÖÿ™ÿØŸáÿß Ÿà ⁄©ŸÑÿßÿ≥‚ÄåŸáÿß€å €å⁄© ⁄©ÿ™ÿßÿ®ÿÆÿßŸÜŸá ÿ®ÿÆÿµŸàÿµ Ÿà ÿ∫€åÿ±Ÿá ŸÜ€åÿ≥ÿ™.
ÿ™ŸÜŸáÿß
Ÿæÿß€åÿ™ŸàŸÜ +€≥.€∂
.
ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ŸÖÿ´ÿßŸÑ ÿ®ÿ±ÿß€å €å⁄© Ÿæÿßÿ±ÿßŸÖÿ™ÿ± ÿßÿ≤ ŸÜŸàÿπ
int
:
item_id
:
int
€åÿß ÿ®ÿ±ÿß€å €å⁄© ŸÖÿØŸÑ Ÿæ€å⁄Ü€åÿØŸá‚Äåÿ™ÿ± ŸÖÿ´ŸÑ
Item
:
item
:
Item
...Ÿà ÿ®ÿß ŸáŸÖ€åŸÜ ÿßÿπŸÑÿßŸÜ ÿ™ŸÖÿßŸÖ€å ŸÇÿßÿ®ŸÑ€åÿ™‚ÄåŸáÿß€å ÿ≤€åÿ± ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÇÿ±ÿßÿ± ŸÖ€å‚Äå⁄Ø€åÿ±ÿØ:
Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å Ÿà€åÿ±ÿß€åÿ¥⁄Øÿ± ŸÖÿ™ŸÜ€å ÿ¥ÿßŸÖŸÑ:
ÿ™⁄©ŸÖ€åŸÑ ⁄©ÿØ.
ÿ®ÿ±ÿ±ÿ≥€å ÿßŸÜŸàÿßÿπ ÿØÿßÿØŸá.
ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å ÿØÿßÿØŸá:
ÿÆÿ∑ÿßŸáÿß€å ÿÆŸàÿØ⁄©ÿßÿ± Ÿà ŸÖÿ¥ÿÆÿµ ÿØÿ± ŸáŸÜ⁄ØÿßŸÖ ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿ®ŸàÿØŸÜ ÿØÿßÿØŸá.
ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€åÿå ÿ≠ÿ™€å ÿ®ÿ±ÿß€å ÿßÿ¥€åÿßÿ° JSON ÿ™Ÿà ÿØÿ± ÿ™Ÿà.
ÿ™ÿ®ÿØ€åŸÑ
ÿØÿßÿØŸá Ÿàÿ±ŸàÿØ€å: ⁄©Ÿá ÿßÿ≤ ÿ¥ÿ®⁄©Ÿá ÿ±ÿ≥€åÿØŸá ÿ®Ÿá ÿßŸÜŸàÿßÿπ Ÿà ÿØÿßÿØ‚ÄåŸá‚Äå Ÿæÿß€åÿ™ŸàŸÜ€å. ÿß€åŸÜ ÿØÿßÿØŸá‚Äå ÿ¥ÿßŸÖŸÑ:
JSON.
Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß€å ŸÖÿ≥€åÿ±
.
Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß€å Ÿæÿ±ÿ≥ŸÖÿßŸÜ
.
⁄©Ÿà⁄©€å‚ÄåŸáÿß
.
ÿ≥ÿ±ÿ¢€åŸÜÿØ‚ÄåŸáÿß (ŸáÿØÿ±Ÿáÿß)
.
ŸÅÿ±ŸÖ‚ÄåŸáÿß
.
ŸÅÿß€åŸÑ‚ÄåŸáÿß
.
ÿ™ÿ®ÿØ€åŸÑ
ÿØÿßÿØŸá ÿÆÿ±Ÿàÿ¨€å: ÿ™ÿ®ÿØ€åŸÑ ÿßÿ≤ ÿßŸÜŸàÿßÿπ Ÿà ÿØÿßÿØŸá‚Äå Ÿæÿß€åÿ™ŸàŸÜ ÿ®Ÿá ÿØÿßÿØŸá ÿ¥ÿ®⁄©Ÿá (ŸÖÿßŸÜŸÜÿØ JSON):
ÿ™ÿ®ÿØ€åŸÑ ÿßŸÜŸàÿßÿπ ÿØÿßÿØŸá Ÿæÿß€åÿ™ŸàŸÜ€å (
str
,
int
,
float
,
bool
,
list
Ÿà ÿ∫€åÿ±Ÿá).
ÿßÿ¥€åÿßÿ°
datetime
.
ÿßÿ¥€åÿßÿ°
UUID
.
qŸÖÿØŸÑ‚ÄåŸáÿß€å Ÿæÿß€å⁄ØÿßŸá‚ÄåÿØÿßÿØŸá.
Ÿà ŸÖŸàÿßÿ±ÿØ ÿ®€åÿ¥ŸÖÿßÿ± ÿØ€å⁄Øÿ±.
ÿØŸà ŸÖÿØŸÑ ŸÖÿ≥ÿ™ŸÜÿØ API ÿ™ÿπÿßŸÖŸÑ€å ÿÆŸàÿØ⁄©ÿßÿ± :
Swagger UI.
ReDoc.
ÿ®Ÿá ŸÖÿ´ÿßŸÑ ŸÇÿ®ŸÑ€å ÿ®ÿßÿ≤ ŸÖ€å‚Äå⁄Øÿ±ÿØ€åŸÖÿå ÿØÿ± ÿß€åŸÜ ŸÖÿ´ÿßŸÑ
FastAPI
ŸÖŸàÿßÿ±ÿØ ÿ≤€åÿ± ÿ±ÿß ÿßŸÜÿ¨ÿßŸÖ ŸÖ€å‚ÄåÿØŸáÿØ:
ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å ÿß€åŸÜ⁄©Ÿá Ÿæÿßÿ±ÿßŸÖÿ™ÿ±
item_id
ÿØÿ± ŸÖÿ≥€åÿ± ÿØÿ±ÿÆŸàÿßÿ≥ÿ™‚ÄåŸáÿß€å
GET
Ÿà
PUT
ŸÖŸàÿ¨ŸàÿØ ÿßÿ≥ÿ™.
ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å ÿß€åŸÜ⁄©Ÿá Ÿæÿßÿ±ÿßŸÖÿ™ÿ±
item_id
ÿØÿ± ÿØÿ±ÿÆŸàÿßÿ≥ÿ™‚ÄåŸáÿß€å
GET
Ÿà
PUT
ÿßÿ≤ ŸÜŸàÿπ
int
ÿßÿ≥ÿ™.
ÿß⁄Øÿ± ÿ∫€åÿ± ÿßÿ≤ ÿß€åŸÜ ŸÖŸàÿßÿ±ÿØ ÿ®ÿßÿ¥ÿØÿå ÿ≥ÿ±Ÿà€åÿ≥‚Äå⁄Ø€åÿ±ŸÜÿØŸá ÿÆÿ∑ÿß€å ŸÖŸÅ€åÿØ Ÿà ŸÖÿ¥ÿÆÿµ€å ÿØÿ±€åÿßŸÅÿ™ ÿÆŸàÿßŸáÿØ ⁄©ÿ±ÿØ.
ÿ®ÿ±ÿ±ÿ≥€å Ÿàÿ¨ŸàÿØ Ÿæÿßÿ±ÿßŸÖÿ™ÿ± Ÿæÿ±ÿ≥ŸÖÿßŸÜ ÿßÿÆÿ™€åÿßÿ±€å
q
(ŸÖÿßŸÜŸÜÿØ
http://127.0.0.1:8000/items/foo?q=somequery
) ÿØÿ± ÿØÿ±ÿÆŸàÿßÿ≥ÿ™‚ÄåŸáÿß€å
GET
.
ÿßÿ≤ ÿ¢ŸÜÿ¨ÿß ⁄©Ÿá Ÿæÿßÿ±ÿßŸÖÿ™ÿ±
q
ÿ®ÿß
= None
ŸÖŸÇÿØÿßÿ±ÿØŸá€å ÿ¥ÿØŸá ÿßÿ≥ÿ™ÿå ÿß€åŸÜ Ÿæÿßÿ±ÿßŸÖÿ™ÿ± ÿßÿÆÿ™€åÿßÿ±€å ÿßÿ≥ÿ™.
ÿß⁄Øÿ± ÿßÿ≤ ŸÖŸÇÿØÿßÿ± ÿßŸàŸÑ€åŸá
None
ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÜ⁄©ŸÜ€åŸÖÿå ÿß€åŸÜ Ÿæÿßÿ±ÿßŸÖÿ™ÿ± ÿßŸÑÿ≤ÿßŸÖ€å ÿÆŸàÿßŸáÿØ ÿ®ŸàÿØ (ŸáŸÖÿßŸÜŸÜÿØ ÿ®ÿØŸÜŸá ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿØÿ± ÿØÿ±ÿÆŸàÿßÿ≥ÿ™
PUT
).
ÿ®ÿ±ÿß€å ÿØÿ±ÿÆŸàÿßÿ≥ÿ™‚ÄåŸáÿß€å
PUT
ÿ®Ÿá ÿ¢ÿØÿ±ÿ≥
/items/{item_id}
ÿå ÿ®ÿØŸÜŸá ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ®ÿß€åÿØ ÿßÿ≤ ŸÜŸàÿπ JSON ÿ™ÿπÿ±€åŸÅ ÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØ:
ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÜ⁄©Ÿá ÿ®ÿØŸÜŸá ÿ¥ÿßŸÖŸÑ ŸÅ€åŸÑÿØ€å ÿ®ÿß ŸÜÿßŸÖ
name
Ÿà ÿßÿ≤ ŸÜŸàÿπ
str
ÿßÿ≥ÿ™.
ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÜ⁄©Ÿá ÿ®ÿØŸÜŸá ÿ¥ÿßŸÖŸÑ ŸÅ€åŸÑÿØ€å ÿ®ÿß ŸÜÿßŸÖ
price
Ÿà ÿßÿ≤ ŸÜŸàÿπ
float
ÿßÿ≥ÿ™.
ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÜ⁄©Ÿá ÿ®ÿØŸÜŸá ÿ¥ÿßŸÖŸÑ ŸÅ€åŸÑÿØ€å ÿßÿÆÿ™€åÿßÿ±€å ÿ®ÿß ŸÜÿßŸÖ
is_offer
ÿßÿ≥ÿ™ÿå ⁄©Ÿá ÿØÿ± ÿµŸàÿ±ÿ™ Ÿàÿ¨ŸàÿØ ÿ®ÿß€åÿØ ÿßÿ≤ ŸÜŸàÿπ
bool
ÿ®ÿßÿ¥ÿØ.
ÿ™ŸÖÿßŸÖ€å ÿß€åŸÜ ŸÖŸàÿßÿ±ÿØ ÿ®ÿ±ÿß€å ÿßÿ¥€åÿßÿ° JSON ÿØÿ± Ÿáÿ± ÿπŸÖŸÇ€å ŸÇÿßÿ®ŸÑ ÿ®ÿ±ÿ±ÿ≥€å ŸÖ€å‚Äåÿ®ÿßÿ¥ÿØ.
ÿ™ÿ®ÿØ€åŸÑ ÿßÿ≤/ÿ®Ÿá JSON ÿ®Ÿá ÿµŸàÿ±ÿ™ ÿÆŸàÿØ⁄©ÿßÿ±.
ŸÖÿ≥ÿ™ŸÜÿØÿ≥ÿßÿ≤€å ŸáŸÖŸá ⁄Ü€åÿ≤ ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ OpenAPIÿå ⁄©Ÿá ŸÖ€å‚Äåÿ™ŸàÿßŸÜ ÿßÿ≤ ÿ¢ŸÜ ÿ®ÿ±ÿß€å ŸÖŸàÿßÿ±ÿØ ÿ≤€åÿ± ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ÿ±ÿØ:
ÿ≥€åÿ≥ÿ™ŸÖ ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ ÿ™ÿπÿßŸÖŸÑ€å.
ÿ™ŸàŸÑ€åÿØ ÿÆŸàÿØ⁄©ÿßÿ± ⁄©ÿØ ÿ≥ÿ±Ÿà€åÿ≥‚Äå⁄Ø€åÿ±ŸÜÿØŸá‚Äå ÿØÿ± ÿ≤ÿ®ÿßŸÜ‚ÄåŸáÿß€å ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ÿ®€åÿ¥ŸÖÿßÿ±.
ŸÅÿ±ÿßŸáŸÖ ÿ≥ÿßÿ≤€å €≤ ŸÖÿ≥ÿ™ŸÜÿØ ÿ™ÿπÿßŸÖŸÑ€å ŸÖÿ®ÿ™ŸÜ€å ÿ®ÿ± Ÿàÿ® ÿ®Ÿá ÿµŸàÿ±ÿ™ Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂.
ŸÖŸàÿßÿ±ÿØ ÿ∞⁄©ÿ± ÿ¥ÿØŸá ÿ™ŸÜŸáÿß Ÿæÿßÿ±Ÿá‚Äåÿß€å ÿßÿ≤ Ÿà€å⁄ò⁄Ø€å‚ÄåŸáÿß€å ÿ®€åÿ¥ŸÖÿßÿ± FastAPI ÿßÿ≥ÿ™ ÿßŸÖÿß ÿß€åÿØŸá‚Äåÿß€å ⁄©ŸÑ€å ÿßÿ≤ ÿ∑ÿ±ÿ≤ ⁄©ÿßÿ± ÿ¢ŸÜ ÿØÿ± ÿßÿÆÿ™€åÿßÿ± ŸÇÿ±ÿßÿ± ŸÖ€å‚ÄåÿØŸáÿØ.
ÿÆÿ∑ ÿ≤€åÿ± ÿ±ÿß ÿ®Ÿá ÿß€åŸÜ ÿµŸàÿ±ÿ™ ÿ™ÿ∫€å€åÿ± ÿØŸá€åÿØ:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
ÿßÿ≤:
...
"item_name"
:
item
.
name
...
ÿ®Ÿá:
...
"item_price"
:
item
.
price
...
ÿØÿ± ÿ≠€åŸÜ ÿ™ÿß€åŸæ ⁄©ÿ±ÿØŸÜ ÿ™Ÿàÿ¨Ÿá ⁄©ŸÜ€åÿØ ⁄©Ÿá ⁄Ü⁄ØŸàŸÜŸá Ÿà€åÿ±ÿß€åÿ¥‚Äå⁄Øÿ±ÿå Ÿà€å⁄ò⁄Ø€å‚ÄåŸáÿß€å ⁄©ŸÑÿßÿ≥
Item
ÿ±ÿß ÿ™ÿ¥ÿÆ€åÿµ ÿØÿßÿØŸá Ÿà ÿ®Ÿá ÿ™⁄©ŸÖ€åŸÑ ÿÆŸàÿØ⁄©ÿßÿ± ÿ¢ŸÜŸáÿß ⁄©ŸÖ⁄© ŸÖ€å‚Äå⁄©ŸÜÿØ:
ÿ®ÿ±ÿß€å ŸÖÿ¥ÿßŸáÿØŸá ŸÖÿ´ÿßŸÑ‚ÄåŸáÿß€å ⁄©ÿßŸÖŸÑ‚Äåÿ™ÿ± ⁄©Ÿá ÿ¥ÿßŸÖŸÑ ŸÇÿßÿ®ŸÑ€åÿ™‚ÄåŸáÿß€å ÿ®€åÿ¥ÿ™ÿ±€å ÿßÿ≤ FastAPI ÿ®ÿßÿ¥ÿØ ÿ®Ÿá ÿ®ÿÆÿ¥
ÿ¢ŸÖŸàÿ≤ÿ¥ - ÿ±ÿßŸáŸÜŸÖÿß€å ⁄©ÿßÿ±ÿ®ÿ±
ŸÖÿ±ÿßÿ¨ÿπŸá ⁄©ŸÜ€åÿØ.
Ÿáÿ¥ÿØÿßÿ± ÿßÿ≥ŸæŸà€åŸÑ
: ÿ®ÿÆÿ¥ ÿ¢ŸÖŸàÿ≤ÿ¥ - ÿ±ÿßŸáŸÜŸÖÿß€å ⁄©ÿßÿ±ÿ®ÿ± ÿ¥ÿßŸÖŸÑ ŸÖŸàÿßÿ±ÿØ ÿ≤€åÿ± ÿßÿ≥ÿ™:
ÿßÿπŸÑÿßŸÜ
Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß€å
ŸÖŸàÿ¨ŸàÿØ ÿØÿ± ÿ®ÿÆÿ¥‚ÄåŸáÿß€å ÿØ€å⁄Øÿ± ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ÿå ÿ¥ÿßŸÖŸÑ:
ÿ≥ÿ±ÿ¢€åŸÜÿØ‚Äå (ŸáÿØÿ±)Ÿáÿß
ÿå
⁄©Ÿà⁄©€å‚ÄåŸáÿß
ÿå
ŸÅ€åŸÑÿØ‚ÄåŸáÿß€å ŸÅÿ±ŸÖ
Ÿà
ŸÅÿß€åŸÑ‚ÄåŸáÿß
.
⁄Ü⁄ØŸàŸÜ⁄Ø€å ÿ™ŸÜÿ∏€åŸÖ
ŸÖÿ≠ÿØŸàÿØ€åÿ™‚ÄåŸáÿß€å ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å
ÿ®Ÿá ÿπŸÜŸàÿßŸÜ ŸÖÿ´ÿßŸÑ
maximum_length
€åÿß
regex
.
ÿ≥€åÿ≥ÿ™ŸÖ
Dependency Injection
ŸÇŸà€å Ÿà ⁄©ÿßÿ±ÿ®ÿ±ÿØ€å.
ÿßŸÖŸÜ€åÿ™ Ÿà ÿ™ÿß€å€åÿØ ŸáŸà€åÿ™, ÿ¥ÿßŸÖŸÑ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ÿßÿ≤
OAuth2
ŸÖÿ®ÿ™ŸÜ€å ÿ®ÿ±
JWT tokens
Ÿà
HTTP Basic
.
ÿ™⁄©ŸÜ€å⁄© Ÿæ€åÿ¥ÿ±ŸÅÿ™Ÿá ÿ®ÿ±ÿß€å ÿ™ÿπÿ±€åŸÅ
ŸÖÿØŸÑ‚ÄåŸáÿß€å ⁄ÜŸÜÿØ ÿ≥ÿ∑ÿ≠€å JSON
(ÿ®ÿ± ÿßÿ≥ÿßÿ≥ Pydantic).
ŸÇÿßÿ®ŸÑ€åÿ™‚ÄåŸáÿß€å ÿßÿ∂ÿßŸÅ€å ÿØ€å⁄Øÿ± (ÿ®ÿ± ÿßÿ≥ÿßÿ≥ Starlette) ÿ¥ÿßŸÖŸÑ:
Ÿàÿ®‚Äåÿ≥Ÿà⁄©ÿ™
GraphQL
ÿ™ÿ≥ÿ™‚ÄåŸáÿß€å ÿÆŸàÿØ⁄©ÿßÿ± ÿ¢ÿ≥ÿßŸÜ ŸÖÿ®ÿ™ŸÜ€å ÿ®ÿ± HTTPX Ÿà
pytest
CORS
Cookie Sessions
Ÿà ŸÖŸàÿßÿ±ÿØ ÿ®€åÿ¥ŸÖÿßÿ± ÿØ€å⁄Øÿ±.
⁄©ÿßÿ±ÿß€å€å
ŸÖÿπ€åÿßÿ± (ÿ®ŸÜ⁄ÜŸÖÿßÿ±⁄©‚Äå)Ÿáÿß€å ŸÖÿ≥ÿ™ŸÇŸÑ TechEmpower ÿ≠ÿß⁄©€å ÿßÿ≤ ÿ¢ŸÜ ÿßÿ≥ÿ™ ⁄©Ÿá ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸáÿß€å
FastAPI
⁄©Ÿá ÿ™ÿ≠ÿ™ Uvicorn ÿßÿ¨ÿ±ÿß ŸÖ€å‚Äåÿ¥ŸàÿØÿå
€å⁄©€å ÿßÿ≤ ÿ≥ÿ±€åÿπ‚Äåÿ™ÿ±€åŸÜ ŸÅÿ±€åŸÖ‚ÄåŸàÿ±⁄©‚ÄåŸáÿß€å ŸÖÿ®ÿ™ŸÜ€å ÿ®ÿ± Ÿæÿß€åÿ™ŸàŸÜ
ÿå ÿßÿ≥ÿ™ ⁄©Ÿá ⁄©ŸÖ€å ÿ∂ÿπ€åŸÅ‚Äåÿ™ÿ± ÿßÿ≤ Starlette Ÿà Uvicorn ÿπŸÖŸÑ ŸÖ€å‚Äå⁄©ŸÜÿØ (ŸÅÿ±€åŸÖ‚ÄåŸàÿ±⁄© Ÿà ÿ≥ÿ±Ÿàÿ±€å ⁄©Ÿá FastAPI ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ¢ŸÜŸáÿß ÿß€åÿ¨ÿßÿØ ÿ¥ÿØŸá ÿßÿ≥ÿ™) (*)
ÿ®ÿ±ÿß€å ÿØÿ±⁄© ÿ®Ÿáÿ™ÿ±€å ÿßÿ≤ ÿß€åŸÜ ŸÖŸàÿ∂Ÿàÿπ ÿ®Ÿá ÿ®ÿÆÿ¥
ÿ®ŸÜ⁄Ü‚ÄåŸÖÿßÿ±⁄©‚ÄåŸáÿß
ŸÖÿ±ÿßÿ¨ÿπŸá ⁄©ŸÜ€åÿØ.
ŸÜ€åÿßÿ≤ŸÖŸÜÿØ€å‚ÄåŸáÿß€å ÿßÿÆÿ™€åÿßÿ±€å
ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿ¥ÿØŸá ÿ™Ÿàÿ≥ÿ∑ Pydantic:
email-validator
- ÿ®ÿ±ÿß€å ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å ÿ¢ÿØÿ±ÿ≥‚ÄåŸáÿß€å ÿß€åŸÖ€åŸÑ.
ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿ¥ÿØŸá ÿ™Ÿàÿ≥ÿ∑ Starlette:
HTTPX
- ÿØÿ± ÿµŸàÿ±ÿ™€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿßÿ≤
TestClient
ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.
aiofiles
- ÿØÿ± ÿµŸàÿ±ÿ™€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿßÿ≤
FileResponse
Ÿà
StaticFiles
ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.
jinja2
- ÿØÿ± ÿµŸàÿ±ÿ™€å ⁄©Ÿá ÿ®ÿÆŸàÿßŸá€åÿØ ÿßÿ≤ Ÿæ€å⁄©ÿ±ÿ®ŸÜÿØ€å Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ ÿ®ÿ±ÿß€å ŸÇÿßŸÑÿ®‚ÄåŸáÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.
python-multipart
- ÿØÿ± ÿµŸàÿ±ÿ™€å ⁄©Ÿá ÿ®ÿÆŸàÿßŸá€åÿØ ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤
request.form()
ÿßÿ≤ ŸÇÿßÿ®ŸÑ€åÿ™
"ÿ™ÿ¨ÿ≤€åŸá (parse)"
ŸÅÿ±ŸÖ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.
itsdangerous
- ÿØÿ± ÿµŸàÿ±ÿ™€å ⁄©Ÿá ÿ®ÿÆŸàÿß€åÿØ ÿßÿ≤
SessionMiddleware
Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ⁄©ŸÜ€åÿØ.
pyyaml
- ÿ®ÿ±ÿß€å Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å
SchemaGenerator
ÿØÿ± Starlet (ÿ®Ÿá ÿßÿ≠ÿ™ŸÖÿßŸÑ ÿ≤€åÿßÿØ ÿ®ÿ±ÿß€å ⁄©ÿßÿ± ⁄©ÿ±ÿØŸÜ ÿ®ÿß FastAPI ÿ®Ÿá ÿ¢ŸÜ ŸÜ€åÿßÿ≤€å Ÿæ€åÿØÿß ŸÜŸÖ€å‚Äå⁄©ŸÜ€åÿØ).
graphene
- ÿØÿ± ÿµŸàÿ±ÿ™€å ⁄©Ÿá ÿßÿ≤
GraphQLApp
Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ŸÖ€å‚Äå⁄©ŸÜ€åÿØ.
ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿ¥ÿØŸá ÿ™Ÿàÿ≥ÿ∑ FastAPI / Starlette:
uvicorn
- ÿ®ÿ±ÿß€å ÿ≥ÿ±Ÿàÿ± ÿßÿ¨ÿ±ÿß ⁄©ŸÜŸÜÿØŸá ÿ®ÿ±ŸÜÿßŸÖŸá Ÿàÿ®.
orjson
- ÿØÿ± ÿµŸàÿ±ÿ™€å ⁄©Ÿá ÿ®ÿÆŸàÿßŸá€åÿØ ÿßÿ≤
ORJSONResponse
ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.
ujson
- ÿØÿ± ÿµŸàÿ±ÿ™€å ⁄©Ÿá ÿ®ÿÆŸàÿßŸá€åÿØ ÿßÿ≤
UJSONResponse
ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.
ŸÖ€å‚Äåÿ™ŸàÿßŸÜ ŸáŸÖŸá ÿß€åŸÜ ŸÖŸàÿßÿ±ÿØ ÿ±ÿß ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ÿØÿ≥ÿ™Ÿàÿ±
pip install fastapi[all]
. ÿ®Ÿá ÿµŸàÿ±ÿ™ €å⁄©ÿ¨ÿß ŸÜÿµÿ® ⁄©ÿ±ÿØ.
ŸÑÿß€åÿ≥ŸÜÿ≥
ÿß€åŸÜ Ÿæÿ±Ÿà⁄òŸá ŸÖÿ¥ŸÖŸàŸÑ ŸÇŸàÿßŸÜ€åŸÜ Ÿà ŸÖŸÇÿ±ÿ±ÿßÿ™ ŸÑÿß€åÿ≥ŸÜÿ≥ MIT ÿßÿ≥ÿ™.

## 052_FASTAPI_CLI
FastAPI CLI¬∂
---

FastAPI CLI
FastAPI CLI
is a command line program that you can use to serve your FastAPI app, manage your FastAPI project, and more.
When you install FastAPI (e.g. with
pip install "fastapi[standard]"
), it includes a package called
fastapi-cli
, this package provides the
fastapi
command in the terminal.
To run your FastAPI app for development, you can use the
fastapi dev
command:
fast ‚Üí
fastapi dev main.py
FastAPI
Starting development server üöÄ
Searching for package file structure from directories with
__init__.py
files
Importing from
/home/user/code/
awesomeapp
module
üêç main.py
code
Importing the FastAPI app object from the module with the
following code:
from
main
import
app
app
Using import string:
main:app
server
Server started at
http://127.0.0.1:8000
server
Documentation at
http://127.0.0.1:8000/docs
tip
Running in development mode, for production use:
fastapi run
Logs:
INFO
Will watch for changes in these directories:
[
'/home/user/code/awesomeapp'
]
INFO
Uvicorn running on
http://127.0.0.1:8000
(
Press CTRL+C to
quit
)
INFO
Started reloader process
[
383138
]
using WatchFiles
INFO
Started server process
[
383153
]
INFO
Waiting for application startup.
INFO
Application startup complete.
The command line program called
fastapi
is
FastAPI CLI
.
FastAPI CLI takes the path to your Python program (e.g.
main.py
) and automatically detects the
FastAPI
instance (commonly named
app
), determines the correct import process, and then serves it.
For production you would use
fastapi run
instead. üöÄ
Internally,
FastAPI CLI
uses
Uvicorn
, a high-performance, production-ready, ASGI server. üòé
fastapi dev
Running
fastapi dev
initiates development mode.
By default,
auto-reload
is enabled, automatically reloading the server when you make changes to your code. This is resource-intensive and could be less stable than when it's disabled. You should only use it for development. It also listens on the IP address
127.0.0.1
, which is the IP for your machine to communicate with itself alone (
localhost
).
fastapi run
Executing
fastapi run
starts FastAPI in production mode by default.
By default,
auto-reload
is disabled. It also listens on the IP address
0.0.0.0
, which means all the available IP addresses, this way it will be publicly accessible to anyone that can communicate with the machine. This is how you would normally run it in production, for example, in a container.
In most cases you would (and should) have a "termination proxy" handling HTTPS for you on top, this will depend on how you deploy your application, your provider might do this for you, or you might need to set it up yourself.
Tip
You can learn more about it in the
deployment documentation
.

## 053_FASTAPI_PEOPLE
FastAPI People¬∂
---

FastAPI People
FastAPI has an amazing community that welcomes people from all backgrounds.
Creator
Hey! üëã
This is me:
@tiangolo
Answers: 1898
Pull Requests: 747
I'm the creator of
FastAPI
. You can read more about that in
Help FastAPI - Get Help - Connect with the author
.
...But here I want to show you the community.
FastAPI
receives a lot of support from the community. And I want to highlight their contributions.
These are the people that:
Help others with questions in GitHub
.
Create Pull Requests
.
Review Pull Requests,
especially important for translations
.
Help
manage the repository
(team members).
All these tasks help maintain the repository.
A round of applause to them. üëè üôá
Team
This is the current list of team members. üòé
They have different levels of involvement and permissions, they can perform
repository management tasks
and together we
manage the FastAPI repository
.
@tiangolo
@Kludex
@alejsdev
@svlandeg
@YuriiMotov
@patrick91
@luzzodev
Although the team members have the permissions to perform privileged tasks, all the
help from others maintaining FastAPI
is very much appreciated! üôá‚Äç‚ôÇÔ∏è
FastAPI Experts
These are the users that have been
helping others the most with questions in GitHub
. üôá
They have proven to be
FastAPI Experts
by helping many others. ‚ú®
Tip
You could become an official FastAPI Expert too!
Just
help others with questions in GitHub
. ü§ì
You can see the
FastAPI Experts
for:
Last Month
ü§ì
3 Months
üòé
6 Months
üßê
1 Year
üßë‚Äçüî¨
All Time
üßô
FastAPI Experts - Last Month
These are the users that have been
helping others the most with questions in GitHub
during the last month. ü§ì
@YuriiMotov
Questions replied: 9
@luzzodev
Questions replied: 8
@alv2017
Questions replied: 3
@sachinh35
Questions replied: 2
@KianAnbarestani
Questions replied: 2
FastAPI Experts - 3 Months
These are the users that have been
helping others the most with questions in GitHub
during the last 3 months. üòé
@luzzodev
Questions replied: 25
@YuriiMotov
Questions replied: 24
@alv2017
Questions replied: 22
@jgould22
Questions replied: 13
@Kludex
Questions replied: 10
@yauhen-sobaleu
Questions replied: 9
@JavierSanchezCastro
Questions replied: 7
@sachinh35
Questions replied: 3
@SobikXexe
Questions replied: 3
FastAPI Experts - 6 Months
These are the users that have been
helping others the most with questions in GitHub
during the last 6 months. üßê
@luzzodev
Questions replied: 57
@YuriiMotov
Questions replied: 56
@Kludex
Questions replied: 34
@alv2017
Questions replied: 25
@jgould22
Questions replied: 17
@sehraramiz
Questions replied: 11
@JavierSanchezCastro
Questions replied: 9
@yauhen-sobaleu
Questions replied: 9
@estebanx64
Questions replied: 7
@yvallois
Questions replied: 7
FastAPI Experts - 1 Year
These are the users that have been
helping others the most with questions in GitHub
during the last year. üßë‚Äçüî¨
@YuriiMotov
Questions replied: 172
@Kludex
Questions replied: 63
@luzzodev
Questions replied: 61
@sinisaos
Questions replied: 41
@JavierSanchezCastro
Questions replied: 33
@jgould22
Questions replied: 27
@alv2017
Questions replied: 25
@ceb10n
Questions replied: 15
@estebanx64
Questions replied: 13
@n8sty
Questions replied: 13
@Kfir-G
Questions replied: 13
@sehraramiz
Questions replied: 11
@PhysicallyActive
Questions replied: 11
@mattmess1221
Questions replied: 11
@yauhen-sobaleu
Questions replied: 9
@AIdjis
Questions replied: 8
@yvallois
Questions replied: 7
@hasansezertasan
Questions replied: 5
@gustavosett
Questions replied: 5
FastAPI Experts - All Time
Here are the all time
FastAPI Experts
. ü§ìü§Ø
These are the users that have
helped others the most with questions in GitHub
through
all time
. üßô
@Kludex
Questions replied: 655
@jgould22
Questions replied: 263
@YuriiMotov
Questions replied: 247
@dmontagu
Questions replied: 240
@Mause
Questions replied: 219
@ycd
Questions replied: 217
@JarroVGIT
Questions replied: 192
@euri10
Questions replied: 153
@iudeen
Questions replied: 128
@phy25
Questions replied: 126
@JavierSanchezCastro
Questions replied: 91
@raphaelauv
Questions replied: 83
@ghandic
Questions replied: 71
@ArcLightSlavik
Questions replied: 71
@n8sty
Questions replied: 67
@luzzodev
Questions replied: 61
@falkben
Questions replied: 59
@acidjunk
Questions replied: 50
@yinziyan1206
Questions replied: 49
@sm-Fifteen
Questions replied: 49
@adriangb
Questions replied: 46
@insomnes
Questions replied: 45
@Dustyposa
Questions replied: 45
@odiseo0
Questions replied: 43
@frankie567
Questions replied: 43
@sinisaos
Questions replied: 41
@includeamin
Questions replied: 40
@chbndrhnns
Questions replied: 37
@STeveShary
Questions replied: 37
@krishnardt
Questions replied: 35
@panla
Questions replied: 32
@prostomarkeloff
Questions replied: 28
@hasansezertasan
Questions replied: 27
@dbanty
Questions replied: 26
@alv2017
Questions replied: 25
@wshayes
Questions replied: 25
@SirTelemak
Questions replied: 23
@connebs
Questions replied: 22
@nymous
Questions replied: 22
@chrisK824
Questions replied: 22
@rafsaf
Questions replied: 21
@ebottos94
Questions replied: 20
@nsidnev
Questions replied: 20
@chris-allnutt
Questions replied: 20
@estebanx64
Questions replied: 19
@zoliknemet
Questions replied: 18
@sehraramiz
Questions replied: 18
@retnikt
Questions replied: 18
Top Contributors
Here are the
Top Contributors
. üë∑
These users have
created the most Pull Requests
that have been
merged
.
They have contributed source code, documentation, etc. üì¶
@alejsdev
Pull Requests: 47
@Kludex
Pull Requests: 23
@dmontagu
Pull Requests: 17
@euri10
Pull Requests: 13
@kantandane
Pull Requests: 13
@nilslindemann
Pull Requests: 11
@zhaohan-dong
Pull Requests: 11
@mariacamilagl
Pull Requests: 9
@handabaldeep
Pull Requests: 9
@vishnuvskvkl
Pull Requests: 8
@svlandeg
Pull Requests: 7
@alissadb
Pull Requests: 6
@wshayes
Pull Requests: 5
@samuelcolvin
Pull Requests: 5
@waynerv
Pull Requests: 5
@krishnamadhavan
Pull Requests: 5
@alv2017
Pull Requests: 5
@jekirl
Pull Requests: 4
@hitrust
Pull Requests: 4
@ShahriyarR
Pull Requests: 4
@adriangb
Pull Requests: 4
@iudeen
Pull Requests: 4
@philipokiokio
Pull Requests: 4
@AlexWendland
Pull Requests: 4
@divums
Pull Requests: 3
@prostomarkeloff
Pull Requests: 3
@nsidnev
Pull Requests: 3
@pawamoy
Pull Requests: 3
@patrickmckenna
Pull Requests: 3
@hukkin
Pull Requests: 3
@marcosmmb
Pull Requests: 3
@Serrones
Pull Requests: 3
@uriyyo
Pull Requests: 3
@andrew222651
Pull Requests: 3
@rkbeatss
Pull Requests: 3
@asheux
Pull Requests: 3
@n25a
Pull Requests: 3
@ghandic
Pull Requests: 3
@TeoZosa
Pull Requests: 3
@graingert
Pull Requests: 3
@jaystone776
Pull Requests: 3
@zanieb
Pull Requests: 3
@MicaelJarniac
Pull Requests: 3
@papb
Pull Requests: 3
@musicinmybrain
Pull Requests: 3
@gitworkflows
Pull Requests: 3
There are hundreds of other contributors, you can see them all in the
FastAPI GitHub Contributors page
. üë∑
Top Translators
These are the
Top Translators
. üåê
These users have created the most Pull Requests with
translations to other languages
that have been
merged
.
@nilslindemann
Translations: 120
@jaystone776
Translations: 46
@ceb10n
Translations: 27
@valentinDruzhinin
Translations: 24
@tokusumi
Translations: 23
@SwftAlpc
Translations: 23
@hasansezertasan
Translations: 22
@waynerv
Translations: 20
@AlertRED
Translations: 16
@hard-coders
Translations: 15
@Joao-Pedro-P-Holanda
Translations: 14
@codingjenny
Translations: 14
@Xewus
Translations: 13
@Zhongheng-Cheng
Translations: 13
@Smlep
Translations: 11
@marcelomarkus
Translations: 11
@KaniKim
Translations: 10
@Vincy1230
Translations: 9
@rjNemo
Translations: 8
@xzmeng
Translations: 8
@pablocm83
Translations: 8
@ptt3199
Translations: 7
@batlopes
Translations: 6
@lucasbalieiro
Translations: 6
@Alexandrhub
Translations: 6
@Serrones
Translations: 5
@RunningIkkyu
Translations: 5
@Attsun1031
Translations: 5
@NinaHwang
Translations: 5
@rostik1410
Translations: 5
@alv2017
Translations: 5
@komtaki
Translations: 4
@JulianMaurin
Translations: 4
@stlucasgarcia
Translations: 4
@ComicShrimp
Translations: 4
@BilalAlpaslan
Translations: 4
@axel584
Translations: 4
@tamtam-fitness
Translations: 4
@Limsunoh
Translations: 4
@kwang1215
Translations: 4
@k94-ishi
Translations: 4
@jfunez
Translations: 3
@ycd
Translations: 3
@mariacamilagl
Translations: 3
@maoyibo
Translations: 3
@blt232018
Translations: 3
@magiskboy
Translations: 3
@luccasmmg
Translations: 3
@lbmendes
Translations: 3
Top Translation Reviewers
These users are the
Top Translation Reviewers
. üïµÔ∏è
I only speak a few languages (and not very well üòÖ). So, the reviewers are the ones that have the
power to approve translations
of the documentation. Without them, there wouldn't be documentation in several other languages.
@s111d
Reviews: 147
@Xewus
Reviews: 140
@sodaMelon
Reviews: 125
@ceb10n
Reviews: 112
@tokusumi
Reviews: 104
@hasansezertasan
Reviews: 95
@hard-coders
Reviews: 92
@alv2017
Reviews: 88
@nazarepiedady
Reviews: 83
@AlertRED
Reviews: 81
@Alexandrhub
Reviews: 68
@waynerv
Reviews: 63
@cassiobotaro
Reviews: 62
@mattwang44
Reviews: 59
@Laineyzhang55
Reviews: 48
@Kludex
Reviews: 47
@komtaki
Reviews: 45
@rostik1410
Reviews: 42
@svlandeg
Reviews: 42
@alperiox
Reviews: 42
@Rishat-F
Reviews: 42
@Winand
Reviews: 40
@solomein-sv
Reviews: 38
@JavierSanchezCastro
Reviews: 38
@stlucasgarcia
Reviews: 36
@SwftAlpc
Reviews: 36
@alejsdev
Reviews: 36
@timothy-jeong
Reviews: 36
@nilslindemann
Reviews: 35
@rjNemo
Reviews: 34
@codingjenny
Reviews: 34
@mezgoodle
Reviews: 33
@akarev0
Reviews: 33
@romashevchenko
Reviews: 32
@LorhanSohaky
Reviews: 30
@Vincy1230
Reviews: 30
@black-redoc
Reviews: 29
@pedabraham
Reviews: 28
@Smlep
Reviews: 28
@dedkot01
Reviews: 28
@hsuanchi
Reviews: 28
@dpinezich
Reviews: 28
@maoyibo
Reviews: 27
@0417taehyun
Reviews: 27
@BilalAlpaslan
Reviews: 26
@junah201
Reviews: 26
@zy7y
Reviews: 25
@mycaule
Reviews: 25
@Aruelius
Reviews: 24
Sponsors
These are the
Sponsors
. üòé
They are supporting my work with
FastAPI
(and others), mainly through
GitHub Sponsors
.
Gold Sponsors
Silver Sponsors
Bronze Sponsors
Individual Sponsors
@Nixtla
@subtotal
@mercedes-benz
@marvin-robot
@Ponte-Energy-Partners
@BoostryJP
@acsone
@Trivie
@takashi-yoneya
@mainframeindustries
@yasyf
@alixlahuec
@primer-io
@upciti
@samuelcolvin
@otosky
@ramonalmeidam
@ashi-agrawal
@RaamEEIL
@ehaca
@raphaellaude
@timlrx
@Leay15
@ProteinQure
@kaoru0310
@DelfinaCare
@Karine-Bauch
@eruditis
@jugeeem
@logic-automation
@roboflow
@dudikbender
@patsatsia
@anthonycepeda
@patricioperezv
@chickenandstats
@dodo5522
@knallgelb
@dblackrun
@zsinx6
@kennywakeland
@aacayaco
@anomaly
@mj0331
@gorhack
@Ryandaydev
@vincentkoc
@jstanden
@paulcwatts
@andreaso
@robintw
@pamelafox
@ericof
@wshayes
@koxudaxi
@falkben
@mintuhouse
@TrevorBenson
@wdwinslow
@catherinenelson1
@jsoques
@joeds13
@dannywade
@khadrawy
@mjohnsey
@jaredtrog
@oliverxchen
@ternaus
@eseglem
@FernandoCelmer
@Rehket
@hiancdtrsnm
@jpizquierdo
@pawamoy
@bnkc
@petercool
@siavashyj
@mobyw
@ArtyomVancyan
@caviri
@hgalytoby
@browniebroke
@joshuatz
@SebTota
@nisutec
@hoenie-ams
@joerambo
@rlnchow
@engineerjoe440
@lukzmu
@conservative-dude
@CR1337
@PunRabbit
@PelicanQ
@miguelgr
@WillHogan
@my3
@leobiscassi
@Alisa-lisa
@ddanier
@bryanculbertson
@slafs
@ceb10n
@tochikuji
@moonape1226
@msehnout
@xncbf
@DMantis
@hard-coders
@supdann
@mntolia
@pheanex
@Zuzah
@artempronevskiy
@TheR1D
@danielunderwood
@rangulvers
@sdevkota
@brizzbuzz
@Baghdady92
@KentShikama
@katnoria
@harsh183
@hcristea
@andrecorumba
@rwxd
@morzan1001
@sadikkuzu
@Olegt0rr
@larsyngvelundin
@one-st-one
@federicsp
@Toothwitch
@andreagrandi
About the data - technical details
The main intention of this page is to highlight the effort of the community to help others.
Especially including efforts that are normally less visible, and in many cases more arduous, like helping others with questions and reviewing Pull Requests with translations.
The data is calculated each month, you can read the
source code here
.
Here I'm also highlighting contributions from sponsors.
I also reserve the right to update the algorithm, sections, thresholds, etc (just in case ü§∑).

## 054_FEATURES
Features¬∂
---

Features
FastAPI features
FastAPI
gives you the following:
Based on open standards
OpenAPI
for API creation, including declarations of
path
operations
, parameters, request bodies, security, etc.
Automatic data model documentation with
JSON Schema
(as OpenAPI itself is based on JSON Schema).
Designed around these standards, after a meticulous study. Instead of an afterthought layer on top.
This also allows using automatic
client code generation
in many languages.
Automatic docs
Interactive API documentation and exploration web user interfaces. As the framework is based on OpenAPI, there are multiple options, 2 included by default.
Swagger UI
, with interactive exploration, call and test your API directly from the browser.
Alternative API documentation with
ReDoc
.
Just Modern Python
It's all based on standard
Python type
declarations (thanks to Pydantic). No new syntax to learn. Just standard modern Python.
If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI), check the short tutorial:
Python Types
.
You write standard Python with types:
from
datetime
import
date
from
pydantic
import
BaseModel
## Declare a variable as a str
## and get editor support inside the function
def
main
(
user_id
:
str
):
return
user_id
## A Pydantic model
class
User
(
BaseModel
):
id
:
int
name
:
str
joined
:
date
That can then be used like:
my_user
:
User
=
User
(
id
=
3
,
name
=
"John Doe"
,
joined
=
"2018-07-19"
)
second_user_data
=
{
"id"
:
4
,
"name"
:
"Mary"
,
"joined"
:
"2018-11-30"
,
}
my_second_user
:
User
=
User
(
**
second_user_data
)
Info
**second_user_data
means:
Pass the keys and values of the
second_user_data
dict directly as key-value arguments, equivalent to:
User(id=4, name="Mary", joined="2018-11-30")
Editor support
All the framework was designed to be easy and intuitive to use, all the decisions were tested on multiple editors even before starting development, to ensure the best development experience.
In the Python developer surveys, it's clear
that one of the most used features is "autocompletion"
.
The whole
FastAPI
framework is based to satisfy that. Autocompletion works everywhere.
You will rarely need to come back to the docs.
Here's how your editor might help you:
in
Visual Studio Code
:
in
PyCharm
:
You will get completion in code you might even consider impossible before. As for example, the
price
key inside a JSON body (that could have been nested) that comes from a request.
No more typing the wrong key names, coming back and forth between docs, or scrolling up and down to find if you finally used
username
or
user_name
.
Short
It has sensible
defaults
for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need and to define the API you need.
But by default, it all
"just works"
.
Validation
Validation for most (or all?) Python
data types
, including:
JSON objects (
dict
).
JSON array (
list
) defining item types.
String (
str
) fields, defining min and max lengths.
Numbers (
int
,
float
) with min and max values, etc.
Validation for more exotic types, like:
URL.
Email.
UUID.
...and others.
All the validation is handled by the well-established and robust
Pydantic
.
Security and authentication
Security and authentication integrated. Without any compromise with databases or data models.
All the security schemes defined in OpenAPI, including:
HTTP Basic.
OAuth2
(also with
JWT tokens
). Check the tutorial on
OAuth2 with JWT
.
API keys in:
Headers.
Query parameters.
Cookies, etc.
Plus all the security features from Starlette (including
session cookies
).
All built as reusable tools and components that are easy to integrate with your systems, data stores, relational and NoSQL databases, etc.
Dependency Injection
FastAPI includes an extremely easy to use, but extremely powerful
Dependency Injection
system.
Even dependencies can have dependencies, creating a hierarchy or
"graph" of dependencies
.
All
automatically handled
by the framework.
All the dependencies can require data from requests and
augment the path operation
constraints and automatic documentation.
Automatic validation
even for
path operation
parameters defined in dependencies.
Support for complex user authentication systems,
database connections
, etc.
No compromise
with databases, frontends, etc. But easy integration with all of them.
Unlimited "plug-ins"
Or in other way, no need for them, import and use the code you need.
Any integration is designed to be so simple to use (with dependencies) that you can create a "plug-in" for your application in 2 lines of code using the same structure and syntax used for your
path operations
.
Tested
100%
test coverage
.
100%
type annotated
code base.
Used in production applications.
Starlette features
FastAPI
is fully compatible with (and based on)
Starlette
. So, any additional Starlette code you have, will also work.
FastAPI
is actually a sub-class of
Starlette
. So, if you already know or use Starlette, most of the functionality will work the same way.
With
FastAPI
you get all of
Starlette
's features (as FastAPI is just Starlette on steroids):
Seriously impressive performance. It is
one of the fastest Python frameworks available, on par with
NodeJS
and
Go
.
WebSocket
support.
In-process background tasks.
Startup and shutdown events.
Test client built on HTTPX.
CORS
, GZip, Static Files, Streaming responses.
Session and Cookie
support.
100% test coverage.
100% type annotated codebase.
Pydantic features
FastAPI
is fully compatible with (and based on)
Pydantic
. So, any additional Pydantic code you have, will also work.
Including external libraries also based on Pydantic, as
ORM
s,
ODM
s for databases.
This also means that in many cases you can pass the same object you get from a request
directly to the database
, as everything is validated automatically.
The same applies the other way around, in many cases you can just pass the object you get from the database
directly to the client
.
With
FastAPI
you get all of
Pydantic
's features (as FastAPI is based on Pydantic for all the data handling):
No brainfuck
:
No new schema definition micro-language to learn.
If you know Python types you know how to use Pydantic.
Plays nicely with your
IDE
/
linter
/brain
:
Because pydantic data structures are just instances of classes you define; auto-completion, linting, mypy and your intuition should all work properly with your validated data.
Validate
complex structures
:
Use of hierarchical Pydantic models, Python
typing
‚Äôs
List
and
Dict
, etc.
And validators allow complex data schemas to be clearly and easily defined, checked and documented as JSON Schema.
You can have deeply
nested JSON
objects and have them all validated and annotated.
Extensible
:
Pydantic allows custom data types to be defined or you can extend validation with methods on a model decorated with the validator decorator.
100% test coverage.

## 055_FR
FastAPI¬∂
---

FastAPI
Framework FastAPI, haute performance, facile √† apprendre, rapide √† coder, pr√™t pour la production
Documentation
:
https://fastapi.tiangolo.com
Code Source
:
https://github.com/fastapi/fastapi
FastAPI est un framework web moderne et rapide (haute performance) pour la cr√©ation d'API avec Python, bas√© sur les annotations de type standard de Python.
Les principales fonctionnalit√©s sont :
Rapidit√©
: De tr√®s hautes performances, au niveau de
NodeJS
et
Go
(gr√¢ce √† Starlette et Pydantic).
L'un des frameworks Python les plus rapides
.
Rapide √† coder
: Augmente la vitesse de d√©veloppement des fonctionnalit√©s d'environ 200 % √† 300 %. *
Moins de bugs
: R√©duit d'environ 40 % les erreurs induites par le d√©veloppeur. *
Intuitif
: Excellente compatibilit√© avec les IDE.
Compl√©tion
compl√®te. Moins de temps pass√© √† d√©boguer.
Facile
: Con√ßu pour √™tre facile √† utiliser et √† apprendre. Moins de temps pass√© √† lire la documentation.
Concis
: Diminue la duplication de code. De nombreuses fonctionnalit√©s li√©es √† la d√©claration de chaque param√®tre. Moins de bugs.
Robuste
: Obtenez un code pr√™t pour la production. Avec une documentation interactive automatique.
Bas√© sur des normes
: Bas√© sur (et enti√®rement compatible avec) les standards ouverts pour les APIs :
OpenAPI
(pr√©c√©demment connu sous le nom de Swagger) et
JSON Schema
.
* estimation bas√©e sur des tests d'une √©quipe de d√©veloppement interne, construisant des applications de production.
Sponsors
Other sponsors
Opinions
"
[...] J'utilise beaucoup
FastAPI
ces derniers temps. [...] Je pr√©vois de l'utiliser dans mon √©quipe pour tous les
services de ML chez Microsoft
. Certains d'entre eux seront int√©gr√©s dans le coeur de
Windows
et dans certains produits
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
Nous avons adopt√© la biblioth√®que
FastAPI
pour cr√©er un serveur
REST
qui peut √™tre interrog√© pour obtenir des
pr√©dictions
. [pour Ludwig]
"
Piero Molino, Yaroslav Dudin et Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
a le plaisir d'annoncer la sortie en open-source de notre framework d'orchestration de
gestion de crise
:
Dispatch
! [construit avec
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Je suis tr√®s enthousiaste √† propos de
FastAPI
. C'est un bonheur !
"
Brian Okken -
Auteur du podcast
Python Bytes
(ref)
"
Honn√™tement, ce que vous avez construit a l'air super solide et √©l√©gant. A bien des √©gards, c'est comme √ßa que je voulais que
Hug
soit - c'est vraiment inspirant de voir quelqu'un construire √ßa.
"
Timothy Crosley -
Cr√©ateur de
Hug
(ref)
"
Si vous cherchez √† apprendre un
framework moderne
pour cr√©er des APIs REST, regardez
FastAPI
[...] C'est rapide, facile √† utiliser et √† apprendre [...]
"
"
Nous sommes pass√©s √†
FastAPI
pour nos
APIs
[...] Je pense que vous l'aimerez [...]
"
Ines Montani - Matthew Honnibal -
Fondateurs de
Explosion AI
- Cr√©ateurs de
spaCy
(ref)
-
(ref)
"
Si quelqu'un cherche √† construire une API Python de production, je recommande vivement
FastAPI
. Il est
bien con√ßu
,
simple √† utiliser
et
tr√®s √©volutif
. Il est devenu un
composant cl√©
dans notre strat√©gie de d√©veloppement API first et il est √† l'origine de nombreux automatismes et services tels que notre ing√©nieur virtuel TAC.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, le FastAPI des
CLI
Si vous souhaitez construire une application
CLI
utilisable dans un terminal au lieu d'une API web, regardez
Typer
.
Typer
est le petit fr√®re de FastAPI. Et il est destin√© √† √™tre le
FastAPI des
CLI
. ‚å®Ô∏è üöÄ
Pr√©requis
FastAPI repose sur les √©paules de g√©ants :
Starlette
pour les parties web.
Pydantic
pour les parties donn√©es.
Installation
fast ‚Üí
pip install fastapi
restart ‚Üª
Vous aurez √©galement besoin d'un serveur ASGI pour la production tel que
Uvicorn
ou
Hypercorn
.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
Exemple
Cr√©ez
Cr√©ez un fichier
main.py
avec :
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Ou utilisez
async def
...
Si votre code utilise
async
/
await
, utilisez
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Note
Si vous n'√™tes pas familier avec cette notion, consultez la section
"Vous √™tes press√©s ?"
√† propos de
async
et
await
dans la documentation
.
Lancez
Lancez le serveur avec :
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
√Ä propos de la commande
uvicorn main:app --reload
...
La commande
uvicorn main:app
fait r√©f√©rence √† :
main
: le fichier
main.py
(le "module" Python).
app
: l'objet cr√©√© √† l'int√©rieur de
main.py
avec la ligne
app = FastAPI()
.
--reload
: fait red√©marrer le serveur apr√®s des changements de code. √Ä n'utiliser que pour le d√©veloppement.
V√©rifiez
Ouvrez votre navigateur √† l'adresse
http://127.0.0.1:8000/items/5?q=somequery
.
Vous obtenez alors cette r√©ponse
JSON
:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Vous venez de cr√©er une API qui :
Re√ßoit les requ√™tes HTTP pour les
chemins
/
et
/items/{item_id}
.
Les deux
chemins
acceptent des
op√©rations
GET
(√©galement connu sous le nom de
m√©thodes
HTTP).
Le
chemin
/items/{item_id}
a un
param√®tre
item_id
qui doit √™tre un
int
.
Le
chemin
/items/{item_id}
a un
param√®tre de requ√™te
optionnel
q
de type
str
.
Documentation API interactive
Maintenant, rendez-vous sur
http://127.0.0.1:8000/docs
.
Vous verrez la documentation interactive automatique de l'API (fournie par
Swagger UI
) :
Documentation API alternative
Et maintenant, rendez-vous sur
http://127.0.0.1:8000/redoc
.
Vous verrez la documentation interactive automatique de l'API (fournie par
ReDoc
) :
Exemple plus pouss√©
Maintenant, modifiez le fichier
main.py
pour recevoir
le corps
d'une requ√™te
PUT
.
D√©clarez ce corps en utilisant les types Python standards, gr√¢ce √† Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Le serveur se recharge normalement automatiquement (car vous avez pens√© √†
--reload
dans la commande
uvicorn
ci-dessus).
Plus loin avec la documentation API interactive
Maintenant, rendez-vous sur
http://127.0.0.1:8000/docs
.
La documentation interactive de l'API sera automatiquement mise √† jour, y compris le nouveau corps de la requ√™te :
Cliquez sur le bouton "Try it out", il vous permet de renseigner les param√®tres et d'interagir directement avec l'API :
Cliquez ensuite sur le bouton "Execute", l'interface utilisateur communiquera avec votre API, enverra les param√®tres, obtiendra les r√©sultats et les affichera √† l'√©cran :
Plus loin avec la documentation API alternative
Et maintenant, rendez-vous sur
http://127.0.0.1:8000/redoc
.
La documentation alternative refl√©tera √©galement le nouveau param√®tre de requ√™te et le nouveau corps :
En r√©sum√©
En r√©sum√©, vous d√©clarez
une fois
les types de param√®tres,
le corps
de la requ√™te, etc. en tant que param√®tres de fonction.
Vous faites cela avec les types Python standard modernes.
Vous n'avez pas √† apprendre une nouvelle syntaxe, les m√©thodes ou les classes d'une biblioth√®que sp√©cifique, etc.
Juste du
Python
standard.
Par exemple, pour un
int
:
item_id
:
int
ou pour un mod√®le
Item
plus complexe :
item
:
Item
... et avec cette d√©claration unique, vous obtenez :
Une assistance dans votre IDE, notamment :
la compl√©tion.
la v√©rification des types.
La validation des donn√©es :
des erreurs automatiques et claires lorsque les donn√©es ne sont pas valides.
une validation m√™me pour les objets
JSON
profond√©ment imbriqu√©s.
Une conversion
des donn√©es d'entr√©e : venant du r√©seau et allant vers les donn√©es et types de Python, permettant de lire :
le
JSON
.
les param√®tres du chemin
.
les param√®tres de la requ√™te
.
les cookies.
les en-t√™tes
.
les formulaires
.
les fichiers
.
La conversion
des donn√©es de sortie : conversion des donn√©es et types Python en donn√©es r√©seau (au format
JSON
), permettant de convertir :
les types Python (
str
,
int
,
float
,
bool
,
list
, etc).
les objets
datetime
.
les objets
UUID
.
les mod√®les de base de donn√©es.
... et beaucoup plus.
La documentation API interactive automatique, avec 2 interfaces utilisateur au choix :
Swagger UI.
ReDoc.
Pour revenir √† l'exemple de code pr√©c√©dent,
FastAPI
permet de :
Valider que
item_id
existe dans le chemin des requ√™tes
GET
et
PUT
.
Valider que
item_id
est de type
int
pour les requ√™tes
GET
et
PUT
.
Si ce n'est pas le cas, le client voit une erreur utile et claire.
V√©rifier qu'il existe un param√®tre de requ√™te facultatif nomm√©
q
(comme dans
http://127.0.0.1:8000/items/foo?q=somequery
) pour les requ√™tes
GET
.
Puisque le param√®tre
q
est d√©clar√© avec
= None
, il est facultatif.
Sans le
None
, il serait n√©cessaire (comme l'est
le corps
de la requ√™te dans le cas du
PUT
).
Pour les requ√™tes
PUT
vers
/items/{item_id}
, de lire
le corps
en
JSON
:
V√©rifier qu'il a un attribut obligatoire
name
qui devrait √™tre un
str
.
V√©rifier qu'il a un attribut obligatoire
prix
qui doit √™tre un
float
.
V√©rifier qu'il a un attribut facultatif
is_offer
, qui devrait √™tre un
bool
, s'il est pr√©sent.
Tout cela fonctionnerait √©galement pour les objets
JSON
profond√©ment imbriqu√©s.
Convertir de et vers
JSON
automatiquement.
Documenter tout avec OpenAPI, qui peut √™tre utilis√© par :
Les syst√®mes de documentation interactifs.
Les syst√®mes de g√©n√©ration automatique de code client, pour de nombreuses langues.
Fournir directement 2 interfaces web de documentation interactive.
Nous n'avons fait qu'effleurer la surface, mais vous avez d√©j√† une id√©e de la fa√ßon dont tout cela fonctionne.
Essayez de changer la ligne contenant :
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
... de :
...
"item_name"
:
item
.
name
...
... vers :
...
"item_price"
:
item
.
price
...
... et voyez comment votre √©diteur compl√©tera automatiquement les attributs et conna√Ætra leurs types :
Pour un exemple plus complet comprenant plus de fonctionnalit√©s, voir le
Tutoriel - Guide utilisateur
.
Spoiler alert
: le tutoriel - guide utilisateur inclut :
D√©claration de
param√®tres
provenant d'autres endroits diff√©rents comme :
en-t√™tes
.
,
cookies
,
champs de formulaire
et
fichiers
.
L'utilisation de
contraintes de validation
comme
maximum_length
ou
regex
.
Un
syst√®me d'injection de d√©pendance
tr√®s puissant et facile √† utiliser .
S√©curit√© et authentification, y compris la prise en charge de
OAuth2
avec les
jetons
JWT
et l'authentification
HTTP Basic
.
Des techniques plus avanc√©es (mais tout aussi faciles) pour d√©clarer les
mod√®les
JSON
profond√©ment imbriqu√©s
(gr√¢ce √† Pydantic).
Int√©gration de
GraphQL
avec
Strawberry
et d'autres biblioth√®ques.
D'obtenir de nombreuses fonctionnalit√©s suppl√©mentaires (gr√¢ce √† Starlette) comme :
WebSockets
de tester le code tr√®s facilement avec
requests
et
pytest
CORS
Cookie Sessions
... et plus encore.
Performance
Les benchmarks TechEmpower ind√©pendants montrent que les applications
FastAPI
s'ex√©cutant sous Uvicorn sont
parmi les frameworks existants en Python les plus rapides
, juste derri√®re Starlette et Uvicorn (utilis√©s en interne par FastAPI). (*)
Pour en savoir plus, consultez la section
Benchmarks
.
D√©pendances facultatives
Utilis√©es par Pydantic:
email-validator
- pour la validation des adresses email.
Utilis√©es par Starlette :
requests
- Obligatoire si vous souhaitez utiliser
TestClient
.
jinja2
- Obligatoire si vous souhaitez utiliser la configuration de template par d√©faut.
python-multipart
- Obligatoire si vous souhaitez supporter le
"d√©codage"
de formulaire avec
request.form()
.
itsdangerous
- Obligatoire pour la prise en charge de
SessionMiddleware
.
pyyaml
- Obligatoire pour le support
SchemaGenerator
de Starlette (vous n'en avez probablement pas besoin avec FastAPI).
Utilis√©es par FastAPI / Starlette :
uvicorn
- Pour le serveur qui charge et sert votre application.
orjson
- Obligatoire si vous voulez utiliser
ORJSONResponse
.
ujson
- Obligatoire si vous souhaitez utiliser
UJSONResponse
.
Vous pouvez tout installer avec
pip install fastapi[all]
.
Licence
Ce projet est soumis aux termes de la licence MIT.

## 056_HE
FastAPI¬∂
---

FastAPI
◊™◊©◊™◊ô◊™ FastAPI, ◊ë◊ô◊¶◊ï◊¢◊ô◊ù ◊í◊ë◊ï◊î◊ô◊ù, ◊ß◊ú◊î ◊ú◊ú◊û◊ô◊ì◊î, ◊û◊î◊ô◊®◊î ◊ú◊™◊õ◊†◊ï◊™, ◊û◊ï◊õ◊†◊î ◊ú◊°◊ë◊ô◊ë◊™ ◊ô◊ô◊¶◊ï◊®
◊™◊ô◊¢◊ï◊ì
:
https://fastapi.tiangolo.com
◊ß◊ï◊ì
:
https://github.com/fastapi/fastapi
FastAPI ◊î◊ô◊ê ◊™◊©◊™◊ô◊™ ◊®◊©◊™ ◊û◊ï◊ì◊®◊†◊ô◊™ ◊ï◊û◊î◊ô◊®◊î (◊ë◊ô◊¶◊ï◊¢◊ô◊ù ◊í◊ë◊ï◊î◊ô◊ù) ◊ú◊ë◊†◊ô◊ô◊™ ◊û◊û◊©◊ß◊ô ◊™◊õ◊†◊ï◊™ ◊ô◊ô◊©◊ï◊û◊ô◊ù (API) ◊¢◊ù ◊§◊ô◊ô◊™◊ï◊ü 3.6+ ◊ë◊î◊™◊ë◊°◊° ◊¢◊ú ◊®◊û◊ñ◊ô ◊ò◊ô◊§◊ï◊°◊ô◊ù ◊°◊ò◊†◊ì◊®◊ò◊ô◊ô◊ù.
◊™◊õ◊ï◊†◊ï◊™ ◊î◊û◊§◊™◊ó ◊î◊ü:
◊û◊î◊ô◊®◊î
: ◊ë◊ô◊¶◊ï◊¢◊ô◊ù ◊í◊ë◊ï◊î◊ô◊ù ◊û◊ê◊ï◊ì, ◊ë◊ß◊†◊î ◊ê◊ó◊ì ◊¢◊ù NodeJS ◊ï - Go (◊™◊ï◊ì◊ï◊™ ◊ú - Starlette ◊ï - Pydantic).
◊ê◊ó◊™ ◊û◊™◊©◊™◊ô◊ï◊™ ◊î◊§◊ô◊ô◊™◊ï◊ü ◊î◊û◊î◊ô◊®◊ï◊™ ◊ë◊ô◊ï◊™◊®
.
◊û◊î◊ô◊®◊î ◊ú◊™◊õ◊†◊ï◊™
: ◊î◊í◊ë◊ô◊®◊ï ◊ê◊™ ◊û◊î◊ô◊®◊ï◊™ ◊§◊ô◊™◊ï◊ó ◊î◊™◊õ◊ï◊†◊ï◊™ ◊î◊ó◊ì◊©◊ï◊™ ◊ë◊õ - %200 ◊¢◊ì %300. *
◊§◊ó◊ï◊™ ◊©◊í◊ô◊ê◊ï◊™
: ◊û◊†◊¢◊ï ◊õ - %40 ◊û◊©◊í◊ô◊ê◊ï◊™ ◊ê◊†◊ï◊© (◊û◊§◊™◊ó◊ô◊ù). *
◊ê◊ô◊†◊ò◊ï◊ê◊ô◊ò◊ô◊ë◊ô◊™
: ◊™◊û◊ô◊õ◊™ ◊¢◊ï◊®◊ö ◊û◊¢◊ï◊ú◊î.
◊î◊©◊ú◊û◊î
◊ë◊õ◊ú ◊û◊ß◊ï◊ù. ◊§◊ó◊ï◊™ ◊ñ◊û◊ü ◊†◊ô◊§◊ï◊ô ◊©◊í◊ô◊ê◊ï◊™.
◊ß◊ú◊î
: ◊û◊™◊ï◊õ◊†◊†◊™ ◊ú◊î◊ô◊ï◊™ ◊ß◊ú◊î ◊ú◊©◊ô◊û◊ï◊© ◊ï◊ú◊ú◊û◊ô◊ì◊î. ◊§◊ó◊ï◊™ ◊ñ◊û◊ü ◊ß◊®◊ô◊ê◊™ ◊™◊ô◊¢◊ï◊ì.
◊ß◊¶◊®◊î
: ◊û◊ñ◊¢◊®◊ï ◊©◊õ◊§◊ï◊ú ◊ß◊ï◊ì. ◊û◊°◊§◊® ◊™◊õ◊ï◊†◊ï◊™ ◊û◊õ◊ú ◊î◊õ◊®◊ñ◊™ ◊§◊®◊û◊ò◊®. ◊§◊ó◊ï◊™ ◊©◊í◊ô◊ê◊ï◊™.
◊ó◊°◊ï◊†◊î
: ◊ß◊ë◊ú◊ï ◊ß◊ï◊ì ◊û◊ï◊õ◊ü ◊ú◊°◊ë◊ô◊ë◊™ ◊ô◊ô◊¶◊ï◊®. ◊¢◊ù ◊™◊ô◊¢◊ï◊ì ◊ê◊ô◊†◊ò◊®◊ß◊ò◊ô◊ë◊ô ◊ê◊ï◊ò◊ï◊û◊ò◊ô.
◊û◊ë◊ï◊°◊°◊™ ◊°◊ò◊†◊ì◊®◊ò◊ô◊ù
: ◊û◊ë◊ï◊°◊°◊™ ◊¢◊ú (◊ï◊™◊ï◊ê◊û◊™ ◊ú◊ó◊ú◊ï◊ò◊ô◊ü ◊ú -) ◊î◊°◊ò◊ì◊†◊®◊ò◊ô◊ù ◊î◊§◊™◊ï◊ó◊ô◊ù ◊ú◊û◊û◊©◊ß◊ô ◊™◊õ◊†◊ï◊™ ◊ô◊ô◊©◊ï◊û◊ô◊ù:
OpenAPI
(◊ô◊ì◊ï◊¢◊ô◊ù ◊ú◊©◊¢◊ë◊® ◊õ - Swagger) ◊ï -
JSON Schema
.
* ◊î◊¢◊®◊õ◊î ◊û◊ë◊ï◊°◊°◊™ ◊¢◊ú ◊ë◊ì◊ô◊ß◊ï◊™ ◊©◊ú ◊¶◊ï◊ï◊™ ◊§◊ô◊™◊ï◊ó ◊§◊†◊ô◊û◊ô ◊©◊ë◊ï◊†◊î ◊ê◊§◊ú◊ô◊ß◊¶◊ô◊ï◊™ ◊ë◊°◊ë◊ô◊ë◊™ ◊ô◊ô◊¶◊ï◊®.
◊†◊ï◊™◊†◊ô ◊ó◊°◊ï◊™
◊†◊ï◊™◊†◊ô ◊ó◊°◊ï◊™ ◊ê◊ó◊®◊ô◊ù
◊ì◊¢◊ï◊™
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I‚Äôm over the moon excited about
FastAPI
. It‚Äôs so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, ◊î - FastAPI ◊©◊ú ◊û◊û◊©◊ß◊ô ◊©◊ï◊®◊™ ◊§◊ß◊ï◊ì◊î (CLI).
◊ê◊ù ◊ê◊™◊ù ◊ë◊ï◊†◊ô◊ù ◊ê◊§◊ú◊ô◊ß◊¶◊ô◊ô◊™
CLI
◊ú◊©◊ô◊û◊ï◊© ◊ë◊û◊°◊ï◊£ ◊ë◊û◊ß◊ï◊ù ◊û◊û◊©◊ß ◊®◊©◊™, ◊î◊¢◊ô◊§◊ï ◊û◊ë◊ò ◊¢◊ú
Typer
.
Typer
◊î◊ô◊ê ◊ê◊ó◊ï◊™◊î ◊î◊ß◊ò◊†◊î ◊©◊ú FastAPI. ◊ï◊û◊ò◊®◊™◊î ◊î◊ô◊ê ◊ú◊î◊ô◊ï◊™ ◊î -
FastAPI ◊©◊ú ◊û◊û◊©◊ß◊ô ◊©◊ï◊®◊™ ◊§◊ß◊ï◊ì◊î
. ‚å®Ô∏è üöÄ
◊™◊ú◊ï◊ô◊ï◊™
◊§◊ô◊ô◊™◊ï◊ü 3.6+
FastAPI ◊¢◊ï◊û◊ì◊™ ◊¢◊ú ◊õ◊™◊§◊ô ◊¢◊†◊ß◊ô◊ï◊™:
Starlette
◊ú◊ó◊ú◊ß◊ô ◊î◊®◊©◊™.
Pydantic
◊ú◊ó◊ú◊ß◊ô ◊î◊û◊ô◊ì◊¢.
◊î◊™◊ß◊†◊î
fast ‚Üí
pip install fastapi
restart ‚Üª
◊™◊¶◊ò◊®◊õ◊ï ◊í◊ù ◊©◊®◊™ ASGI ◊õ◊í◊ï◊ü
Uvicorn
◊ê◊ï
Hypercorn
.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
◊ì◊ï◊í◊û◊ê
◊¶◊®◊ï ◊ê◊ï◊™◊î
◊¶◊®◊ï ◊ß◊ï◊ë◊• ◊ë◊©◊ù
main.py
◊¢◊ù:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
◊ê◊ï ◊î◊©◊™◊û◊©◊ï ◊ë -
async def
...
◊ê◊ù ◊î◊ß◊ï◊ì ◊©◊ú◊õ◊ù ◊û◊©◊™◊û◊© ◊ë -
async
/
await
, ◊î◊©◊™◊û◊©◊ï ◊ë -
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
◊©◊ô◊û◊ï ◊ú◊ë
:
◊ê◊ù ◊ê◊ô◊†◊õ◊ù ◊ô◊ï◊ì◊¢◊ô◊ù, ◊ë◊ì◊ß◊ï ◊ê◊™ ◊§◊®◊ß "◊û◊û◊î◊®◊ô◊ù?" ◊¢◊ú
async
◊ï -
await
◊ë◊™◊ô◊¢◊ï◊ì
.
◊î◊®◊ô◊¶◊ï ◊ê◊ï◊™◊î
◊î◊™◊ó◊ô◊ú◊ï ◊ê◊™ ◊î◊©◊®◊™ ◊¢◊ù:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
◊¢◊ú ◊î◊§◊ß◊ï◊ì◊î
uvicorn main:app --reload
...
◊î◊§◊ß◊ï◊ì◊î
uvicorn main:app
◊û◊™◊ô◊ô◊ó◊°◊™ ◊ú:
main
: ◊î◊ß◊ï◊ë◊•
main.py
(◊û◊ï◊ì◊ï◊ú ◊§◊ô◊ô◊™◊ï◊ü).
app
: ◊î◊ê◊ï◊ë◊ô◊ô◊ß◊ò ◊©◊†◊ï◊¶◊® ◊ë◊™◊ï◊ö
main.py
◊¢◊ù ◊î◊©◊ï◊®◊î
app = FastAPI()
.
--reload
: ◊í◊®◊û◊ï ◊ú◊©◊®◊™ ◊ú◊î◊™◊ê◊™◊ó◊ú ◊ú◊ê◊ó◊® ◊©◊ô◊†◊ï◊ô◊ô◊ù ◊ë◊ß◊ï◊ì. ◊¢◊©◊ï ◊ñ◊ê◊™ ◊®◊ß ◊ë◊°◊ë◊ô◊ë◊™ ◊§◊ô◊™◊ï◊ó.
◊ë◊ì◊ß◊ï ◊ê◊ï◊™◊î
◊§◊™◊ó◊ï ◊ê◊™ ◊î◊ì◊§◊ì◊§◊ü ◊©◊ú◊õ◊ù ◊ë◊õ◊™◊ï◊ë◊™
http://127.0.0.1:8000/items/5?q=somequery
.
◊ê◊™◊ù ◊™◊®◊ê◊ï ◊™◊í◊ï◊ë◊™ JSON:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
◊õ◊ë◊® ◊ô◊¶◊®◊™◊ù API ◊©:
◊û◊ß◊ë◊ú ◊ë◊ß◊©◊ï◊™ HTTP ◊ë◊†◊™◊ô◊ë◊ô◊ù
/
◊ï -
/items/{item_id}
.
◊©◊†◊ô ◊î
◊†◊™◊ô◊ë◊ô◊ù
◊û◊ß◊ë◊ú◊ô◊ù
◊ë◊ß◊©◊ï◊™
GET
(◊ô◊ì◊ï◊¢◊ï◊™ ◊í◊ù ◊õ
◊û◊™◊ï◊ì◊ï◊™
HTTP).
◊î
◊†◊™◊ô◊ë
/items/{item_id}
◊õ◊ï◊ú◊ú *◊§◊®◊û◊ò◊® ◊†◊™◊ô◊ë_
item_id
◊©◊ê◊û◊ï◊® ◊ú◊î◊ô◊ï◊™
int
.
◊î
◊†◊™◊ô◊ë
/items/{item_id}
*◊§◊®◊û◊ò◊® ◊©◊ê◊ô◊ú◊™◊ê_ ◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô
q
.
◊™◊ô◊¢◊ï◊ì API ◊ê◊ô◊†◊ò◊®◊ß◊ò◊ô◊ë◊ô
◊õ◊¢◊™ ◊§◊†◊ï ◊ú◊õ◊™◊ï◊ë◊™
http://127.0.0.1:8000/docs
.
◊ê◊™◊ù ◊™◊®◊ê◊ï ◊ê◊™ ◊î◊™◊ô◊¢◊ï◊ì ◊î◊ê◊ï◊ò◊ï◊û◊ò◊ô (◊û◊°◊ï◊§◊ß ◊¢◊ú ◊ô◊ì◊ô
Swagger UI
):
◊™◊ô◊¢◊ï◊ì ◊ê◊ú◊ò◊®◊†◊ò◊ô◊ë◊ô
◊õ◊¢◊™ ◊§◊†◊ï ◊ú◊õ◊™◊ï◊ë◊™
http://127.0.0.1:8000/redoc
.
◊ê◊™◊ù ◊™◊®◊ê◊ï ◊™◊ô◊¢◊ï◊ì ◊ê◊ú◊ò◊®◊†◊ò◊ô◊ë◊ô (◊û◊°◊ï◊§◊ß ◊¢◊ú ◊ô◊ì◊ô
ReDoc
):
◊©◊ì◊®◊ï◊í ◊ú◊ì◊ï◊í◊û◊ê
◊õ◊¢◊™ ◊¢◊®◊õ◊ï ◊ê◊™ ◊î◊ß◊ï◊ë◊•
main.py
◊õ◊ö ◊©◊ô◊ï◊õ◊ú ◊ú◊ß◊ë◊ú ◊í◊ï◊£ ◊û◊ë◊ß◊©◊™
PUT
.
◊î◊í◊ì◊ô◊®◊ï ◊ê◊™ ◊î◊í◊ï◊£ ◊ë◊¢◊ñ◊®◊™ ◊®◊û◊ñ◊ô ◊ò◊ô◊§◊ï◊°◊ô◊ù ◊°◊ò◊†◊ì◊®◊ò◊ô◊ô◊ù, ◊î◊ï◊ì◊ï◊™ ◊ú -
Pydantic
.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
◊î◊©◊®◊™ ◊ê◊û◊ï◊ú ◊ú◊î◊™◊ê◊™◊ó◊ú ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ (◊û◊ê◊ó◊® ◊ï◊î◊ï◊°◊§◊™◊ù
--reload
◊ú◊§◊ß◊ï◊ì◊™
uvicorn
◊©◊ú◊û◊¢◊ú◊î).
◊©◊ì◊®◊ï◊í ◊î◊™◊ô◊¢◊ï◊ì ◊î◊ê◊ô◊†◊ò◊®◊ß◊ò◊ô◊ë◊ô
◊õ◊¢◊™ ◊§◊†◊ï ◊ú◊õ◊™◊ï◊ë◊™
http://127.0.0.1:8000/docs
.
◊î◊™◊ô◊¢◊ï◊ì ◊î◊ê◊ï◊ò◊ï◊û◊ò◊ô ◊ô◊™◊¢◊ì◊õ◊ü, ◊õ◊ï◊ú◊ú ◊î◊í◊ï◊£ ◊î◊ó◊ì◊©:
◊ú◊ó◊¶◊ï ◊¢◊ú ◊î◊õ◊§◊™◊ï◊® "Try it out", ◊î◊ï◊ê ◊ô◊ê◊§◊©◊® ◊ú◊õ◊ù ◊ú◊û◊ú◊ê ◊ê◊™ ◊î◊§◊®◊û◊ò◊®◊ô◊ù ◊ï◊ú◊¢◊ë◊ï◊ì ◊ô◊©◊ô◊®◊ï◊™ ◊û◊ï◊ú ◊î - API.
◊ê◊ó◊® ◊õ◊ö ◊ú◊ó◊¶◊ï ◊¢◊ú ◊î◊õ◊§◊™◊ï◊® "Execute", ◊î◊ê◊™◊® ◊ô◊™◊ß◊©◊® ◊¢◊ù ◊î - API ◊©◊ú◊õ◊ù, ◊ô◊©◊ú◊ó ◊ê◊™ ◊î◊§◊®◊û◊ò◊®◊ô◊ù, ◊ô◊©◊ô◊í ◊ê◊™ ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊ï◊ê◊ñ ◊ô◊®◊ê◊î ◊ê◊ï◊™◊ü ◊¢◊ú ◊î◊û◊°◊ö:
◊©◊ì◊®◊ï◊í ◊î◊™◊ô◊¢◊ï◊ì ◊î◊ê◊ú◊ò◊®◊†◊ò◊ô◊ë◊ô
◊õ◊¢◊™ ◊§◊†◊ï ◊ú◊õ◊™◊ï◊ë◊™
http://127.0.0.1:8000/redoc
.
◊î◊™◊ô◊¢◊ï◊ì ◊î◊ê◊ú◊ò◊®◊†◊ò◊ô◊ë◊ô ◊í◊ù ◊ô◊®◊ê◊î ◊ê◊™ ◊§◊®◊û◊ò◊® ◊î◊©◊ê◊ô◊ú◊™◊ê ◊ï◊î◊í◊ï◊£ ◊î◊ó◊ì◊©◊ô◊ù.
◊°◊ô◊õ◊ï◊ù
◊ú◊°◊ô◊õ◊ï◊ù, ◊ê◊™◊ù ◊û◊õ◊®◊ô◊ñ◊ô◊ù ** ◊§◊¢◊ù ◊ê◊ó◊™** ◊¢◊ú ◊ò◊ô◊§◊ï◊°◊ô ◊î◊§◊®◊û◊ò◊®◊ô◊ù, ◊í◊ï◊£ ◊ï◊õ◊ï' ◊õ◊§◊®◊û◊ò◊®◊ô◊ù ◊ú◊§◊ï◊†◊ß◊¶◊ô◊î.
◊ê◊™◊ù ◊¢◊ï◊©◊ô◊ù ◊ê◊™ ◊ñ◊î ◊¢◊ù ◊ò◊ô◊§◊ï◊°◊ô ◊§◊ô◊ô◊™◊ï◊ü ◊û◊ï◊ì◊®◊†◊ô◊ô◊ù.
◊ê◊™◊ù ◊ú◊ê ◊¶◊®◊ô◊õ◊ô◊ù ◊ú◊ú◊û◊ï◊ì ◊™◊ó◊ë◊ô◊® ◊ó◊ì◊©, ◊û◊™◊ï◊ì◊ï◊™ ◊ê◊ï ◊û◊ó◊ú◊ß◊ï◊™ ◊©◊ú ◊°◊§◊®◊ô◊ô◊î ◊°◊§◊ô◊¶◊ô◊§◊ô◊™, ◊ï◊õ◊ï'
◊®◊ß
◊§◊ô◊ô◊™◊ï◊ü 3.6+
◊°◊ò◊†◊ì◊®◊ò◊ô.
◊ú◊ì◊ï◊í◊û◊ê, ◊ú -
int
:
item_id
:
int
◊ê◊ï ◊ú◊û◊ï◊ì◊ú
Item
◊û◊ï◊®◊õ◊ë ◊ô◊ï◊™◊®:
item
:
Item
...◊ï◊¢◊ù ◊î◊õ◊®◊ñ◊™ ◊î◊ò◊ô◊§◊ï◊° ◊î◊ê◊ó◊™ ◊î◊ñ◊ï ◊ê◊™◊ù ◊û◊ß◊ë◊ú◊ô◊ù:
◊™◊û◊ô◊õ◊™ ◊¢◊ï◊®◊ö, ◊õ◊ï◊ú◊ú:
◊î◊©◊ú◊û◊ï◊™.
◊ë◊ì◊ô◊ß◊™ ◊ò◊ô◊§◊ï◊°◊ô◊ù.
◊ê◊ô◊û◊ï◊™ ◊û◊ô◊ì◊¢:
◊©◊í◊ô◊ê◊ï◊™ ◊ë◊®◊ï◊®◊ï◊™ ◊ï◊ê◊ò◊ï◊û◊ò◊ô◊ï◊™ ◊õ◊ê◊©◊® ◊û◊ï◊õ◊†◊° ◊û◊ô◊ì◊¢ ◊ú◊ê ◊ó◊ï◊ß◊ô .
◊ê◊ô◊û◊ï◊™ ◊ê◊§◊ô◊ú◊ï ◊ú◊ê◊ï◊ë◊ô◊ô◊ß◊ò◊ô JSON ◊û◊ß◊ï◊†◊†◊ô◊ù.
◊î◊û◊®◊î
◊©◊ú ◊û◊ô◊ì◊¢ ◊ß◊ú◊ò: ◊î◊û◊®◊î ◊©◊ú ◊û◊ô◊ì◊¢ ◊©◊û◊í◊ô◊¢ ◊û◊î◊®◊©◊™ ◊ú◊û◊ô◊ì◊¢ ◊ï◊ò◊ô◊§◊ï◊°◊ô◊ù ◊©◊ú ◊§◊ô◊ô◊™◊ï◊ü. ◊ß◊ï◊®◊ê ◊û:
JSON.
◊§◊®◊û◊ò◊®◊ô ◊†◊™◊ô◊ë.
◊§◊®◊û◊ò◊®◊ô ◊©◊ê◊ô◊ú◊™◊ê.
◊¢◊ï◊í◊ô◊ï◊™.
◊õ◊ï◊™◊®◊ï◊™.
◊ò◊§◊°◊ô◊ù.
◊ß◊ë◊¶◊ô◊ù.
◊î◊û◊®◊î
◊©◊ú ◊û◊ô◊ì◊¢ ◊§◊ú◊ò: ◊î◊û◊®◊î ◊©◊ú ◊û◊ô◊ì◊¢ ◊ï◊ò◊ô◊§◊ï◊°◊ô◊ù ◊û◊§◊ô◊ô◊™◊ï◊ü ◊ú◊û◊ô◊ì◊¢ ◊®◊©◊™ (◊õ - JSON):
◊î◊û◊ô◊®◊ï ◊ò◊ô◊§◊ï◊°◊ô ◊§◊ô◊ô◊™◊ï◊ü (
str
,
int
,
float
,
bool
,
list
, etc).
◊¢◊¶◊û◊ô
datetime
.
◊¢◊¶◊û◊ô
UUID
.
◊û◊ï◊ì◊ú◊ô ◊ë◊°◊ô◊°◊ô ◊†◊™◊ï◊†◊ô◊ù.
...◊ï◊®◊ë◊ô◊ù ◊ê◊ó◊®◊ô◊ù.
◊™◊ô◊¢◊ï◊ì API ◊ê◊ï◊ò◊ï◊û◊ò◊ô ◊ï◊ê◊ô◊†◊ò◊®◊ß◊ò◊ô◊ë◊ô◊™ ◊õ◊ï◊ú◊ú ◊©◊™◊ô ◊ê◊ú◊ò◊®◊†◊ò◊ô◊ë◊ï◊™ ◊ú◊û◊û◊©◊ß ◊î◊û◊©◊™◊û◊©:
Swagger UI.
ReDoc.
◊ë◊ó◊ñ◊®◊î ◊ú◊ì◊ï◊í◊û◊ê◊™ ◊î◊ß◊ï◊ì ◊î◊ß◊ï◊ì◊û◊™,
FastAPI
◊ô◊ì◊ê◊í:
◊ú◊ê◊û◊™ ◊©◊ô◊©
item_id
◊ë◊†◊™◊ô◊ë ◊ë◊ë◊ß◊©◊ï◊™
GET
◊ï -
PUT
.
◊ú◊ê◊û◊™ ◊©◊î -
item_id
◊î◊ï◊ê ◊û◊ò◊ô◊§◊ï◊°
int
◊ë◊ë◊ß◊©◊ï◊™
GET
◊ï -
PUT
.
◊ê◊ù ◊î◊ï◊ê ◊ú◊ê, ◊î◊ú◊ß◊ï◊ó ◊ô◊®◊ê◊î ◊©◊í◊ô◊ê◊î ◊ë◊®◊ï◊®◊î ◊ï◊©◊ô◊û◊ï◊©◊ô◊™.
◊ú◊ë◊ì◊ï◊ß ◊î◊ê◊ù ◊ß◊ô◊ô◊ù ◊§◊®◊û◊ò◊® ◊©◊ê◊ô◊ú◊™◊ê ◊ë◊©◊ù
q
(◊ß◊®◊ô
http://127.0.0.1:8000/items/foo?q=somequery
) ◊ú◊ë◊ß◊©◊ï◊™
GET
.
◊û◊ê◊ó◊® ◊ï◊î◊§◊®◊û◊ò◊®
q
◊û◊ï◊í◊ì◊® ◊¢◊ù
= None
, ◊î◊ï◊ê ◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô.
◊ú◊ï◊ú◊ê ◊î -
None
◊î◊ï◊ê ◊î◊ô◊î ◊ó◊ï◊ë◊î (◊õ◊û◊ï ◊î◊í◊ï◊£ ◊ë◊û◊ß◊®◊î ◊©◊ú
PUT
).
◊ú◊ë◊ß◊©◊ï◊™
PUT
◊ú◊†◊™◊ô◊ë
/items/{item_id}
, ◊ú◊ß◊®◊ï◊ê ◊ê◊™ ◊í◊ï◊£ ◊î◊ë◊ß◊©◊î ◊õ - JSON:
◊ú◊ê◊û◊™ ◊©◊î◊ï◊ê ◊õ◊ï◊ú◊ú ◊ê◊™ ◊û◊ê◊§◊ô◊ô◊ü ◊î◊ó◊ï◊ë◊î
name
◊©◊ê◊û◊ï◊® ◊ú◊î◊ô◊ï◊™ ◊û◊ò◊ô◊§◊ï◊°
str
.
◊ú◊ê◊û◊™ ◊©◊î◊ï◊ê ◊õ◊ï◊ú◊ú ◊ê◊™ ◊û◊ê◊§◊ô◊ô◊ü ◊î◊ó◊ï◊ë◊î
price
◊©◊ó◊ô◊ô◊ë ◊ú◊î◊ô◊ï◊™ ◊û◊ò◊ô◊§◊ï◊°
float
.
◊ú◊ë◊ì◊ï◊ß ◊î◊ê◊ù ◊î◊ï◊ê ◊õ◊ï◊ú◊ú ◊ê◊™ ◊û◊ê◊§◊ô◊ô◊ü ◊î◊®◊©◊ï◊™
is_offer
◊©◊ê◊û◊ï◊® ◊ú◊î◊ô◊ï◊™ ◊û◊ò◊ô◊§◊ï◊°
bool
, ◊ê◊ù ◊î◊ï◊ê ◊†◊û◊¶◊ê.
◊õ◊ú ◊ñ◊î ◊ô◊¢◊ë◊ï◊ì ◊í◊ù ◊ú◊ê◊ï◊ë◊ô◊ô◊ß◊ò JSON ◊û◊ß◊ï◊†◊ü.
◊ú◊î◊û◊ô◊® ◊û - JSON ◊ï◊ú- JSON ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™.
◊ú◊™◊¢◊ì ◊î◊õ◊ú ◊ë◊ê◊û◊¶◊¢◊ï◊™ OpenAPI, ◊™◊ô◊¢◊ï◊ì ◊©◊ë◊ï ◊ô◊ï◊õ◊ú◊ï ◊ú◊î◊©◊™◊û◊©:
◊û◊¢◊®◊õ◊ï◊™ ◊™◊ô◊¢◊ï◊ì ◊ê◊ô◊†◊ò◊®◊ß◊ò◊ô◊ë◊ô◊ï◊™.
◊û◊¢◊®◊õ◊ï◊™ ◊ô◊ô◊¶◊ï◊® ◊ß◊ï◊ì ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊ï◊™, ◊ú◊î◊®◊ë◊î ◊©◊§◊ï◊™.
◊ú◊°◊§◊ß ◊ô◊©◊ô◊®◊ï◊™ ◊©◊™◊ô ◊û◊¢◊®◊õ◊ï◊™ ◊™◊ô◊¢◊ï◊ì ◊®◊©◊™◊ô◊ï◊™.
◊®◊ß ◊í◊®◊ì◊†◊ï ◊ê◊™ ◊ß◊¶◊î ◊î◊ß◊®◊ó◊ï◊ü, ◊ê◊ë◊ú ◊õ◊ë◊® ◊ô◊© ◊ú◊õ◊ù ◊®◊¢◊ô◊ï◊ü ◊©◊ú ◊ê◊ô◊ö ◊î◊õ◊ú ◊¢◊ï◊ë◊ì.
◊†◊°◊ï ◊ú◊©◊†◊ï◊™ ◊ê◊™ ◊î◊©◊ï◊®◊î:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...◊û:
...
"item_name"
:
item
.
name
...
...◊ú:
...
"item_price"
:
item
.
price
...
...◊ï◊®◊ê◊ï ◊ê◊ô◊ö ◊î◊¢◊ï◊®◊ö ◊©◊ú◊õ◊ù ◊û◊©◊ú◊ô◊ù ◊ê◊™ ◊î◊û◊ê◊§◊ô◊ô◊†◊ô◊ù ◊ï◊ô◊ï◊ì◊¢ ◊ê◊™ ◊î◊ò◊ô◊§◊ï◊°◊ô◊ù ◊©◊ú◊î◊ù:
◊ú◊ì◊ï◊í◊û◊ê ◊ô◊ï◊™◊® ◊©◊ú◊û◊î ◊©◊õ◊ï◊ú◊ú◊™ ◊¢◊ï◊ì ◊™◊õ◊ï◊†◊ï◊™, ◊®◊ê◊ï ◊ê◊™ ◊î
◊û◊ì◊®◊ô◊ö - ◊ú◊û◊©◊™◊û◊©
.
◊î◊™◊®◊ê◊™ ◊°◊§◊ï◊ô◊ú◊®◊ô◊ù
: ◊î◊û◊ì◊®◊ô◊ö - ◊ú◊û◊©◊™◊û◊© ◊õ◊ï◊ú◊ú:
◊î◊õ◊®◊ñ◊î ◊¢◊ú
◊§◊®◊û◊ò◊®◊ô◊ù
◊û◊û◊ß◊ï◊®◊ï◊™ ◊ê◊ó◊®◊ô◊ù ◊ï◊©◊ï◊†◊ô◊ù ◊õ◊í◊ï◊ü:
◊õ◊ï◊™◊®◊ï◊™
,
◊¢◊ï◊í◊ô◊ï◊™
,
◊ò◊§◊°◊ô◊ù
◊ï -
◊ß◊ë◊¶◊ô◊ù
.
◊ê◊ô◊ö ◊ú◊ß◊ë◊ï◊¢
◊û◊í◊ë◊ú◊ï◊™ ◊ê◊ô◊û◊ï◊™
◊ë◊¢◊ñ◊®◊™
maximum_length
◊ê◊ï
regex
.
◊ì◊®◊ö ◊ó◊ñ◊ß◊î ◊ï◊ß◊ú◊î ◊ú◊î◊©◊™◊û◊© ◊ë
◊î◊ñ◊®◊ß◊™ ◊™◊ú◊ï◊ô◊ï◊™
.
◊ê◊ë◊ò◊ó◊î ◊ï◊î◊™◊ê◊û◊™◊ï◊™, ◊õ◊ï◊ú◊ú ◊™◊û◊ô◊õ◊î ◊ë -
OAuth2
◊¢◊ù
JWT
◊ï◊î◊™◊ê◊û◊™◊ï◊™
HTTP Basic
.
◊ò◊õ◊†◊ô◊ß◊ï◊™ ◊û◊™◊ß◊ì◊û◊ï◊™ (◊ê◊ë◊ú ◊ß◊ú◊ï◊™ ◊ë◊ê◊ï◊™◊î ◊û◊ô◊ì◊î) ◊ú◊î◊õ◊®◊ñ◊™ ◊ê◊ï◊ë◊ô◊ô◊ß◊ò◊ô JSON ◊û◊ß◊ï◊†◊†◊ô◊ù (◊™◊ï◊ì◊ï◊™ ◊ú - Pydantic).
◊ê◊ô◊†◊ò◊®◊ß◊¶◊ô◊î ◊¢◊ù
GraphQL
◊ì◊®◊ö
Strawberry
◊ï◊°◊§◊®◊ô◊ï◊™ ◊ê◊ó◊®◊ï◊™.
◊™◊õ◊ï◊†◊ï◊™ ◊†◊ï◊°◊§◊ï◊™ ◊®◊ë◊ï◊™ (◊™◊ï◊ì◊ï◊™ ◊ú - Starlette) ◊õ◊í◊ï◊ü:
WebSockets
◊ë◊ì◊ô◊ß◊ï◊™ ◊ß◊ú◊ï◊™ ◊ë◊û◊ô◊ï◊ó◊ì ◊û◊ë◊ï◊°◊°◊ï◊™ ◊¢◊ú
requests
◊ï -
pytest
CORS
Cookie Sessions
...◊ï◊¢◊ï◊ì.
◊ë◊ô◊¶◊ï◊¢◊ô◊ù
◊ë◊ì◊ô◊ß◊ï◊™ ◊¢◊¶◊û◊ê◊ô◊ï◊™ ◊©◊ú TechEmpower ◊î◊®◊ê◊ï ◊©◊ê◊§◊ú◊ô◊ß◊¶◊ô◊ï◊™
FastAPI
◊©◊®◊¶◊ï◊™ ◊™◊ó◊™ Uvicorn ◊î◊ü
◊û◊™◊©◊™◊ô◊ï◊™ ◊î◊§◊ô◊ô◊™◊ï◊ü ◊î◊û◊î◊ô◊®◊ï◊™ ◊ë◊ô◊ï◊™◊®
, ◊®◊ß ◊û◊™◊ó◊™ ◊ú - Starlette ◊ï - Uvicorn ◊¢◊¶◊û◊ü (◊© - FastAPI ◊û◊ë◊ï◊°◊°◊™ ◊¢◊ú◊ô◊î◊ü). (*)
◊õ◊ì◊ô ◊ú◊î◊ë◊ô◊ü ◊¢◊ï◊ì ◊¢◊ú ◊î◊†◊ï◊©◊ê, ◊®◊ê◊ï ◊ê◊™ ◊î◊§◊®◊ß
Benchmarks
.
◊™◊ú◊ï◊ô◊ï◊™ ◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô◊ï◊™
◊ë◊©◊ô◊û◊ï◊© Pydantic:
email-validator
- ◊ú◊ê◊ô◊û◊ï◊™ ◊õ◊™◊ï◊ë◊ï◊™ ◊ê◊ô◊û◊ô◊ô◊ú.
◊ë◊©◊ô◊û◊ï◊© Starlette:
httpx
- ◊ì◊®◊ï◊© ◊ê◊ù ◊ë◊®◊¶◊ï◊†◊õ◊ù ◊ú◊î◊©◊™◊û◊© ◊ë -
TestClient
.
jinja2
- ◊ì◊®◊ï◊© ◊ê◊ù ◊ë◊®◊¶◊ï◊†◊õ◊ù ◊ú◊î◊©◊™◊û◊© ◊ë◊ë◊®◊ô◊®◊™ ◊î◊û◊ó◊ì◊ú ◊©◊ú ◊™◊¶◊ï◊®◊™ ◊î◊ò◊û◊§◊ú◊ô◊ô◊ò◊ô◊ù.
python-multipart
- ◊ì◊®◊ï◊© ◊ê◊ù ◊ë◊®◊¶◊ï◊†◊õ◊ù ◊ú◊™◊û◊ï◊ö ◊ë
"◊§◊®◊°◊ï◊®"
◊ò◊§◊°◊ô◊ù, ◊ë◊ê◊¶◊û◊¢◊ï◊™
request.form()
.
itsdangerous
- ◊ì◊®◊ï◊© ◊ê◊ù ◊ë◊®◊¶◊ï◊†◊õ◊ù ◊ú◊î◊©◊™◊û◊© ◊ë -
SessionMiddleware
.
pyyaml
- ◊ì◊®◊ï◊© ◊ê◊ù ◊ë◊®◊¶◊ï◊†◊õ◊ù ◊ú◊î◊©◊™◊û◊© ◊ë -
SchemaGenerator
◊©◊ú Starlette (◊õ◊†◊®◊ê◊î ◊©◊ê◊™◊ù ◊ú◊ê ◊¶◊®◊ô◊õ◊ô◊ù ◊ê◊™ ◊ñ◊î ◊¢◊ù FastAPI).
◊ë◊©◊ô◊û◊ï◊© FastAPI / Starlette:
uvicorn
- ◊ú◊©◊®◊™ ◊©◊ò◊ï◊¢◊ü ◊ï◊û◊í◊ô◊© ◊ê◊™ ◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î ◊©◊ú◊õ◊ù.
orjson
- ◊ì◊®◊ï◊© ◊ê◊ù ◊ë◊®◊¶◊ï◊†◊õ◊ù ◊ú◊î◊©◊™◊û◊© ◊ë -
ORJSONResponse
.
ujson
- ◊ì◊®◊ï◊© ◊ê◊ù ◊ë◊®◊¶◊ï◊†◊õ◊ù ◊ú◊î◊©◊™◊û◊© ◊ë -
UJSONResponse
.
◊™◊ï◊õ◊ú◊ï ◊ú◊î◊™◊ß◊ô◊ü ◊ê◊™ ◊õ◊ú ◊ê◊ú◊ï ◊ë◊ê◊û◊¶◊¢◊ï◊™
pip install "fastapi[all]"
.
◊®◊©◊ô◊ï◊ü
◊î◊§◊®◊ï◊ô◊ß◊ò ◊î◊ñ◊î ◊î◊ï◊ê ◊™◊ó◊™ ◊î◊™◊†◊ê◊ô◊ù ◊©◊ú ◊®◊©◊ô◊ï◊ü MIT.

## 057_HELP_FASTAPI
Help FastAPI - Get Help¬∂
---

Help FastAPI - Get Help
Do you like
FastAPI
?
Would you like to help FastAPI, other users, and the author?
Or would you like to get help with
FastAPI
?
There are very simple ways to help (several involve just one or two clicks).
And there are several ways to get help too.
Subscribe to the newsletter
You can subscribe to the (infrequent)
FastAPI and friends
newsletter
to stay updated about:
News about FastAPI and friends üöÄ
Guides üìù
Features ‚ú®
Breaking changes üö®
Tips and tricks ‚úÖ
Follow FastAPI on Twitter
Follow @fastapi on
Twitter
to get the latest news about
FastAPI
. üê¶
Star
FastAPI
in GitHub
You can "star" FastAPI in GitHub (clicking the star button at the top right):
https://github.com/fastapi/fastapi
. ‚≠êÔ∏è
By adding a star, other users will be able to find it more easily and see that it has been already useful for others.
Watch the GitHub repository for releases
You can "watch" FastAPI in GitHub (clicking the "watch" button at the top right):
https://github.com/fastapi/fastapi
. üëÄ
There you can select "Releases only".
By doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of
FastAPI
with bug fixes and new features.
Connect with the author
You can connect with
me (Sebasti√°n Ram√≠rez /
tiangolo
)
, the author.
You can:
Follow me on
GitHub
.
See other Open Source projects I have created that could help you.
Follow me to see when I create a new Open Source project.
Follow me on
Twitter
or
Mastodon
.
Tell me how you use FastAPI (I love to hear that).
Hear when I make announcements or release new tools.
You can also
follow @fastapi on Twitter
(a separate account).
Follow me on
LinkedIn
.
Hear when I make announcements or release new tools (although I use Twitter more often ü§∑‚Äç‚ôÇ).
Read what I write (or follow me) on
Dev.to
or
Medium
.
Read other ideas, articles, and read about tools I have created.
Follow me to read when I publish something new.
Tweet about
FastAPI
Tweet about
FastAPI
and let me and others know why you like it. üéâ
I love to hear about how
FastAPI
is being used, what you have liked in it, in which project/company are you using it, etc.
Vote for FastAPI
Vote for
FastAPI
in Slant
.
Vote for
FastAPI
in AlternativeTo
.
Say you use
FastAPI
on StackShare
.
Help others with questions in GitHub
You can try and help others with their questions in:
GitHub Discussions
GitHub Issues
In many cases you might already know the answer for those questions. ü§ì
If you are helping a lot of people with their questions, you will become an official
FastAPI Expert
. üéâ
Just remember, the most important point is: try to be kind. People come with their frustrations and in many cases don't ask in the best way, but try as best as you can to be kind. ü§ó
The idea is for the
FastAPI
community to be kind and welcoming. At the same time, don't accept bullying or disrespectful behavior towards others. We have to take care of each other.
Here's how to help others with questions (in discussions or issues):
Understand the question
Check if you can understand what is the
purpose
and use case of the person asking.
Then check if the question (the vast majority are questions) is
clear
.
In many cases the question asked is about an imaginary solution from the user, but there might be a
better
one. If you can understand the problem and use case better, you might be able to suggest a better
alternative solution
.
If you can't understand the question, ask for more
details
.
Reproduce the problem
For most of the cases and most of the questions there's something related to the person's
original code
.
In many cases they will only copy a fragment of the code, but that's not enough to
reproduce the problem
.
You can ask them to provide a
minimal, reproducible, example
, that you can
copy-paste
and run locally to see the same error or behavior they are seeing, or to understand their use case better.
If you are feeling too generous, you can try to
create an example
like that yourself, just based on the description of the problem. Just keep in mind that this might take a lot of time and it might be better to ask them to clarify the problem first.
Suggest solutions
After being able to understand the question, you can give them a possible
answer
.
In many cases, it's better to understand their
underlying problem or use case
, because there might be a better way to solve it than what they are trying to do.
Ask to close
If they reply, there's a high chance you would have solved their problem, congrats,
you're a hero
! ü¶∏
Now, if that solved their problem, you can ask them to:
In GitHub Discussions: mark the comment as the
answer
.
In GitHub Issues:
close
the issue.
Watch the GitHub repository
You can "watch" FastAPI in GitHub (clicking the "watch" button at the top right):
https://github.com/fastapi/fastapi
. üëÄ
If you select "Watching" instead of "Releases only" you will receive notifications when someone creates a new issue or question. You can also specify that you only want to be notified about new issues, or discussions, or PRs, etc.
Then you can try and help them solve those questions.
Ask Questions
You can
create a new question
in the GitHub repository, for example to:
Ask a
question
or ask about a
problem
.
Suggest a new
feature
.
Note
: if you do it, then I'm going to ask you to also help others. üòâ
Review Pull Requests
You can help me review pull requests from others.
Again, please try your best to be kind. ü§ó
Here's what to keep in mind and how to review a pull request:
Understand the problem
First, make sure you
understand the problem
that the pull request is trying to solve. It might have a longer discussion in a GitHub Discussion or issue.
There's also a good chance that the pull request is not actually needed because the problem can be solved in a
different way
. Then you can suggest or ask about that.
Don't worry about style
Don't worry too much about things like commit message styles, I will squash and merge customizing the commit manually.
Also don't worry about style rules, there are already automatized tools checking that.
And if there's any other style or consistency need, I'll ask directly for that, or I'll add commits on top with the needed changes.
Check the code
Check and read the code, see if it makes sense,
run it locally
and see if it actually solves the problem.
Then
comment
saying that you did that, that's how I will know you really checked it.
Info
Unfortunately, I can't simply trust PRs that just have several approvals.
Several times it has happened that there are PRs with 3, 5 or more approvals, probably because the description is appealing, but when I check the PRs, they are actually broken, have a bug, or don't solve the problem they claim to solve. üòÖ
So, it's really important that you actually read and run the code, and let me know in the comments that you did. ü§ì
If the PR can be simplified in a way, you can ask for that, but there's no need to be too picky, there might be a lot of subjective points of view (and I will have my own as well üôà), so it's better if you can focus on the fundamental things.
Tests
Help me check that the PR has
tests
.
Check that the tests
fail
before the PR. üö®
Then check that the tests
pass
after the PR. ‚úÖ
Many PRs don't have tests, you can
remind
them to add tests, or you can even
suggest
some tests yourself. That's one of the things that consume most time and you can help a lot with that.
Then also comment what you tried, that way I'll know that you checked it. ü§ì
Create a Pull Request
You can
contribute
to the source code with Pull Requests, for example:
To fix a typo you found on the documentation.
To share an article, video, or podcast you created or found about FastAPI by
editing this file
.
Make sure you add your link to the start of the corresponding section.
To help
translate the documentation
to your language.
You can also help to review the translations created by others.
To propose new documentation sections.
To fix an existing issue/bug.
Make sure to add tests.
To add a new feature.
Make sure to add tests.
Make sure to add documentation if it's relevant.
Help Maintain FastAPI
Help me maintain
FastAPI
! ü§ì
There's a lot of work to do, and for most of it,
YOU
can do it.
The main tasks that you can do right now are:
Help others with questions in GitHub
(see the section above).
Review Pull Requests
(see the section above).
Those two tasks are what
consume time the most
. That's the main work of maintaining FastAPI.
If you can help me with that,
you are helping me maintain FastAPI
and making sure it keeps
advancing faster and better
. üöÄ
Join the chat
Join the üë•
Discord chat server
üë• and hang out with others in the FastAPI community.
Tip
For questions, ask them in
GitHub Discussions
, there's a much better chance you will receive help by the
FastAPI Experts
.
Use the chat only for other general conversations.
Don't use the chat for questions
Keep in mind that as chats allow more "free conversation", it's easy to ask questions that are too general and more difficult to answer, so, you might not receive answers.
In GitHub, the template will guide you to write the right question so that you can more easily get a good answer, or even solve the problem yourself even before asking. And in GitHub I can make sure I always answer everything, even if it takes some time. I can't personally do that with the chat systems. üòÖ
Conversations in the chat systems are also not as easily searchable as in GitHub, so questions and answers might get lost in the conversation. And only the ones in GitHub count to become a
FastAPI Expert
, so you will most probably receive more attention in GitHub.
On the other side, there are thousands of users in the chat systems, so there's a high chance you'll find someone to talk to there, almost all the time. üòÑ
Sponsor the author
If your
product/company
depends on or is related to
FastAPI
and you want to reach its users, you can sponsor the author (me) through
GitHub sponsors
. Depending on the tier, you could get some extra benefits, like a badge in the docs. üéÅ
Thanks! üöÄ

## 058_HISTORY_DESIGN_FUTURE
History, Design and Future¬∂
---

History, Design and Future
Some time ago,
a
FastAPI
user asked
:
What‚Äôs the history of this project? It seems to have come from nowhere to awesome in a few weeks [...]
Here's a little bit of that history.
Alternatives
I have been creating APIs with complex requirements for several years (Machine Learning, distributed systems, asynchronous jobs, NoSQL databases, etc), leading several teams of developers.
As part of that, I needed to investigate, test and use many alternatives.
The history of
FastAPI
is in great part the history of its predecessors.
As said in the section
Alternatives
:
FastAPI
wouldn't exist if not for the previous work of others.
There have been many tools created before that have helped inspire its creation.
I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by
FastAPI
using many different frameworks, plug-ins, and tools.
But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints).
Investigation
By using all the previous alternatives I had the chance to learn from all of them, take ideas, and combine them in the best way I could find for myself and the teams of developers I have worked with.
For example, it was clear that ideally it should be based on standard Python type hints.
Also, the best approach was to use already existing standards.
So, before even starting to code
FastAPI
, I spent several months studying the specs for OpenAPI, JSON Schema, OAuth2, etc. Understanding their relationship, overlap, and differences.
Design
Then I spent some time designing the developer "API" I wanted to have as a user (as a developer using FastAPI).
I tested several ideas in the most popular Python editors: PyCharm, VS Code, Jedi based editors.
By the last
Python Developer Survey
, that covers about 80% of the users.
It means that
FastAPI
was specifically tested with the editors used by 80% of the Python developers. And as most of the other editors tend to work similarly, all its benefits should work for virtually all editors.
That way I could find the best ways to reduce code duplication as much as possible, to have completion everywhere, type and error checks, etc.
All in a way that provided the best development experience for all the developers.
Requirements
After testing several alternatives, I decided that I was going to use
Pydantic
for its advantages.
Then I contributed to it, to make it fully compliant with JSON Schema, to support different ways to define constraint declarations, and to improve editor support (type checks, autocompletion) based on the tests in several editors.
During the development, I also contributed to
Starlette
, the other key requirement.
Development
By the time I started creating
FastAPI
itself, most of the pieces were already in place, the design was defined, the requirements and tools were ready, and the knowledge about the standards and specifications was clear and fresh.
Future
By this point, it's already clear that
FastAPI
with its ideas is being useful for many people.
It is being chosen over previous alternatives for suiting many use cases better.
Many developers and teams already depend on
FastAPI
for their projects (including me and my team).
But still, there are many improvements and features to come.
FastAPI
has a great future ahead.
And
your help
is greatly appreciated.

## 059_HOW_TO
How To - Recipes¬∂
---

How To - Recipes
Here you will see different recipes or "how to" guides for
several topics
.
Most of these ideas would be more or less
independent
, and in most cases you should only need to study them if they apply directly to
your project
.
If something seems interesting and useful to your project, go ahead and check it, but otherwise, you might probably just skip them.
Tip
If you want to
learn FastAPI
in a structured way (recommended), go and read the
Tutorial - User Guide
chapter by chapter instead.

## 060_HOW_TO_CONDITIONAL_OPENAPI
Conditional OpenAPI¬∂
---

Conditional OpenAPI
If you needed to, you could use settings and environment variables to configure OpenAPI conditionally depending on the environment, and even disable it entirely.
About security, APIs, and docs
Hiding your documentation user interfaces in production
shouldn't
be the way to protect your API.
That doesn't add any extra security to your API, the
path operations
will still be available where they are.
If there's a security flaw in your code, it will still exist.
Hiding the documentation just makes it more difficult to understand how to interact with your API, and could make it more difficult for you to debug it in production. It could be considered simply a form of
Security through obscurity
.
If you want to secure your API, there are several better things you can do, for example:
Make sure you have well defined Pydantic models for your request bodies and responses.
Configure any required permissions and roles using dependencies.
Never store plaintext passwords, only password hashes.
Implement and use well-known cryptographic tools, like Passlib and JWT tokens, etc.
Add more granular permission controls with OAuth2 scopes where needed.
...etc.
Nevertheless, you might have a very specific use case where you really need to disable the API docs for some environment (e.g. for production) or depending on configurations from environment variables.
Conditional OpenAPI from settings and env vars
You can easily use the same Pydantic settings to configure your generated OpenAPI and the docs UIs.
For example:
Python 3.8+
from
fastapi
import
FastAPI
from
pydantic_settings
import
BaseSettings
class
Settings
(
BaseSettings
):
openapi_url
:
str
=
"/openapi.json"
settings
=
Settings
()
app
=
FastAPI
(
openapi_url
=
settings
.
openapi_url
)
@app
.
get
(
"/"
)
def
root
():
return
{
"message"
:
"Hello World"
}
Here we declare the setting
openapi_url
with the same default of
"/openapi.json"
.
And then we use it when creating the
FastAPI
app.
Then you could disable OpenAPI (including the UI docs) by setting the environment variable
OPENAPI_URL
to the empty string, like:
fast ‚Üí
OPENAPI_URL= uvicorn main:app
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
Then if you go to the URLs at
/openapi.json
,
/docs
, or
/redoc
you will just get a
404 Not Found
error like:
{
"detail"
:
"Not Found"
}

## 061_HOW_TO_CONFIGURE_SWAGGER_UI
Configure Swagger UI¬∂
---

Configure Swagger UI
You can configure some extra
Swagger UI parameters
.
To configure them, pass the
swagger_ui_parameters
argument when creating the
FastAPI()
app object or to the
get_swagger_ui_html()
function.
swagger_ui_parameters
receives a dictionary with the configurations passed to Swagger UI directly.
FastAPI converts the configurations to
JSON
to make them compatible with JavaScript, as that's what Swagger UI needs.
Disable Syntax Highlighting
For example, you could disable syntax highlighting in Swagger UI.
Without changing the settings, syntax highlighting is enabled by default:
But you can disable it by setting
syntaxHighlight
to
False
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
(
swagger_ui_parameters
=
{
"syntaxHighlight"
:
False
})
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
...and then Swagger UI won't show the syntax highlighting anymore:
Change the Theme
The same way you could set the syntax highlighting theme with the key
"syntaxHighlight.theme"
(notice that it has a dot in the middle):
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
(
swagger_ui_parameters
=
{
"syntaxHighlight"
:
{
"theme"
:
"obsidian"
}})
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
That configuration would change the syntax highlighting color theme:
Change Default Swagger UI Parameters
FastAPI includes some default configuration parameters appropriate for most of the use cases.
It includes these default configurations:
Python 3.8+
## Code above omitted üëÜ
swagger_ui_default_parameters
:
Annotated
[
Dict
[
str
,
Any
],
Doc
(
"""
Default configurations for Swagger UI.
You can use it as a template to add any other configurations needed.
"""
),
]
=
{
"dom_id"
:
"#swagger-ui"
,
"layout"
:
"BaseLayout"
,
"deepLinking"
:
True
,
"showExtensions"
:
True
,
"showCommonExtensions"
:
True
,
}
## Code below omitted üëá
üëÄ Full file preview
Python 3.8+
import
json
from
typing
import
Any
,
Dict
,
Optional
from
fastapi.encoders
import
jsonable_encoder
from
starlette.responses
import
HTMLResponse
from
typing_extensions
import
Annotated
,
Doc
swagger_ui_default_parameters
:
Annotated
[
Dict
[
str
,
Any
],
Doc
(
"""
Default configurations for Swagger UI.
You can use it as a template to add any other configurations needed.
"""
),
]
=
{
"dom_id"
:
"#swagger-ui"
,
"layout"
:
"BaseLayout"
,
"deepLinking"
:
True
,
"showExtensions"
:
True
,
"showCommonExtensions"
:
True
,
}
def
get_swagger_ui_html
(
*
,
openapi_url
:
Annotated
[
str
,
Doc
(
"""
The OpenAPI URL that Swagger UI should load and use.
This is normally done automatically by FastAPI using the default URL
`/openapi.json`.
"""
),
],
title
:
Annotated
[
str
,
Doc
(
"""
The HTML `<title>` content, normally shown in the browser tab.
"""
),
],
swagger_js_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the Swagger UI JavaScript.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the Swagger UI CSS.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css"
,
swagger_favicon_url
:
Annotated
[
str
,
Doc
(
"""
The URL of the favicon to use. It is normally shown in the browser tab.
"""
),
]
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
oauth2_redirect_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The OAuth2 redirect URL, it is normally automatically handled by FastAPI.
"""
),
]
=
None
,
init_oauth
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
A dictionary with Swagger UI OAuth2 initialization configurations.
"""
),
]
=
None
,
swagger_ui_parameters
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Configuration parameters for Swagger UI.
It defaults to [swagger_ui_default_parameters][fastapi.openapi.docs.swagger_ui_default_parameters].
"""
),
]
=
None
,
)
->
HTMLResponse
:
"""
Generate and return the HTML that loads Swagger UI for the interactive
API docs (normally served at `/docs`).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load Swagger UI's JavaScript and CSS.
Read more about it in the
[FastAPI docs for Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/)
and the [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
"""
current_swagger_ui_parameters
=
swagger_ui_default_parameters
.
copy
()
if
swagger_ui_parameters
:
current_swagger_ui_parameters
.
update
(
swagger_ui_parameters
)
html
=
f
"""
<!DOCTYPE html>
<html>
<head>
<link type="text/css" rel="stylesheet" href="
{
swagger_css_url
}
">
<link rel="shortcut icon" href="
{
swagger_favicon_url
}
">
<title>
{
title
}
</title>
</head>
<body>
<div id="swagger-ui">
</div>
<script src="
{
swagger_js_url
}
"></script>
<!-- `SwaggerUIBundle` is now available on the page -->
<script>
const ui = SwaggerUIBundle(
{{
url: '
{
openapi_url
}
',
"""
for
key
,
value
in
current_swagger_ui_parameters
.
items
():
html
+=
f
"
{
json
.
dumps
(
key
)
}
:
{
json
.
dumps
(
jsonable_encoder
(
value
))
}
,
\n
"
if
oauth2_redirect_url
:
html
+=
f
"oauth2RedirectUrl: window.location.origin + '
{
oauth2_redirect_url
}
',"
html
+=
"""
presets: [
SwaggerUIBundle.presets.apis,
SwaggerUIBundle.SwaggerUIStandalonePreset
],
})"""
if
init_oauth
:
html
+=
f
"""
ui.initOAuth(
{
json
.
dumps
(
jsonable_encoder
(
init_oauth
))
}
)
"""
html
+=
"""
</script>
</body>
</html>
"""
return
HTMLResponse
(
html
)
def
get_redoc_html
(
*
,
openapi_url
:
Annotated
[
str
,
Doc
(
"""
The OpenAPI URL that ReDoc should load and use.
This is normally done automatically by FastAPI using the default URL
`/openapi.json`.
"""
),
],
title
:
Annotated
[
str
,
Doc
(
"""
The HTML `<title>` content, normally shown in the browser tab.
"""
),
],
redoc_js_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the ReDoc JavaScript.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js"
,
redoc_favicon_url
:
Annotated
[
str
,
Doc
(
"""
The URL of the favicon to use. It is normally shown in the browser tab.
"""
),
]
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
with_google_fonts
:
Annotated
[
bool
,
Doc
(
"""
Load and use Google Fonts.
"""
),
]
=
True
,
)
->
HTMLResponse
:
"""
Generate and return the HTML response that loads ReDoc for the alternative
API docs (normally served at `/redoc`).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load ReDoc's JavaScript and CSS.
Read more about it in the
[FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
"""
html
=
f
"""
<!DOCTYPE html>
<html>
<head>
<title>
{
title
}
</title>
<!-- needed for adaptive design -->
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
"""
if
with_google_fonts
:
html
+=
"""
<link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
"""
html
+=
f
"""
<link rel="shortcut icon" href="
{
redoc_favicon_url
}
">
<!--
ReDoc doesn't change outer page styles
-->
<style>
body
{{
margin: 0;
padding: 0;
}}
</style>
</head>
<body>
<noscript>
ReDoc requires Javascript to function. Please enable it to browse the documentation.
</noscript>
<redoc spec-url="
{
openapi_url
}
"></redoc>
<script src="
{
redoc_js_url
}
"> </script>
</body>
</html>
"""
return
HTMLResponse
(
html
)
def
get_swagger_ui_oauth2_redirect_html
()
->
HTMLResponse
:
"""
Generate the HTML response with the OAuth2 redirection for Swagger UI.
You normally don't need to use or change this.
"""
## copied from https://github.com/swagger-api/swagger-ui/blob/v4.14.0/dist/oauth2-redirect.html
html
=
"""
<!doctype html>
<html lang="en-US">
<head>
<title>Swagger UI: OAuth2 Redirect</title>
</head>
<body>
<script>
'use strict';
function run () {
var oauth2 = window.opener.swaggerUIRedirectOauth2;
var sentState = oauth2.state;
var redirectUrl = oauth2.redirectUrl;
var isValid, qp, arr;
if (/code|token|error/.test(window.location.hash)) {
qp = window.location.hash.substring(1).replace('?', '&');
} else {
qp = location.search.substring(1);
}
arr = qp.split("&");
arr.forEach(function (v,i,_arr) { _arr[i] = '"' + v.replace('=', '":"') + '"';});
qp = qp ? JSON.parse('{' + arr.join() + '}',
function (key, value) {
return key === "" ? value : decodeURIComponent(value);
}
) :
{}
;
isValid = qp.state === sentState;
if ((
oauth2.auth.schema.get("flow") === "accessCode" ||
oauth2.auth.schema.get("flow") === "authorizationCode" ||
oauth2.auth.schema.get("flow") === "authorization_code"
) && !oauth2.auth.code) {
if (!isValid) {
oauth2.errCb({
authId: oauth2.auth.name,
source: "auth",
level: "warning",
message: "Authorization may be unsafe, passed state was changed in server. The passed state wasn't returned from auth server."
});
}
if (qp.code) {
delete oauth2.state;
oauth2.auth.code = qp.code;
oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});
} else {
let oauthErrorMsg;
if (qp.error) {
oauthErrorMsg = "["+qp.error+"]: " +
(qp.error_description ? qp.error_description+ ". " : "no accessCode received from the server. ") +
(qp.error_uri ? "More info: "+qp.error_uri : "");
}
oauth2.errCb({
authId: oauth2.auth.name,
source: "auth",
level: "error",
message: oauthErrorMsg || "[Authorization failed]: no accessCode received from the server."
});
}
} else {
oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});
}
window.close();
}
if (document.readyState !== 'loading') {
run();
} else {
document.addEventListener('DOMContentLoaded', function () {
run();
});
}
</script>
</body>
</html>
"""
return
HTMLResponse
(
content
=
html
)
You can override any of them by setting a different value in the argument
swagger_ui_parameters
.
For example, to disable
deepLinking
you could pass these settings to
swagger_ui_parameters
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
(
swagger_ui_parameters
=
{
"deepLinking"
:
False
})
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Other Swagger UI Parameters
To see all the other possible configurations you can use, read the official
docs for Swagger UI parameters
.
JavaScript-only settings
Swagger UI also allows other configurations to be
JavaScript-only
objects (for example, JavaScript functions).
FastAPI also includes these JavaScript-only
presets
settings:
presets
:
[
SwaggerUIBundle
.
presets
.
apis
,
SwaggerUIBundle
.
SwaggerUIStandalonePreset
]
These are
JavaScript
objects, not strings, so you can't pass them from Python code directly.
If you need to use JavaScript-only configurations like those, you can use one of the methods above. Override all the Swagger UI
path operation
and manually write any JavaScript you need.

## 062_HOW_TO_CUSTOM_DOCS_UI_ASSETS
Custom Docs UI Static Assets (Self-Hosting)¬∂
---

Custom Docs UI Static Assets (Self-Hosting)
The API docs use
Swagger UI
and
ReDoc
, and each of those need some JavaScript and CSS files.
By default, those files are served from a
CDN
.
But it's possible to customize it, you can set a specific CDN, or serve the files yourself.
Custom CDN for JavaScript and CSS
Let's say that you want to use a different
CDN
, for example you want to use
https://unpkg.com/
.
This could be useful if for example you live in a country that restricts some URLs.
Disable the automatic docs
The first step is to disable the automatic docs, as by default, those use the default CDN.
To disable them, set their URLs to
None
when creating your
FastAPI
app:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"https://unpkg.com/redoc@2/bundles/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Include the custom docs
Now you can create the
path operations
for the custom docs.
You can reuse FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments:
openapi_url
: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute
app.openapi_url
.
title
: the title of your API.
oauth2_redirect_url
: you can use
app.swagger_ui_oauth2_redirect_url
here to use the default.
swagger_js_url
: the URL where the HTML for your Swagger UI docs can get the
JavaScript
file. This is the custom CDN URL.
swagger_css_url
: the URL where the HTML for your Swagger UI docs can get the
CSS
file. This is the custom CDN URL.
And similarly for ReDoc...
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"https://unpkg.com/redoc@2/bundles/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Tip
The
path operation
for
swagger_ui_redirect
is a helper for when you use OAuth2.
If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication.
Swagger UI will handle it behind the scenes for you, but it needs this "redirect" helper.
Create a
path operation
to test it
Now, to be able to test that everything works, create a
path operation
:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
=
"https://unpkg.com/swagger-ui-dist@5/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"https://unpkg.com/redoc@2/bundles/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Test it
Now, you should be able to go to your docs at
http://127.0.0.1:8000/docs
, and reload the page, it will load those assets from the new CDN.
Self-hosting JavaScript and CSS for docs
Self-hosting the JavaScript and CSS could be useful if, for example, you need your app to keep working even while offline, without open Internet access, or in a local network.
Here you'll see how to serve those files yourself, in the same FastAPI app, and configure the docs to use them.
Project file structure
Let's say your project file structure looks like this:
.
‚îú‚îÄ‚îÄ app
‚îÇ ‚îú‚îÄ‚îÄ __init__.py
‚îÇ ‚îú‚îÄ‚îÄ main.py
Now create a directory to store those static files.
Your new file structure could look like this:
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îî‚îÄ‚îÄ static/
Download the files
Download the static files needed for the docs and put them on that
static/
directory.
You can probably right-click each link and select an option similar to
Save link as...
.
Swagger UI
uses the files:
swagger-ui-bundle.js
swagger-ui.css
And
ReDoc
uses the file:
redoc.standalone.js
After that, your file structure could look like:
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îî‚îÄ‚îÄ static
‚îú‚îÄ‚îÄ redoc.standalone.js
‚îú‚îÄ‚îÄ swagger-ui-bundle.js
‚îî‚îÄ‚îÄ swagger-ui.css
Serve the static files
Import
StaticFiles
.
"Mount" a
StaticFiles()
instance in a specific path.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
from
fastapi.staticfiles
import
StaticFiles
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"/static/swagger-ui-bundle.js"
,
swagger_css_url
=
"/static/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"/static/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Test the static files
Start your application and go to
http://127.0.0.1:8000/static/redoc.standalone.js
.
You should see a very long JavaScript file for
ReDoc
.
It could start with something like:
/*! For license information please see redoc.standalone.js.LICENSE.txt */
!
function
(
e
,
t
){
"object"
==
typeof
exports
&&
"object"
==
typeof
module
?
module
.
exports
=
t
(
require
(
"null"
))
:
...
That confirms that you are being able to serve static files from your app, and that you placed the static files for the docs in the correct place.
Now we can configure the app to use those static files for the docs.
Disable the automatic docs for static files
The same as when using a custom CDN, the first step is to disable the automatic docs, as those use the CDN by default.
To disable them, set their URLs to
None
when creating your
FastAPI
app:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
from
fastapi.staticfiles
import
StaticFiles
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"/static/swagger-ui-bundle.js"
,
swagger_css_url
=
"/static/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"/static/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Include the custom docs for static files
And the same way as with a custom CDN, now you can create the
path operations
for the custom docs.
Again, you can reuse FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments:
openapi_url
: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute
app.openapi_url
.
title
: the title of your API.
oauth2_redirect_url
: you can use
app.swagger_ui_oauth2_redirect_url
here to use the default.
swagger_js_url
: the URL where the HTML for your Swagger UI docs can get the
JavaScript
file.
This is the one that your own app is now serving
.
swagger_css_url
: the URL where the HTML for your Swagger UI docs can get the
CSS
file.
This is the one that your own app is now serving
.
And similarly for ReDoc...
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
from
fastapi.staticfiles
import
StaticFiles
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"/static/swagger-ui-bundle.js"
,
swagger_css_url
=
"/static/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"/static/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Tip
The
path operation
for
swagger_ui_redirect
is a helper for when you use OAuth2.
If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication.
Swagger UI will handle it behind the scenes for you, but it needs this "redirect" helper.
Create a
path operation
to test static files
Now, to be able to test that everything works, create a
path operation
:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.docs
import
(
get_redoc_html
,
get_swagger_ui_html
,
get_swagger_ui_oauth2_redirect_html
,
)
from
fastapi.staticfiles
import
StaticFiles
app
=
FastAPI
(
docs_url
=
None
,
redoc_url
=
None
)
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
@app
.
get
(
"/docs"
,
include_in_schema
=
False
)
async
def
custom_swagger_ui_html
():
return
get_swagger_ui_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - Swagger UI"
,
oauth2_redirect_url
=
app
.
swagger_ui_oauth2_redirect_url
,
swagger_js_url
=
"/static/swagger-ui-bundle.js"
,
swagger_css_url
=
"/static/swagger-ui.css"
,
)
@app
.
get
(
app
.
swagger_ui_oauth2_redirect_url
,
include_in_schema
=
False
)
async
def
swagger_ui_redirect
():
return
get_swagger_ui_oauth2_redirect_html
()
@app
.
get
(
"/redoc"
,
include_in_schema
=
False
)
async
def
redoc_html
():
return
get_redoc_html
(
openapi_url
=
app
.
openapi_url
,
title
=
app
.
title
+
" - ReDoc"
,
redoc_js_url
=
"/static/redoc.standalone.js"
,
)
@app
.
get
(
"/users/
{username}
"
)
async
def
read_user
(
username
:
str
):
return
{
"message"
:
f
"Hello
{
username
}
"
}
Test Static Files UI
Now, you should be able to disconnect your WiFi, go to your docs at
http://127.0.0.1:8000/docs
, and reload the page.
And even without Internet, you would be able to see the docs for your API and interact with it.

## 063_HOW_TO_CUSTOM_REQUEST_AND_ROUTE
Custom Request and APIRoute class¬∂
---

Custom Request and APIRoute class
In some cases, you may want to override the logic used by the
Request
and
APIRoute
classes.
In particular, this may be a good alternative to logic in a middleware.
For example, if you want to read or manipulate the request body before it is processed by your application.
Danger
This is an "advanced" feature.
If you are just starting with
FastAPI
you might want to skip this section.
Use cases
Some use cases include:
Converting non-JSON request bodies to JSON (e.g.
msgpack
).
Decompressing gzip-compressed request bodies.
Automatically logging all request bodies.
Handling custom request body encodings
Let's see how to make use of a custom
Request
subclass to decompress gzip requests.
And an
APIRoute
subclass to use that custom request class.
Create a custom
GzipRequest
class
Tip
This is a toy example to demonstrate how it works, if you need Gzip support, you can use the provided
GzipMiddleware
.
First, we create a
GzipRequest
class, which will overwrite the
Request.body()
method to decompress the body in the presence of an appropriate header.
If there's no
gzip
in the header, it will not try to decompress the body.
That way, the same route class can handle gzip compressed or uncompressed requests.
Python 3.8+
import
gzip
from
typing
import
Callable
,
List
from
fastapi
import
Body
,
FastAPI
,
Request
,
Response
from
fastapi.routing
import
APIRoute
class
GzipRequest
(
Request
):
async
def
body
(
self
)
->
bytes
:
if
not
hasattr
(
self
,
"_body"
):
body
=
await
super
()
.
body
()
if
"gzip"
in
self
.
headers
.
getlist
(
"Content-Encoding"
):
body
=
gzip
.
decompress
(
body
)
self
.
_body
=
body
return
self
.
_body
class
GzipRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
request
=
GzipRequest
(
request
.
scope
,
request
.
receive
)
return
await
original_route_handler
(
request
)
return
custom_route_handler
app
=
FastAPI
()
app
.
router
.
route_class
=
GzipRoute
@app
.
post
(
"/sum"
)
async
def
sum_numbers
(
numbers
:
List
[
int
]
=
Body
()):
return
{
"sum"
:
sum
(
numbers
)}
Create a custom
GzipRoute
class
Next, we create a custom subclass of
fastapi.routing.APIRoute
that will make use of the
GzipRequest
.
This time, it will overwrite the method
APIRoute.get_route_handler()
.
This method returns a function. And that function is what will receive a request and return a response.
Here we use it to create a
GzipRequest
from the original request.
Python 3.8+
import
gzip
from
typing
import
Callable
,
List
from
fastapi
import
Body
,
FastAPI
,
Request
,
Response
from
fastapi.routing
import
APIRoute
class
GzipRequest
(
Request
):
async
def
body
(
self
)
->
bytes
:
if
not
hasattr
(
self
,
"_body"
):
body
=
await
super
()
.
body
()
if
"gzip"
in
self
.
headers
.
getlist
(
"Content-Encoding"
):
body
=
gzip
.
decompress
(
body
)
self
.
_body
=
body
return
self
.
_body
class
GzipRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
request
=
GzipRequest
(
request
.
scope
,
request
.
receive
)
return
await
original_route_handler
(
request
)
return
custom_route_handler
app
=
FastAPI
()
app
.
router
.
route_class
=
GzipRoute
@app
.
post
(
"/sum"
)
async
def
sum_numbers
(
numbers
:
List
[
int
]
=
Body
()):
return
{
"sum"
:
sum
(
numbers
)}
Technical Details
A
Request
has a
request.scope
attribute, that's just a Python
dict
containing the metadata related to the request.
A
Request
also has a
request.receive
, that's a function to "receive" the body of the request.
The
scope
dict
and
receive
function are both part of the ASGI specification.
And those two things,
scope
and
receive
, are what is needed to create a new
Request
instance.
To learn more about the
Request
check
Starlette's docs about Requests
.
The only thing the function returned by
GzipRequest.get_route_handler
does differently is convert the
Request
to a
GzipRequest
.
Doing this, our
GzipRequest
will take care of decompressing the data (if necessary) before passing it to our
path operations
.
After that, all of the processing logic is the same.
But because of our changes in
GzipRequest.body
, the request body will be automatically decompressed when it is loaded by
FastAPI
when needed.
Accessing the request body in an exception handler
Tip
To solve this same problem, it's probably a lot easier to use the
body
in a custom handler for
RequestValidationError
(
Handling Errors
).
But this example is still valid and it shows how to interact with the internal components.
We can also use this same approach to access the request body in an exception handler.
All we need to do is handle the request inside a
try
/
except
block:
Python 3.8+
from
typing
import
Callable
,
List
from
fastapi
import
Body
,
FastAPI
,
HTTPException
,
Request
,
Response
from
fastapi.exceptions
import
RequestValidationError
from
fastapi.routing
import
APIRoute
class
ValidationErrorLoggingRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
try
:
return
await
original_route_handler
(
request
)
except
RequestValidationError
as
exc
:
body
=
await
request
.
body
()
detail
=
{
"errors"
:
exc
.
errors
(),
"body"
:
body
.
decode
()}
raise
HTTPException
(
status_code
=
422
,
detail
=
detail
)
return
custom_route_handler
app
=
FastAPI
()
app
.
router
.
route_class
=
ValidationErrorLoggingRoute
@app
.
post
(
"/"
)
async
def
sum_numbers
(
numbers
:
List
[
int
]
=
Body
()):
return
sum
(
numbers
)
If an exception occurs, the
Request
instance will still be in scope, so we can read and make use of the request body when handling the error:
Python 3.8+
from
typing
import
Callable
,
List
from
fastapi
import
Body
,
FastAPI
,
HTTPException
,
Request
,
Response
from
fastapi.exceptions
import
RequestValidationError
from
fastapi.routing
import
APIRoute
class
ValidationErrorLoggingRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
try
:
return
await
original_route_handler
(
request
)
except
RequestValidationError
as
exc
:
body
=
await
request
.
body
()
detail
=
{
"errors"
:
exc
.
errors
(),
"body"
:
body
.
decode
()}
raise
HTTPException
(
status_code
=
422
,
detail
=
detail
)
return
custom_route_handler
app
=
FastAPI
()
app
.
router
.
route_class
=
ValidationErrorLoggingRoute
@app
.
post
(
"/"
)
async
def
sum_numbers
(
numbers
:
List
[
int
]
=
Body
()):
return
sum
(
numbers
)
Custom
APIRoute
class in a router
You can also set the
route_class
parameter of an
APIRouter
:
Python 3.8+
import
time
from
typing
import
Callable
from
fastapi
import
APIRouter
,
FastAPI
,
Request
,
Response
from
fastapi.routing
import
APIRoute
class
TimedRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
before
=
time
.
time
()
response
:
Response
=
await
original_route_handler
(
request
)
duration
=
time
.
time
()
-
before
response
.
headers
[
"X-Response-Time"
]
=
str
(
duration
)
print
(
f
"route duration:
{
duration
}
"
)
print
(
f
"route response:
{
response
}
"
)
print
(
f
"route response headers:
{
response
.
headers
}
"
)
return
response
return
custom_route_handler
app
=
FastAPI
()
router
=
APIRouter
(
route_class
=
TimedRoute
)
@app
.
get
(
"/"
)
async
def
not_timed
():
return
{
"message"
:
"Not timed"
}
@router
.
get
(
"/timed"
)
async
def
timed
():
return
{
"message"
:
"It's the time of my life"
}
app
.
include_router
(
router
)
In this example, the
path operations
under the
router
will use the custom
TimedRoute
class, and will have an extra
X-Response-Time
header in the response with the time it took to generate the response:
Python 3.8+
import
time
from
typing
import
Callable
from
fastapi
import
APIRouter
,
FastAPI
,
Request
,
Response
from
fastapi.routing
import
APIRoute
class
TimedRoute
(
APIRoute
):
def
get_route_handler
(
self
)
->
Callable
:
original_route_handler
=
super
()
.
get_route_handler
()
async
def
custom_route_handler
(
request
:
Request
)
->
Response
:
before
=
time
.
time
()
response
:
Response
=
await
original_route_handler
(
request
)
duration
=
time
.
time
()
-
before
response
.
headers
[
"X-Response-Time"
]
=
str
(
duration
)
print
(
f
"route duration:
{
duration
}
"
)
print
(
f
"route response:
{
response
}
"
)
print
(
f
"route response headers:
{
response
.
headers
}
"
)
return
response
return
custom_route_handler
app
=
FastAPI
()
router
=
APIRouter
(
route_class
=
TimedRoute
)
@app
.
get
(
"/"
)
async
def
not_timed
():
return
{
"message"
:
"Not timed"
}
@router
.
get
(
"/timed"
)
async
def
timed
():
return
{
"message"
:
"It's the time of my life"
}
app
.
include_router
(
router
)

## 064_HOW_TO_EXTENDING_OPENAPI
Extending OpenAPI¬∂
---

Extending OpenAPI
There are some cases where you might need to modify the generated OpenAPI schema.
In this section you will see how.
The normal process
The normal (default) process, is as follows.
A
FastAPI
application (instance) has an
.openapi()
method that is expected to return the OpenAPI schema.
As part of the application object creation, a
path operation
for
/openapi.json
(or for whatever you set your
openapi_url
) is registered.
It just returns a JSON response with the result of the application's
.openapi()
method.
By default, what the method
.openapi()
does is check the property
.openapi_schema
to see if it has contents and return them.
If it doesn't, it generates them using the utility function at
fastapi.openapi.utils.get_openapi
.
And that function
get_openapi()
receives as parameters:
title
: The OpenAPI title, shown in the docs.
version
: The version of your API, e.g.
2.5.0
.
openapi_version
: The version of the OpenAPI specification used. By default, the latest:
3.1.0
.
summary
: A short summary of the API.
description
: The description of your API, this can include markdown and will be shown in the docs.
routes
: A list of routes, these are each of the registered
path operations
. They are taken from
app.routes
.
Info
The parameter
summary
is available in OpenAPI 3.1.0 and above, supported by FastAPI 0.99.0 and above.
Overriding the defaults
Using the information above, you can use the same utility function to generate the OpenAPI schema and override each part that you need.
For example, let's add
ReDoc's OpenAPI extension to include a custom logo
.
Normal
FastAPI
First, write all your
FastAPI
application as normally:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.utils
import
get_openapi
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
def
custom_openapi
():
if
app
.
openapi_schema
:
return
app
.
openapi_schema
openapi_schema
=
get_openapi
(
title
=
"Custom title"
,
version
=
"2.5.0"
,
summary
=
"This is a very custom OpenAPI schema"
,
description
=
"Here's a longer description of the custom **OpenAPI** schema"
,
routes
=
app
.
routes
,
)
openapi_schema
[
"info"
][
"x-logo"
]
=
{
"url"
:
"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
}
app
.
openapi_schema
=
openapi_schema
return
app
.
openapi_schema
app
.
openapi
=
custom_openapi
Generate the OpenAPI schema
Then, use the same utility function to generate the OpenAPI schema, inside a
custom_openapi()
function:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.utils
import
get_openapi
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
def
custom_openapi
():
if
app
.
openapi_schema
:
return
app
.
openapi_schema
openapi_schema
=
get_openapi
(
title
=
"Custom title"
,
version
=
"2.5.0"
,
summary
=
"This is a very custom OpenAPI schema"
,
description
=
"Here's a longer description of the custom **OpenAPI** schema"
,
routes
=
app
.
routes
,
)
openapi_schema
[
"info"
][
"x-logo"
]
=
{
"url"
:
"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
}
app
.
openapi_schema
=
openapi_schema
return
app
.
openapi_schema
app
.
openapi
=
custom_openapi
Modify the OpenAPI schema
Now you can add the ReDoc extension, adding a custom
x-logo
to the
info
"object" in the OpenAPI schema:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.utils
import
get_openapi
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
def
custom_openapi
():
if
app
.
openapi_schema
:
return
app
.
openapi_schema
openapi_schema
=
get_openapi
(
title
=
"Custom title"
,
version
=
"2.5.0"
,
summary
=
"This is a very custom OpenAPI schema"
,
description
=
"Here's a longer description of the custom **OpenAPI** schema"
,
routes
=
app
.
routes
,
)
openapi_schema
[
"info"
][
"x-logo"
]
=
{
"url"
:
"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
}
app
.
openapi_schema
=
openapi_schema
return
app
.
openapi_schema
app
.
openapi
=
custom_openapi
Cache the OpenAPI schema
You can use the property
.openapi_schema
as a "cache", to store your generated schema.
That way, your application won't have to generate the schema every time a user opens your API docs.
It will be generated only once, and then the same cached schema will be used for the next requests.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.utils
import
get_openapi
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
def
custom_openapi
():
if
app
.
openapi_schema
:
return
app
.
openapi_schema
openapi_schema
=
get_openapi
(
title
=
"Custom title"
,
version
=
"2.5.0"
,
summary
=
"This is a very custom OpenAPI schema"
,
description
=
"Here's a longer description of the custom **OpenAPI** schema"
,
routes
=
app
.
routes
,
)
openapi_schema
[
"info"
][
"x-logo"
]
=
{
"url"
:
"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
}
app
.
openapi_schema
=
openapi_schema
return
app
.
openapi_schema
app
.
openapi
=
custom_openapi
Override the method
Now you can replace the
.openapi()
method with your new function.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.openapi.utils
import
get_openapi
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
def
custom_openapi
():
if
app
.
openapi_schema
:
return
app
.
openapi_schema
openapi_schema
=
get_openapi
(
title
=
"Custom title"
,
version
=
"2.5.0"
,
summary
=
"This is a very custom OpenAPI schema"
,
description
=
"Here's a longer description of the custom **OpenAPI** schema"
,
routes
=
app
.
routes
,
)
openapi_schema
[
"info"
][
"x-logo"
]
=
{
"url"
:
"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
}
app
.
openapi_schema
=
openapi_schema
return
app
.
openapi_schema
app
.
openapi
=
custom_openapi
Check it
Once you go to
http://127.0.0.1:8000/redoc
you will see that you are using your custom logo (in this example,
FastAPI
's logo):

## 065_HOW_TO_GENERAL
General - How To - Recipes¬∂
---

General - How To - Recipes
Here are several pointers to other places in the docs, for general or frequent questions.
Filter Data - Security
To ensure that you don't return more data than you should, read the docs for
Tutorial - Response Model - Return Type
.
Documentation Tags - OpenAPI
To add tags to your
path operations
, and group them in the docs UI, read the docs for
Tutorial - Path Operation Configurations - Tags
.
Documentation Summary and Description - OpenAPI
To add a summary and description to your
path operations
, and show them in the docs UI, read the docs for
Tutorial - Path Operation Configurations - Summary and Description
.
Documentation Response description - OpenAPI
To define the description of the response, shown in the docs UI, read the docs for
Tutorial - Path Operation Configurations - Response description
.
Documentation Deprecate a
Path Operation
- OpenAPI
To deprecate a
path operation
, and show it in the docs UI, read the docs for
Tutorial - Path Operation Configurations - Deprecation
.
Convert any Data to JSON-compatible
To convert any data to JSON-compatible, read the docs for
Tutorial - JSON Compatible Encoder
.
OpenAPI Metadata - Docs
To add metadata to your OpenAPI schema, including a license, version, contact, etc, read the docs for
Tutorial - Metadata and Docs URLs
.
OpenAPI Custom URL
To customize the OpenAPI URL (or remove it), read the docs for
Tutorial - Metadata and Docs URLs
.
OpenAPI Docs URLs
To update the URLs used for the automatically generated docs user interfaces, read the docs for
Tutorial - Metadata and Docs URLs
.

## 066_HOW_TO_GRAPHQL
GraphQL¬∂
---

GraphQL
As
FastAPI
is based on the
ASGI
standard, it's very easy to integrate any
GraphQL
library also compatible with ASGI.
You can combine normal FastAPI
path operations
with GraphQL on the same application.
Tip
GraphQL
solves some very specific use cases.
It has
advantages
and
disadvantages
when compared to common
web APIs
.
Make sure you evaluate if the
benefits
for your use case compensate the
drawbacks
. ü§ì
GraphQL Libraries
Here are some of the
GraphQL
libraries that have
ASGI
support. You could use them with
FastAPI
:
Strawberry
üçì
With
docs for FastAPI
Ariadne
With
docs for FastAPI
Tartiflette
With
Tartiflette ASGI
to provide ASGI integration
Graphene
With
starlette-graphene3
GraphQL with Strawberry
If you need or want to work with
GraphQL
,
Strawberry
is the
recommended
library as it has the design closest to
FastAPI's
design, it's all based on
type annotations
.
Depending on your use case, you might prefer to use a different library, but if you asked me, I would probably suggest you try
Strawberry
.
Here's a small preview of how you could integrate Strawberry with FastAPI:
Python 3.8+
import
strawberry
from
fastapi
import
FastAPI
from
strawberry.fastapi
import
GraphQLRouter
@strawberry
.
type
class
User
:
name
:
str
age
:
int
@strawberry
.
type
class
Query
:
@strawberry
.
field
def
user
(
self
)
->
User
:
return
User
(
name
=
"Patrick"
,
age
=
100
)
schema
=
strawberry
.
Schema
(
query
=
Query
)
graphql_app
=
GraphQLRouter
(
schema
)
app
=
FastAPI
()
app
.
include_router
(
graphql_app
,
prefix
=
"/graphql"
)
You can learn more about Strawberry in the
Strawberry documentation
.
And also the docs about
Strawberry with FastAPI
.
Older
GraphQLApp
from Starlette
Previous versions of Starlette included a
GraphQLApp
class to integrate with
Graphene
.
It was deprecated from Starlette, but if you have code that used it, you can easily
migrate
to
starlette-graphene3
, that covers the same use case and has an
almost identical interface
.
Tip
If you need GraphQL, I still would recommend you check out
Strawberry
, as it's based on type annotations instead of custom classes and types.
Learn More
You can learn more about
GraphQL
in the
official GraphQL documentation
.
You can also read more about each those libraries described above in their links.

## 067_HOW_TO_SEPARATE_OPENAPI_SCHEMAS
Separate OpenAPI Schemas for Input and Output or Not¬∂
---

Separate OpenAPI Schemas for Input and Output or Not
When using
Pydantic v2
, the generated OpenAPI is a bit more exact and
correct
than before. üòé
In fact, in some cases, it will even have
two JSON Schemas
in OpenAPI for the same Pydantic model, for input and output, depending on if they have
default values
.
Let's see how that works and how to change it if you need to do that.
Pydantic Models for Input and Output
Let's say you have a Pydantic model with default values, like this one:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Optional
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Optional
[
str
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
List
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
Model for Input
If you use this model as an input like here:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Optional
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Optional
[
str
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
List
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
...then the
description
field will
not be required
. Because it has a default value of
None
.
Input Model in Docs
You can confirm that in the docs, the
description
field doesn't have a
red asterisk
, it's not marked as required:
Model for Output
But if you use the same model as an output, like here:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Optional
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Optional
[
str
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
List
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
...then because
description
has a default value, if you
don't return anything
for that field, it will still have that
default value
.
Model for Output Response Data
If you interact with the docs and check the response, even though the code didn't add anything in one of the
description
fields, the JSON response contains the default value (
null
):
This means that it will
always have a value
, it's just that sometimes the value could be
None
(or
null
in JSON).
That means that, clients using your API don't have to check if the value exists or not, they can
assume the field will always be there
, but just that in some cases it will have the default value of
None
.
The way to describe this in OpenAPI, is to mark that field as
required
, because it will always be there.
Because of that, the JSON Schema for a model can be different depending on if it's used for
input or output
:
for
input
the
description
will
not be required
for
output
it will be
required
(and possibly
None
, or in JSON terms,
null
)
Model for Output in Docs
You can check the output model in the docs too,
both
name
and
description
are marked as
required
with a
red asterisk
:
Model for Input and Output in Docs
And if you check all the available Schemas (JSON Schemas) in OpenAPI, you will see that there are two, one
Item-Input
and one
Item-Output
.
For
Item-Input
,
description
is
not required
, it doesn't have a red asterisk.
But for
Item-Output
,
description
is
required
, it has a red asterisk.
With this feature from
Pydantic v2
, your API documentation is more
precise
, and if you have autogenerated clients and SDKs, they will be more precise too, with a better
developer experience
and consistency. üéâ
Do not Separate Schemas
Now, there are some cases where you might want to have the
same schema for input and output
.
Probably the main use case for this is if you already have some autogenerated client code/SDKs and you don't want to update all the autogenerated client code/SDKs yet, you probably will want to do it at some point, but maybe not right now.
In that case, you can disable this feature in
FastAPI
, with the parameter
separate_input_output_schemas=False
.
Info
Support for
separate_input_output_schemas
was added in FastAPI
0.102.0
. ü§ì
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
(
separate_input_output_schemas
=
False
)
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Optional
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Optional
[
str
]
=
None
app
=
FastAPI
(
separate_input_output_schemas
=
False
)
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
(
separate_input_output_schemas
=
False
)
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
)
def
read_items
()
->
List
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
description
=
"Device to travel through the multi-rick-verse"
,
),
Item
(
name
=
"Plumbus"
),
]
Same Schema for Input and Output Models in Docs
And now there will be one single schema for input and output for the model, only
Item
, and it will have
description
as
not required
:
This is the same behavior as in Pydantic v1. ü§ì

## 068_HOW_TO_TESTING_DATABASE
Testing a Database¬∂
---

Testing a Database
You can study about databases, SQL, and SQLModel in the
SQLModel docs
. ü§ì
There's a mini
tutorial on using SQLModel with FastAPI
. ‚ú®
That tutorial includes a section about
testing SQL databases
. üòé

## 069_HU
FastAPI
FastAPI keretrendszer, nagy teljes√≠tm√©ny, k√∂nnyen tanulhat√≥, gyorsan k√≥dolhat√≥, productionre k√©sz
Dokument√°ci√≥
:
https://fastapi.tiangolo.com
Forr√°s k√≥d
:
https://github.com/fastapi/fastapi
A FastAPI egy modern, gyors (nagy teljes√≠tm√©ny≈±), webes keretrendszer API-ok √©p√≠t√©s√©hez Python -al, a Python szabv√°nyos t√≠pusjel√∂l√©seire √©p√≠tve.
Kulcs funkci√≥k:
Gyors
: Nagyon nagy teljes√≠tm√©ny, a
NodeJS
-el √©s a
Go
-val egyenrang√∫ (a Starlettenek √©s a Pydantic-nek k√∂sz√∂nhet≈ëen).
Az egyik leggyorsabb Python keretrendszer
.
Gyorsan k√≥dolhat√≥
: A funkci√≥k fejleszt√©si sebess√©g√©t 200-300 sz√°zal√©kkal megn√∂veli. *
Kevesebb hiba
: K√∂r√ºlbel√ºl 40%-al cs√∂kkenti az emberi (fejleszt≈ëi) hib√°k sz√°m√°t. *
Intuit√≠v
: Kiv√°l√≥ szerkeszt≈ë t√°mogat√°s.
Kieg√©sz√≠t√©s
mindenhol. Kevesebb hibakeres√©ssel t√∂lt√∂tt id≈ë.
Egyszer≈±
: Egyszer≈± tanul√°sra √©s haszn√°latra tervezve. Kevesebb dokument√°ci√≥ olvas√°ssal t√∂lt√∂tt id≈ë.
R√∂vid
: K√≥d duplik√°ci√≥ minimaliz√°l√°sa. T√∂bb funkci√≥ minden param√©ter deklar√°l√°s√°val. Kevesebb hiba.
Robosztus
: Production ready k√≥d. Automatikus interakt√≠v dokument√°ci√≥ val.
Szabv√°ny alap√∫
: Az API-ok ny√≠lt szabv√°nyaira alapul√≥ (√©s azokkal teljesen kompatibilis):
OpenAPI
(kor√°bban Swagger n√©ven ismert) √©s a
JSON Schema
.
* Egy production alkalmaz√°sokat √©p√≠t≈ë bels≈ë fejleszt≈ëi csapat tesztjein alapul√≥ becsl√©s.
Szponzorok
Tov√°bbi szponzorok
V√©lem√©nyek
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I‚Äôm over the moon excited about
FastAPI
. It‚Äôs so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
If anyone is looking to build a production Python API, I would highly recommend
FastAPI
. It is
beautifully designed
,
simple to use
and
highly scalable
, it has become a
key component
in our API first development strategy and is driving many automations and services such as our Virtual TAC Engineer.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, a CLI-ok FastAPI-ja
Ha egy olyan CLI alkalmaz√°st fejlesztesz amit a parancssorban kell haszn√°lni webes API helyett, tekintsd meg:
Typer
.
Typer
a FastAPI kistestv√©re. A
CLI-k FastAPI-ja
. ‚å®Ô∏è üöÄ
K√∂vetelm√©nyek
A FastAPI √≥ri√°sok v√°ll√°n √°ll:
Starlette
a webes r√©szekhez.
Pydantic
az adat r√©szekhez.
Telep√≠t√©s
fast ‚Üí
pip install fastapi
restart ‚Üª
A production-h√∂z egy ASGI szerverre is sz√ºks√©g lesz, mint p√©ld√°ul az
Uvicorn
vagy a
Hypercorn
.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
P√©lda
Hozd l√©tre
Hozz l√©tre a
main.py
f√°jlt a k√∂vetkez≈ë tartalommal:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Vagy haszn√°ld az
async def
-et...
Ha a k√≥dod
async
/
await
-et, haszn√°l
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Megjegyz√©s
:
Ha nem tudod, tekintsd meg a
"Sietsz?"
szekci√≥t
async
√©s
await
-r≈ël dokument√°ci√≥ba
.
Futtasd le
Ind√≠tsd el a szervert a k√∂vetkez≈ë paranccsal:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
A parancsr√≥l
uvicorn main:app --reload
...
A
uvicorn main:app
parancs a k√∂vetkez≈ëre utal:
main
: f√°jl
main.py
(a Python "modul").
app
: a
main.py
-ban a
app = FastAPI()
sorral l√©trehozott objektum.
--reload
: k√≥d v√°ltoztat√°s eset√©n √∫jra ind√≠tja a szervert. Csak fejleszt√©s k√∂zben haszn√°land√≥.
Ellen≈ërizd
Nyisd meg a b√∂ng√©sz≈ëd a k√∂vetkez≈ë c√≠men:
http://127.0.0.1:8000/items/5?q=somequery
.
A k√∂vetkez≈ë JSON v√°laszt fogod l√°tni:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
M√°ris l√©trehozt√°l egy API-t ami:
HTTP k√©r√©seket fogad a
/
√©s
/items/{item_id}
√∫tvonalakon
.
Mindk√©t
√∫tvonal
a
GET
m≈±veletet
haszn√°lja (m√°sik elnevez√©s: HTTP
met√≥dus
).
A
/items/{item_id}
√∫tvonalnak
van egy
path param√©tere
, az
item_id
, aminek
int
t√≠pus√∫nak kell lennie.
A
/items/{item_id}
√∫tvonalnak
m√©g van egy opcion√°lis,
str
t√≠pus√∫
query param√©tere
is, a
q
.
Interakt√≠v API dokument√°ci√≥
Most nyisd meg a
http://127.0.0.1:8000/docs
c√≠met.
Az automatikus interakt√≠v API dokument√°ci√≥t fogod l√°tni (amit a
Swagger UI
-al hozunk l√©tre):
Alternat√≠v API dokument√°ci√≥
√âs most menj el a
http://127.0.0.1:8000/redoc
c√≠mre.
Az alternat√≠v automatikus dokument√°ci√≥t fogod l√°tni. (l√°sd
ReDoc
):
P√©lda friss√≠t√©se
M√≥dos√≠tsuk a
main.py
f√°jlt, hogy
PUT
k√©r√©sek eset√©n tudjon body-t fogadni.
Deklar√°ld a body-t standard Python t√≠pusokkal, a Pydantic-nak k√∂sz√∂nhet≈ëen.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
A szerver automatikusan √∫jraindul (mert hozz√°adtuk a --reload param√©tert a fenti
uvicorn
parancshoz).
Interakt√≠v API dokument√°ci√≥ friss√≠t√©se
Most menj el a
http://127.0.0.1:8000/docs
c√≠mre.
Az interakt√≠v API dokument√°ci√≥ automatikusan friss√ºlt √≠gy m√°r benne van az √∫j body.
Kattints r√° a "Try it out" gombra, ennek seg√≠ts√©g√©vel kit√∂ltheted a param√©tereket √©s k√∂zvetlen haszn√°lhatod az API-t:
Ezut√°n kattints az "Execute" gompra, a felhaszn√°l√≥i fel√ºlet kommunik√°lni fog az API-oddal. Elk√ºldi a param√©tereket √©s a visszakapott v√°laszt megmutatja a k√©perny≈ëd√∂n.
Alternat√≠v API dokument√°ci√≥ friss√≠t√©s
Most menj el a
http://127.0.0.1:8000/redoc
c√≠mre.
Az alternat√≠v dokument√°ci√≥ szint√∫gy t√ºkr√∂zni fogja az √∫j k√©r√©si param√©ter √©s body-t.
√ñsszefoglal√°s
√ñsszegz√©s√ºl, deklar√°lod
egyszer
a param√©terek, body, stb t√≠pus√°t funkci√≥s param√©terekk√©nt.
Ezt standard modern Python t√≠pusokkal csin√°lod.
Nem kell √∫j szintaxist, vagy specifikus k√∂nyvt√°r mert met√≥d√≥sait, stb. megtanulnod.
Csak standard
Python
.
P√©ld√°ul egy
int
-nek:
item_id
:
int
Egy komplexebb
Item
modellnek:
item
:
Item
... √âs csup√°n egy deklar√°ci√≥val megkapod a:
Szerkeszt≈ë t√°mogat√°st, bele√©rtve:
Sz√∂vegkieg√©sz√≠t√©s.
T√≠pus ellen≈ërz√©s.
Adatok valid√°ci√≥ja:
Automatikus √©s √©rthet≈ë hib√°k amikor az adatok hib√°sak.
Valid√°ci√≥ m√©lyen √°gyazott objektumok eset√©n is.
Bemeneti adatok
√°tv√°lt√°sa
: a h√°l√≥zatr√≥l √©rkez≈ë Python adatokk√° √©s t√≠pusokk√°. Adatok olvas√°sa k√∂vetkez≈ë forr√°sokb√≥l:
JSON.
C√≠m param√©terek.
Query param√©terek.
Cookie-k.
Header-√∂k.
Formok.
F√°jlok.
Kimeneti adatok
√°tv√°lt√°sa
: Python adatok is t√≠pusokr√≥l h√°l√≥zati adatokk√°:
v√°lts √°t Python t√≠pusokat (
str
,
int
,
float
,
bool
,
list
, etc).
datetime
csak objektumokat.
UUID
objektumokat.
Adatb√°zis modelleket.
...√âs sok m√°st.
Automatikus interakt√≠v dokument√°ci√≥, bele√©rtve k√©t alternat√≠v dokument√°ci√≥t is:
Swagger UI.
ReDoc.
Visszat√©rve az el≈ëz≈ë k√≥d p√©ld√°hoz. A
FastAPI
:
Valid√°lja hogy van egy
item_id
mez≈ë a
GET
√©s
PUT
k√©r√©sekben.
Valid√°lja hogy az
item_id
int
t√≠pus√∫ a
GET
√©s
PUT
k√©r√©sekben.
Ha nem akkor l√°tni fogunk egy tiszta hib√°t ezzel kapcsolatban.
ellen≈ërzi hogyha van egy opcion√°lis query param√©ter
q
n√©vvel (azaz
http://127.0.0.1:8000/items/foo?q=somequery
)
GET
k√©r√©sek eset√©n.
Mivel a
q
param√©ter
= None
-al van deklar√°lva, ez√©rt opcion√°lis.
None
n√©lk√ºl ez a mez≈ë k√∂telez≈ë lenne (mint p√©ld√°ul a body
PUT
k√©r√©sek eset√©n).
a
/items/{item_id}
c√≠mre √©rkez≈ë
PUT
k√©r√©sek eset√©n, a JSON-t a k√∂vetkez≈ëk√©ppen olvassa be:
Ellen≈ërzi hogy l√©tezik a k√∂telez≈ë
name
nev≈± attrib√∫tum √©s
string
.
Ellen≈ërzi hogy l√©tezik a k√∂telez≈ë
price
nev≈± attrib√∫tum √©s
float
.
Ellen≈ërzi hogy l√©tezik a
is_offer
nev≈± opcion√°lis param√©ter, ami ha l√©tezik akkor
bool
Ez √°gyazott JSON objektumokkal is m≈±k√∂dik
JSONr≈ël val√≥ automatikus konvert√°l√°s.
dokument√°ljuk mindent OpenAPI-al amit haszn√°lhat√≥:
Interakt√≠v dokument√°ci√≥s rendszerekkel.
Automatikus kliens k√≥d gener√°l√≥ a rendszerekkel, t√∂bb nyelven.
Hozz√° tartozik kett≈ë interakt√≠v dokument√°ci√≥s web fel√ºlet.
Eddig csak a felsz√≠nt kapargattuk, de a l√©nyeg hogy most m√°r k√∂nnyebben √©rthet≈ë hogyan m≈±k√∂dik.
Pr√≥b√°ld kicser√©lni a k√∂vetkez≈ë sorban:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...ezt:
...
"item_name"
:
item
.
name
...
...erre:
...
"item_price"
:
item
.
price
...
... √âs figyeld meg hogy a szerkeszt≈ë automatikusan tudni fogja a t√≠pusokat √©s kieg√©sz√≠ti azokat:
Teljesebb p√©ld√°k√©rt √©s funkci√≥k√©rt tekintsd meg a
Tutorial - User Guide
-t.
Spoiler vesz√©ly
: a Tutorial - User Guidehoz tartozik:
Param√©terek
deklar√°ci√≥ja k√ºl√∂nb√∂z≈ë helyekr≈ël:
header-√∂k
,
cookie-k
,
form mez≈ëk
√©s
f√°jlok
.
Hogyan √°ll√≠ts be
valid√°ci√≥s felt√©teleket
mint a
maximum_length
vagy a
regex
.
Nagyon hat√©kony √©s er≈ës
F√ºgg≈ës√©g Injekci√≥
rendszerek.
Biztons√°g √©s autentik√°ci√≥ bele√©rtve,
OAuth2
,
JWT tokens
√©s
HTTP Basic
t√°mogat√°st.
T√∂bb halad√≥ (de ugyanannyira k√∂nny≈±) technika
m√©lyen √°gyazott JSON modellek deklar√°ci√≥j√°ra
(Pydantic-nek k√∂sz√∂nhet≈ëen).
GraphQL
integr√°ci√≥
Strawberry
-vel √©s m√°s k√∂nyvt√°rakkal.
t√∂bb extra funkci√≥ (Starlette-nek k√∂sz√∂nhet≈ëen) pl.:
WebSockets
rendk√≠v√ºl k√∂nny≈± tesztek HTTPX √©s
pytest
alapokra √©p√≠tve
CORS
Cookie Sessions
...√©s t√∂bb.
Teljes√≠tm√©ny
A f√ºggetlen TechEmpower benchmarkok szerint az Uvicorn alatt fut√≥
FastAPI
alkalmaz√°sok az
egyik leggyorsabb Python keretrendszerek k√∂z√© tartoznak
, √©ppen lemaradva a Starlette √©s az Uvicorn (melyeket a FastAPI bels≈ëleg haszn√°l) m√∂g√∂tt.(*)
Ezeknek a tov√°bbi meg√©rt√©s√©hez:
Benchmarks
.
Opcion√°lis k√∂vetelm√©nyek
Pydantic √°ltal haszn√°lt:
email-validator
- e-mail valid√°ci√≥kra.
pydantic-settings
- Be√°ll√≠t√°sok k√∂vet√©s√©re.
pydantic-extra-types
- Extra t√≠pusok Pydantic-hoz.
Starlette √°ltal haszn√°lt:
httpx
- K√∂vetelm√©ny ha a
TestClient
-et akarod haszn√°lni.
jinja2
- K√∂vetelm√©ny ha az alap template konfigur√°ci√≥t akarod haszn√°lni.
python-multipart
- K√∂vetelm√©ny ha
"parsing"
-ot akarsz t√°mogatni,
request.form()
-al.
itsdangerous
- K√∂vetelm√©ny
SessionMiddleware
t√°mogat√°shoz.
pyyaml
- K√∂vetelm√©ny a Starlette
SchemaGenerator
-√°nak t√°mogat√°s√°hoz (val√≥sz√≠n≈±leg erre nincs sz√ºks√©g FastAPI haszn√°l√°sa eset√©n).
FastAPI / Starlette √°ltal haszn√°lt
uvicorn
- Szerverekhez am√≠g bet√∂ltik √©s szolg√°ltatj√°k az applik√°ci√≥dat.
orjson
- K√∂vetelm√©ny ha
ORJSONResponse
-t akarsz haszn√°lni.
ujson
- K√∂vetelm√©ny ha
UJSONResponse
-t akarsz haszn√°lni.
Ezeket mind telep√≠theted a
pip install "fastapi[all]"
paranccsal.
Licensz
Ez a projekt az MIT license, licensz alatt fut

## 070_ID
FastAPI¬∂
---

FastAPI
FastAPI, framework performa tinggi, mudah dipelajari, cepat untuk coding, siap untuk pengembangan
Dokumentasi
:
https://fastapi.tiangolo.com
Kode Sumber
:
https://github.com/fastapi/fastapi
FastAPI adalah
framework
web
moderen, cepat (performa-tinggi) untuk membangun API dengan Python berdasarkan tipe petunjuk Python.
Fitur utama FastAPI:
Cepat
: Performa sangat tinggi, setara
NodeJS
dan
Go
(berkat Starlette dan Pydantic).
Salah satu
framework
Python tercepat yang ada
.
Cepat untuk coding
: Meningkatkan kecepatan pengembangan fitur dari 200% sampai 300%. *
Sedikit bug
: Mengurangi hingga 40% kesalahan dari manusia (pemrogram). *
Intuitif
: Dukungan editor hebat.
Penyelesaian
di mana pun. Lebih sedikit
debugging
.
Mudah
: Dibuat mudah digunakan dan dipelajari. Sedikit waktu membaca dokumentasi.
Ringkas
: Mengurasi duplikasi kode. Beragam fitur dari setiap deklarasi parameter. Lebih sedikit
bug
.
Handal
: Dapatkan kode siap-digunakan. Dengan dokumentasi otomatis interaktif.
Standar-resmi
: Berdasarkan (kompatibel dengan ) standar umum untuk API:
OpenAPI
(sebelumnya disebut Swagger) dan
JSON Schema
.
* estimasi berdasarkan pengujian tim internal pengembangan applikasi siap pakai.
Sponsor
Sponsor lainnya
Opini
"
[...] Saya banyak menggunakan
FastAPI
sekarang ini. [...] Saya berencana menggunakannya di semua tim servis ML Microsoft. Beberapa dari mereka sudah mengintegrasikan dengan produk inti
Windows
* dan sebagian produk
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
Kami adopsi library
FastAPI
untuk membuat server
REST
yang melakukan kueri untuk menghasilkan
prediksi
. [untuk Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
dengan bangga mengumumkan rilis open-source orkestrasi framework
manajemen krisis
:
Dispatch
! [dibuat dengan
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Saya sangat senang dengan
FastAPI
. Sangat menyenangkan!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Jujur, apa yang anda buat sangat solid dan berkualitas. Ini adalah yang saya inginkan di
Hug
- sangat menginspirasi melihat seseorang membuat ini.
"
Timothy Crosley -
Hug
creator
(ref)
"
Jika anda ingin mempelajari
framework moderen
untuk membangun REST API, coba
FastAPI
[...] cepat, mudah digunakan dan dipelajari [...]
"
"
Kami sudah pindah ke
FastAPI
untuk
API
kami [...] Saya pikir kamu juga akan suka [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
Jika anda ingin membuat API Python siap pakai, saya merekomendasikan
FastAPI
. FastAPI
didesain indah
,
mudah digunakan
dan
sangat scalable
, FastAPI adalah
komponen kunci
di strategi pengembangan API pertama kami dan mengatur banyak otomatisasi dan service seperti TAC Engineer kami.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, CLI FastAPI
Jika anda mengembangkan app
CLI
yang digunakan di terminal bukan sebagai API web, kunjungi
Typer
.
Typer
adalah saudara kecil FastAPI. Dan ditujukan sebagai
CLI FastAPI
. ‚å®Ô∏è üöÄ
Prayarat
FastAPI berdiri di pundak raksasa:
Starlette
untuk bagian web.
Pydantic
untuk bagian data.
Instalasi
Buat dan aktifkan
virtual environment
kemudian
install
FastAPI:
fast ‚Üí
pip install "fastapi[standard]"
restart ‚Üª
Catatan
: Pastikan anda menulis
"fastapi[standard]"
dengan tanda petik untuk memastikan bisa digunakan di semua
terminal
.
Contoh
Buat app
Buat file
main.py
dengan:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Atau gunakan
async def
...
Jika kode anda menggunakan
async
/
await
, gunakan
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Catatan
:
Jika anda tidak paham, kunjungi
"Panduan cepat"
bagian
async
dan
await
di dokumentasi
.
Jalankan
Jalankan
server
dengan:
fast ‚Üí
fastapi dev main.py
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FastAPI CLI - Development mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ ‚îÇ
‚îÇ Serving at: http://127.0.0.1:8000 ‚îÇ
‚îÇ ‚îÇ
‚îÇ API docs: http://127.0.0.1:8000/docs ‚îÇ
‚îÇ ‚îÇ
‚îÇ Running in development mode, for production use: ‚îÇ
‚îÇ ‚îÇ
‚îÇ fastapi run ‚îÇ
‚îÇ ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
Mengenai perintah
fastapi dev main.py
...
Perintah
fastapi dev
membaca file
main.py
, memeriksa app
FastAPI
di dalamnya, dan menjalan server dengan
Uvicorn
.
Secara otomatis,
fastapi dev
akan mengaktifkan
auto-reload
untuk pengembangan lokal.
Informasi lebih lanjut kunjungi
Dokumen FastAPI CLI
.
Periksa
Buka
browser
di
http://127.0.0.1:8000/items/5?q=somequery
.
Anda akan melihat respon JSON berikut:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Anda telah membuat API:
Menerima permintaan HTTP di
path
/
dan
/items/{item_id}
.
Kedua
paths
menerima
operasi
GET
(juga disebut
metode
HTTP).
path
/items/{item_id}
memiliki
parameter path
item_id
yang harus berjenis
int
.
path
/items/{item_id}
memiliki
query parameter
q
berjenis
str
.
Dokumentasi API interaktif
Sekarang kunjungi
http://127.0.0.1:8000/docs
.
Anda akan melihat dokumentasi API interaktif otomatis (dibuat oleh
Swagger UI
):
Dokumentasi API alternatif
Kemudian kunjungi
http://127.0.0.1:8000/redoc
.
Anda akan melihat dokumentasi alternatif otomatis (dibuat oleh
ReDoc
):
Contoh upgrade
Sekarang ubah
main.py
untuk menerima struktur permintaan
PUT
.
Deklarasikan struktur menggunakan tipe standar Python, berkat Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Server
fastapi dev
akan otomatis memuat kembali.
Upgrade dokumentasi API interaktif
Kunjungi
http://127.0.0.1:8000/docs
.
Dokumentasi API interaktif akan otomatis diperbarui, termasuk kode yang baru:
Klik tombol "Try it out", anda dapat mengisi parameter dan langsung berinteraksi dengan API:
Kemudian klik tombol "Execute", tampilan pengguna akan berkomunikasi dengan API, mengirim parameter, mendapatkan dan menampilkan hasil ke layar:
Upgrade dokumentasi API alternatif
Kunjungi
http://127.0.0.1:8000/redoc
.
Dokumentasi alternatif akan menampilkan parameter
query
dan struktur
request
:
Ringkasan
Singkatnya, anda mendeklarasikan
sekali
jenis parameter, struktur, dll. sebagai parameter fungsi.
Anda melakukannya dengan tipe standar moderen Python.
Anda tidak perlu belajar sintaksis, metode,
classs
baru dari
library
tertentu, dll.
Cukup
Python
standar.
Sebagai contoh untuk
int
:
item_id
:
int
atau untuk model lebih rumit
Item
:
item
:
Item
...dengan sekali deklarasi anda mendapatkan:
Dukungan editor, termasuk:
Pelengkapan kode.
Pengecekan tipe.
Validasi data:
Kesalahan otomatis dan jelas ketika data tidak sesuai.
Validasi hingga untuk object JSON bercabang mendalam.
Konversi
input data: berasal dari jaringan ke data dan tipe Python. Membaca dari:
JSON.
Parameter path.
Parameter query.
Cookie.
Header.
Form.
File.
Konversi
output data: konversi data Python ke tipe jaringan data (seperti JSON):
Konversi tipe Python (
str
,
int
,
float
,
bool
,
list
, dll).
Objek
datetime
.
Objek
UUID
.
Model database.
...dan banyak lagi.
Dokumentasi interaktif otomatis, termasuk 2 alternatif tampilan pengguna:
Swagger UI.
ReDoc.
Kembali ke kode contoh sebelumnya,
FastAPI
akan:
Validasi apakah terdapat
item_id
di
path
untuk permintaan
GET
dan
PUT
requests.
Validasi apakah
item_id
berjenit
int
untuk permintaan
GET
dan
PUT
.
Jika tidak, klien akan melihat pesan kesalahan jelas.
Periksa jika ada parameter
query
opsional bernama
q
(seperti
http://127.0.0.1:8000/items/foo?q=somequery
) untuk permintaan
GET
.
Karena parameter
q
dideklarasikan dengan
= None
, maka bersifat opsional.
Tanpa
None
maka akan menjadi wajib ada (seperti struktur di kondisi dengan
PUT
).
Untuk permintaan
PUT
/items/{item_id}
, membaca struktur sebagai JSON:
Memeriksa terdapat atribut wajib
name
harus berjenis
str
.
Memeriksa terdapat atribut wajib
price
harus berjenis
float
.
Memeriksa atribut opsional
is_offer
, harus berjenis
bool
, jika ada.
Semua ini juga sama untuk objek json yang bersarang mendalam.
Konversi dari dan ke JSON secara otomatis.
Dokumentasi segalanya dengan OpenAPI, dengan menggunakan:
Sistem dokumentasi interaktif.
Sistem otomatis penghasil kode, untuk banyak bahasa.
Menyediakan 2 tampilan dokumentasi web interaktif dengan langsung.
Kita baru menyentuh permukaannya saja, tetapi anda sudah mulai paham gambaran besar cara kerjanya.
Coba ubah baris:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...dari:
...
"item_name"
:
item
.
name
...
...menjadi:
...
"item_price"
:
item
.
price
...
...anda akan melihat kode editor secara otomatis melengkapi atributnya dan tahu tipe nya:
Untuk contoh lengkap termasuk fitur lainnya, kunjungi
Tutorial - Panduan Pengguna
.
Peringatan spoiler
: tutorial - panduan pengguna termasuk:
Deklarasi
parameter
dari tempat berbeda seperti:
header
,
cookie
,
form field
and
file
.
Bagaimana mengatur
batasan validasi
seperti
maximum_length
atau
regex
.
Sistem
Dependency Injection
yang hebat dan mudah digunakan.
Keamanan dan autentikasi, termasuk dukungan ke
OAuth2
dengan
JWT token
dan autentikasi
HTTP Basic
.
Teknik lebih aju (tetapi mudah dipakai untuk deklarasi
model JSON bersarang ke dalam
(berkat Pydantic).
Integrasi
GraphQL
dengan
Strawberry
dan library lainnya.
Fitur lainnya (berkat Starlette) seperti:
WebSocket
Test yang sangat mudah berdasarkan HTTPX dan
pytest
CORS
Cookie Session
...dan lainnya.
Performa
Tolok ukur Independent TechEmpower mendapati aplikasi
FastAPI
berjalan menggunakan Uvicorn sebagai
salah satu framework Python tercepat yang ada
, hanya di bawah Starlette dan Uvicorn itu sendiri (digunakan di internal FastAPI). (*)
Penjelasan lebih lanjut, lihat bagian
Tolok ukur
.
Dependensi
FastAPI bergantung pada Pydantic dan Starlette.
Dependensi
standar
Ketika anda meng-
install
FastAPI dengan
pip install "fastapi[standard]"
, maka FastAPI akan menggunakan sekumpulan dependensi opsional
standar
:
Digunakan oleh Pydantic:
email-validator
- untuk validasi email.
Digunakan oleh Starlette:
httpx
- Dibutuhkan jika anda menggunakan
TestClient
.
jinja2
- Dibutuhkan jika anda menggunakan konfigurasi template bawaan.
python-multipart
- Dibutuhkan jika anda menggunakan form dukungan
"parsing"
, dengan
request.form()
.
Digunakan oleh FastAPI / Starlette:
uvicorn
- untuk server yang memuat dan melayani aplikasi anda. Termasuk
uvicorn[standard]
, yang memasukan sejumlah dependensi (misal
uvloop
) untuk needed melayani dengan performa tinggi.
fastapi-cli
- untuk menyediakan perintah
fastapi
.
Tanpda dependensi
standard
Jika anda tidak ingin menambahkan dependensi opsional
standard
, anda dapat menggunakan
pip install fastapi
daripada
pip install "fastapi[standard]"
.
Dependensi Opsional Tambahan
Ada beberapa dependensi opsional yang bisa anda install.
Dependensi opsional tambahan Pydantic:
pydantic-settings
- untuk manajemen setting.
pydantic-extra-types
- untuk tipe tambahan yang digunakan dengan Pydantic.
Dependensi tambahan opsional FastAPI:
orjson
- Diperlukan jika anda akan menggunakan
ORJSONResponse
.
ujson
- Diperlukan jika anda akan menggunakan
UJSONResponse
.
Lisensi
Project terlisensi dengan lisensi MIT.

## 071_IT
FastAPI
FastAPI framework, alte prestazioni, facile da imparare, rapido da implementare, pronto per il rilascio in produzione
Documentazione
:
https://fastapi.tiangolo.com
Codice Sorgente
:
https://github.com/fastapi/fastapi
FastAPI √® un web framework moderno e veloce (a prestazioni elevate) che serve a creare API con Python 3.6+ basato sulle annotazioni di tipo di Python.
Le sue caratteristiche principali sono:
Velocit√†
: Prestazioni molto elevate, alla pari di
NodeJS
e
Go
(grazie a Starlette e Pydantic).
Uno dei framework Python pi√π veloci in circolazione
.
Veloce da programmare
: Velocizza il lavoro consentendo il rilascio di nuove funzionalit√† tra il 200% e il 300% pi√π rapidamente. *
Meno bug
: Riduce di circa il 40% gli errori che commettono gli sviluppatori durante la scrittura del codice. *
Intuitivo
: Grande supporto per gli editor di testo con
autocompletamento
in ogni dove. In questo modo si pu√≤ dedicare meno tempo al debugging.
Facile
: Progettato per essere facile da usare e imparare. Si riduce il tempo da dedicare alla lettura della documentazione.
Sintentico
: Minimizza la duplicazione di codice. Molteplici funzionalit√†, ognuna con la propria dichiarazione dei parametri. Meno errori.
Robusto
: Crea codice pronto per la produzione con documentazione automatica interattiva.
Basato sugli standard
: Basato su (e completamente compatibile con) gli open standard per le API:
OpenAPI
(precedentemente Swagger) e
JSON Schema
.
* Stima basata sull'esito di test eseguiti su codice sorgente di applicazioni rilasciate in produzione da un team interno di sviluppatori.
Sponsor
Altri sponsor
Recensioni
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, e Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I‚Äôm over the moon excited about
FastAPI
. It‚Äôs so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, la FastAPI delle CLI
Se stai sviluppando un'app
CLI
da usare nel terminale invece che una web API, ti consigliamo
Typer
.
Typer
√® il fratello minore di FastAPI. Ed √® stato ideato per essere la
FastAPI delle CLI
. ‚å®Ô∏è üöÄ
Requisiti
Python 3.6+
FastAPI √® basata su importanti librerie:
Starlette
per le parti web.
Pydantic
per le parti dei dati.
Installazione
fast ‚Üí
pip install fastapi
restart ‚Üª
Per il rilascio in produzione, sar√† necessario un server ASGI come
Uvicorn
oppure
Hypercorn
.
fast ‚Üí
pip install uvicorn[standard]
restart ‚Üª
Esempio
Crea un file
Crea un file
main.py
con:
from
fastapi
import
FastAPI
from
typing
import
Optional
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
str
=
Optional
[
None
]):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Oppure usa
async def
...
Se il tuo codice usa
async
/
await
, allora usa
async def
:
from
fastapi
import
FastAPI
from
typing
import
Optional
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Optional
[
str
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Nota
:
e vuoi approfondire, consulta la sezione
"In a hurry?"
su
async
e
await
nella documentazione
.
Esegui il server
Puoi far partire il server cos√¨:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
Informazioni sul comando
uvicorn main:app --reload
...
Vediamo il comando
uvicorn main:app
in dettaglio:
main
: il file
main.py
(il "modulo" Python).
app
: l'oggetto creato dentro
main.py
con la riga di codice
app = FastAPI()
.
--reload
: ricarica il server se vengono rilevati cambiamenti del codice. Usalo solo durante la fase di sviluppo.
Testa l'API
Apri il browser all'indirizzo
http://127.0.0.1:8000/items/5?q=somequery
.
Vedrai la seguente risposta JSON:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Hai appena creato un'API che:
Riceve richieste HTTP sui
paths
/
and
/items/{item_id}
.
Entrambi i
paths
accettano
GET
operations
(conosciuti anche come
HTTP
methods
).
Il
path
/items/{item_id}
ha un
path parameter
item_id
che deve essere un
int
.
Il
path
/items/{item_id}
ha una
str
query parameter
q
.
Documentazione interattiva dell'API
Adesso vai all'indirizzo
http://127.0.0.1:8000/docs
.
Vedrai la documentazione interattiva dell'API (offerta da
Swagger UI
):
Documentazione interattiva alternativa
Adesso accedi all'url
http://127.0.0.1:8000/redoc
.
Vedrai la documentazione interattiva dell'API (offerta da
ReDoc
):
Esempio pi√π avanzato
Adesso modifica il file
main.py
per ricevere un
body
da una richiesta
PUT
.
Dichiara il
body
usando le annotazioni di tipo standard di Python, grazie a Pydantic.
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
from
typing
import
Optional
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
bool
=
Optional
[
None
]
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Optional
[
str
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Il server dovrebbe ricaricarsi in automatico (perch√© hai specificato
--reload
al comando
uvicorn
lanciato precedentemente).
Aggiornamento della documentazione interattiva
Adesso vai su
http://127.0.0.1:8000/docs
.
La documentazione interattiva dell'API verr√† automaticamente aggiornata, includendo il nuovo
body
:
Fai click sul pulsante "Try it out", che ti permette di inserire i parametri per interagire direttamente con l'API:
Successivamente, premi sul pulsante "Execute". L'interfaccia utente comunicher√† con la tua API, invier√† i parametri, ricever√† i risultati della richiesta, e li mostrer√† sullo schermo:
Aggiornamento della documentazione alternativa
Ora vai su
http://127.0.0.1:8000/redoc
.
Anche la documentazione alternativa dell'API mostrer√† il nuovo parametro della query e il
body
:
Riepilogo
Ricapitolando, √® sufficiente dichiarare
una sola volta
i tipi dei parametri, del body, ecc. come parametri di funzioni.
Questo con le annotazioni per i tipi standard di Python.
Non c'√® bisogno di imparare una nuova sintassi, metodi o classi specifici a una libreria, ecc.
√à normalissimo
Python 3.6+
.
Per esempio, per un
int
:
item_id
:
int
o per un modello
Item
pi√π complesso:
item
:
Item
...e con quella singola dichiarazione hai in cambio:
Supporto per gli editor di testo, incluso:
Autocompletamento.
Controllo sulle annotazioni di tipo.
Validazione dei dati:
Errori chiari e automatici quando i dati sono invalidi.
Validazione anche per gli oggetti JSON pi√π complessi.
Conversione
dei dati di input: da risorse esterne a dati e tipi di Python. √à possibile leggere da:
JSON.
Path parameters.
Query parameters.
Cookies.
Headers.
Form.
File.
Conversione
dei dati di output: converte dati e tipi di Python a dati per la rete (come JSON):
Converte i tipi di Python (
str
,
int
,
float
,
bool
,
list
, ecc).
Oggetti
datetime
.
Oggetti
UUID
.
Modelli del database.
...e molto di pi√π.
Generazione di una documentazione dell'API interattiva, con scelta dell'interfaccia grafica:
Swagger UI.
ReDoc.
Tornando al precedente esempio,
FastAPI
:
Valider√† che esiste un
item_id
nel percorso delle richieste
GET
e
PUT
.
Valider√† che
item_id
sia di tipo
int
per le richieste
GET
e
PUT
.
Se non lo √®, il client vedr√† un errore chiaro e utile.
Controller√† se ci sia un parametro opzionale chiamato
q
(per esempio
http://127.0.0.1:8000/items/foo?q=somequery
) per le richieste
GET
.
Siccome il parametro
q
√® dichiarato con
= None
, √® opzionale.
Senza il
None
sarebbe stato obbligatorio (come per il body della richiesta
PUT
).
Per le richieste
PUT
su
/items/{item_id}
, legger√† il body come JSON, questo comprende:
verifica che la richiesta abbia un attributo obbligatorio
name
e che sia di tipo
str
.
verifica che la richiesta abbia un attributo obbligatorio
price
e che sia di tipo
float
.
verifica che la richiesta abbia un attributo opzionale
is_offer
e che sia di tipo
bool
, se presente.
Tutto questo funzionerebbe anche con oggetti JSON pi√π complessi.
Convertir√†
da
e
a
JSON automaticamente.
Documenter√† tutto con OpenAPI, che pu√≤ essere usato per:
Sistemi di documentazione interattivi.
Sistemi di generazione di codice dal lato client, per molti linguaggi.
Fornir√† 2 interfacce di documentazione dell'API interattive.
Questa √® solo la punta dell'iceberg, ma dovresti avere gi√† un'idea di come il tutto funzioni.
Prova a cambiare questa riga di codice:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...da:
...
"item_name"
:
item
.
name
...
...a:
...
"item_price"
:
item
.
price
...
...e osserva come il tuo editor di testo autocompleter√† gli attributi e sar√† in grado di riconoscere i loro tipi:
Per un esempio pi√π completo che mostra pi√π funzionalit√† del framework, consulta
Tutorial - Guida Utente
.
Spoiler alert
: il tutorial - Guida Utente include:
Dichiarazione di
parameters
da altri posti diversi come:
headers
,
cookies
,
form fields
e
files
.
Come stabilire
vincoli di validazione
come
maximum_length
o
regex
.
Un sistema di
Dependency Injection
facile da usare e molto potente.
e potente.
Sicurezza e autenticazione, incluso il supporto per
OAuth2
con
token JWT
e autenticazione
HTTP Basic
.
Tecniche pi√π avanzate (ma ugualmente semplici) per dichiarare
modelli JSON altamente nidificati
(grazie a Pydantic).
E altre funzionalit√† (grazie a Starlette) come:
WebSockets
GraphQL
test molto facili basati su
requests
e
pytest
CORS
Cookie Sessions
...e altro ancora.
Prestazioni
Benchmark indipendenti di TechEmpower mostrano che
FastAPI
basato su Uvicorn √®
uno dei framework Python pi√π veloci in circolazione
, solamente dietro a Starlette e Uvicorn (usate internamente da FastAPI). (*)
Per approfondire, consulta la sezione
Benchmarks
.
Dipendenze opzionali
Usate da Pydantic:
email-validator
- per la validazione di email.
Usate da Starlette:
requests
- Richiesto se vuoi usare il
TestClient
.
aiofiles
- Richiesto se vuoi usare
FileResponse
o
StaticFiles
.
jinja2
- Richiesto se vuoi usare la configurazione template di default.
python-multipart
- Richiesto se vuoi supportare il
"parsing"
con
request.form()
.
itsdangerous
- Richiesto per usare
SessionMiddleware
.
pyyaml
- Richiesto per il supporto dello
SchemaGenerator
di Starlette (probabilmente non ti serve con FastAPI).
graphene
- Richiesto per il supporto di
GraphQLApp
.
Usate da FastAPI / Starlette:
uvicorn
- per il server che carica e serve la tua applicazione.
orjson
- ichiesto se vuoi usare
ORJSONResponse
.
ujson
- Richiesto se vuoi usare
UJSONResponse
.
Puoi installarle tutte con
pip install fastapi[all]
.
Licenza
Questo progetto √® concesso in licenza in base ai termini della licenza MIT.

## 072_JA
FastAPI¬∂
---

FastAPI
FastAPI framework, high performance, easy to learn, fast to code, ready for production
„Éâ„Ç≠„É•„É°„É≥„Éà
:
https://fastapi.tiangolo.com
„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ
:
https://github.com/fastapi/fastapi
FastAPI „ÅØ„ÄÅPython„ÅÆÊ®ôÊ∫ñ„Åß„ÅÇ„ÇãÂûã„Éí„É≥„Éà„Å´Âü∫„Å•„ÅÑ„Å¶Python ‰ª•Èôç„ÅßAPI „ÇíÊßãÁØâ„Åô„Çã„Åü„ÇÅ„ÅÆ„ÄÅ„É¢„ÉÄ„É≥„Åß„ÄÅÈ´òÈÄü(È´ò„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ)„Å™„ÄÅWeb „Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ„Åß„Åô„ÄÇ
‰∏ª„Å™ÁâπÂæ¥:
È´òÈÄü
:
NodeJS
„ÇÑ
Go
‰∏¶„Åø„ÅÆ„Å®„Å¶„ÇÇÈ´ò„ÅÑ„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ (Starlette „Å® Pydantic „ÅÆ„Åä„Åã„Åí„Åß„Åô)„ÄÇ
ÊúÄ„ÇÇÈ´òÈÄü„Å™ Python „Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ„ÅÆ‰∏Ä„Å§„Åß„Åô
.
È´òÈÄü„Å™„Ç≥„Éº„Éá„Ç£„É≥„Ç∞
: ÈñãÁô∫ÈÄüÂ∫¶„ÇíÁ¥Ñ 200%~300%Âêë‰∏ä„Åï„Åõ„Åæ„Åô„ÄÇ *
Â∞ë„Å™„ÅÑ„Éê„Ç∞
: ÈñãÁô∫ËÄÖËµ∑Âõ†„ÅÆ„Éí„É•„Éº„Éû„É≥„Ç®„É©„Éº„ÇíÁ¥Ñ 40ÔºÖÂâäÊ∏õ„Åó„Åæ„Åô„ÄÇ *
Áõ¥ÊÑüÁöÑ
: Á¥†Êô¥„Çâ„Åó„ÅÑ„Ç®„Éá„Ç£„Çø„ÅÆ„Çµ„Éù„Éº„Éà„ÇÑ
„Ç™„Éº„Éà„Ç≥„É≥„Éó„É™„Éº„Éà„ÄÇ
„Éá„Éê„ÉÉ„Ç∞ÊôÇÈñì„ÇíÂâäÊ∏õ„Åó„Åæ„Åô„ÄÇ
Á∞°Âçò
: Á∞°Âçò„Å´Âà©Áî®„ÄÅÁøíÂæó„Åß„Åç„Çã„Çà„ÅÜ„Å´„Éá„Ç∂„Ç§„É≥„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíË™≠„ÇÄÊôÇÈñì„ÇíÂâäÊ∏õ„Åó„Åæ„Åô„ÄÇ
Áü≠„ÅÑ
: „Ç≥„Éº„Éâ„ÅÆÈáçË§á„ÇíÊúÄÂ∞èÈôê„Å´„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂêÑ„Éë„É©„É°„Éº„Çø„Åã„Çâ„ÅÆË§áÊï∞„ÅÆÊ©üËÉΩ„ÄÇÂ∞ë„Å™„ÅÑ„Éê„Ç∞„ÄÇ
Â†ÖÁâ¢ÊÄß
: Ëá™ÂãïÂØæË©±„Éâ„Ç≠„É•„É°„É≥„Éà„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÊú¨Áï™Áí∞Â¢É„Åß‰ΩøÁî®„Åß„Åç„Çã„Ç≥„Éº„Éâ„ÇíÂèñÂæó„Åó„Åæ„Åô„ÄÇ
Standards-based
: API „ÅÆ„Ç™„Éº„Éó„É≥„Çπ„Çø„É≥„ÉÄ„Éº„Éâ„Å´Âü∫„Å•„ÅÑ„Å¶„Åä„Çä„ÄÅÂÆåÂÖ®„Å´‰∫íÊèõÊÄß„Åå„ÅÇ„Çä„Åæ„Åô:
OpenAPI
(‰ª•Ââç„ÅØ Swagger „Å®„Åó„Å¶Áü•„Çâ„Çå„Å¶„ÅÑ„Åæ„Åó„Åü) „ÇÑ
JSON „Çπ„Ç≠„Éº„Éû
.
* Êú¨Áï™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíÊßãÁØâ„Åó„Å¶„ÅÑ„ÇãÈñãÁô∫„ÉÅ„Éº„É†„ÅÆ„ÉÜ„Çπ„Éà„Å´„Çà„ÇãË¶ãÁ©ç„ÇÇ„Çä„ÄÇ
Sponsors
Other sponsors
Ë©ï‰æ°
"
[...] ÊúÄËøë
FastAPI
„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ [...] ÂÆüÈöõ„Å´ÁßÅ„ÅÆ„ÉÅ„Éº„É†„ÅÆÂÖ®„Å¶„ÅÆ
Microsoft „ÅÆÊ©üÊ¢∞Â≠¶Áøí„Çµ„Éº„Éì„Çπ
„Åß‰ΩøÁî®„Åô„Çã‰∫àÂÆö„Åß„Åô„ÄÇ „Åù„ÅÆ„ÅÜ„Å°„ÅÆ„ÅÑ„Åè„Å§„Åã„ÅÆ„Ç≥„Ç¢„Å™
Windows
Ë£ΩÂìÅ„Å®
Office
Ë£ΩÂìÅ„Å´Áµ±Âêà„Åï„Çå„Å§„Å§„ÅÇ„Çä„Åæ„Åô„ÄÇ
"
Kabir Khan -
Microsoft
(ref)
"
FastAPI„É©„Ç§„Éñ„É©„É™„ÇíÊé°Áî®„Åó„ÄÅ„ÇØ„Ç®„É™„Åß
‰∫àÊ∏¨ÂÄ§
„ÇíÂèñÂæó„Åß„Åç„Çã
REST
„Çµ„Éº„Éê„ÇíÊßãÁØâ„Åó„Åæ„Åó„Åü„ÄÇ [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
„ÅØ„ÄÅ
Âç±Ê©üÁÆ°ÁêÜ
„Ç™„Éº„Ç±„Çπ„Éà„É¨„Éº„Ç∑„Éß„É≥„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ„ÄÅ
Dispatch
„ÅÆ„Ç™„Éº„Éó„É≥„ÇΩ„Éº„Çπ„É™„É™„Éº„Çπ„ÇíÁô∫Ë°®„Åß„Åç„Çã„Åì„Å®„Çí„ÅÜ„Çå„Åó„ÅèÊÄù„ÅÑ„Åæ„Åô„ÄÇ [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
ÁßÅ„ÅØ
FastAPI
„Å´„ÉØ„ÇØ„ÉØ„ÇØ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ „ÇÅ„Å°„ÇÉ„Åè„Å°„ÇÉÊ•Ω„Åó„ÅÑ„Åß„ÅôÔºÅ
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Ê≠£Áõ¥„ÄÅË∂ÖÂ†ÖÂÆü„ÅßÊ¥óÁ∑¥„Åï„Çå„Å¶„ÅÑ„Çã„Çà„ÅÜ„Å´Ë¶ã„Åà„Åæ„Åô„ÄÇ„ÅÑ„Çç„Çì„Å™ÊÑèÂë≥„Åß„ÄÅ„Åù„Çå„ÅØÁßÅ„Åå„Éè„Ç∞„Åó„Åü„Åã„Å£„Åü„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
"
Timothy Crosley -
Hug
creator
(ref)
"
REST API „ÇíÊßãÁØâ„Åô„Çã„Åü„ÇÅ„ÅÆ
„É¢„ÉÄ„É≥„Å™„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ
„ÇíÂ≠¶„Å≥„Åü„ÅÑÊñπ„ÅØ„ÄÅ
FastAPI
[...] „Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ [...] È´òÈÄü„Åß, ‰ΩøÁî®„ÄÅÁøíÂæó„ÅåÁ∞°Âçò„Åß„Åô„ÄÇ[...]
"
"
ÁßÅ„Åü„Å°„ÅÆ
API
„ÅØ
FastAPI
„Å´Âàá„ÇäÊõø„Åà„Åæ„Åó„Åü„ÄÇ[...] „Åç„Å£„Å®Ê∞ó„Å´ÂÖ•„Çã„Å®ÊÄù„ÅÑ„Åæ„Åô„ÄÇ [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, the FastAPI of CLIs
„ÇÇ„Åó Web API „ÅÆ‰ª£„Çè„Çä„Å´„Çø„Éº„Éü„Éä„É´„Åß‰ΩøÁî®„Åô„Çã
CLI
„Ç¢„Éó„É™„ÇíÊßãÁØâ„Åô„ÇãÂ†¥Âêà„ÅØ„ÄÅ
Typer
„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Typer
„ÅØ FastAPI „ÅÆÂºüÂàÜ„Åß„Åô„ÄÇ„Åù„Åó„Å¶„ÄÅ
CLI Áâà „ÅÆ FastAPI
„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÂøÖË¶ÅÊù°‰ª∂
FastAPI „ÅØÂ∑®‰∫∫„ÅÆËÇ©„ÅÆ‰∏ä„Å´Á´ã„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Web „ÅÆÈÉ®ÂàÜ„ÅØ
Starlette
„Éá„Éº„Çø„ÅÆÈÉ®ÂàÜ„ÅØ
Pydantic
„Ç§„É≥„Çπ„Éà„Éº„É´
fast ‚Üí
pip install fastapi
restart ‚Üª
Êú¨Áï™Áí∞Â¢É„Åß„ÅØ„ÄÅ
Uvicorn
„Åæ„Åü„ÅØ„ÄÅ
Hypercorn
„ÅÆ„Çà„ÅÜ„Å™„ÄÅ ASGI „Çµ„Éº„Éê„Éº„ÅåÂøÖË¶Å„Å´„Å™„Çä„Åæ„Åô„ÄÇ
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥‰æã
„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ‰ΩúÊàê
main.py
„Çí‰ΩúÊàê„Åó„ÄÅ‰ª•‰∏ã„ÅÆ„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Åæ„Åô:
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
str
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
„Åæ„Åü„ÅØ
async def
„Çí‰Ωø„ÅÑ„Åæ„Åô...
async
/
await
„Çí‰ΩøÁî®„Åô„Çã„Å®„Åç„ÅØ„ÄÅ
async def
„Çí‰Ωø„ÅÑ„Åæ„Åô:
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
str
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Ê≥®
:
„Çè„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ
„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆ
async
„Å®
await
„Å´„ÅÇ„Çã
"In a hurry?"„Çª„ÇØ„Ç∑„Éß„É≥„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
ÂÆüË°å
‰ª•‰∏ã„ÅÆ„Ç≥„Éû„É≥„Éâ„Åß„Çµ„Éº„Éê„Éº„ÇíËµ∑Âãï„Åó„Åæ„Åô:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
uvicorn main:app --reload
„Ç≥„Éû„É≥„Éâ„Å´„Å§„ÅÑ„Å¶
uvicorn main:app
„Ç≥„Éû„É≥„Éâ„ÅØ‰ª•‰∏ã„ÅÆÈ†ÖÁõÆ„ÇíÂèÇÁÖß„Åó„Åæ„Åô:
main
:
main.py
„Éï„Ç°„Ç§„É´ (Python "„É¢„Ç∏„É•„Éº„É´")
app
:
main.py
„ÅÆ
app = FastAPI()
„ÅÆË°å„ÅßÁîüÊàê„Åï„Çå„Åü„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
--reload
: „Ç≥„Éº„Éâ„ÇíÂ§âÊõ¥„Åó„Åü„Çâ„Çµ„Éº„Éê„Éº„ÇíÂÜçËµ∑Âãï„Åó„Åæ„Åô„ÄÇ„Åì„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥„ÅØÈñãÁô∫Áí∞Â¢É„Åß„ÅÆ„Åø‰ΩøÁî®„Åó„Åæ„Åô
Âãï‰ΩúÁ¢∫Ë™ç
„Éñ„É©„Ç¶„Ç∂„Åã„Çâ
http://127.0.0.1:8000/items/5?q=somequery
„ÇíÈñã„Åç„Åæ„Åô„ÄÇ
‰ª•‰∏ã„ÅÆ JSON „ÅÆ„É¨„Çπ„Éù„É≥„Çπ„ÅåÁ¢∫Ë™ç„Åß„Åç„Åæ„Åô:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
„ÇÇ„ÅÜ„Åô„Åß„Å´‰ª•‰∏ã„ÅÆ API „Åå‰ΩúÊàê„Åï„Çå„Å¶„ÅÑ„Åæ„Åô:
/
„Å®
/items/{item_id}
„ÅÆ„Éë„Çπ„Åß HTTP „É™„ÇØ„Ç®„Çπ„Éà„ÇíÂèó„Åë„Åæ„Åô„ÄÇ
„Å©„Å°„Çâ„ÅÆ„Éë„Çπ„ÇÇ
GET
Êìç‰Ωú
„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ(HTTP „É°„ÇΩ„ÉÉ„Éâ„Å®„Åó„Å¶„ÇÇÁü•„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ)
/items/{item_id}
„Éë„Çπ„ÅÆ„Éë„Çπ„Éë„É©„É°„Éº„Çø
item_id
„ÅØ
int
„Åß„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ
„Éë„Çπ
/items/{item_id}
„ÅØ„Ç™„Éó„Ç∑„Éß„É≥„ÅÆ
str
„ÇØ„Ç®„É™„Éë„É©„É°„Éº„Çø
q
„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ
Ëá™ÂãïÂØæË©±Âûã„ÅÆ API „Éâ„Ç≠„É•„É°„É≥„Éà
http://127.0.0.1:8000/docs
„Å´„Ç¢„ÇØ„Çª„Çπ„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Ëá™ÂãïÂØæË©±Âûã„ÅÆ API „Éâ„Ç≠„É•„É°„É≥„Éà„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ (
Swagger UI
„ÅåÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ):
‰ª£Êõø„ÅÆ API „Éâ„Ç≠„É•„É°„É≥„Éà
http://127.0.0.1:8000/redoc
„Å´„Ç¢„ÇØ„Çª„Çπ„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
‰ª£Êõø„ÅÆËá™Âãï„Éâ„Ç≠„É•„É°„É≥„Éà„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ(
ReDoc
„ÅåÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ):
„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ‰æã
PUT
„É™„ÇØ„Ç®„Çπ„Éà„Åã„Çâ„Éú„Éá„Ç£„ÇíÂèó„ÅëÂèñ„Çã„Åü„ÇÅ„Å´
main.py
„Çí‰øÆÊ≠£„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
Pydantic „Å´„Çà„Å£„Å¶„ÄÅPython „ÅÆÊ®ôÊ∫ñÁöÑ„Å™Âûã„Çí‰Ωø„Å£„Å¶„Éú„Éá„Ç£„ÇíÂÆ£Ë®Ä„Åó„Åæ„Åô„ÄÇ
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
bool
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
str
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
„Çµ„Éº„Éê„Éº„ÅØËá™Âãï„Åß„É™„É≠„Éº„Éâ„Åï„Çå„Åæ„Åô„ÄÇ(‰∏äËø∞„ÅÆ
uvicorn
„Ç≥„Éû„É≥„Éâ„Åß
--reload
„Ç™„Éó„Ç∑„Éß„É≥„ÇíËøΩÂä†„Åó„Å¶„ÅÑ„Çã„Åã„Çâ„Åß„Åô„ÄÇ)
Ëá™ÂãïÂØæË©±Âûã„ÅÆ API „Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆ„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ
http://127.0.0.1:8000/docs
„Å´„Ç¢„ÇØ„Çª„Çπ„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
Ëá™ÂãïÂØæË©±Âûã„ÅÆ API „Éâ„Ç≠„É•„É°„É≥„Éà„ÅåÊñ∞„Åó„ÅÑ„Éú„Éá„Ç£„ÇÇÂê´„ÇÅ„Å¶Ëá™Âãï„Åß„Ç¢„ÉÉ„Éó„Éá„Éº„Éà„Åï„Çå„Åæ„Åô:
"Try it out"„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Éë„É©„É°„Éº„Çø„ÇíÂÖ•Âäõ„Åó„Å¶ API „Å®Áõ¥Êé•„ÇÑ„Çä„Å®„Çä„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô:
„Åù„Çå„Åã„Çâ„ÄÅ"Execute" „Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ „É¶„Éº„Ç∂„Éº„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„ÅØ API „Å®ÈÄö‰ø°„Åó„ÄÅ„Éë„É©„É°„Éº„Çø„ÇíÈÄÅ‰ø°„Åó„ÄÅÁµêÊûú„ÇíÂèñÂæó„Åó„Å¶ÁîªÈù¢„Å´Ë°®Á§∫„Åó„Åæ„Åô:
‰ª£Êõø„ÅÆ API „Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆ„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ
http://127.0.0.1:8000/redoc
„Å´„Ç¢„ÇØ„Çª„Çπ„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
‰ª£Êõø„ÅÆ API „Éâ„Ç≠„É•„É°„É≥„Éà„Å´„ÇÇÊñ∞„Åó„ÅÑ„ÇØ„Ç®„É™„Éë„É©„É°„Éº„Çø„ÇÑ„Éú„Éá„Ç£„ÅåÂèçÊò†„Åï„Çå„Åæ„Åô„ÄÇ
„Åæ„Å®„ÇÅ
Ë¶ÅÁ¥Ñ„Åô„Çã„Å®„ÄÅÈñ¢Êï∞„ÅÆ„Éë„É©„É°„Éº„Çø„Å®„Åó„Å¶„ÄÅ„Éë„É©„É°„Éº„Çø„ÇÑ„Éú„Éá„Ç£ „Å™„Å©„ÅÆÂûã„Çí
‰∏ÄÂ∫¶„Å†„Åë
ÂÆ£Ë®Ä„Åó„Åæ„Åô„ÄÇ
Ê®ôÊ∫ñÁöÑ„Å™ÊúÄÊñ∞„ÅÆ Python „ÅÆÂûã„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Êñ∞„Åó„ÅÑÊßãÊñá„ÇÑÁâπÂÆö„ÅÆ„É©„Ç§„Éñ„É©„É™„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÇÑ„ÇØ„É©„Çπ„Å™„Å©„ÇíË¶ö„Åà„ÇãÂøÖË¶Å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
Âçò„Å™„ÇãÊ®ôÊ∫ñÁöÑ„Å™
3.8 ‰ª•Èôç„ÅÆ Python
„Åß„Åô„ÄÇ
‰æã„Åà„Å∞„ÄÅ
int
„ÅÆÂ†¥Âêà:
item_id
:
int
„Åæ„Åü„ÅØ„ÄÅ„Çà„ÇäË§áÈõë„Å™
Item
„É¢„Éá„É´„ÅÆÂ†¥Âêà:
item
:
Item
...„Åù„Åó„Å¶„ÄÅ„Åì„ÅÆ‰∏ÄÂ∫¶„ÅÆÂÆ£Ë®Ä„Åß„ÄÅ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô:
‰ª•‰∏ã„ÇíÂê´„ÇÄ„Ç®„Éá„Ç£„Çø„Çµ„Éù„Éº„Éà:
Ë£úÂÆå
„Çø„Ç§„Éó„ÉÅ„Çß„ÉÉ„ÇØ
„Éá„Éº„Çø„ÅÆÊ§úË®º:
„Éá„Éº„Çø„ÅåÁÑ°Âäπ„Å™Â†¥Âêà„Å´Ëá™Âãï„Åß„Ç®„É©„Éº„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÄÇ
Ê∑±„ÅÑÂÖ•„ÇåÂ≠ê„Å´„Å™„Å£„Åü JSON „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åß„ÇÇÊ§úË®º„ÅåÂèØËÉΩ„Åß„Åô„ÄÇ
ÂÖ•Âäõ„Éá„Éº„Çø„ÅÆ
Â§âÊèõ
: „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Åã„Çâ Python „ÅÆ„Éá„Éº„Çø„ÇÑÂûã„Å´Â§âÊèõ„Åó„Å¶„Åã„ÇâË™≠„ÅøÂèñ„Çä„Åæ„Åô:
JSON.
„Éë„Çπ„Éë„É©„É°„Éº„Çø
„ÇØ„Ç®„É™„Éë„É©„É°„Éº„Çø
„ÇØ„ÉÉ„Ç≠„Éº
„Éò„ÉÉ„ÉÄ„Éº
„Éï„Ç©„Éº„É†
„Éï„Ç°„Ç§„É´
Âá∫Âäõ„Éá„Éº„Çø„ÅÆ
Â§âÊèõ
: Python „ÅÆ„Éá„Éº„Çø„ÇÑÂûã„Åã„Çâ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Éá„Éº„Çø„Å∏Â§âÊèõ„Åó„Åæ„Åô (JSON „Å®„Åó„Å¶):
Convert Python types (
str
,
int
,
float
,
bool
,
list
, etc).
datetime
„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
UUID
„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
„Éá„Éº„Çø„Éô„Éº„Çπ„É¢„Éá„É´
...„Å™„Å©„Å™„Å©
2 „Å§„ÅÆ‰ª£Êõø„É¶„Éº„Ç∂„Éº„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„ÇíÂê´„ÇÄËá™Âãï„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ API „Éâ„Ç≠„É•„É°„É≥„Éà:
Swagger UI.
ReDoc.
„Ç≥„Éº„Éâ‰æã„Å´Êàª„Çä„Åæ„Åó„Çá„ÅÜ„ÄÅ
FastAPI
„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô:
GET
„Åä„Çà„Å≥
PUT
„É™„ÇØ„Ç®„Çπ„Éà„ÅÆ„Éë„Çπ„Å´
item_id
„Åå„ÅÇ„Çã„Åì„Å®„ÇíÊ§úË®º„Åó„Åæ„Åô„ÄÇ
item_id
„Åå
GET
„Åä„Çà„Å≥
PUT
„É™„ÇØ„Ç®„Çπ„Éà„Å´ÂØæ„Åó„Å¶
int
Âûã„Åß„ÅÇ„Çã„Åì„Å®„ÇíÊ§úË®º„Åó„Åæ„Åô„ÄÇ
„Åù„ÅÜ„Åß„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅØÊúâÁî®„ÅßÊòéÁ¢∫„Å™„Ç®„É©„Éº„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ
GET
„É™„ÇØ„Ç®„Çπ„Éà„Å´ÂØæ„Åó„Å¶„Ç™„Éó„Ç∑„Éß„É≥„ÅÆ„ÇØ„Ç®„É™„Éë„É©„É°„Éº„Çø
q
(
http://127.0.0.1:8000/items/foo?q=somequery
„ÅÆ„Çà„ÅÜ„Å´) „ÅåÂ≠òÂú®„Åô„Çã„Åã„Å©„ÅÜ„Åã„ÇíË™ø„Åπ„Åæ„Åô„ÄÇ
„Éë„É©„É°„Éº„Çø
q
„ÅØ
= None
„ÅßÂÆ£Ë®Ä„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ„Ç™„Éó„Ç∑„Éß„É≥„Åß„Åô„ÄÇ
None
„Åå„Å™„Åë„Çå„Å∞ÂøÖÈ†à„Å´„Å™„Çä„Åæ„ÅôÔºà
PUT
„ÅÆÂ†¥Âêà„ÅÆ„Éú„Éá„Ç£„Å®ÂêåÊßò„Åß„ÅôÔºâ„ÄÇ
PUT
„É™„ÇØ„Ç®„Çπ„Éà„Çí
/items/{item_id}
„Å´ÈÄÅ‰ø°„Åô„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Éú„Éá„Ç£„Çí JSON „Å®„Åó„Å¶Ë™≠„ÅøËæº„Åø„Åæ„Åô:
ÂøÖÈ†à„ÅÆÂ±ûÊÄß
name
„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ „Åù„Çå„ÅØ
str
„Åß„ÅÇ„Çã„Åπ„Åç„Åß„Åô„ÄÇ
ÂøÖÈ†à„ÅÆÂ±ûÊÄß
price
„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åù„Çå„ÅØ
float
„Åß„Å™„Åë„Çå„Å∞„Å™„Çâ„Å™„ÅÑ„Åß„Åô„ÄÇ
„Ç™„Éó„Ç∑„Éß„É≥„ÅÆÂ±ûÊÄß
is_offer
„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÂÄ§„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅ
bool
„Åß„ÅÇ„Çã„Åπ„Åç„Åß„Åô„ÄÇ
„Åì„Çå„Çâ„ÅØ„Åô„Åπ„Å¶„ÄÅÊ∑±„Åè„Éç„Çπ„Éà„Åï„Çå„Åü JSON „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´ÂØæ„Åó„Å¶„ÇÇÂãï‰Ωú„Åó„Åæ„Åô„ÄÇ
JSON „Åã„Çâ JSON „Å´Ëá™ÂãïÁöÑ„Å´Â§âÊèõ„Åó„Åæ„Åô„ÄÇ
OpenAPI„Åß„Åô„Åπ„Å¶„ÇíÊñáÊõ∏Âåñ„Åó„ÄÅ‰ª•‰∏ã„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô:
ÂØæË©±ÁöÑ„Å™„Éâ„Ç≠„É•„É°„É≥„Éà„Ç∑„Çπ„ÉÜ„É†„ÄÇ
Â§ö„Åè„ÅÆË®ÄË™û„Å´ÂØæÂøú„Åó„ÅüËá™Âãï„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Ç≥„Éº„ÉâÁîüÊàê„Ç∑„Çπ„ÉÜ„É†„ÄÇ
2 „Å§„ÅÆÂØæË©±ÁöÑ„Å™„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆWeb„Ç§„É≥„Çø„Éº„Éï„Çß„Ç§„Çπ„ÇíÁõ¥Êé•Êèê‰æõ„Åó„Åæ„Åô„ÄÇ
„Åæ„Å†Ë°®Èù¢ÁöÑ„Å™ÈÉ®ÂàÜ„Å´Ëß¶„Çå„Åü„Å†„Åë„Åß„Åô„Åå„ÄÅ„ÇÇ„ÅÜÂÖ®„Å¶„ÅÆ‰ªïÁµÑ„Åø„ÅØÂàÜ„Åã„Å£„Å¶„ÅÑ„Çã„ÅØ„Åö„Åß„Åô„ÄÇ
‰ª•‰∏ã„ÅÆË°å„ÇíÂ§âÊõ¥„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...‰ª•‰∏ã„Çí:
...
"item_name"
:
item
.
name
...
...‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´:
...
"item_price"
:
item
.
price
...
...„Åù„Åó„Å¶„ÄÅ„Ç®„Éá„Ç£„Çø„ÅåÂ±ûÊÄß„ÇíËá™ÂãïË£úÂÆå„Åó„ÄÅ„Åù„ÅÆ„Çø„Ç§„Éó„ÇíÁü•„ÇãÊñπÊ≥ï„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ:
„Çà„ÇäÂ§ö„Åè„ÅÆÊ©üËÉΩ„ÇíÂê´„ÇÄ„ÄÅ„Çà„ÇäÂÆåÂÖ®„Å™‰æã„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅ
„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´ - „É¶„Éº„Ç∂„Éº„Ç¨„Ç§„Éâ
„Çí„ÅîË¶ß„Åè„Å†„Åï„ÅÑ„ÄÇ
„Éç„Çø„Éê„É¨Ê≥®ÊÑè
: „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´ - „É¶„Éº„Ç∂„Éº„Ç¨„Ç§„Éâ„ÅØ‰ª•‰∏ã„ÅÆÊÉÖÂ†±„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô:
„Éò„ÉÉ„ÉÄ„Éº
„ÄÅ
„ÇØ„ÉÉ„Ç≠„Éº
„ÄÅ
„Éï„Ç©„Éº„É†„Éï„Ç£„Éº„É´„Éâ
„ÄÅ
„Éï„Ç°„Ç§„É´
„Å™„Å©„ÅÆ‰ªñ„ÅÆÂ†¥ÊâÄ„Åã„Çâ„ÅÆ
„Éë„É©„É°„Éº„Çø
ÂÆ£Ë®Ä„ÄÇ
maximum_length
„ÇÑ
regex
„ÅÆ„Çà„ÅÜ„Å™
Ê§úË®º„ÇÑÂà∂Á¥Ñ
„ÇíË®≠ÂÆö„Åô„ÇãÊñπÊ≥ï„ÄÇ
ÈùûÂ∏∏„Å´Âº∑Âäõ„Åß‰Ωø„ÅÑ„ÇÑ„Åô„ÅÑ
‰æùÂ≠òÊÄßÊ≥®ÂÖ•
„Ç∑„Çπ„ÉÜ„É†„ÄÇ
JWT „Éà„Éº„ÇØ„É≥
„ÇíÁî®„ÅÑ„Åü
OAuth2
„ÇÑ
HTTP Basic Ë™çË®º
„ÅÆ„Çµ„Éù„Éº„Éà„ÇíÂê´„ÇÄ„ÄÅ„Çª„Ç≠„É•„É™„ÉÜ„Ç£„Å®Ë™çË®º„ÄÇ
Ê∑±„Åè„Éç„Çπ„Éà„Åï„Çå„Åü JSON „É¢„Éá„É´
„ÇíÂÆ£Ë®Ä„Åô„Çã„Åü„ÇÅ„ÅÆ„Çà„ÇäÈ´òÂ∫¶„Å™Ôºà„Åó„Åã„ÅóÂêåÊßò„Å´Á∞°Âçò„Å™ÔºâÊäÄË°ìÔºàPydantic „ÅÆ„Åä„Åã„Åí„Åß„ÅôÔºâ„ÄÇ
‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å™„Åü„Åè„Åï„Çì„ÅÆ„Åä„Åæ„ÅëÊ©üËÉΩ(Starlette „ÅÆ„Åä„Åã„Åí„Åß„Åô):
WebSockets
GraphQL
httpx
„ÇÑ
pytest
„Çí„ÇÇ„Å®„Å´„Åó„ÅüÊ•µÈôê„Å´Á∞°Âçò„Å™„ÉÜ„Çπ„Éà
CORS
„ÇØ„ÉÉ„Ç≠„Éº„Çª„ÉÉ„Ç∑„Éß„É≥
...„Å™„Å©„Å™„Å©„ÄÇ
„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ
Áã¨Á´ã„Åó„Åü TechEmpower „ÅÆ„Éô„É≥„ÉÅ„Éû„Éº„ÇØ„Åß„ÅØ„ÄÅUvicorn „ÅßÂãï‰Ωú„Åô„Çã
FastAPI
„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Åå„ÄÅ
Python „Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ„ÅÆ‰∏≠„ÅßÊúÄ„ÇÇÈ´òÈÄü„Å™„ÇÇ„ÅÆ„ÅÆ 1 „Å§
„Åß„ÅÇ„Çä„ÄÅStarlette „Å® UvicornÔºàFastAPI „ÅßÂÜÖÈÉ®ÁöÑ„Å´‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Åæ„ÅôÔºâ„Å´„ÅÆ„Åø‰∏ãÂõû„Å£„Å¶„ÅÑ„Çã„Å®Á§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Ë©≥Á¥∞„ÅØ
„Éô„É≥„ÉÅ„Éû„Éº„ÇØ
„Çª„ÇØ„Ç∑„Éß„É≥„Çí„ÅîË¶ß„Åè„Å†„Åï„ÅÑ„ÄÇ
„Ç™„Éó„Ç∑„Éß„É≥„ÅÆ‰æùÂ≠òÈñ¢‰øÇ
Pydantic „Å´„Çà„Å£„Å¶‰ΩøÁî®„Åï„Çå„Çã„ÇÇ„ÅÆ:
email-validator
- E „É°„Éº„É´„ÅÆÊ§úË®º
Starlette „Å´„Çà„Å£„Å¶‰ΩøÁî®„Åï„Çå„Çã„ÇÇ„ÅÆ:
httpx
-
TestClient
„Çí‰ΩøÁî®„Åô„Çã„Åü„ÇÅ„Å´ÂøÖË¶Å„Åß„Åô„ÄÇ
jinja2
- „Éá„Éï„Ç©„É´„Éà„ÅÆ„ÉÜ„É≥„Éó„É¨„Éº„ÉàË®≠ÂÆö„Çí‰ΩøÁî®„Åô„ÇãÂ†¥Âêà„ÅØÂøÖË¶Å„Åß„Åô„ÄÇ
python-multipart
-
"parsing"
request.form()
„Åã„Çâ„ÅÆÂ§âÊèõ„Çí„Çµ„Éù„Éº„Éà„Åó„Åü„ÅÑÂ†¥Âêà„ÅØÂøÖË¶Å„Åß„Åô„ÄÇ
itsdangerous
-
SessionMiddleware
„Çµ„Éù„Éº„Éà„ÅÆ„Åü„ÇÅ„Å´„ÅØÂøÖË¶Å„Åß„Åô„ÄÇ
pyyaml
- Starlette „ÅÆ
SchemaGenerator
„Çµ„Éù„Éº„Éà„ÅÆ„Åü„ÇÅ„Å´ÂøÖË¶Å„Åß„Åô„ÄÇ (FastAPI „Åß„ÅØÂøÖË¶Å„Å™„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ)
graphene
-
GraphQLApp
„Çµ„Éù„Éº„Éà„ÅÆ„Åü„ÇÅ„Å´„ÅØÂøÖË¶Å„Åß„Åô„ÄÇ
FastAPI / Starlette „Å´‰ΩøÁî®„Åï„Çå„Çã„ÇÇ„ÅÆ:
uvicorn
- „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Çí„É≠„Éº„Éâ„Åó„Å¶„Çµ„Éº„Éñ„Åô„Çã„Çµ„Éº„Éê„Éº„ÅÆ„Åü„ÇÅ„ÄÇ
orjson
-
ORJSONResponse
„Çí‰ΩøÁî®„Åó„Åü„ÅÑÂ†¥Âêà„ÅØÂøÖË¶Å„Åß„Åô„ÄÇ
ujson
-
UJSONResponse
„Çí‰ΩøÁî®„Åô„ÇãÂ†¥Âêà„ÅØÂøÖÈ†à„Åß„Åô„ÄÇ
„Åì„Çå„Çâ„ÅØÂÖ®„Å¶
pip install fastapi[all]
„Åß„Ç§„É≥„Çπ„Éà„Éº„É´„Åß„Åç„Åæ„Åô„ÄÇ
„É©„Ç§„Çª„É≥„Çπ
„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅØ MIT „É©„Ç§„Çª„É≥„Çπ„Åß„Åô„ÄÇ

## 073_KO
FastAPI¬∂
---

FastAPI
FastAPI ÌîÑÎ†àÏûÑÏõåÌÅ¨, Í≥†ÏÑ±Îä•, Í∞ÑÌé∏Ìïú ÌïôÏäµ, Îπ†Î•∏ ÏΩîÎìú ÏûëÏÑ±, Ï§ÄÎπÑÎêú ÌîÑÎ°úÎçïÏÖò
Î¨∏ÏÑú
:
https://fastapi.tiangolo.com
ÏÜåÏä§ ÏΩîÎìú
:
https://github.com/fastapi/fastapi
FastAPIÎäî ÌòÑÎåÄÏ†ÅÏù¥Í≥†, Îπ†Î•¥Î©∞(Í≥†ÏÑ±Îä•), ÌååÏù¥Ïç¨ ÌëúÏ§Ä ÌÉÄÏûÖ ÌûåÌä∏Ïóê Í∏∞Ï¥àÌïú PythonÏùò APIÎ•º ÎπåÎìúÌïòÍ∏∞ ÏúÑÌïú Ïõπ ÌîÑÎ†àÏûÑÏõåÌÅ¨ÏûÖÎãàÎã§.
Ï£ºÏöî ÌäπÏßïÏúºÎ°ú:
Îπ†Î¶Ñ
: (StarletteÍ≥º Pydantic ÎçïÎ∂ÑÏóê)
NodeJS
Î∞è
Go
ÏôÄ ÎåÄÎì±Ìï† Ï†ïÎèÑÎ°ú Îß§Ïö∞ ÎÜíÏùÄ ÏÑ±Îä•.
ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Í∞ÄÏû• Îπ†Î•∏ ÌååÏù¥Ïç¨ ÌîÑÎ†àÏûÑÏõåÌÅ¨ Ï§ë ÌïòÎÇò
.
Îπ†Î•∏ ÏΩîÎìú ÏûëÏÑ±
: ÏïΩ 200%ÏóêÏÑú 300%ÍπåÏßÄ Í∏∞Îä• Í∞úÎ∞ú ÏÜçÎèÑ Ï¶ùÍ∞Ä. *
Ï†ÅÏùÄ Î≤ÑÍ∑∏
: ÏÇ¨Îûå(Í∞úÎ∞úÏûê)Ïóê ÏùòÌïú ÏóêÎü¨ ÏïΩ 40% Í∞êÏÜå. *
ÏßÅÍ¥ÄÏ†Å
: ÌõåÎ•≠Ìïú Ìé∏ÏßëÍ∏∞ ÏßÄÏõê. Î™®Îì† Í≥≥ÏóêÏÑú
ÏûêÎèôÏôÑÏÑ±
. Ï†ÅÏùÄ ÎîîÎ≤ÑÍπÖ ÏãúÍ∞Ñ.
Ïâ¨ÏõÄ
: ÏâΩÍ≤å ÏÇ¨Ïö©ÌïòÍ≥† Î∞∞Ïö∞ÎèÑÎ°ù ÏÑ§Í≥Ñ. Ï†ÅÏùÄ Î¨∏ÏÑú ÏùΩÍ∏∞ ÏãúÍ∞Ñ.
ÏßßÏùå
: ÏΩîÎìú Ï§ëÎ≥µ ÏµúÏÜåÌôî. Í∞Å Îß§Í∞úÎ≥ÄÏàò ÏÑ†Ïñ∏Ïùò Ïó¨Îü¨ Í∏∞Îä•. Ï†ÅÏùÄ Î≤ÑÍ∑∏.
Í≤¨Í≥†Ìï®
: Ï§ÄÎπÑÎêú ÌîÑÎ°úÎçïÏÖò Ïö© ÏΩîÎìúÎ•º ÏñªÏúºÏã≠ÏãúÏò§. ÏûêÎèô ÎåÄÌôîÌòï Î¨∏ÏÑúÏôÄ Ìï®Íªò.
ÌëúÏ§Ä Í∏∞Î∞ò
: APIÏóê ÎåÄÌïú (ÏôÑÏ†ÑÌûà Ìò∏ÌôòÎêòÎäî) Í∞úÎ∞©Ìòï ÌëúÏ§Ä Í∏∞Î∞ò:
OpenAPI
(Ïù¥Ï†ÑÏóê SwaggerÎ°ú ÏïåÎ†§Ï°åÎçò) Î∞è
JSON Ïä§ÌÇ§Îßà
.
* ÎÇ¥Î∂Ä Í∞úÎ∞úÌåÄÏùò ÌîÑÎ°úÎçïÏÖò Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùÑ ÎπåÎìúÌïú ÌÖåÏä§Ìä∏Ïóê Í∑ºÍ±∞Ìïú Ï∏°Ï†ï
Í≥®Îìú Ïä§Ìè∞ÏÑú
Îã§Î•∏ Ïä§Ìè∞ÏÑú
ÏùòÍ≤¨Îì§
"
[...] Ï†ÄÎäî ÏöîÏ¶ò
FastAPI
Î•º ÎßéÏù¥ ÏÇ¨Ïö©ÌïòÍ≥† ÏûàÏäµÎãàÎã§. [...] ÏÇ¨Ïã§ Ïö∞Î¶¨ ÌåÄÏùò
ÎßàÏù¥ÌÅ¨Î°úÏÜåÌîÑÌä∏ ML ÏÑúÎπÑÏä§
Ï†ÑÎ∂ÄÎ•º Î∞îÍøÄ Í≥ÑÌöçÏûÖÎãàÎã§. Í∑∏Ï§ë ÏùºÎ∂ÄÎäî ÌïµÏã¨
Windows
ÏôÄ Î™áÎ™áÏùò
Office
Ï†úÌíàÎì§Ïù¥ ÌÜµÌï©ÎêòÍ≥† ÏûàÏäµÎãàÎã§.
"
Kabir Khan -
ÎßàÏù¥ÌÅ¨Î°úÏÜåÌîÑÌä∏
(ref)
"
FastAPI
ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º Ï±ÑÌÉùÌïòÏó¨
ÏòàÏ∏°
ÏùÑ ÏñªÍ∏∞ ÏúÑÌï¥ ÏøºÎ¶¨Î•º Ïã§Ìñâ Ìï† Ïàò ÏûàÎäî
REST
ÏÑúÎ≤ÑÎ•º ÏÉùÏÑ±ÌñàÏäµÎãàÎã§. [LudwigÏùÑ ÏúÑÌï¥]
"
Piero Molino, Yaroslav Dudin Í∑∏Î¶¨Í≥† Sai Sumanth Miryala -
Ïö∞Î≤Ñ
(ref)
"
Netflix
Îäî Ïö∞Î¶¨Ïùò Ïò§Ìîà ÏÜåÏä§ Î∞∞Ìè¨ÌåêÏù∏
ÏúÑÍ∏∞ Í¥ÄÎ¶¨
Ïò§ÏºÄÏä§Ìä∏Î†àÏù¥ÏÖò ÌîÑÎ†àÏûÑÏõåÌÅ¨Î•º Î∞úÌëúÌï† Ïàò ÏûàÏñ¥ Í∏∞ÏÅ©ÎãàÎã§: Î∞îÎ°ú
Dispatch
ÏûÖÎãàÎã§! [
FastAPI
Î°ú ÎπåÎìú]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
ÎÑ∑ÌîåÎ¶≠Ïä§
(ref)
"
FastAPI
Í∞Ä ÎÑàÎ¨¥ Ï¢ãÏïÑÏÑú Íµ¨Î¶Ñ ÏúÑÎ•º Í±∑ÎäîÎìØ Ìï©ÎãàÎã§. Ï†ïÎßê Ï¶êÍ≤ÅÏäµÎãàÎã§!
"
Brian Okken -
Python Bytes
ÌåüÏ∫êÏä§Ìä∏ Ìò∏Ïä§Ìä∏
(ref)
"
ÏÜîÏßÅÌûà, ÎãπÏã†Ïù¥ ÎßåÎì† Í≤ÉÏùÄ Îß§Ïö∞ Í≤¨Í≥†ÌïòÍ≥† ÏÑ∏Î†®ÎêòÏñ¥ Î≥¥ÏûÖÎãàÎã§. Ïó¨Îü¨ Î©¥ÏóêÏÑú
Hug
Í∞Ä Ïù¥Î†áÍ≤å ÎêòÏóàÏúºÎ©¥ Ìï©ÎãàÎã§ - Í∑∏Í±∏ ÎßåÎì† ÎàÑÍµ∞Í∞ÄÎ•º Î≥¥Îäî Í≤ÉÏùÄ ÎßéÏùÄ ÏòÅÍ∞êÏùÑ Ï§çÎãàÎã§.
"
Timothy Crosley -
Hug
Ï†úÏûëÏûê
(ref)
"
REST APIÎ•º ÎßåÎì§Í∏∞ ÏúÑÌï¥
ÌòÑÎåÄÏ†ÅÏù∏ ÌîÑÎ†àÏûÑÏõåÌÅ¨
Î•º Ï∞æÍ≥† ÏûàÎã§Î©¥
FastAPI
Î•º ÌôïÏù∏Ìï¥ Î≥¥Ïã≠ÏãúÏò§. [...] Îπ†Î•¥Í≥†, Ïì∞Í∏∞ ÏâΩÍ≥†, Î∞∞Ïö∞Í∏∞ÎèÑ ÏâΩÏäµÎãàÎã§ [...]
"
"
Ïö∞Î¶¨
API
Î•º
FastAPI
Î°ú Î∞îÍø®ÏäµÎãàÎã§ [...] ÏïÑÎßà Ïó¨Îü¨Î∂ÑÎèÑ Ï¢ãÏïÑÌïòÏã§ Í≤ÉÏûÖÎãàÎã§ [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
ÏÑ§Î¶ΩÏûê -
spaCy
Ï†úÏûëÏûê
(ref)
-
(ref)
Typer
, FastAPIÏùò CLI
Ïõπ API ÎåÄÏã† ÌÑ∞ÎØ∏ÎÑêÏóêÏÑú ÏÇ¨Ïö©Ìï†
CLI
Ïï±ÏùÑ ÎßåÎì§Í≥† ÏûàÎã§Î©¥,
Typer
Î•º ÌôïÏù∏Ìï¥ Î≥¥Ïã≠ÏãúÏò§.
Typer
Îäî FastAPIÏùò ÎèôÏÉùÏûÖÎãàÎã§. Í∑∏Î¶¨Í≥†
FastAPIÏùò CLI
Í∞Ä ÎêòÍ∏∞ ÏúÑÌï¥ ÏÉùÍ≤ºÏäµÎãàÎã§. ‚å®Ô∏è üöÄ
ÏöîÍµ¨ÏÇ¨Ìï≠
FastAPIÎäî Í±∞Ïù∏Îì§Ïùò Ïñ¥Íπ® ÏúÑÏóê ÏÑú ÏûàÏäµÎãàÎã§:
Ïõπ Î∂ÄÎ∂ÑÏùÑ ÏúÑÌïú
Starlette
.
Îç∞Ïù¥ÌÑ∞ Î∂ÄÎ∂ÑÏùÑ ÏúÑÌïú
Pydantic
.
ÏÑ§Ïπò
fast ‚Üí
pip install fastapi
restart ‚Üª
ÌîÑÎ°úÎçïÏÖòÏùÑ ÏúÑÌï¥
Uvicorn
ÎòêÎäî
Hypercorn
Í≥º Í∞ôÏùÄ ASGI ÏÑúÎ≤ÑÎèÑ ÌïÑÏöîÌï† Í≤ÅÎãàÎã§.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
ÏòàÏ†ú
ÎßåÎì§Í∏∞
main.py
ÌååÏùºÏùÑ ÎßåÎìúÏã≠ÏãúÏò§:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
ÎòêÎäî
async def
ÏÇ¨Ïö©ÌïòÍ∏∞...
Ïó¨Îü¨Î∂ÑÏùò ÏΩîÎìúÍ∞Ä
async
/
await
ÏùÑ ÏÇ¨Ïö©ÌïúÎã§Î©¥,
async def
Î•º ÏÇ¨Ïö©ÌïòÏã≠ÏãúÏò§.
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Note
:
Ïûò Î™®Î•¥Í≤†Îã§Î©¥,
Î¨∏ÏÑúÏóêÏÑú
async
ÏôÄ
await
Ïóê Í¥ÄÌïú
"Í∏âÌïòÏÑ∏Ïöî?"
ÏÑπÏÖòÏùÑ ÌôïÏù∏Ìï¥ Î≥¥Ïã≠ÏãúÏò§.
Ïã§ÌñâÌïòÍ∏∞
ÏÑúÎ≤ÑÎ•º Ïã§ÌñâÌïòÏã≠ÏãúÏò§:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
uvicorn main:app --reload
Î™ÖÎ†πÏóê Í¥ÄÌïòÏó¨...
Î™ÖÎ†π
uvicorn main:app
ÏùÄ Îã§ÏùåÏùÑ ÎÇòÌÉÄÎÉÖÎãàÎã§:
main
:
main.py
ÌååÏùº (ÌååÏù¥Ïç¨ "Î™®Îìà").
app
: the object created inside of
main.py
with the line
app = FastAPI()
.
--reload
: ÏΩîÎìúÍ∞Ä Î≥ÄÍ≤ΩÎêú ÌõÑ ÏÑúÎ≤Ñ Ïû¨ÏãúÏûëÌïòÍ∏∞. Í∞úÎ∞úÌôòÍ≤ΩÏóêÏÑúÎßå ÏÇ¨Ïö©ÌïòÏã≠ÏãúÏò§.
ÌôïÏù∏ÌïòÍ∏∞
Î∏åÎùºÏö∞Ï†ÄÎ°ú
http://127.0.0.1:8000/items/5?q=somequery
Î•º Ïó¥Ïñ¥Î≥¥Ïã≠ÏãúÏò§.
ÏïÑÎûòÏùò JSON ÏùëÎãµÏùÑ Î≥º Ïàò ÏûàÏäµÎãàÎã§:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Ïó¨Îü¨Î∂ÑÏùÄ Î≤åÏç® APIÎ•º ÎßåÎì§ÏóàÏäµÎãàÎã§:
Í≤ΩÎ°ú
/
Î∞è
/items/{item_id}
ÏóêÏÑú HTTP ÏöîÏ≤≠ Î∞õÍ∏∞.
Îëê
Í≤ΩÎ°ú
Î™®Îëê
GET
Ïó∞ÏÇ∞
(HTTP
Î©îÏÜåÎìú
Î°ú ÏïåÎ†§ÏßÑ)ÏùÑ Î∞õÏäµÎãàÎã§.
Í≤ΩÎ°ú
/items/{item_id}
Îäî
Í≤ΩÎ°ú Îß§Í∞úÎ≥ÄÏàò
int
Ìòï Ïù¥Ïñ¥Ïïº ÌïòÎäî
item_id
Î•º Í∞ÄÏßÄÍ≥† ÏûàÏäµÎãàÎã§.
Í≤ΩÎ°ú
/items/{item_id}
Îäî ÏÑ†ÌÉùÏ†ÅÏù∏
str
Ìòï Ïù¥Ïñ¥Ïïº ÌïòÎäî
Í≤ΩÎ°ú Îß§Í∞úÎ≥ÄÏàò
q
Î•º Í∞ÄÏßÄÍ≥† ÏûàÏäµÎãàÎã§.
ÎåÄÌôîÌòï API Î¨∏ÏÑú
Ïù¥Ï†ú
http://127.0.0.1:8000/docs
Î°ú Í∞ÄÎ≥¥Ïã≠ÏãúÏò§.
ÏûêÎèô ÎåÄÌôîÌòï API Î¨∏ÏÑúÎ•º Î≥º Ïàò ÏûàÏäµÎãàÎã§ (
Swagger UI
Ï†úÍ≥µ):
ÎåÄÏïà API Î¨∏ÏÑú
Í∑∏Î¶¨Í≥† Ïù¥Ï†ú
http://127.0.0.1:8000/redoc
Î°ú Í∞ÄÎ¥ÖÏãúÎã§.
Îã§Î•∏ ÏûêÎèô Î¨∏ÏÑúÎ•º Î≥º Ïàò ÏûàÏäµÎãàÎã§(
ReDoc
Ï†úÍ≥µ):
ÏòàÏ†ú Ïã¨Ìôî
Ïù¥Ï†ú
PUT
ÏöîÏ≤≠Ïóê ÏûàÎäî Î≥∏Î¨∏(Body)ÏùÑ Î∞õÍ∏∞ ÏúÑÌï¥
main.py
Î•º ÏàòÏ†ïÌï¥Î¥ÖÏãúÎã§.
PydanticÏùÑ Ïù¥Ïö©Ìï¥ ÌååÏù¥Ïç¨ ÌëúÏ§Ä ÌÉÄÏûÖÏúºÎ°ú Î≥∏Î¨∏ÏùÑ ÏÑ†Ïñ∏Ìï©ÎãàÎã§.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
ÏÑúÎ≤ÑÍ∞Ä ÏûêÎèôÏúºÎ°ú Î¶¨Î°úÎî© Ìï† Ïàò ÏûàÏñ¥Ïïº Ìï©ÎãàÎã§ (ÏúÑÏóêÏÑú
uvicorn
Î™ÖÎ†πÏóê
--reload
ÏùÑ Ï∂îÍ∞Ä ÌñàÍ∏∞ ÎïåÎ¨∏ÏûÖÎãàÎã§).
ÎåÄÌôîÌòï API Î¨∏ÏÑú ÏóÖÍ∑∏Î†àÏù¥Îìú
Ïù¥Ï†ú
http://127.0.0.1:8000/docs
Î°ú Ïù¥ÎèôÌï©ÎãàÎã§.
ÎåÄÌôîÌòï API Î¨∏ÏÑúÍ∞Ä ÏÉà Î≥∏Î¨∏Í≥º Ìï®Íªò ÏûêÎèôÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ Ìï©ÎãàÎã§:
"Try it out" Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÎ©¥, Îß§Í∞úÎ≥ÄÏàòÎ•º Ï±ÑÏö∏ Ïàò ÏûàÍ≤å Ìï¥Ï£ºÍ≥† ÏßÅÏ†ë APIÏôÄ ÏÉÅÌò∏ÏûëÏö© Ìï† Ïàò ÏûàÏäµÎãàÎã§:
Í∑∏Îü¨Í≥† ÎÇòÏÑú "Execute" Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Î©¥, ÏÇ¨Ïö©Ïûê Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Îäî APIÏôÄ ÌÜµÏã†ÌïòÍ≥† Îß§Í∞úÎ≥ÄÏàòÎ•º Ï†ÑÏÜ°ÌïòÎ©∞ Í∑∏ Í≤∞Í≥ºÎ•º Í∞ÄÏ†∏ÏôÄÏÑú ÌôîÎ©¥Ïóê ÌëúÏãúÌï©ÎãàÎã§:
ÎåÄÏïà API Î¨∏ÏÑú ÏóÖÍ∑∏Î†àÏù¥Îìú
Í∑∏Î¶¨Í≥† Ïù¥Ï†ú,
http://127.0.0.1:8000/redoc
Î°ú Ïù¥ÎèôÌï©ÎãàÎã§.
ÎåÄÏïà Î¨∏ÏÑú Ïó≠Ïãú ÏÉà ÏøºÎ¶¨ Îß§Í∞úÎ≥ÄÏàòÏôÄ Î≥∏Î¨∏ÏùÑ Î∞òÏòÅÌï©ÎãàÎã§:
ÏöîÏïΩ
ÏöîÏïΩÌïòÎ©¥, Ïó¨Îü¨Î∂ÑÏùÄ Îß§Í∞úÎ≥ÄÏàòÏùò ÌÉÄÏûÖ, Î≥∏Î¨∏ Îì±ÏùÑ Ìï®Ïàò Îß§Í∞úÎ≥ÄÏàòÎ°úÏÑú
ÌïúÎ≤àÏóê
ÏÑ†Ïñ∏ÌñàÏäµÎãàÎã§.
Ïó¨Îü¨Î∂ÑÏùÄ ÌòÑÎåÄ ÌëúÏ§Ä ÌååÏù¥Ïç¨ ÌÉÄÏûÖÏúºÎ°ú Ïù¥Î•º ÌñâÌñàÏäµÎãàÎã§.
ÏÉàÎ°úÏö¥ Î¨∏Î≤ï, ÌäπÏ†ï ÎùºÏù¥Î∏åÎü¨Î¶¨Ïùò Î©îÏÜåÎìúÎÇò ÌÅ¥ÎûòÏä§ Îì±ÏùÑ Î∞∞Ïö∏ ÌïÑÏöîÍ∞Ä ÏóÜÏäµÎãàÎã§.
Í∑∏Ï†Ä ÌëúÏ§Ä
Python
ÏûÖÎãàÎã§.
ÏòàÎ•º Îì§Ïñ¥,
int
Ïóê ÎåÄÌï¥ÏÑ†:
item_id
:
int
ÎòêÎäî Ï¢Ä Îçî Î≥µÏû°Ìïú
Item
Î™®Îç∏Ïóê ÎåÄÌï¥ÏÑ†:
item
:
Item
...Í∑∏Î¶¨Í≥† Îã® ÌïòÎÇòÏùò ÏÑ†Ïñ∏ÏúºÎ°ú Ïó¨Îü¨Î∂ÑÏù¥ ÏñªÎäî Í≤ÉÏùÄ:
Îã§ÏùåÏùÑ Ìè¨Ìï®Ìïú Ìé∏ÏßëÍ∏∞ ÏßÄÏõê:
ÏûêÎèôÏôÑÏÑ±.
ÌÉÄÏûÖ Í≤ÄÏÇ¨.
Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù:
Îç∞Ïù¥ÌÑ∞Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÑ Îïå ÏûêÎèôÏúºÎ°ú ÏÉùÏÑ±ÌïòÎäî Î™ÖÌôïÌïú ÏóêÎü¨.
Ï§ëÏ≤©Îêú JSON Í∞ùÏ≤¥Ïóê ÎåÄÌïú Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨.
ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞
Î≥ÄÌôò
: ÎÑ§Ìä∏ÏõåÌÅ¨ÏóêÏÑú ÌååÏù¥Ïç¨ Îç∞Ïù¥ÌÑ∞ Î∞è ÌÉÄÏûÖÏúºÎ°ú Ï†ÑÏÜ°. ÏùΩÏùÑ Ïàò ÏûàÎäî Í≤ÉÎì§:
JSON.
Í≤ΩÎ°ú Îß§Í∞úÎ≥ÄÏàò.
ÏøºÎ¶¨ Îß§Í∞úÎ≥ÄÏàò.
Ïø†ÌÇ§.
Ìó§Îçî.
Ìèº(Forms).
ÌååÏùº.
Ï∂úÎ†• Îç∞Ïù¥ÌÑ∞
Î≥ÄÌôò
: ÌååÏù¥Ïç¨ Îç∞Ïù¥ÌÑ∞ Î∞è ÌÉÄÏûÖÏùÑ ÎÑ§Ìä∏ÏõåÌÅ¨ Îç∞Ïù¥ÌÑ∞Î°ú Ï†ÑÌôò(JSON ÌòïÏãùÏúºÎ°ú):
ÌååÏù¥Ïç¨ ÌÉÄÏûÖ Î≥ÄÌôò (
str
,
int
,
float
,
bool
,
list
, Îì±).
datetime
Í∞ùÏ≤¥.
UUID
Í∞ùÏ≤¥.
Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î™®Îç∏.
...Îçî ÎßéÏùÄ Í≤ÉÎì§.
ÎåÄÏïàÍ∞ÄÎä•Ìïú ÏÇ¨Ïö©Ïûê Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Î•º 2Í∞ú Ìè¨Ìï®Ìïú ÏûêÎèô ÎåÄÌôîÌòï API Î¨∏ÏÑú:
Swagger UI.
ReDoc.
Ïù¥Ï†Ñ ÏΩîÎìú ÏòàÏ†úÎ°ú ÎèåÏïÑÍ∞ÄÏÑú,
FastAPI
Îäî Îã§ÏùåÏ≤òÎüº Ï≤òÎ¶¨Ìï©ÎãàÎã§:
GET
Î∞è
PUT
ÏöîÏ≤≠Ïóê
item_id
Í∞Ä Í≤ΩÎ°úÏóê ÏûàÎäîÏßÄ Í≤ÄÏ¶ù.
GET
Î∞è
PUT
ÏöîÏ≤≠Ïóê
item_id
Í∞Ä
int
ÌÉÄÏûÖÏù∏ÏßÄ Í≤ÄÏ¶ù.
Í∑∏Î†áÏßÄ ÏïäÎã§Î©¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Îäî Ïú†Ïö©ÌïòÍ≥† Î™ÖÌôïÌïú ÏóêÎü¨Î•º Î≥º Ïàò ÏûàÏäµÎãàÎã§.
GET
ÏöîÏ≤≠Ïóê
q
ÎùºÎäî ÏÑ†ÌÉùÏ†ÅÏù∏ ÏøºÎ¶¨ Îß§Í∞úÎ≥ÄÏàòÍ∞Ä Í≤ÄÏÇ¨(
http://127.0.0.1:8000/items/foo?q=somequery
Ï≤òÎüº).
q
Îß§Í∞úÎ≥ÄÏàòÎäî
= None
ÏúºÎ°ú ÏÑ†Ïñ∏ÎêòÏóàÍ∏∞ ÎïåÎ¨∏Ïóê ÏÑ†ÌÉùÏÇ¨Ìï≠ÏûÖÎãàÎã§.
None
Ïù¥ ÏóÜÎã§Î©¥ ÌïÑÏàòÏÇ¨Ìï≠ÏûÖÎãàÎã§(
PUT
Ïùò Í≤ΩÏö∞ÏôÄ ÎßàÏ∞¨Í∞ÄÏßÄÎ°ú).
/items/{item_id}
ÏúºÎ°úÏùò
PUT
ÏöîÏ≤≠ÏùÄ Î≥∏Î¨∏ÏùÑ JSONÏúºÎ°ú ÏùΩÏùå:
name
ÏùÑ ÌïÑÏàò ÏÜçÏÑ±ÏúºÎ°ú Í∞ñÍ≥†
str
ÌòïÏù∏ÏßÄ Í≤ÄÏÇ¨.
price
ÏùÑ ÌïÑÏàò ÏÜçÏÑ±ÏúºÎ°ú Í∞ñÍ≥†
float
ÌòïÏù∏ÏßÄ Í≤ÄÏÇ¨.
ÎßåÏïΩ Ï£ºÏñ¥ÏßÑÎã§Î©¥,
is_offer
Î•º ÏÑ†ÌÉù ÏÜçÏÑ±ÏúºÎ°ú Í∞ñÍ≥†
bool
ÌòïÏù∏ÏßÄ Í≤ÄÏÇ¨.
Ïù¥ Î™®Îì† Í≤ÉÏùÄ ÍπäÏù¥ Ï§ëÏ≤©Îêú JSON Í∞ùÏ≤¥ÏóêÎèÑ Ï†ÅÏö©Îê©ÎãàÎã§.
JSONÏùÑ Î≥ÄÌôòÌïòÍ±∞ÎÇò JSONÏúºÎ°ú Î≥ÄÌôòÌïòÎäî Í≤ÉÏùÑ ÏûêÎèôÌôî.
Îã§ÏùåÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎäî Î™®Îì† Í≤ÉÏùÑ OpenAPIÎ°ú Î¨∏ÏÑúÌôî:
ÎåÄÌôîÌòï Î¨∏ÏÑú ÏãúÏä§ÌÖú.
Ïó¨Îü¨ Ïñ∏Ïñ¥Îì§Ïóê ÎåÄÌïú ÏûêÎèô ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏΩîÎìú ÏÉùÏÑ± ÏãúÏä§ÌÖú.
2Í∞úÏùò ÎåÄÌôîÌòï Î¨∏ÏÑú Ïõπ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Î•º ÏßÅÏ†ë Ï†úÍ≥µ.
Ïö∞Î¶¨Îäî Í∑∏Ï†Ä ÏàòÎ∞ï Í≤â Ìï•Í∏∞Îßå ÌñàÏùÑ ÎøêÏù∏Îç∞ Ïó¨Îü¨Î∂ÑÏùÄ Î≤åÏç® Ïñ¥ÎñªÍ≤å ÏûëÎèôÌïòÎäîÏßÄ ÏïåÍ≥† ÏûàÏäµÎãàÎã§.
Îã§Ïùå Ï§ÑÏùÑ Î∞îÍøîÎ≥¥Ïã≠ÏãúÏò§:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...ÏóêÏÑú:
...
"item_name"
:
item
.
name
...
...ÏúºÎ°ú:
...
"item_price"
:
item
.
price
...
...Í∑∏Îü¨Í≥† ÎÇòÏÑú Ïó¨Îü¨Î∂ÑÏùò Ìé∏ÏßëÍ∏∞Í∞Ä ÏÜçÏÑ±Í≥º ÌÉÄÏûÖÏùÑ ÏïåÍ≥† ÏûêÎèô ÏôÑÏÑ±ÌïòÎäîÏßÄ Î≥¥Ïã≠ÏãúÏò§:
Îçî ÎßéÏùÄ Í∏∞Îä•ÏùÑ Ìè¨Ìï®Ìïú Î≥¥Îã§ ÏôÑÏ†ÑÌïú ÏòàÏ†úÏùò Í≤ΩÏö∞,
ÌäúÌÜ†Î¶¨Ïñº - ÏÇ¨Ïö©Ïûê Í∞ÄÏù¥Îìú
Î•º Î≥¥Ïã≠ÏãúÏò§.
Ïä§Ìè¨ÏùºÎü¨ Ï£ºÏùò
: ÌäúÌÜ†Î¶¨Ïñº - ÏÇ¨Ïö©Ïûê Í∞ÄÏù¥ÎìúÎäî:
ÏÑúÎ°ú Îã§Î•∏ Ïû•ÏÜåÏóêÏÑú
Îß§Í∞úÎ≥ÄÏàò
ÏÑ†Ïñ∏:
Ìó§Îçî
,
Ïø†ÌÇ§
,
Ìèº ÌïÑÎìú
Í∑∏Î¶¨Í≥†
ÌååÏùº
.
maximum_length
ÎòêÎäî
regex
Ï≤òÎüº
Ïú†Ìö®ÏÑ± Ï†úÏïΩ
ÌïòÎäî Î∞©Î≤ï.
Í∞ïÎ†•ÌïòÍ≥† ÏÇ¨Ïö©ÌïòÍ∏∞ Ïâ¨Ïö¥
ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ
ÏãúÏä§ÌÖú.
OAuth2
ÏßÄÏõêÏùÑ Ìè¨Ìï®Ìïú
JWT tokens
Î∞è
HTTP Basic
ÏùÑ Í∞ñÎäî Î≥¥ÏïàÍ≥º Ïù∏Ï¶ù.
(Pydantic ÎçïÎ∂ÑÏóê)
ÍπäÏùÄ Ï§ëÏ≤© JSON Î™®Îç∏
ÏùÑ ÏÑ†Ïñ∏ÌïòÎäîÎç∞ Îçî ÏßÑÎ≥¥Ìïú (ÌïòÏßÄÎßå ÎßàÏ∞¨Í∞ÄÏßÄÎ°ú Ïâ¨Ïö¥) Í∏∞Ïà†.
(Starlette ÎçïÎ∂ÑÏóê) ÎßéÏùÄ Ï∂îÍ∞Ä Í∏∞Îä•:
Ïõπ ÏÜåÏºì
GraphQL
HTTPX Î∞è
pytest
Ïóê Í∏∞Î∞òÌïú Í∑πÌûà Ïâ¨Ïö¥ ÌÖåÏä§Ìä∏
CORS
Ïø†ÌÇ§ ÏÑ∏ÏÖò
...Í∏∞ÌÉÄ Îì±Îì±.
ÏÑ±Îä•
ÎèÖÎ¶ΩÎêú TechEmpower Î≤§ÏπòÎßàÌÅ¨ÏóêÏÑú UvicornÏóêÏÑú ÏûëÎèôÌïòÎäî FastAPI Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏù¥
ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Í∞ÄÏû• Îπ†Î•∏ ÌîÑÎ†àÏûÑÏõåÌÅ¨ Ï§ë ÌïòÎÇò
Î°ú StarletteÏôÄ Uvicorn(FastAPIÏóêÏÑú ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú ÏÇ¨Ïö©)ÏóêÎßå Î∞ëÎèåÍ≥† ÏûàÏäµÎãàÎã§. (*)
ÏûêÏÑ∏Ìïú ÎÇ¥Ïö©ÏùÄ
Î≤§ÏπòÎßàÌÅ¨
ÏÑπÏÖòÏùÑ Î≥¥Ïã≠ÏãúÏò§.
ÏÑ†ÌÉùÍ∞ÄÎä•Ìïú ÏùòÏ°¥ÏÑ±
PydanticÏù¥ ÏÇ¨Ïö©ÌïòÎäî:
email-validator
- Ïù¥Î©îÏùº Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨.
StarletteÏù¥ ÏÇ¨Ïö©ÌïòÎäî:
HTTPX
-
TestClient
Î•º ÏÇ¨Ïö©ÌïòÎ†§Î©¥ ÌïÑÏöî.
jinja2
- Í∏∞Î≥∏ ÌÖúÌîåÎ¶ø ÏÑ§Ï†ïÏùÑ ÏÇ¨Ïö©ÌïòÎ†§Î©¥ ÌïÑÏöî.
python-multipart
-
request.form()
Í≥º Ìï®Íªò
"parsing"
Ïùò ÏßÄÏõêÏùÑ ÏõêÌïòÎ©¥ ÌïÑÏöî.
itsdangerous
-
SessionMiddleware
ÏßÄÏõêÏùÑ ÏúÑÌï¥ ÌïÑÏöî.
pyyaml
- StarletteÏùò
SchemaGenerator
ÏßÄÏõêÏùÑ ÏúÑÌï¥ ÌïÑÏöî (FastAPIÏôÄ Ïì∏ÎïåÎäî ÌïÑÏöî ÏóÜÏùÑ Í≤ÉÏûÖÎãàÎã§).
graphene
-
GraphQLApp
ÏßÄÏõêÏùÑ ÏúÑÌï¥ ÌïÑÏöî.
FastAPI / StarletteÏù¥ ÏÇ¨Ïö©ÌïòÎäî:
uvicorn
- Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùÑ Î°úÎìúÌïòÍ≥† Ï†úÍ≥µÌïòÎäî ÏÑúÎ≤Ñ.
orjson
-
ORJSONResponse
ÏùÑ ÏÇ¨Ïö©ÌïòÎ†§Î©¥ ÌïÑÏöî.
ujson
-
UJSONResponse
Î•º ÏÇ¨Ïö©ÌïòÎ†§Î©¥ ÌïÑÏöî.
pip install fastapi[all]
Î•º ÌÜµÌï¥ Ïù¥ Î™®ÎëêÎ•º ÏÑ§Ïπò Ìï† Ïàò ÏûàÏäµÎãàÎã§.
ÎùºÏù¥ÏÑºÏä§
Ïù¥ ÌîÑÎ°úÏ†ùÌä∏Îäî MIT ÎùºÏù¥ÏÑºÏä§ Ï°∞ÏïΩÏóê Îî∞Îùº ÎùºÏù¥ÏÑºÏä§Í∞Ä Î∂ÄÏó¨Îê©ÎãàÎã§.

## 074_LEARN
Learn¬∂
---

Learn
Here are the introductory sections and the tutorials to learn
FastAPI
.
You could consider this a
book
, a
course
, the
official
and recommended way to learn FastAPI. üòé

## 075_MANAGEMENT_TASKS
Repository Management Tasks¬∂
---

Repository Management Tasks
These are the tasks that can be performed to manage the FastAPI repository by
team members
.
Tip
This section is useful only to a handful of people, team members with permissions to manage the repository. You can probably skip it. üòâ
...so, you are a
team member of FastAPI
? Wow, you are so cool! üòé
You can help with everything on
Help FastAPI - Get Help
the same ways as external contributors. But additionally, there are some tasks that only you (as part of the team) can perform.
Here are the general instructions for the tasks you can perform.
Thanks a lot for your help. üôá
Be Nice
First of all, be nice. üòä
You probably are super nice if you were added to the team, but it's worth mentioning it. ü§ì
When Things are Difficult
When things are great, everything is easier, so that doesn't need much instructions. But when things are difficult, here are some guidelines.
Try to find the good side. In general, if people are not being unfriendly, try to thank their effort and interest, even if you disagree with the main subject (discussion, PR), just thank them for being interested in the project, or for having dedicated some time to try to do something.
It's difficult to convey emotion in text, use emojis to help. üòÖ
In discussions and PRs, in many cases, people bring their frustration and show it without filter, in many cases exaggerating, complaining, being entitled, etc. That's really not nice, and when it happens, it lowers our priority to solve their problems. But still, try to breath, and be gentle with your answers.
Try to avoid using bitter sarcasm or potentially passive-aggressive comments. If something is wrong, it's better to be direct (try to be gentle) than sarcastic.
Try to be as specific and objective as possible, avoid generalizations.
For conversations that are more difficult, for example to reject a PR, you can ask me (@tiangolo) to handle it directly.
Edit PR Titles
Edit the PR title to start with an emoji from
gitmoji
.
Use the emoji character, not the GitHub code. So, use
üêõ
instead of
:bug:
. This is so that it shows up correctly outside of GitHub, for example in the release notes.
For translations use the
üåê
emoji ("globe with meridians").
Start the title with a verb. For example
Add
,
Refactor
,
Fix
, etc. This way the title will say the action that the PR does. Like
Add support for teleporting
, instead of
Teleporting wasn't working, so this PR fixes it
.
Edit the text of the PR title to start in "imperative", like giving an order. So, instead of
Adding support for teleporting
use
Add support for teleporting
.
Try to make the title descriptive about what it achieves. If it's a feature, try to describe it, for example
Add support for teleporting
instead of
Create TeleportAdapter class
.
Do not finish the title with a period (
.
).
When the PR is for a translation, start with the
üåê
and then
Add {language} translation for
and then the translated file path. For example:
üåê Add Spanish translation for
`docs/es/docs/teleporting.md`
Once the PR is merged, a GitHub Action (
latest-changes
) will use the PR title to update the latest changes automatically.
So, having a nice PR title will not only look nice in GitHub, but also in the release notes. üìù
Add Labels to PRs
The same GitHub Action
latest-changes
uses one label in the PR to decide the section in the release notes to put this PR in.
Make sure you use a supported label from the
latest-changes list of labels
:
breaking
: Breaking Changes
Existing code will break if they update the version without changing their code. This rarely happens, so this label is not frequently used.
security
: Security Fixes
This is for security fixes, like vulnerabilities. It would almost never be used.
feature
: Features
New features, adding support for things that didn't exist before.
bug
: Fixes
Something that was supported didn't work, and this fixes it. There are many PRs that claim to be bug fixes because the user is doing something in an unexpected way that is not supported, but they considered it what should be supported by default. Many of these are actually features or refactors. But in some cases there's an actual bug.
refactor
: Refactors
This is normally for changes to the internal code that don't change the behavior. Normally it improves maintainability, or enables future features, etc.
upgrade
: Upgrades
This is for upgrades to direct dependencies from the project, or extra optional dependencies, normally in
pyproject.toml
. So, things that would affect final users, they would end up receiving the upgrade in their code base once they update. But this is not for upgrades to internal dependencies used for development, testing, docs, etc. Those internal dependencies, normally in
requirements.txt
files or GitHub Action versions should be marked as
internal
, not
upgrade
.
docs
: Docs
Changes in docs. This includes updating the docs, fixing typos. But it doesn't include changes to translations.
You can normally quickly detect it by going to the "Files changed" tab in the PR and checking if the updated file(s) starts with
docs/en/docs
. The original version of the docs is always in English, so in
docs/en/docs
.
lang-all
: Translations
Use this for translations. You can normally quickly detect it by going to the "Files changed" tab in the PR and checking if the updated file(s) starts with
docs/{some lang}/docs
but not
docs/en/docs
. For example,
docs/es/docs
.
internal
: Internal
Use this for changes that only affect how the repo is managed. For example upgrades to internal dependencies, changes in GitHub Actions or scripts, etc.
Tip
Some tools like Dependabot, will add some labels, like
dependencies
, but have in mind that this label is not used by the
latest-changes
GitHub Action, so it won't be used in the release notes. Please make sure one of the labels above is added.
Add Labels to Translation PRs
When there's a PR for a translation, apart from adding the
lang-all
label, also add a label for the language.
There will be a label for each language using the language code, like
lang-{lang code}
, for example,
lang-es
for Spanish,
lang-fr
for French, etc.
Add the specific language label.
Add the label
awaiting-review
.
The label
awaiting-review
is special, only used for translations. A GitHub Action will detect it, then it will read the language label, and it will update the GitHub Discussions managing the translations for that language to notify people that there's a new translation to review.
Once a native speaker comes, reviews the PR, and approves it, the GitHub Action will come and remove the
awaiting-review
label, and add the
approved-1
label.
This way, we can notice when there are new translations ready, because they have the
approved-1
label.
Merge Translation PRs
For Spanish, as I'm a native speaker and it's a language close to me, I will give it a final review myself and in most cases tweak the PR a bit before merging it.
For the other languages, confirm that:
The title is correct following the instructions above.
It has the labels
lang-all
and
lang-{lang code}
.
The PR changes only one Markdown file adding a translation.
Or in some cases, at most two files, if they are small, for the same language, and people reviewed them.
If it's the first translation for that language, it will have additional
mkdocs.yml
files, for those cases follow the instructions below.
The PR doesn't add any additional or extraneous files.
The translation seems to have a similar structure as the original English file.
The translation doesn't seem to change the original content, for example with obvious additional documentation sections.
The translation doesn't use different Markdown structures, for example adding HTML tags when the original didn't have them.
The "admonition" sections, like
tip
,
info
, etc. are not changed or translated. For example:
/// tip
This is a tip.
///
looks like this:
Tip
This is a tip.
...it could be translated as:
/// tip
Esto es un consejo.
///
...but needs to keep the exact
tip
keyword. If it was translated to
consejo
, like:
/// consejo
Esto es un consejo.
///
it would change the style to the default one, it would look like:
/// consejo
Esto es un consejo.
///
Those don't have to be translated, but if they are, they need to be written as:
/// tip | consejo
Esto es un consejo.
///
Which looks like:
consejo
Esto es un consejo.
First Translation PR
When there's a first translation for a language, it will have a
docs/{lang code}/docs/index.md
translated file and a
docs/{lang code}/mkdocs.yml
.
For example, for Bosnian, it would be:
docs/bs/docs/index.md
docs/bs/mkdocs.yml
The
mkdocs.yml
file will have only the following content:
INHERIT
:
../en/mkdocs.yml
The language code would normally be in the
ISO 639-1 list of language codes
.
In any case, the language code should be in the file
docs/language_names.yml
.
There won't be yet a label for the language code, for example, if it was Bosnian, there wouldn't be a
lang-bs
. Before creating the label and adding it to the PR, create the GitHub Discussion:
Go to the
Translations GitHub Discussions
Create a new discussion with the title
Bosnian Translations
(or the language name in English)
A description of:
## Bosnian translations
This is the issue to track translations of the docs to Bosnian. üöÄ
Here are the [
PRs to review with the label `lang-bs`
](
https://github.com/fastapi/fastapi/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc+label%3Alang-bs+label%3A%22awaiting-review%22
). ü§ì
Update "Bosnian" with the new language.
And update the search link to point to the new language label that will be created, like
lang-bs
.
Create and add the label to that new Discussion just created, like
lang-bs
.
Then go back to the PR, and add the label, like
lang-bs
, and
lang-all
and
awaiting-review
.
Now the GitHub action will automatically detect the label
lang-bs
and will post in that Discussion that this PR is waiting to be reviewed.
Review PRs
If a PR doesn't explain what it does or why, ask for more information.
A PR should have a specific use case that it is solving.
If the PR is for a feature, it should have docs.
Unless it's a feature we want to discourage, like support for a corner case that we don't want users to use.
The docs should include a source example file, not write Python directly in Markdown.
If the source example(s) file can have different syntax for Python 3.8, 3.9, 3.10, there should be different versions of the file, and they should be shown in tabs in the docs.
There should be tests testing the source example.
Before the PR is applied, the new tests should fail.
After applying the PR, the new tests should pass.
Coverage should stay at 100%.
If you see the PR makes sense, or we discussed it and considered it should be accepted, you can add commits on top of the PR to tweak it, to add docs, tests, format, refactor, remove extra files, etc.
Feel free to comment in the PR to ask for more information, to suggest changes, etc.
Once you think the PR is ready, move it in the internal GitHub project for me to review it.
FastAPI People PRs
Every month, a GitHub Action updates the FastAPI People data. Those PRs look like this one:
üë• Update FastAPI People
.
If the tests are passing, you can merge it right away.
External Links PRs
When people add external links they edit this file
external_links.yml
.
Make sure the new link is in the correct category (e.g. "Podcasts") and language (e.g. "Japanese").
A new link should be at the top of its list.
The link URL should work (it should not return a 404).
The content of the link should be about FastAPI.
The new addition should have these fields:
author
: The name of the author.
link
: The URL with the content.
title
: The title of the link (the title of the article, podcast, etc).
After checking all these things and ensuring the PR has the right labels, you can merge it.
Dependabot PRs
Dependabot will create PRs to update dependencies for several things, and those PRs all look similar, but some are way more delicate than others.
If the PR is for a direct dependency, so, Dependabot is modifying
pyproject.toml
,
don't merge it
. üò± Let me check it first. There's a good chance that some additional tweaks or updates are needed.
If the PR updates one of the internal dependencies, for example it's modifying
requirements.txt
files, or GitHub Action versions, if the tests are passing, the release notes (shown in a summary in the PR) don't show any obvious potential breaking change, you can merge it. üòé
Mark GitHub Discussions Answers
When a question in GitHub Discussions has been answered, mark the answer by clicking "Mark as answer".
You can filter discussions by
Questions
that are
Unanswered
.

## 076_MANAGEMENT
Repository Management¬∂
---

Repository Management
Here's a short description of how the FastAPI repository is managed and maintained.
Owner
I,
@tiangolo
, am the creator and owner of the FastAPI repository. ü§ì
I normally give the final review to each PR before merging them. I make the final decisions on the project, I'm the
BDFL
. üòÖ
Team
There's a team of people that help manage and maintain the project. üòé
They have different levels of permissions and
specific instructions
.
Some of the tasks they can perform include:
Adding labels to PRs.
Editing PR titles.
Adding commits on top of PRs to tweak them.
Mark answers in GitHub Discussions questions, etc.
Merge some specific types of PRs.
You can see the current team members in
FastAPI People - Team
.
Joining the team is by invitation only, and I could update or remove permissions, instructions, or membership.
FastAPI Experts
The people that help others the most in GitHub Discussions can become
FastAPI Experts
.
This is normally the best way to contribute to the project.
External Contributions
External contributions are very welcome and appreciated, including answering questions, submitting PRs, etc. üôá‚Äç‚ôÇÔ∏è
There are many ways to
help maintain FastAPI
.

## 077_NL
FastAPI¬∂
---

FastAPI
FastAPI framework, zeer goede prestaties, eenvoudig te leren, snel te programmeren, klaar voor productie
Documentatie
:
https://fastapi.tiangolo.com
Broncode
:
https://github.com/tiangolo/fastapi
FastAPI is een modern, snel (zeer goede prestaties), web framework voor het bouwen van API's in Python, gebruikmakend van standaard Python type-hints.
De belangrijkste kenmerken zijn:
Snel
: Zeer goede prestaties, vergelijkbaar met
NodeJS
en
Go
(dankzij Starlette en Pydantic).
Een van de snelste beschikbare Python frameworks
.
Snel te programmeren
: Verhoog de snelheid om functionaliteit te ontwikkelen met ongeveer 200% tot 300%. *
Minder bugs
: Verminder ongeveer 40% van de door mensen (ontwikkelaars) veroorzaakte fouten. *
Intu√Øtief
: Buitengewoon goede ondersteuning voor editors.
Overal automische code aanvulling
. Minder tijd kwijt aan debuggen.
Eenvoudig
: Ontworpen om gemakkelijk te gebruiken en te leren. Minder tijd nodig om documentatie te lezen.
Kort
: Minimaliseer codeduplicatie. Elke parameterdeclaratie ondersteunt meerdere functionaliteiten. Minder bugs.
Robust
: Code gereed voor productie. Met automatische interactieve documentatie.
Standards-based
: Gebaseerd op (en volledig verenigbaar met) open standaarden voor API's:
OpenAPI
(voorheen bekend als Swagger) en
JSON Schema
.
* schatting op basis van testen met een intern ontwikkelteam en bouwen van productieapplicaties.
Sponsors
Overige sponsoren
Meningen
"
[...] Ik gebruik
FastAPI
heel vaak tegenwoordig. [...] Ik ben van plan om het te gebruiken voor alle
ML-services van mijn team bij Microsoft
. Sommige van deze worden ge√Øntegreerd in het kernproduct van
Windows
en sommige
Office
-producten.
"
Kabir Khan -
Microsoft
(ref)
"
We hebben de
FastAPI
library gebruikt om een
REST
server te maken die bevraagd kan worden om
voorspellingen
te maken. [voor Ludwig]
"
Piero Molino, Yaroslav Dudin en Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is verheugd om een open-source release aan te kondigen van ons
crisismanagement
-orkestratieframework:
Dispatch
! [gebouwd met
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Ik ben super enthousiast over
FastAPI
. Het is zo leuk!
"
Brian Okken -
Python Bytes
podcast presentator
(ref)
"
Wat je hebt gebouwd ziet er echt super solide en gepolijst uit. In veel opzichten is het wat ik wilde dat
Hug
kon zijn - het is echt inspirerend om iemand dit te zien bouwen.
"
Timothy Crosley -
Hug
creator
(ref)
"Wie ge√Ønteresseerd is in een
modern framework
voor het bouwen van REST API's, bekijkt best eens
FastAPI
[...] Het is snel, gebruiksvriendelijk en gemakkelijk te leren [...]_"
"
We zijn overgestapt naar
FastAPI
voor onze
API's
[...] Het gaat jou vast ook bevallen [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
oprichters -
spaCy
ontwikkelaars
(ref)
-
(ref)
"
Wie een Python API wil bouwen voor productie, kan ik ten stelligste
FastAPI
aanraden. Het is
prachtig ontworpen
,
eenvoudig te gebruiken
en
gemakkelijk schaalbaar
, het is een
cruciale component
geworden in onze strategie om API's centraal te zetten, en het vereenvoudigt automatisering en diensten zoals onze Virtual TAC Engineer.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, de FastAPI van CLIs
Als je een
CLI
-app bouwt die in de terminal moet worden gebruikt in plaats van een web-API, gebruik dan
Typer
.
Typer
is het kleine broertje van FastAPI. En het is bedoeld als de
FastAPI van CLI's
. Ô∏è
Vereisten
FastAPI staat op de schouders van reuzen:
Starlette
voor de webonderdelen.
Pydantic
voor de datadelen.
Installatie
fast ‚Üí
pip install "fastapi[standard]"
restart ‚Üª
Opmerking
: Zet
"fastapi[standard]"
tussen aanhalingstekens om ervoor te zorgen dat het werkt in alle terminals.
Voorbeeld
Cre√´er het
Maak het bestand
main.py
aan met daarin:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Of maak gebruik van
async def
...
Als je code gebruik maakt van
async
/
await
, gebruik dan
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Opmerking
:
Als je het niet weet, kijk dan in het gedeelte
"Heb je haast?"
over
async
en
await
in de documentatie
.
Voer het uit
Run de server met:
fast ‚Üí
fastapi dev main.py
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FastAPI CLI - Development mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ ‚îÇ
‚îÇ Serving at: http://127.0.0.1:8000 ‚îÇ
‚îÇ ‚îÇ
‚îÇ API docs: http://127.0.0.1:8000/docs ‚îÇ
‚îÇ ‚îÇ
‚îÇ Running in development mode, for production use: ‚îÇ
‚îÇ ‚îÇ
‚îÇ fastapi run ‚îÇ
‚îÇ ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
Over het commando
fastapi dev main.py
...
Het commando
fastapi dev
leest het
main.py
bestand, detecteert de
FastAPI
app, en start een server met
Uvicorn
.
Standaard zal dit commando
fastapi dev
starten met "auto-reload" geactiveerd voor ontwikkeling op het lokale systeem.
Je kan hier meer over lezen in de
FastAPI CLI documentatie
.
Controleer het
Open je browser op
http://127.0.0.1:8000/items/5?q=somequery
.
Je zult een JSON response zien:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Je hebt een API gemaakt die:
HTTP verzoeken kan ontvangen op de
paden
/
en
/items/{item_id}
.
Beide
paden
hebben
GET
operaties
(ook bekend als HTTP
methoden
).
Het
pad
/items/{item_id}
heeft een
pad parameter
item_id
dat een
int
moet zijn.
Het
pad
/items/{item_id}
heeft een optionele
str
query parameter
q
.
Interactieve API documentatie
Ga naar
http://127.0.0.1:8000/docs
.
Je ziet de automatische interactieve API documentatie (verstrekt door
Swagger UI
):
Alternatieve API documentatie
Ga vervolgens naar
http://127.0.0.1:8000/redoc
.
Je ziet de automatische interactieve API documentatie (verstrekt door
ReDoc
):
Voorbeeld upgrade
Pas nu het bestand
main.py
aan om de body van een
PUT
request te ontvangen.
Dankzij Pydantic kunnen we de body declareren met standaard Python types.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
De
fastapi dev
server zou automatisch moeten herladen.
Interactieve API documentatie upgrade
Ga nu naar
http://127.0.0.1:8000/docs
.
De interactieve API-documentatie wordt automatisch bijgewerkt, inclusief de nieuwe body:
Klik op de knop "Try it out", hiermee kan je de parameters invullen en direct met de API interacteren:
Klik vervolgens op de knop "Execute", de gebruikersinterface zal communiceren met jouw API, de parameters verzenden, de resultaten ophalen en deze op het scherm tonen:
Alternatieve API documentatie upgrade
Ga vervolgens naar
http://127.0.0.1:8000/redoc
.
De alternatieve documentatie zal ook de nieuwe queryparameter en body weergeven:
Samenvatting
Samengevat declareer je
eenmalig
de types van parameters, body, etc. als functieparameters.
Dat doe je met standaard moderne Python types.
Je hoeft geen nieuwe syntax te leren, de methods of klassen van een specifieke bibliotheek, etc.
Gewoon standaard
Python
.
Bijvoorbeeld, voor een
int
:
item_id
:
int
of voor een complexer
Item
model:
item
:
Item
...en met die ene verklaring krijg je:
Editor ondersteuning, inclusief:
Code aanvulling.
Type validatie.
Validatie van data:
Automatische en duidelijke foutboodschappen wanneer de data ongeldig is.
Validatie zelfs voor diep geneste JSON objecten.
Conversie
van invoergegevens: afkomstig van het netwerk naar Python-data en -types. Zoals:
JSON.
Pad parameters.
Query parameters.
Cookies.
Headers.
Formulieren.
Bestanden.
Conversie
van uitvoergegevens: converstie van Python-data en -types naar netwerkgegevens (zoals JSON):
Converteer Python types (
str
,
int
,
float
,
bool
,
list
, etc).
datetime
objecten.
UUID
objecten.
Database modellen.
...en nog veel meer.
Automatische interactieve API-documentatie, inclusief 2 alternatieve gebruikersinterfaces:
Swagger UI.
ReDoc.
Terugkomend op het vorige code voorbeeld,
FastAPI
zal:
Valideren dat er een
item_id
bestaat in het pad voor
GET
en
PUT
verzoeken.
Valideren dat het
item_id
van het type
int
is voor
GET
en
PUT
verzoeken.
Wanneer dat niet het geval is, krijgt de cli√´nt een nuttige, duidelijke foutmelding.
Controleren of er een optionele query parameter is met de naam
q
(zoals in
http://127.0.0.1:8000/items/foo?q=somequery
) voor
GET
verzoeken.
Aangezien de
q
parameter werd gedeclareerd met
= None
, is deze optioneel.
Zonder de
None
declaratie zou deze verplicht zijn (net als bij de body in het geval met
PUT
).
Voor
PUT
verzoeken naar
/items/{item_id}
, lees de body als JSON:
Controleer of het een verplicht attribuut
naam
heeft en dat dat een
str
is.
Controleer of het een verplicht attribuut
price
heeft en dat dat een
float
is.
Controleer of het een optioneel attribuut
is_offer
heeft, dat een
bool
is wanneer het aanwezig is.
Dit alles werkt ook voor diep geneste JSON objecten.
Converteer automatisch van en naar JSON.
Documenteer alles met OpenAPI, dat gebruikt kan worden door:
Interactieve documentatiesystemen.
Automatische client code generatie systemen, voor vele talen.
Biedt 2 interactieve documentatie-webinterfaces aan.
Dit was nog maar een snel overzicht, maar je zou nu toch al een idee moeten hebben over hoe het allemaal werkt.
Probeer deze regel te veranderen:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...van:
...
"item_name"
:
item
.
name
...
...naar:
...
"item_price"
:
item
.
price
...
...en zie hoe je editor de attributen automatisch invult en hun types herkent:
Voor een vollediger voorbeeld met meer mogelijkheden, zie de
Tutorial - Gebruikershandleiding
.
Spoiler alert
: de tutorial - gebruikershandleiding bevat:
Declaratie van
parameters
op andere plaatsen zoals:
headers
,
cookies
,
formuliervelden
en
bestanden
.
Hoe stel je
validatie restricties
in zoals
maximum_length
of een
regex
.
Een zeer krachtig en eenvoudig te gebruiken
Dependency Injection
systeem.
Beveiliging en authenticatie, inclusief ondersteuning voor
OAuth2
met
JWT-tokens
en
HTTP Basic
auth.
Meer geavanceerde (maar even eenvoudige) technieken voor het declareren van
diep geneste JSON modellen
(dankzij Pydantic).
GraphQL
integratie met
Strawberry
en andere packages.
Veel extra functies (dankzij Starlette) zoals:
WebSockets
uiterst gemakkelijke tests gebaseerd op HTTPX en
pytest
CORS
Cookie Sessions
...en meer.
Prestaties
Onafhankelijke TechEmpower benchmarks tonen
FastAPI
applicaties draaiend onder Uvicorn aan als
een van de snelste Python frameworks beschikbaar
, alleen onder Starlette en Uvicorn zelf (intern gebruikt door FastAPI). (*)
Zie de sectie
Benchmarks
om hier meer over te lezen.
Afhankelijkheden
FastAPI maakt gebruik van Pydantic en Starlette.
standard
Afhankelijkheden
Wanneer je FastAPI installeert met
pip install "fastapi[standard]"
, worden de volgende
standard
optionele afhankelijkheden ge√Ønstalleerd:
Gebruikt door Pydantic:
email_validator
- voor email validatie.
Gebruikt door Starlette:
httpx
- Vereist indien je de
TestClient
wil gebruiken.
jinja2
- Vereist als je de standaard templateconfiguratie wil gebruiken.
python-multipart
- Vereist indien je
"parsen"
van formulieren wil ondersteunen met
requests.form()
.
Gebruikt door FastAPI / Starlette:
uvicorn
- voor de server die jouw applicatie laadt en bedient.
fastapi-cli
- om het
fastapi
commando te voorzien.
Zonder
standard
Afhankelijkheden
Indien je de optionele
standard
afhankelijkheden niet wenst te installeren, kan je installeren met
pip install fastapi
in plaats van
pip install "fastapi[standard]"
.
Bijkomende Optionele Afhankelijkheden
Er zijn nog een aantal bijkomende afhankelijkheden die je eventueel kan installeren.
Bijkomende optionele afhankelijkheden voor Pydantic:
pydantic-settings
- voor het beheren van settings.
pydantic-extra-types
- voor extra data types die gebruikt kunnen worden met Pydantic.
Bijkomende optionele afhankelijkheden voor FastAPI:
orjson
- Vereist indien je
ORJSONResponse
wil gebruiken.
ujson
- Vereist indien je
UJSONResponse
wil gebruiken.
Licentie
Dit project is gelicenseerd onder de voorwaarden van de MIT licentie.

## 078_PL
FastAPI¬∂
---

FastAPI
FastAPI to szybki, prosty w nauce i gotowy do u≈ºycia w produkcji framework
Dokumentacja
:
https://fastapi.tiangolo.com
Kod ≈ºr√≥d≈Çowy
:
https://github.com/fastapi/fastapi
FastAPI to nowoczesny, wydajny framework webowy do budowania API z u≈ºyciem Pythona bazujƒÖcy na standardowym typowaniu Pythona.
Kluczowe cechy:
Wydajno≈õƒá
: FastAPI jest bardzo wydajny, na r√≥wni z
NodeJS
oraz
Go
(dziƒôki Starlette i Pydantic).
Jeden z najszybszych dostƒôpnych framework√≥w Pythonowych
.
Szybko≈õƒá kodowania
: Przy≈õpiesza szybko≈õƒá pisania nowych funkcjonalno≈õci o oko≈Ço 200% do 300%. *
Mniejsza ilo≈õƒá b≈Çƒôd√≥w
: Zmniejsza ilo≈õƒá ludzkich (dewelopera) b≈Çƒôdy o oko≈Ço 40%. *
Intuicyjno≈õƒá
: Wspania≈Çe wsparcie dla edytor√≥w kodu. Dostƒôpne wszƒôdzie
automatyczne uzupe≈Çnianie
kodu. Kr√≥tszy czas debugowania.
≈Åatwo≈õƒá
: Zaprojektowany by byƒá prosty i ≈Çatwy do nauczenia. Mniej czasu spƒôdzonego na czytanie dokumentacji.
Kompaktowo≈õƒá
: Minimalizacja powtarzajƒÖcego siƒô kodu. Wiele funkcjonalno≈õci dla ka≈ºdej deklaracji parametru. Mniej b≈Çƒôd√≥w.
Solidno≈õƒá
: Kod gotowy dla ≈õrodowiska produkcyjnego. Wraz z automatycznƒÖ interaktywnƒÖ dokumentacjƒÖ.
BazujƒÖcy na standardach
: Oparty na (i w pe≈Çni kompatybilny z) otwartych standardach API:
OpenAPI
(wcze≈õniej znane jako Swagger) oraz
JSON Schema
.
* oszacowania bazowane na testach wykonanych przez wewnƒôtrzny zesp√≥≈Ç deweloper√≥w, budujƒÖcych aplikacie u≈ºywane na ≈õrodowisku produkcyjnym.
Sponsorzy
Inni sponsorzy
Opinie
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I‚Äôm over the moon excited about
FastAPI
. It‚Äôs so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, FastAPI aplikacji konsolowych
Je≈ºeli tworzysz aplikacje
CLI
, kt√≥ra ma byƒá u≈ºywana w terminalu zamiast API, sprawd≈∫
Typer
.
Typer
to m≈Çodsze rodze≈Ñstwo FastAPI. Jego celem jest pozostanie
FastAPI aplikacji konsolowych
. ‚å®Ô∏è üöÄ
Wymagania
FastAPI oparty jest na:
Starlette
dla czƒô≈õci webowej.
Pydantic
dla czƒô≈õci obs≈ÇugujƒÖcych dane.
Instalacja
fast ‚Üí
pip install fastapi
restart ‚Üª
Na serwerze produkcyjnym bƒôdziesz tak≈ºe potrzebowa≈Ç serwera ASGI, np.
Uvicorn
lub
Hypercorn
.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
Przyk≈Çad
Stw√≥rz
Utw√≥rz plik o nazwie
main.py
z:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Albo u≈ºyj
async def
...
Je≈ºeli tw√≥j kod korzysta z
async
/
await
, u≈ºyj
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Przypis
:
Je≈ºeli nie znasz, sprawd≈∫ sekcjƒô
"In a hurry?"
o
async
i
await
w dokumentacji
.
Uruchom
Uruchom serwer u≈ºywajƒÖc:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
O komendzie
uvicorn main:app --reload
...
Komenda
uvicorn main:app
odnosi siƒô do:
main
: plik
main.py
("modu≈Ç" w Pythonie).
app
: obiekt stworzony w
main.py
w lini
app = FastAPI()
.
--reload
: spraw by serwer resetowa≈Ç siƒô po ka≈ºdej zmianie w kodzie. U≈ºywaj tego tylko w ≈õrodowisku deweloperskim.
Wypr√≥buj
Otw√≥rz link
http://127.0.0.1:8000/items/5?q=somequery
w przeglƒÖdarce.
Zobaczysz nastƒôpujƒÖcƒÖ odpowied≈∫ JSON:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
W≈Ça≈õnie stworzy≈Çe≈õ API kt√≥re:
Otrzymuje ≈ºƒÖdania HTTP w
≈õcie≈ºce
/
i
/items/{item_id}
.
Obie
≈õcie≈ºki
u≈ºywajƒÖ
operacji
GET
(znane tak≈ºe jako
metody
HTTP).
≈öcie≈ºka
/items/{item_id}
ma
parametr ≈õcie≈ºki
item_id
kt√≥ry powinien byƒá obiektem typu
int
.
≈öcie≈ºka
/items/{item_id}
ma opcjonalny
parametr zapytania
typu
str
o nazwie
q
.
Interaktywna dokumentacja API
Otw√≥rz teraz stronƒô
http://127.0.0.1:8000/docs
.
Zobaczysz automatycznƒÖ interaktywnƒÖ dokumentacjƒô API (dostarczonƒÖ z pomocƒÖ
Swagger UI
):
Alternatywna dokumentacja API
Otw√≥rz teraz
http://127.0.0.1:8000/redoc
.
Zobaczysz alternatywnƒÖ, lecz wciƒÖ≈º automatycznƒÖ dokumentacjƒô (wygenerowanƒÖ z pomocƒÖ
ReDoc
):
Aktualizacja przyk≈Çadu
Zmodyfikuj teraz plik
main.py
, aby otrzmywa≈Ç tre≈õƒá (body) ≈ºƒÖdania
PUT
.
Zadeklaruj tre≈õƒá ≈ºƒÖdania, u≈ºywajƒÖc standardowych typ√≥w w Pythonie dziƒôki Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Serwer powinien prze≈Çadowaƒá siƒô automatycznie (poniewa≈º doda≈Çe≈õ
--reload
do komendy
uvicorn
powy≈ºej).
Zaktualizowana interaktywna dokumentacja API
Wejd≈∫ teraz na
http://127.0.0.1:8000/docs
.
Interaktywna dokumentacja API zaktualizuje sie automatycznie, tak≈ºe z nowƒÖ tre≈õciƒÖ ≈ºƒÖdania (body):
Kliknij przycisk "Try it out" (wypr√≥buj), pozwoli Ci to wype≈Çniƒá parametry i bezpo≈õrednio u≈ºyƒá API:
Kliknij potem przycisk "Execute" (wykonaj), interfejs u≈ºytkownika po≈ÇƒÖczy siƒô z API, wy≈õle parametry, otrzyma odpowied≈∫ i wy≈õwietli jƒÖ na ekranie:
Zaktualizowana alternatywna dokumentacja API
Otw√≥rz teraz
http://127.0.0.1:8000/redoc
.
Alternatywna dokumentacja r√≥wnie≈º poka≈ºe zaktualizowane parametry i tre≈õƒá ≈ºƒÖdania (body):
Podsumowanie
PodsumowujƒÖc, musia≈Çe≈õ zadeklarowaƒá typy parametr√≥w, tre≈õci ≈ºƒÖdania (body) itp. tylko
raz
, i sƒÖ one dostƒôpne jako parametry funkcji.
Robisz to tak samo jak ze standardowymi typami w Pythonie.
Nie musisz sie uczyƒá ≈ºadnej nowej sk≈Çadni, metod lub klas ze specyficznych bibliotek itp.
Po prostu standardowy
Python
.
Na przyk≈Çad, dla danych typu
int
:
item_id
:
int
albo dla bardziej z≈Ço≈ºonego obiektu
Item
:
item
:
Item
...i z pojedy≈ÑczƒÖ deklaracjƒÖ otrzymujesz:
Wsparcie edytor√≥w kodu, wliczajƒÖc:
Auto-uzupe≈Çnianie.
Sprawdzanie typ√≥w.
Walidacja danych:
Automatyczne i przejrzyste b≈Çƒôdy gdy dane sƒÖ niepoprawne.
Walidacja nawet dla g≈Çƒôboko zagnie≈ºd≈ºonych obiekt√≥w JSON.
Konwersja
danych wej≈õciowych: przychodzƒÖcych z sieci na Pythonowe typy. Pozwala na przetwarzanie danych:
JSON.
Parametr√≥w ≈õcie≈ºki.
Parametr√≥w zapytania.
Dane cookies.
Dane nag≈Ç√≥wk√≥w (headers).
Formularze.
Pliki.
Konwersja
danych wyj≈õciowych: wychodzƒÖcych z Pythona do sieci (jako JSON):
Przetwarzanie Pythonowych typ√≥w (
str
,
int
,
float
,
bool
,
list
, itp).
Obiekty
datetime
.
Obiekty
UUID
.
Modele baz danych.
...i wiele wiƒôcej.
Automatyczne interaktywne dokumentacje API, wliczajƒÖc 2 alternatywne interfejsy u≈ºytkownika:
Swagger UI.
ReDoc.
WracajƒÖc do poprzedniego przyk≈Çadu,
FastAPI
:
Potwierdzi, ≈ºe w ≈õcie≈ºce jest
item_id
dla ≈ºƒÖda≈Ñ
GET
i
PUT
.
Potwierdzi, ≈ºe
item_id
jest typu
int
dla ≈ºƒÖda≈Ñ
GET
i
PUT
.
Je≈ºeli nie jest, odbiorca zobaczy przydatnƒÖ, przejrzystƒÖ wiadomo≈õƒá z b≈Çƒôdem.
Sprawdzi czy w ≈õcie≈ºce jest opcjonalny parametr zapytania
q
(np.
http://127.0.0.1:8000/items/foo?q=somequery
) dla ≈ºƒÖdania
GET
.
Jako ≈ºe parametr
q
jest zadeklarowany jako
= None
, jest on opcjonalny.
Gdyby tego
None
nie by≈Ço, parametr ten by≈Çby wymagany (tak jak tre≈õƒá ≈ºƒÖdania w ≈ºƒÖdaniu
PUT
).
Dla ≈ºƒÖdania
PUT
z ≈õcie≈ºkƒÖ
/items/{item_id}
, odczyta tre≈õƒá ≈ºƒÖdania jako JSON:
Sprawdzi czy posiada wymagany atrybut
name
, kt√≥ry powinien byƒá typu
str
.
Sprawdzi czy posiada wymagany atrybut
price
, kt√≥ry musi byƒá typu
float
.
Sprawdzi czy posiada opcjonalny atrybut
is_offer
, kt√≥ry (je≈ºeli obecny) powinien byƒá typu
bool
.
To wszystko bƒôdzie r√≥wnie≈º dzia≈Çaƒá dla g≈Çƒôboko zagnie≈ºd≈ºonych obiekt√≥w JSON.
Automatycznie konwertuje z i do JSON.
Dokumentuje wszystko w OpenAPI, kt√≥re mo≈ºe byƒá u≈ºywane przez:
Interaktywne systemy dokumentacji.
Systemy automatycznego generowania kodu klienckiego, dla wielu jƒôzyk√≥w.
Dostarczy bezpo≈õrednio 2 interaktywne dokumentacje webowe.
To dopiero poczƒÖtek, ale ju≈º masz mniej-wiƒôcej pojƒôcie jak to wszystko dzia≈Ça.
Spr√≥buj zmieniƒá linijkƒô:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...z:
...
"item_name"
:
item
.
name
...
...na:
...
"item_price"
:
item
.
price
...
...i zobacz jak edytor kodu automatycznie uzupe≈Çni atrybuty i bƒôdzie zna≈Ç ich typy:
Dla bardziej kompletnych przyk≈Çad√≥w posiadajƒÖcych wiƒôcej funkcjonalno≈õci, zobacz
Tutorial - User Guide
.
Uwaga Spoiler
: tutorial - user guide zawiera:
Deklaracje
parametr√≥w
z innych miejsc takich jak:
nag≈Ç√≥wki
,
pliki cookies
,
formularze
i
pliki
.
Jak ustawiƒá
ograniczenia walidacyjne
takie jak
maksymalna d≈Çugo≈õƒá
lub
regex
.
Potƒô≈ºny i ≈Çatwy w u≈ºyciu system
Dependency Injection
.
Zabezpieczenia i autentykacja, wliczajƒÖc wsparcie dla
OAuth2
z
tokenami JWT
oraz autoryzacjƒÖ
HTTP Basic
.
Bardziej zaawansowane (ale r√≥wnie proste) techniki deklarowania
g≈Çƒôboko zagnie≈ºd≈ºonych modeli JSON
(dziƒôki Pydantic).
Wiele dodatkowych funkcji (dziƒôki Starlette) takie jak:
WebSockety
GraphQL
bardzo proste testy bazujƒÖce na HTTPX oraz
pytest
CORS
Sesje cookie
...i wiƒôcej.
Wydajno≈õƒá
Niezale≈ºne benchmarki TechEmpower pokazujƒÖ, ≈ºe
FastAPI
(uruchomiony na serwerze Uvicorn)
jest jednym z najszybszych dostƒôpnych Pythonowych framework√≥w
, zaraz po Starlette i Uvicorn (u≈ºywanymi wewnƒÖtrznie przez FastAPI). (*)
Aby dowiedzieƒá siƒô o tym wiƒôcej, zobacz sekcjƒô
Benchmarks
.
Opcjonalne zale≈ºno≈õci
U≈ºywane przez Pydantic:
email-validator
- dla walidacji adres√≥w email.
U≈ºywane przez Starlette:
httpx
- Wymagane je≈ºeli chcesz korzystaƒá z
TestClient
.
aiofiles
- Wymagane je≈ºeli chcesz korzystaƒá z
FileResponse
albo
StaticFiles
.
jinja2
- Wymagane je≈ºeli chcesz u≈ºywaƒá domy≈õlnej konfiguracji szablon√≥w.
python-multipart
- Wymagane je≈ºelich chcesz wsparcie
"parsowania"
formularzy, u≈ºywajƒÖc
request.form()
.
itsdangerous
- Wymagany dla wsparcia
SessionMiddleware
.
pyyaml
- Wymagane dla wsparcia
SchemaGenerator
z Starlette (z FastAPI prawdopodobnie tego nie potrzebujesz).
graphene
- Wymagane dla wsparcia
GraphQLApp
.
U≈ºywane przez FastAPI / Starlette:
uvicorn
- jako serwer, kt√≥ry ≈Çaduje i obs≈Çuguje TwojƒÖ aplikacjƒô.
orjson
- Wymagane je≈ºeli chcesz u≈ºywaƒá
ORJSONResponse
.
ujson
- Wymagane je≈ºeli chcesz korzystaƒá z
UJSONResponse
.
Mo≈ºesz zainstalowaƒá wszystkie te aplikacje przy pomocy
pip install fastapi[all]
.
Licencja
Ten projekt jest na licencji MIT.

## 079_PROJECT_GENERATION
Full Stack FastAPI Template¬∂
---

Full Stack FastAPI Template
Templates, while typically come with a specific setup, are designed to be flexible and customizable. This allows you to modify and adapt them to your project's requirements, making them an excellent starting point. üèÅ
You can use this template to get started, as it includes a lot of the initial set up, security, database and some API endpoints already done for you.
GitHub Repository:
Full Stack FastAPI Template
Full Stack FastAPI Template - Technology Stack and Features
‚ö°
FastAPI
for the Python backend API.
üß∞
SQLModel
for the Python SQL database interactions (ORM).
üîç
Pydantic
, used by FastAPI, for the data validation and settings management.
üíæ
PostgreSQL
as the SQL database.
üöÄ
React
for the frontend.
üíÉ Using TypeScript, hooks,
Vite
, and other parts of a modern frontend stack.
üé®
Chakra UI
for the frontend components.
ü§ñ An automatically generated frontend client.
üß™
Playwright
for End-to-End testing.
ü¶á Dark mode support.
üêã
Docker Compose
for development and production.
üîí Secure password hashing by default.
üîë JWT token authentication.
üì´ Email based password recovery.
‚úÖ Tests with
Pytest
.
üìû
Traefik
as a reverse proxy / load balancer.
üö¢ Deployment instructions using Docker Compose, including how to set up a frontend Traefik proxy to handle automatic HTTPS certificates.
üè≠ CI (continuous integration) and CD (continuous deployment) based on GitHub Actions.

## 080_PT
FastAPI¬∂
---

FastAPI
Framework FastAPI, alta performance, f√°cil de aprender, f√°cil de codar, pronto para produ√ß√£o
Documenta√ß√£o
:
https://fastapi.tiangolo.com
C√≥digo fonte
:
https://github.com/fastapi/fastapi
FastAPI √© um moderno e r√°pido (alta performance)
framework web
para constru√ß√£o de APIs com Python, baseado nos
type hints
padr√µes do Python.
Os recursos chave s√£o:
R√°pido
: alta performance, equivalente a
NodeJS
e
Go
(gra√ßas ao Starlette e Pydantic).
Um dos frameworks mais r√°pidos dispon√≠veis
.
R√°pido para codar
: Aumenta a velocidade para desenvolver recursos entre 200% a 300%. *
Poucos bugs
: Reduz cerca de 40% de erros induzidos por humanos (desenvolvedores). *
Intuitivo
: Grande suporte a
IDEs
.
Auto-Complete
em todos os lugares. Menos tempo debugando.
F√°cil
: Projetado para ser f√°cil de aprender e usar. Menos tempo lendo documenta√ß√£o.
Enxuto
: Minimize duplica√ß√£o de c√≥digo. M√∫ltiplos recursos para cada declara√ß√£o de par√¢metro. Menos bugs.
Robusto
: Tenha c√≥digo pronto para produ√ß√£o. E com documenta√ß√£o interativa autom√°tica.
Baseado em padr√µes
: Baseado em (e totalmente compat√≠vel com) os padr√µes abertos para APIs:
OpenAPI
(anteriormente conhecido como Swagger) e
JSON Schema
.
* estimativas baseadas em testes realizados com equipe interna de desenvolvimento, construindo aplica√ß√µes em produ√ß√£o.
Patrocinadores Ouro
Outros patrocinadores
Opini√µes
"
[...] Estou usando
FastAPI
muito esses dias. [...] Estou na verdade planejando utilizar ele em todos os times de
servi√ßos
Machine Learning
na Microsoft
. Alguns deles est√£o sendo integrados no
core
do produto
Windows
e alguns produtos
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
N√≥s adotamos a biblioteca
FastAPI
para iniciar um servidor
REST
que pode ser consultado para obter
previs√µes
. [para o Ludwig]
"
Piero Molino, Yaroslav Dudin, e Sai Sumanth Miryala -
Uber
(ref)
"
A
Netflix
tem o prazer de anunciar o lan√ßamento open-source do nosso framework de orquestra√ß√£o de
gerenciamento de crises
:
Dispatch
! [criado com
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
Estou extremamente entusiasmado com o
FastAPI
. √â t√£o divertido!
"
Brian Okken -
Python Bytes
podcaster
(ref)
"
Honestamente, o que voc√™ construiu parece super s√≥lido e rebuscado. De muitas formas, eu queria que o
Hug
fosse assim - √© realmente inspirador ver algu√©m que construiu ele.
"
Timothy Crosley -
criador do
Hug
(ref)
"
Se voc√™ est√° procurando aprender um
framework
moderno
para construir aplica√ß√µes
REST
, d√™ uma olhada no
FastAPI
[...] √â r√°pido, f√°cil de usar e f√°cil de aprender [...]
"
"
N√≥s trocamos nossas
APIs
por
FastAPI
[...] Acredito que voc√™s gostar√£o dele [...]
"
Ines Montani - Matthew Honnibal -
fundadores da
Explosion AI
- criadores da
spaCy
(ref)
-
(ref)
"
Se algu√©m estiver procurando construir uma API Python para produ√ß√£o, eu recomendaria fortemente o
FastAPI
. Ele √©
lindamente projetado
,
simples de usar
e
altamente escal√°vel
. Ele se tornou um
componente chave
para a nossa estrat√©gia API first de desenvolvimento e est√° impulsionando diversas automa√ß√µes e servi√ßos, como o nosso Virtual TAC Engineer.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, o FastAPI das interfaces de linhas de comando
Se voc√™ estiver construindo uma aplica√ß√£o
CLI
para ser utilizada em um terminal ao inv√©s de uma aplica√ß√£o web, d√™ uma olhada no
Typer
.
Typer
√© o irm√£o menor do FastAPI. E seu prop√≥sito √© ser o
FastAPI das
CLIs
. ‚å®Ô∏è üöÄ
Requisitos
FastAPI est√° nos ombros de gigantes:
Starlette
para as partes web.
Pydantic
para a parte de dados.
Instala√ß√£o
Crie e ative um
ambiente virtual
, e ent√£o instale o FastAPI:
fast ‚Üí
pip install "fastapi[standard]"
restart ‚Üª
Nota
: Certifique-se de que voc√™ colocou
"fastapi[standard]"
com aspas, para garantir que funcione em todos os terminais.
Exemplo
Crie
Crie um arquivo
main.py
com:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Ou use
async def
...
Se seu c√≥digo utiliza
async
/
await
, use
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Nota
:
Se voc√™ n√£o sabe, verifique a se√ß√£o
"Com pressa?"
sobre
async
e
await
nas docs
.
Rode
Rode o servidor com:
fast ‚Üí
fastapi dev main.py
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FastAPI CLI - Development mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ ‚îÇ
‚îÇ Serving at: http://127.0.0.1:8000 ‚îÇ
‚îÇ ‚îÇ
‚îÇ API docs: http://127.0.0.1:8000/docs ‚îÇ
‚îÇ ‚îÇ
‚îÇ Running in development mode, for production use: ‚îÇ
‚îÇ ‚îÇ
‚îÇ fastapi run ‚îÇ
‚îÇ ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
Sobre o comando
fastapi dev main.py
...
O comando
fastapi dev
l√™ o seu arquivo
main.py
, identifica o aplicativo
FastAPI
nele, e inicia um servidor usando o
Uvicorn
.
Por padr√£o, o
fastapi dev
iniciar√° com
auto-reload
habilitado para desenvolvimento local.
Voc√™ pode ler mais sobre isso na
documenta√ß√£o do FastAPI CLI
.
Verifique
Abra seu navegador em
http://127.0.0.1:8000/items/5?q=somequery
.
Voc√™ ver√° a resposta JSON como:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Voc√™ acabou de criar uma API que:
Recebe requisi√ß√µes HTTP nas
rotas
/
e
/items/{item_id}
.
Ambas
rotas
fazem
opera√ß√µes
GET
(tamb√©m conhecido como
m√©todos
HTTP).
A
rota
/items/{item_id}
tem um
par√¢metro de rota
item_id
que deve ser um
int
.
A
rota
/items/{item_id}
tem um
par√¢metro query
q
str
opcional.
Documenta√ß√£o Interativa da API
Agora v√° para
http://127.0.0.1:8000/docs
.
Voc√™ ver√° a documenta√ß√£o autom√°tica interativa da API (fornecida por
Swagger UI
):
Documenta√ß√£o Alternativa da API
E agora, v√° para
http://127.0.0.1:8000/redoc
.
Voc√™ ver√° a documenta√ß√£o autom√°tica alternativa (fornecida por
ReDoc
):
Evoluindo o Exemplo
Agora modifique o arquivo
main.py
para receber um corpo para uma requisi√ß√£o
PUT
.
Declare o corpo utilizando tipos padr√£o Python, gra√ßas ao Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
O servidor
fastapi dev
dever√° recarregar automaticamente.
Evoluindo a Documenta√ß√£o Interativa da API
Agora v√° para
http://127.0.0.1:8000/docs
.
A documenta√ß√£o interativa da API ser√° automaticamente atualizada, incluindo o novo corpo:
Clique no bot√£o "Try it out", ele permitir√° que voc√™ preencha os par√¢metros e interaja diretamente com a API:
Ent√£o clique no bot√£o "Execute", a interface do usu√°rio ir√° se comunicar com a API, enviar os par√¢metros, pegar os resultados e mostr√°-los na tela:
Evoluindo a Documenta√ß√£o Alternativa da API
E agora, v√° para
http://127.0.0.1:8000/redoc
.
A documenta√ß√£o alternativa tamb√©m ir√° refletir o novo par√¢metro da
query
e o corpo:
Recapitulando
Resumindo, voc√™ declara
uma vez
os tipos dos par√¢metros, corpo etc. como par√¢metros de fun√ß√£o.
Voc√™ faz isso com os tipos padr√£o do Python moderno.
Voc√™ n√£o ter√° que aprender uma nova sintaxe, m√©todos ou classes de uma biblioteca espec√≠fica etc.
Apenas
Python
padr√£o.
Por exemplo, para um
int
:
item_id
:
int
ou para um modelo mais complexo,
Item
:
item
:
Item
...e com essa √∫nica declara√ß√£o voc√™ tem:
Suporte ao Editor, incluindo:
Completa√ß√£o.
Verifica√ß√£o de tipos.
Valida√ß√£o de dados:
Erros autom√°ticos e claros quando o dado √© inv√°lido.
Valida√ß√£o at√© para objetos JSON profundamente aninhados.
Convers√£o
de dados de entrada: vindo da rede para dados e tipos Python. Consegue ler:
JSON.
Par√¢metros de rota.
Par√¢metros de
query
.
Cookies
.
Cabe√ßalhos.
Formul√°rios.
Arquivos.
Convers√£o
de dados de sa√≠da de tipos e dados Python para dados de rede (como JSON):
Converte tipos Python (
str
,
int
,
float
,
bool
,
list
etc).
Objetos
datetime
.
Objetos
UUID
.
Modelos de Banco de Dados.
...e muito mais.
Documenta√ß√£o interativa autom√°tica da API, incluindo 2 alternativas de interface de usu√°rio:
Swagger UI.
ReDoc.
Voltando ao c√≥digo do exemplo anterior,
FastAPI
ir√°:
Validar que existe um
item_id
na rota para requisi√ß√µes
GET
e
PUT
.
Validar que
item_id
√© do tipo
int
para requisi√ß√µes
GET
e
PUT
.
Se n√£o √© validado, o cliente ver√° um √∫til, claro erro.
Verificar se existe um par√¢metro de
query
opcional nomeado como
q
(como em
http://127.0.0.1:8000/items/foo?q=somequery
) para requisi√ß√µes
GET
.
Como o par√¢metro
q
√© declarado com
= None
, ele √© opcional.
Sem o
None
ele poderia ser obrigat√≥rio (como o corpo no caso de
PUT
).
Para requisi√ß√µes
PUT
para
/items/{item_id}
, ler√° o corpo como JSON e:
Verifica que tem um atributo obrigat√≥rio
name
que deve ser
str
.
Verifica que tem um atributo obrigat√≥rio
price
que deve ser
float
.
Verifica que tem an atributo opcional
is_offer
, que deve ser
bool
, se presente.
Tudo isso tamb√©m funciona para objetos JSON profundamente aninhados.
Converter de e para JSON automaticamente.
Documentar tudo com OpenAPI, que poder√° ser usado por:
Sistemas de documenta√ß√£o interativos.
Sistemas de clientes de gera√ß√£o de c√≥digo autom√°ticos, para muitas linguagens.
Fornecer diretamente 2 interfaces
web
de documenta√ß√£o interativa.
N√≥s apenas arranhamos a superf√≠cie, mas voc√™ j√° tem id√©ia de como tudo funciona.
Experimente mudar a seguinte linha:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...de:
...
"item_name"
:
item
.
name
...
...para:
...
"item_price"
:
item
.
price
...
...e veja como seu editor ir√° auto-completar os atributos e saber√° os tipos:
Para um exemplo mais completo incluindo mais recursos, veja
Tutorial - Guia do Usu√°rio
.
Alerta de Spoiler
: o tutorial - guia do usu√°rio inclui:
Declara√ß√£o de
par√¢metetros
de diferentes lugares como:
cabe√ßalhos
,
cookies
,
campos de formul√°rios
e
arquivos
.
Como configurar
Limita√ß√µes de Valida√ß√£o
como
maximum_length
ou
regex
.
Um poderoso e f√°cil de usar sistema de
Inje√ß√£o de Depend√™ncia
.
Seguran√ßa e autentica√ß√£o, incluindo suporte para
OAuth2
com autentica√ß√£o
JWT tokens
e
HTTP Basic
.
T√©cnicas mais avan√ßadas (mas igualmente f√°ceis) para declara√ß√£o de
modelos JSON profundamente aninhados
(gra√ßas ao Pydantic).
Integra√ß√µes
GraphQL
com o
Strawberry
e outras bibliotecas.
Muitos recursos extras (gra√ßas ao Starlette) como:
WebSockets
testes extrememamente f√°ceis baseados em HTTPX e
pytest
CORS
Cookie Sessions
...e mais.
Performance
Testes de performance da
Independent TechEmpower
mostram aplica√ß√µes
FastAPI
rodando sob Uvicorn como
um dos
frameworks
Python mais r√°pidos dispon√≠veis
, somente atr√°s de Starlette e Uvicorn (utilizados internamente pelo FastAPI). (*)
Para entender mais sobre performance, veja a se√ß√£o
Compara√ß√µes
.
Depend√™ncias
O FastAPI depende do Pydantic e do Starlette.
Depend√™ncias
standard
Quando voc√™ instala o FastAPI com
pip install "fastapi[standard]"
, ele v√™m com o grupo
standard
(padr√£o) de depend√™ncias opcionais:
Utilizado pelo Pydantic:
email-validator
- para valida√ß√£o de email.
Utilizado pelo Starlette:
httpx
- Obrigat√≥rio caso voc√™ queira utilizar o
TestClient
.
jinja2
- Obrigat√≥rio se voc√™ quer utilizar a configura√ß√£o padr√£o de templates.
python-multipart
- Obrigat√≥rio se voc√™ deseja suporte a
"parsing"
de formul√°rio, com
request.form()
.
Utilizado pelo FastAPI / Starlette:
uvicorn
- para o servidor que carrega e serve a sua aplica√ß√£o. Isto inclui
uvicorn[standard]
, que inclui algumas depend√™ncias (e.g.
uvloop
) necess√°rias para servir em alta performance.
fastapi-cli
- que disponibiliza o comando
fastapi
.
Sem as depend√™ncias
standard
Se voc√™ n√£o deseja incluir as depend√™ncias opcionais
standard
, voc√™ pode instalar utilizando
pip install fastapi
ao inv√©s de
pip install "fastapi[standard]"
.
Dpend√™ncias opcionais adicionais
Existem algumas depend√™ncias adicionais que voc√™ pode querer instalar.
Depend√™ncias opcionais adicionais do Pydantic:
pydantic-settings
- para gerenciamento de configura√ß√µes.
pydantic-extra-types
- tipos extras para serem utilizados com o Pydantic.
Depend√™ncias opcionais adicionais do FastAPI:
orjson
- Obrigat√≥rio se voc√™ deseja utilizar o
ORJSONResponse
.
ujson
- Obrigat√≥rio se voc√™ deseja utilizar o
UJSONResponse
.
Licen√ßa
Esse projeto √© licenciado sob os termos da licen√ßa MIT.

## 081_PYTHON_TYPES
Python Types Intro¬∂
---

Python Types Intro
Python has support for optional "type hints" (also called "type annotations").
These
"type hints"
or annotations are a special syntax that allow declaring the
type
of a variable.
By declaring types for your variables, editors and tools can give you better support.
This is just a
quick tutorial / refresher
about Python type hints. It covers only the minimum necessary to use them with
FastAPI
... which is actually very little.
FastAPI
is all based on these type hints, they give it many advantages and benefits.
But even if you never use
FastAPI
, you would benefit from learning a bit about them.
Note
If you are a Python expert, and you already know everything about type hints, skip to the next chapter.
Motivation
Let's start with a simple example:
Python 3.8+
def
get_full_name
(
first_name
,
last_name
):
full_name
=
first_name
.
title
()
+
" "
+
last_name
.
title
()
return
full_name
print
(
get_full_name
(
"john"
,
"doe"
))
Calling this program outputs:
John Doe
The function does the following:
Takes a
first_name
and
last_name
.
Converts the first letter of each one to upper case with
title()
.
Concatenates
them with a space in the middle.
Python 3.8+
def
get_full_name
(
first_name
,
last_name
):
full_name
=
first_name
.
title
()
+
" "
+
last_name
.
title
()
return
full_name
print
(
get_full_name
(
"john"
,
"doe"
))
Edit it
It's a very simple program.
But now imagine that you were writing it from scratch.
At some point you would have started the definition of the function, you had the parameters ready...
But then you have to call "that method that converts the first letter to upper case".
Was it
upper
? Was it
uppercase
?
first_uppercase
?
capitalize
?
Then, you try with the old programmer's friend, editor autocompletion.
You type the first parameter of the function,
first_name
, then a dot (
.
) and then hit
Ctrl+Space
to trigger the completion.
But, sadly, you get nothing useful:
Add types
Let's modify a single line from the previous version.
We will change exactly this fragment, the parameters of the function, from:
first_name
,
last_name
to:
first_name
:
str
,
last_name
:
str
That's it.
Those are the "type hints":
Python 3.8+
def
get_full_name
(
first_name
:
str
,
last_name
:
str
):
full_name
=
first_name
.
title
()
+
" "
+
last_name
.
title
()
return
full_name
print
(
get_full_name
(
"john"
,
"doe"
))
That is not the same as declaring default values like would be with:
first_name
=
"john"
,
last_name
=
"doe"
It's a different thing.
We are using colons (
:
), not equals (
=
).
And adding type hints normally doesn't change what happens from what would happen without them.
But now, imagine you are again in the middle of creating that function, but with type hints.
At the same point, you try to trigger the autocomplete with
Ctrl+Space
and you see:
With that, you can scroll, seeing the options, until you find the one that "rings a bell":
More motivation
Check this function, it already has type hints:
Python 3.8+
def
get_name_with_age
(
name
:
str
,
age
:
int
):
name_with_age
=
name
+
" is this old: "
+
age
return
name_with_age
Because the editor knows the types of the variables, you don't only get completion, you also get error checks:
Now you know that you have to fix it, convert
age
to a string with
str(age)
:
Python 3.8+
def
get_name_with_age
(
name
:
str
,
age
:
int
):
name_with_age
=
name
+
" is this old: "
+
str
(
age
)
return
name_with_age
Declaring types
You just saw the main place to declare type hints. As function parameters.
This is also the main place you would use them with
FastAPI
.
Simple types
You can declare all the standard Python types, not only
str
.
You can use, for example:
int
float
bool
bytes
Python 3.8+
def
get_items
(
item_a
:
str
,
item_b
:
int
,
item_c
:
float
,
item_d
:
bool
,
item_e
:
bytes
):
return
item_a
,
item_b
,
item_c
,
item_d
,
item_d
,
item_e
Generic types with type parameters
There are some data structures that can contain other values, like
dict
,
list
,
set
and
tuple
. And the internal values can have their own type too.
These types that have internal types are called "
generic
" types. And it's possible to declare them, even with their internal types.
To declare those types and the internal types, you can use the standard Python module
typing
. It exists specifically to support these type hints.
Newer versions of Python
The syntax using
typing
is
compatible
with all versions, from Python 3.6 to the latest ones, including Python 3.9, Python 3.10, etc.
As Python advances,
newer versions
come with improved support for these type annotations and in many cases you won't even need to import and use the
typing
module to declare the type annotations.
If you can choose a more recent version of Python for your project, you will be able to take advantage of that extra simplicity.
In all the docs there are examples compatible with each version of Python (when there's a difference).
For example "
Python 3.6+
" means it's compatible with Python 3.6 or above (including 3.7, 3.8, 3.9, 3.10, etc). And "
Python 3.9+
" means it's compatible with Python 3.9 or above (including 3.10, etc).
If you can use the
latest versions of Python
, use the examples for the latest version, those will have the
best and simplest syntax
, for example, "
Python 3.10+
".
List
For example, let's define a variable to be a
list
of
str
.
Python 3.9+
Python 3.8+
Declare the variable, with the same colon (
:
) syntax.
As the type, put
list
.
As the list is a type that contains some internal types, you put them in square brackets:
def
process_items
(
items
:
list
[
str
]):
for
item
in
items
:
print
(
item
)
From
typing
, import
List
(with a capital
L
):
from
typing
import
List
def
process_items
(
items
:
List
[
str
]):
for
item
in
items
:
print
(
item
)
Declare the variable, with the same colon (
:
) syntax.
As the type, put the
List
that you imported from
typing
.
As the list is a type that contains some internal types, you put them in square brackets:
from
typing
import
List
def
process_items
(
items
:
List
[
str
]):
for
item
in
items
:
print
(
item
)
Info
Those internal types in the square brackets are called "type parameters".
In this case,
str
is the type parameter passed to
List
(or
list
in Python 3.9 and above).
That means: "the variable
items
is a
list
, and each of the items in this list is a
str
".
Tip
If you use Python 3.9 or above, you don't have to import
List
from
typing
, you can use the same regular
list
type instead.
By doing that, your editor can provide support even while processing items from the list:
Without types, that's almost impossible to achieve.
Notice that the variable
item
is one of the elements in the list
items
.
And still, the editor knows it is a
str
, and provides support for that.
Tuple and Set
You would do the same to declare
tuple
s and
set
s:
Python 3.9+
Python 3.8+
def
process_items
(
items_t
:
tuple
[
int
,
int
,
str
],
items_s
:
set
[
bytes
]):
return
items_t
,
items_s
from
typing
import
Set
,
Tuple
def
process_items
(
items_t
:
Tuple
[
int
,
int
,
str
],
items_s
:
Set
[
bytes
]):
return
items_t
,
items_s
This means:
The variable
items_t
is a
tuple
with 3 items, an
int
, another
int
, and a
str
.
The variable
items_s
is a
set
, and each of its items is of type
bytes
.
Dict
To define a
dict
, you pass 2 type parameters, separated by commas.
The first type parameter is for the keys of the
dict
.
The second type parameter is for the values of the
dict
:
Python 3.9+
Python 3.8+
def
process_items
(
prices
:
dict
[
str
,
float
]):
for
item_name
,
item_price
in
prices
.
items
():
print
(
item_name
)
print
(
item_price
)
from
typing
import
Dict
def
process_items
(
prices
:
Dict
[
str
,
float
]):
for
item_name
,
item_price
in
prices
.
items
():
print
(
item_name
)
print
(
item_price
)
This means:
The variable
prices
is a
dict
:
The keys of this
dict
are of type
str
(let's say, the name of each item).
The values of this
dict
are of type
float
(let's say, the price of each item).
Union
You can declare that a variable can be any of
several types
, for example, an
int
or a
str
.
In Python 3.6 and above (including Python 3.10) you can use the
Union
type from
typing
and put inside the square brackets the possible types to accept.
In Python 3.10 there's also a
new syntax
where you can put the possible types separated by a
vertical bar (
|
)
.
Python 3.10+
Python 3.8+
def
process_item
(
item
:
int
|
str
):
print
(
item
)
from
typing
import
Union
def
process_item
(
item
:
Union
[
int
,
str
]):
print
(
item
)
In both cases this means that
item
could be an
int
or a
str
.
Possibly
None
You can declare that a value could have a type, like
str
, but that it could also be
None
.
In Python 3.6 and above (including Python 3.10) you can declare it by importing and using
Optional
from the
typing
module.
from
typing
import
Optional
def
say_hi
(
name
:
Optional
[
str
]
=
None
):
if
name
is
not
None
:
print
(
f
"Hey
{
name
}
!"
)
else
:
print
(
"Hello World"
)
Using
Optional[str]
instead of just
str
will let the editor help you detect errors where you could be assuming that a value is always a
str
, when it could actually be
None
too.
Optional[Something]
is actually a shortcut for
Union[Something, None]
, they are equivalent.
This also means that in Python 3.10, you can use
Something | None
:
Python 3.10+
Python 3.8+
Python 3.8+ alternative
def
say_hi
(
name
:
str
|
None
=
None
):
if
name
is
not
None
:
print
(
f
"Hey
{
name
}
!"
)
else
:
print
(
"Hello World"
)
from
typing
import
Optional
def
say_hi
(
name
:
Optional
[
str
]
=
None
):
if
name
is
not
None
:
print
(
f
"Hey
{
name
}
!"
)
else
:
print
(
"Hello World"
)
from
typing
import
Union
def
say_hi
(
name
:
Union
[
str
,
None
]
=
None
):
if
name
is
not
None
:
print
(
f
"Hey
{
name
}
!"
)
else
:
print
(
"Hello World"
)
Using
Union
or
Optional
If you are using a Python version below 3.10, here's a tip from my very
subjective
point of view:
üö® Avoid using
Optional[SomeType]
Instead ‚ú®
use
Union[SomeType, None]
‚ú®.
Both are equivalent and underneath they are the same, but I would recommend
Union
instead of
Optional
because the word "
optional
" would seem to imply that the value is optional, and it actually means "it can be
None
", even if it's not optional and is still required.
I think
Union[SomeType, None]
is more explicit about what it means.
It's just about the words and names. But those words can affect how you and your teammates think about the code.
As an example, let's take this function:
Python 3.8+
from
typing
import
Optional
def
say_hi
(
name
:
Optional
[
str
]):
print
(
f
"Hey
{
name
}
!"
)
ü§ì Other versions and variants
Python 3.10+
def
say_hi
(
name
:
str
|
None
):
print
(
f
"Hey
{
name
}
!"
)
The parameter
name
is defined as
Optional[str]
, but it is
not optional
, you cannot call the function without the parameter:
say_hi
()
## Oh, no, this throws an error! üò±
The
name
parameter is
still required
(not
optional
) because it doesn't have a default value. Still,
name
accepts
None
as the value:
say_hi
(
name
=
None
)
## This works, None is valid üéâ
The good news is, once you are on Python 3.10 you won't have to worry about that, as you will be able to simply use
|
to define unions of types:
Python 3.10+
def
say_hi
(
name
:
str
|
None
):
print
(
f
"Hey
{
name
}
!"
)
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Optional
def
say_hi
(
name
:
Optional
[
str
]):
print
(
f
"Hey
{
name
}
!"
)
And then you won't have to worry about names like
Optional
and
Union
. üòé
Generic types
These types that take type parameters in square brackets are called
Generic types
or
Generics
, for example:
Python 3.10+
Python 3.9+
Python 3.8+
You can use the same builtin types as generics (with square brackets and types inside):
list
tuple
set
dict
And the same as with Python 3.8, from the
typing
module:
Union
Optional
(the same as with Python 3.8)
...and others.
In Python 3.10, as an alternative to using the generics
Union
and
Optional
, you can use the
vertical bar (
|
)
to declare unions of types, that's a lot better and simpler.
You can use the same builtin types as generics (with square brackets and types inside):
list
tuple
set
dict
And the same as with Python 3.8, from the
typing
module:
Union
Optional
...and others.
List
Tuple
Set
Dict
Union
Optional
...and others.
Classes as types
You can also declare a class as the type of a variable.
Let's say you have a class
Person
, with a name:
Python 3.8+
class
Person
:
def
__init__
(
self
,
name
:
str
):
self
.
name
=
name
def
get_person_name
(
one_person
:
Person
):
return
one_person
.
name
Then you can declare a variable to be of type
Person
:
Python 3.8+
class
Person
:
def
__init__
(
self
,
name
:
str
):
self
.
name
=
name
def
get_person_name
(
one_person
:
Person
):
return
one_person
.
name
And then, again, you get all the editor support:
Notice that this means "
one_person
is an
instance
of the class
Person
".
It doesn't mean "
one_person
is the
class
called
Person
".
Pydantic models
Pydantic
is a Python library to perform data validation.
You declare the "shape" of the data as classes with attributes.
And each attribute has a type.
Then you create an instance of that class with some values and it will validate the values, convert them to the appropriate type (if that's the case) and give you an object with all the data.
And you get all the editor support with that resulting object.
An example from the official Pydantic docs:
Python 3.10+
Python 3.9+
Python 3.8+
from
datetime
import
datetime
from
pydantic
import
BaseModel
class
User
(
BaseModel
):
id
:
int
name
:
str
=
"John Doe"
signup_ts
:
datetime
|
None
=
None
friends
:
list
[
int
]
=
[]
external_data
=
{
"id"
:
"123"
,
"signup_ts"
:
"2017-06-01 12:22"
,
"friends"
:
[
1
,
"2"
,
b
"3"
],
}
user
=
User
(
**
external_data
)
print
(
user
)
## > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print
(
user
.
id
)
## > 123
from
datetime
import
datetime
from
typing
import
Union
from
pydantic
import
BaseModel
class
User
(
BaseModel
):
id
:
int
name
:
str
=
"John Doe"
signup_ts
:
Union
[
datetime
,
None
]
=
None
friends
:
list
[
int
]
=
[]
external_data
=
{
"id"
:
"123"
,
"signup_ts"
:
"2017-06-01 12:22"
,
"friends"
:
[
1
,
"2"
,
b
"3"
],
}
user
=
User
(
**
external_data
)
print
(
user
)
## > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print
(
user
.
id
)
## > 123
from
datetime
import
datetime
from
typing
import
List
,
Union
from
pydantic
import
BaseModel
class
User
(
BaseModel
):
id
:
int
name
:
str
=
"John Doe"
signup_ts
:
Union
[
datetime
,
None
]
=
None
friends
:
List
[
int
]
=
[]
external_data
=
{
"id"
:
"123"
,
"signup_ts"
:
"2017-06-01 12:22"
,
"friends"
:
[
1
,
"2"
,
b
"3"
],
}
user
=
User
(
**
external_data
)
print
(
user
)
## > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print
(
user
.
id
)
## > 123
Info
To learn more about
Pydantic, check its docs
.
FastAPI
is all based on Pydantic.
You will see a lot more of all this in practice in the
Tutorial - User Guide
.
Tip
Pydantic has a special behavior when you use
Optional
or
Union[Something, None]
without a default value, you can read more about it in the Pydantic docs about
Required Optional fields
.
Type Hints with Metadata Annotations
Python also has a feature that allows putting
additional
metadata
in these type hints using
Annotated
.
Python 3.9+
Python 3.8+
In Python 3.9,
Annotated
is part of the standard library, so you can import it from
typing
.
from
typing
import
Annotated
def
say_hello
(
name
:
Annotated
[
str
,
"this is just metadata"
])
->
str
:
return
f
"Hello
{
name
}
"
In versions below Python 3.9, you import
Annotated
from
typing_extensions
.
It will already be installed with
FastAPI
.
from
typing_extensions
import
Annotated
def
say_hello
(
name
:
Annotated
[
str
,
"this is just metadata"
])
->
str
:
return
f
"Hello
{
name
}
"
Python itself doesn't do anything with this
Annotated
. And for editors and other tools, the type is still
str
.
But you can use this space in
Annotated
to provide
FastAPI
with additional metadata about how you want your application to behave.
The important thing to remember is that
the first
type parameter
you pass to
Annotated
is the
actual type
. The rest, is just metadata for other tools.
For now, you just need to know that
Annotated
exists, and that it's standard Python. üòé
Later you will see how
powerful
it can be.
Tip
The fact that this is
standard Python
means that you will still get the
best possible developer experience
in your editor, with the tools you use to analyze and refactor your code, etc. ‚ú®
And also that your code will be very compatible with many other Python tools and libraries. üöÄ
Type hints in
FastAPI
FastAPI
takes advantage of these type hints to do several things.
With
FastAPI
you declare parameters with type hints and you get:
Editor support
.
Type checks
.
...and
FastAPI
uses the same declarations to:
Define requirements
: from request path parameters, query parameters, headers, bodies, dependencies, etc.
Convert data
: from the request to the required type.
Validate data
: coming from each request:
Generating
automatic errors
returned to the client when the data is invalid.
Document
the API using OpenAPI:
which is then used by the automatic interactive documentation user interfaces.
This might all sound abstract. Don't worry. You'll see all this in action in the
Tutorial - User Guide
.
The important thing is that by using standard Python types, in a single place (instead of adding more classes, decorators, etc),
FastAPI
will do a lot of the work for you.
Info
If you already went through all the tutorial and came back to see more about types, a good resource is
the "cheat sheet" from
mypy
.

## 082_REFERENCE
Reference¬∂
---

Reference
Here's the reference or code API, the classes, functions, parameters, attributes, and
all the FastAPI parts you can use in your applications.
If you want to
learn FastAPI
you are much better off reading the
FastAPI Tutorial
.

## 083_REFERENCE_APIROUTER
APIRouterclass¬∂
---

APIRouter
class
Here's the reference information for the
APIRouter
class, with all its parameters, attributes and methods.
You can import the
APIRouter
class directly from
fastapi
:
from
fastapi
import
APIRouter
fastapi.APIRouter
APIRouter
(
*
,
prefix
=
""
,
tags
=
None
,
dependencies
=
None
,
default_response_class
=
Default
(
JSONResponse
),
responses
=
None
,
callbacks
=
None
,
routes
=
None
,
redirect_slashes
=
True
,
default
=
None
,
dependency_overrides_provider
=
None
,
route_class
=
APIRoute
,
on_startup
=
None
,
on_shutdown
=
None
,
lifespan
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Bases:
Router
APIRouter
class, used to group
path operations
, for example to structure
an app in multiple files. It would then be included in the
FastAPI
app, or
in another
APIRouter
(ultimately included in the app).
Read more about it in the
FastAPI docs for Bigger Applications - Multiple Files
.
Example
from
fastapi
import
APIRouter
,
FastAPI
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
prefix
An optional path prefix for the router.
TYPE:
str
DEFAULT:
''
tags
A list of tags to be applied to all the
path operations
in this
router.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to all the
path operations
in this router.
Read more about it in the
FastAPI docs for Bigger Applications - Multiple Files
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
default_response_class
The default response class to be used.
Read more in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
responses
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Additional Responses in OpenAPI
.
And in the
FastAPI docs for Bigger Applications
.
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
callbacks
OpenAPI callbacks that should apply to all
path operations
in this
router.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
routes
Note
: you probably shouldn't use this parameter, it is inherited
from Starlette and supported for compatibility.
A list of routes to serve incoming HTTP and WebSocket requests.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
redirect_slashes
Whether to detect and redirect slashes in URLs when the client doesn't
use the same format.
TYPE:
bool
DEFAULT:
True
default
Default function handler for this router. Used to handle
404 Not Found errors.
TYPE:
Optional
[
ASGIApp
]
DEFAULT:
None
dependency_overrides_provider
Only used internally by FastAPI to handle dependency overrides.
You shouldn't need to use it. It normally points to the
FastAPI
app
object.
TYPE:
Optional
[
Any
]
DEFAULT:
None
route_class
Custom route (
path operation
) class to be used by this router.
Read more about it in the
FastAPI docs for Custom Request and APIRoute class
.
TYPE:
Type
[
APIRoute
]
DEFAULT:
APIRoute
on_startup
A list of startup event handler functions.
You should instead use the
lifespan
handlers.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Sequence
[
Callable
[[],
Any
]]]
DEFAULT:
None
on_shutdown
A list of shutdown event handler functions.
You should instead use the
lifespan
handlers.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Sequence
[
Callable
[[],
Any
]]]
DEFAULT:
None
lifespan
A
Lifespan
context manager handler. This replaces
startup
and
shutdown
functions with a single context manager.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Lifespan
[
Any
]]
DEFAULT:
None
deprecated
Mark all
path operations
in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
bool
]
DEFAULT:
None
include_in_schema
To include (or not) all the
path operations
in this router in the
generated OpenAPI.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812
813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
def
__init__
(
self
,
*
,
prefix
:
Annotated
[
str
,
Doc
(
"An optional path prefix for the router."
)]
=
""
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to all the *path operations* in this
router.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to all the
*path operations* in this router.
Read more about it in the
[FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
default_response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
The default response class to be used.
Read more in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
"""
),
]
=
Default
(
JSONResponse
),
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
And in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
OpenAPI callbacks that should apply to all *path operations* in this
router.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
routes
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
**Note**: you probably shouldn't use this parameter, it is inherited
from Starlette and supported for compatibility.
---
A list of routes to serve incoming HTTP and WebSocket requests.
"""
),
deprecated
(
"""
You normally wouldn't use this parameter with FastAPI, it is inherited
from Starlette and supported for compatibility.
In FastAPI, you normally would use the *path operation methods*,
like `router.get()`, `router.post()`, etc.
"""
),
]
=
None
,
redirect_slashes
:
Annotated
[
bool
,
Doc
(
"""
Whether to detect and redirect slashes in URLs when the client doesn't
use the same format.
"""
),
]
=
True
,
default
:
Annotated
[
Optional
[
ASGIApp
],
Doc
(
"""
Default function handler for this router. Used to handle
404 Not Found errors.
"""
),
]
=
None
,
dependency_overrides_provider
:
Annotated
[
Optional
[
Any
],
Doc
(
"""
Only used internally by FastAPI to handle dependency overrides.
You shouldn't need to use it. It normally points to the `FastAPI` app
object.
"""
),
]
=
None
,
route_class
:
Annotated
[
Type
[
APIRoute
],
Doc
(
"""
Custom route (*path operation*) class to be used by this router.
Read more about it in the
[FastAPI docs for Custom Request and APIRoute class](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#custom-apiroute-class-in-a-router).
"""
),
]
=
APIRoute
,
on_startup
:
Annotated
[
Optional
[
Sequence
[
Callable
[[],
Any
]]],
Doc
(
"""
A list of startup event handler functions.
You should instead use the `lifespan` handlers.
Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
on_shutdown
:
Annotated
[
Optional
[
Sequence
[
Callable
[[],
Any
]]],
Doc
(
"""
A list of shutdown event handler functions.
You should instead use the `lifespan` handlers.
Read more in the
[FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
## the generic to Lifespan[AppType] is the type of the top level application
## which the router cannot know statically, so we use typing.Any
lifespan
:
Annotated
[
Optional
[
Lifespan
[
Any
]],
Doc
(
"""
A `Lifespan` context manager handler. This replaces `startup` and
`shutdown` functions with a single context manager.
Read more in the
[FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark all *path operations* in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) all the *path operations* in this router in the
generated OpenAPI.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
None
:
super
()
.
__init__
(
routes
=
routes
,
redirect_slashes
=
redirect_slashes
,
default
=
default
,
on_startup
=
on_startup
,
on_shutdown
=
on_shutdown
,
lifespan
=
lifespan
,
)
if
prefix
:
assert
prefix
.
startswith
(
"/"
),
"A path prefix must start with '/'"
assert
not
prefix
.
endswith
(
"/"
),
(
"A path prefix must not end with '/', as the routes will start with '/'"
)
self
.
prefix
=
prefix
self
.
tags
:
List
[
Union
[
str
,
Enum
]]
=
tags
or
[]
self
.
dependencies
=
list
(
dependencies
or
[])
self
.
deprecated
=
deprecated
self
.
include_in_schema
=
include_in_schema
self
.
responses
=
responses
or
{}
self
.
callbacks
=
callbacks
or
[]
self
.
dependency_overrides_provider
=
dependency_overrides_provider
self
.
route_class
=
route_class
self
.
default_response_class
=
default_response_class
self
.
generate_unique_id_function
=
generate_unique_id_function
websocket
websocket
(
path
,
name
=
None
,
*
,
dependencies
=
None
)
Decorate a WebSocket function.
Read more about it in the
FastAPI docs for WebSockets
.
Example
Example
from
fastapi
import
APIRouter
,
FastAPI
,
WebSocket
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
websocket
(
"/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
"
)
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
WebSocket path.
TYPE:
str
name
A name for the WebSocket. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be used for this
WebSocket.
Read more about it in the
FastAPI docs for WebSockets
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
Source code in
fastapi/routing.py
1046
1047
1048
1049
1050
1051
1052
1053
1054
1055
1056
1057
1058
1059
1060
1061
1062
1063
1064
1065
1066
1067
1068
1069
1070
1071
1072
1073
1074
1075
1076
1077
1078
1079
1080
1081
1082
1083
1084
1085
1086
1087
1088
1089
1090
1091
1092
1093
1094
1095
1096
1097
1098
1099
1100
1101
1102
1103
1104
1105
1106
1107
1108
1109
1110
1111
def
websocket
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
WebSocket path.
"""
),
],
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A name for the WebSocket. Only used internally.
"""
),
]
=
None
,
*
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be used for this
WebSocket.
Read more about it in the
[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
"""
),
]
=
None
,
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Decorate a WebSocket function.
Read more about it in the
[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
**Example**
## Example
```python
from fastapi import APIRouter, FastAPI, WebSocket
app = FastAPI()
router = APIRouter()
@router.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
await websocket.accept()
while True:
data = await websocket.receive_text()
await websocket.send_text(f"Message text was: {data}")
app.include_router(router)
```
"""
def
decorator
(
func
:
DecoratedCallable
)
->
DecoratedCallable
:
self
.
add_api_websocket_route
(
path
,
func
,
name
=
name
,
dependencies
=
dependencies
)
return
func
return
decorator
include_router
include_router
(
router
,
*
,
prefix
=
""
,
tags
=
None
,
dependencies
=
None
,
default_response_class
=
Default
(
JSONResponse
),
responses
=
None
,
callbacks
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Include another
APIRouter
in the same current
APIRouter
.
Read more about it in the
FastAPI docs for Bigger Applications
.
Example
from
fastapi
import
APIRouter
,
FastAPI
app
=
FastAPI
()
internal_router
=
APIRouter
()
users_router
=
APIRouter
()
@users_router
.
get
(
"/users/"
)
def
read_users
():
return
[{
"name"
:
"Rick"
},
{
"name"
:
"Morty"
}]
internal_router
.
include_router
(
users_router
)
app
.
include_router
(
internal_router
)
PARAMETER
DESCRIPTION
router
The
APIRouter
to include.
TYPE:
APIRouter
prefix
An optional path prefix for the router.
TYPE:
str
DEFAULT:
''
tags
A list of tags to be applied to all the
path operations
in this
router.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to all the
path operations
in this router.
Read more about it in the
FastAPI docs for Bigger Applications - Multiple Files
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
default_response_class
The default response class to be used.
Read more in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
responses
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Additional Responses in OpenAPI
.
And in the
FastAPI docs for Bigger Applications
.
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
callbacks
OpenAPI callbacks that should apply to all
path operations
in this
router.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
deprecated
Mark all
path operations
in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
bool
]
DEFAULT:
None
include_in_schema
Include (or not) all the
path operations
in this router in the
generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
1122
1123
1124
1125
1126
1127
1128
1129
1130
1131
1132
1133
1134
1135
1136
1137
1138
1139
1140
1141
1142
1143
1144
1145
1146
1147
1148
1149
1150
1151
1152
1153
1154
1155
1156
1157
1158
1159
1160
1161
1162
1163
1164
1165
1166
1167
1168
1169
1170
1171
1172
1173
1174
1175
1176
1177
1178
1179
1180
1181
1182
1183
1184
1185
1186
1187
1188
1189
1190
1191
1192
1193
1194
1195
1196
1197
1198
1199
1200
1201
1202
1203
1204
1205
1206
1207
1208
1209
1210
1211
1212
1213
1214
1215
1216
1217
1218
1219
1220
1221
1222
1223
1224
1225
1226
1227
1228
1229
1230
1231
1232
1233
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243
1244
1245
1246
1247
1248
1249
1250
1251
1252
1253
1254
1255
1256
1257
1258
1259
1260
1261
1262
1263
1264
1265
1266
1267
1268
1269
1270
1271
1272
1273
1274
1275
1276
1277
1278
1279
1280
1281
1282
1283
1284
1285
1286
1287
1288
1289
1290
1291
1292
1293
1294
1295
1296
1297
1298
1299
1300
1301
1302
1303
1304
1305
1306
1307
1308
1309
1310
1311
1312
1313
1314
1315
1316
1317
1318
1319
1320
1321
1322
1323
1324
1325
1326
1327
1328
1329
1330
1331
1332
1333
1334
1335
1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352
1353
1354
1355
1356
1357
1358
1359
1360
1361
1362
1363
1364
def
include_router
(
self
,
router
:
Annotated
[
"APIRouter"
,
Doc
(
"The `APIRouter` to include."
)],
*
,
prefix
:
Annotated
[
str
,
Doc
(
"An optional path prefix for the router."
)]
=
""
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to all the *path operations* in this
router.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to all the
*path operations* in this router.
Read more about it in the
[FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
default_response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
The default response class to be used.
Read more in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
"""
),
]
=
Default
(
JSONResponse
),
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
And in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
OpenAPI callbacks that should apply to all *path operations* in this
router.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark all *path operations* in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include (or not) all the *path operations* in this router in the
generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
None
:
"""
Include another `APIRouter` in the same current `APIRouter`.
Read more about it in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).
## Example
```python
from fastapi import APIRouter, FastAPI
app = FastAPI()
internal_router = APIRouter()
users_router = APIRouter()
@users_router.get("/users/")
def read_users():
return [{"name": "Rick"}, {"name": "Morty"}]
internal_router.include_router(users_router)
app.include_router(internal_router)
```
"""
if
prefix
:
assert
prefix
.
startswith
(
"/"
),
"A path prefix must start with '/'"
assert
not
prefix
.
endswith
(
"/"
),
(
"A path prefix must not end with '/', as the routes will start with '/'"
)
else
:
for
r
in
router
.
routes
:
path
=
getattr
(
r
,
"path"
)
## noqa: B009
name
=
getattr
(
r
,
"name"
,
"unknown"
)
if
path
is
not
None
and
not
path
:
raise
FastAPIError
(
f
"Prefix and path cannot be both empty (path operation:
{
name
}
)"
)
if
responses
is
None
:
responses
=
{}
for
route
in
router
.
routes
:
if
isinstance
(
route
,
APIRoute
):
combined_responses
=
{
**
responses
,
**
route
.
responses
}
use_response_class
=
get_value_or_default
(
route
.
response_class
,
router
.
default_response_class
,
default_response_class
,
self
.
default_response_class
,
)
current_tags
=
[]
if
tags
:
current_tags
.
extend
(
tags
)
if
route
.
tags
:
current_tags
.
extend
(
route
.
tags
)
current_dependencies
:
List
[
params
.
Depends
]
=
[]
if
dependencies
:
current_dependencies
.
extend
(
dependencies
)
if
route
.
dependencies
:
current_dependencies
.
extend
(
route
.
dependencies
)
current_callbacks
=
[]
if
callbacks
:
current_callbacks
.
extend
(
callbacks
)
if
route
.
callbacks
:
current_callbacks
.
extend
(
route
.
callbacks
)
current_generate_unique_id
=
get_value_or_default
(
route
.
generate_unique_id_function
,
router
.
generate_unique_id_function
,
generate_unique_id_function
,
self
.
generate_unique_id_function
,
)
self
.
add_api_route
(
prefix
+
route
.
path
,
route
.
endpoint
,
response_model
=
route
.
response_model
,
status_code
=
route
.
status_code
,
tags
=
current_tags
,
dependencies
=
current_dependencies
,
summary
=
route
.
summary
,
description
=
route
.
description
,
response_description
=
route
.
response_description
,
responses
=
combined_responses
,
deprecated
=
route
.
deprecated
or
deprecated
or
self
.
deprecated
,
methods
=
route
.
methods
,
operation_id
=
route
.
operation_id
,
response_model_include
=
route
.
response_model_include
,
response_model_exclude
=
route
.
response_model_exclude
,
response_model_by_alias
=
route
.
response_model_by_alias
,
response_model_exclude_unset
=
route
.
response_model_exclude_unset
,
response_model_exclude_defaults
=
route
.
response_model_exclude_defaults
,
response_model_exclude_none
=
route
.
response_model_exclude_none
,
include_in_schema
=
route
.
include_in_schema
and
self
.
include_in_schema
and
include_in_schema
,
response_class
=
use_response_class
,
name
=
route
.
name
,
route_class_override
=
type
(
route
),
callbacks
=
current_callbacks
,
openapi_extra
=
route
.
openapi_extra
,
generate_unique_id_function
=
current_generate_unique_id
,
)
elif
isinstance
(
route
,
routing
.
Route
):
methods
=
list
(
route
.
methods
or
[])
self
.
add_route
(
prefix
+
route
.
path
,
route
.
endpoint
,
methods
=
methods
,
include_in_schema
=
route
.
include_in_schema
,
name
=
route
.
name
,
)
elif
isinstance
(
route
,
APIWebSocketRoute
):
current_dependencies
=
[]
if
dependencies
:
current_dependencies
.
extend
(
dependencies
)
if
route
.
dependencies
:
current_dependencies
.
extend
(
route
.
dependencies
)
self
.
add_api_websocket_route
(
prefix
+
route
.
path
,
route
.
endpoint
,
dependencies
=
current_dependencies
,
name
=
route
.
name
,
)
elif
isinstance
(
route
,
routing
.
WebSocketRoute
):
self
.
add_websocket_route
(
prefix
+
route
.
path
,
route
.
endpoint
,
name
=
route
.
name
)
for
handler
in
router
.
on_startup
:
self
.
add_event_handler
(
"startup"
,
handler
)
for
handler
in
router
.
on_shutdown
:
self
.
add_event_handler
(
"shutdown"
,
handler
)
self
.
lifespan_context
=
_merge_lifespan_context
(
self
.
lifespan_context
,
router
.
lifespan_context
,
)
get
get
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP GET operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
get
(
"/items/"
)
def
read_items
():
return
[{
"name"
:
"Empanada"
},
{
"name"
:
"Arepa"
}]
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
1366
1367
1368
1369
1370
1371
1372
1373
1374
1375
1376
1377
1378
1379
1380
1381
1382
1383
1384
1385
1386
1387
1388
1389
1390
1391
1392
1393
1394
1395
1396
1397
1398
1399
1400
1401
1402
1403
1404
1405
1406
1407
1408
1409
1410
1411
1412
1413
1414
1415
1416
1417
1418
1419
1420
1421
1422
1423
1424
1425
1426
1427
1428
1429
1430
1431
1432
1433
1434
1435
1436
1437
1438
1439
1440
1441
1442
1443
1444
1445
1446
1447
1448
1449
1450
1451
1452
1453
1454
1455
1456
1457
1458
1459
1460
1461
1462
1463
1464
1465
1466
1467
1468
1469
1470
1471
1472
1473
1474
1475
1476
1477
1478
1479
1480
1481
1482
1483
1484
1485
1486
1487
1488
1489
1490
1491
1492
1493
1494
1495
1496
1497
1498
1499
1500
1501
1502
1503
1504
1505
1506
1507
1508
1509
1510
1511
1512
1513
1514
1515
1516
1517
1518
1519
1520
1521
1522
1523
1524
1525
1526
1527
1528
1529
1530
1531
1532
1533
1534
1535
1536
1537
1538
1539
1540
1541
1542
1543
1544
1545
1546
1547
1548
1549
1550
1551
1552
1553
1554
1555
1556
1557
1558
1559
1560
1561
1562
1563
1564
1565
1566
1567
1568
1569
1570
1571
1572
1573
1574
1575
1576
1577
1578
1579
1580
1581
1582
1583
1584
1585
1586
1587
1588
1589
1590
1591
1592
1593
1594
1595
1596
1597
1598
1599
1600
1601
1602
1603
1604
1605
1606
1607
1608
1609
1610
1611
1612
1613
1614
1615
1616
1617
1618
1619
1620
1621
1622
1623
1624
1625
1626
1627
1628
1629
1630
1631
1632
1633
1634
1635
1636
1637
1638
1639
1640
1641
1642
1643
1644
1645
1646
1647
1648
1649
1650
1651
1652
1653
1654
1655
1656
1657
1658
1659
1660
1661
1662
1663
1664
1665
1666
1667
1668
1669
1670
1671
1672
1673
1674
1675
1676
1677
1678
1679
1680
1681
1682
1683
1684
1685
1686
1687
1688
1689
1690
1691
1692
1693
1694
1695
1696
1697
1698
1699
1700
1701
1702
1703
1704
1705
1706
1707
1708
1709
1710
1711
1712
1713
1714
1715
1716
1717
1718
1719
1720
1721
1722
1723
1724
1725
1726
1727
1728
1729
1730
1731
1732
1733
1734
1735
1736
1737
1738
1739
1740
1741
def
get
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP GET operation.
## Example
```python
from fastapi import APIRouter, FastAPI
app = FastAPI()
router = APIRouter()
@router.get("/items/")
def read_items():
return [{"name": "Empanada"}, {"name": "Arepa"}]
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"GET"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
put
put
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP PUT operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
put
(
"/items/
{item_id}
"
)
def
replace_item
(
item_id
:
str
,
item
:
Item
):
return
{
"message"
:
"Item replaced"
,
"id"
:
item_id
}
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
1743
1744
1745
1746
1747
1748
1749
1750
1751
1752
1753
1754
1755
1756
1757
1758
1759
1760
1761
1762
1763
1764
1765
1766
1767
1768
1769
1770
1771
1772
1773
1774
1775
1776
1777
1778
1779
1780
1781
1782
1783
1784
1785
1786
1787
1788
1789
1790
1791
1792
1793
1794
1795
1796
1797
1798
1799
1800
1801
1802
1803
1804
1805
1806
1807
1808
1809
1810
1811
1812
1813
1814
1815
1816
1817
1818
1819
1820
1821
1822
1823
1824
1825
1826
1827
1828
1829
1830
1831
1832
1833
1834
1835
1836
1837
1838
1839
1840
1841
1842
1843
1844
1845
1846
1847
1848
1849
1850
1851
1852
1853
1854
1855
1856
1857
1858
1859
1860
1861
1862
1863
1864
1865
1866
1867
1868
1869
1870
1871
1872
1873
1874
1875
1876
1877
1878
1879
1880
1881
1882
1883
1884
1885
1886
1887
1888
1889
1890
1891
1892
1893
1894
1895
1896
1897
1898
1899
1900
1901
1902
1903
1904
1905
1906
1907
1908
1909
1910
1911
1912
1913
1914
1915
1916
1917
1918
1919
1920
1921
1922
1923
1924
1925
1926
1927
1928
1929
1930
1931
1932
1933
1934
1935
1936
1937
1938
1939
1940
1941
1942
1943
1944
1945
1946
1947
1948
1949
1950
1951
1952
1953
1954
1955
1956
1957
1958
1959
1960
1961
1962
1963
1964
1965
1966
1967
1968
1969
1970
1971
1972
1973
1974
1975
1976
1977
1978
1979
1980
1981
1982
1983
1984
1985
1986
1987
1988
1989
1990
1991
1992
1993
1994
1995
1996
1997
1998
1999
2000
2001
2002
2003
2004
2005
2006
2007
2008
2009
2010
2011
2012
2013
2014
2015
2016
2017
2018
2019
2020
2021
2022
2023
2024
2025
2026
2027
2028
2029
2030
2031
2032
2033
2034
2035
2036
2037
2038
2039
2040
2041
2042
2043
2044
2045
2046
2047
2048
2049
2050
2051
2052
2053
2054
2055
2056
2057
2058
2059
2060
2061
2062
2063
2064
2065
2066
2067
2068
2069
2070
2071
2072
2073
2074
2075
2076
2077
2078
2079
2080
2081
2082
2083
2084
2085
2086
2087
2088
2089
2090
2091
2092
2093
2094
2095
2096
2097
2098
2099
2100
2101
2102
2103
2104
2105
2106
2107
2108
2109
2110
2111
2112
2113
2114
2115
2116
2117
2118
2119
2120
2121
2122
2123
def
put
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP PUT operation.
## Example
```python
from fastapi import APIRouter, FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
router = APIRouter()
@router.put("/items/{item_id}")
def replace_item(item_id: str, item: Item):
return {"message": "Item replaced", "id": item_id}
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"PUT"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
post
post
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP POST operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item created"
}
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
2125
2126
2127
2128
2129
2130
2131
2132
2133
2134
2135
2136
2137
2138
2139
2140
2141
2142
2143
2144
2145
2146
2147
2148
2149
2150
2151
2152
2153
2154
2155
2156
2157
2158
2159
2160
2161
2162
2163
2164
2165
2166
2167
2168
2169
2170
2171
2172
2173
2174
2175
2176
2177
2178
2179
2180
2181
2182
2183
2184
2185
2186
2187
2188
2189
2190
2191
2192
2193
2194
2195
2196
2197
2198
2199
2200
2201
2202
2203
2204
2205
2206
2207
2208
2209
2210
2211
2212
2213
2214
2215
2216
2217
2218
2219
2220
2221
2222
2223
2224
2225
2226
2227
2228
2229
2230
2231
2232
2233
2234
2235
2236
2237
2238
2239
2240
2241
2242
2243
2244
2245
2246
2247
2248
2249
2250
2251
2252
2253
2254
2255
2256
2257
2258
2259
2260
2261
2262
2263
2264
2265
2266
2267
2268
2269
2270
2271
2272
2273
2274
2275
2276
2277
2278
2279
2280
2281
2282
2283
2284
2285
2286
2287
2288
2289
2290
2291
2292
2293
2294
2295
2296
2297
2298
2299
2300
2301
2302
2303
2304
2305
2306
2307
2308
2309
2310
2311
2312
2313
2314
2315
2316
2317
2318
2319
2320
2321
2322
2323
2324
2325
2326
2327
2328
2329
2330
2331
2332
2333
2334
2335
2336
2337
2338
2339
2340
2341
2342
2343
2344
2345
2346
2347
2348
2349
2350
2351
2352
2353
2354
2355
2356
2357
2358
2359
2360
2361
2362
2363
2364
2365
2366
2367
2368
2369
2370
2371
2372
2373
2374
2375
2376
2377
2378
2379
2380
2381
2382
2383
2384
2385
2386
2387
2388
2389
2390
2391
2392
2393
2394
2395
2396
2397
2398
2399
2400
2401
2402
2403
2404
2405
2406
2407
2408
2409
2410
2411
2412
2413
2414
2415
2416
2417
2418
2419
2420
2421
2422
2423
2424
2425
2426
2427
2428
2429
2430
2431
2432
2433
2434
2435
2436
2437
2438
2439
2440
2441
2442
2443
2444
2445
2446
2447
2448
2449
2450
2451
2452
2453
2454
2455
2456
2457
2458
2459
2460
2461
2462
2463
2464
2465
2466
2467
2468
2469
2470
2471
2472
2473
2474
2475
2476
2477
2478
2479
2480
2481
2482
2483
2484
2485
2486
2487
2488
2489
2490
2491
2492
2493
2494
2495
2496
2497
2498
2499
2500
2501
2502
2503
2504
2505
def
post
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP POST operation.
## Example
```python
from fastapi import APIRouter, FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
router = APIRouter()
@router.post("/items/")
def create_item(item: Item):
return {"message": "Item created"}
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"POST"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
delete
delete
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP DELETE operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
delete
(
"/items/
{item_id}
"
)
def
delete_item
(
item_id
:
str
):
return
{
"message"
:
"Item deleted"
}
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
2507
2508
2509
2510
2511
2512
2513
2514
2515
2516
2517
2518
2519
2520
2521
2522
2523
2524
2525
2526
2527
2528
2529
2530
2531
2532
2533
2534
2535
2536
2537
2538
2539
2540
2541
2542
2543
2544
2545
2546
2547
2548
2549
2550
2551
2552
2553
2554
2555
2556
2557
2558
2559
2560
2561
2562
2563
2564
2565
2566
2567
2568
2569
2570
2571
2572
2573
2574
2575
2576
2577
2578
2579
2580
2581
2582
2583
2584
2585
2586
2587
2588
2589
2590
2591
2592
2593
2594
2595
2596
2597
2598
2599
2600
2601
2602
2603
2604
2605
2606
2607
2608
2609
2610
2611
2612
2613
2614
2615
2616
2617
2618
2619
2620
2621
2622
2623
2624
2625
2626
2627
2628
2629
2630
2631
2632
2633
2634
2635
2636
2637
2638
2639
2640
2641
2642
2643
2644
2645
2646
2647
2648
2649
2650
2651
2652
2653
2654
2655
2656
2657
2658
2659
2660
2661
2662
2663
2664
2665
2666
2667
2668
2669
2670
2671
2672
2673
2674
2675
2676
2677
2678
2679
2680
2681
2682
2683
2684
2685
2686
2687
2688
2689
2690
2691
2692
2693
2694
2695
2696
2697
2698
2699
2700
2701
2702
2703
2704
2705
2706
2707
2708
2709
2710
2711
2712
2713
2714
2715
2716
2717
2718
2719
2720
2721
2722
2723
2724
2725
2726
2727
2728
2729
2730
2731
2732
2733
2734
2735
2736
2737
2738
2739
2740
2741
2742
2743
2744
2745
2746
2747
2748
2749
2750
2751
2752
2753
2754
2755
2756
2757
2758
2759
2760
2761
2762
2763
2764
2765
2766
2767
2768
2769
2770
2771
2772
2773
2774
2775
2776
2777
2778
2779
2780
2781
2782
2783
2784
2785
2786
2787
2788
2789
2790
2791
2792
2793
2794
2795
2796
2797
2798
2799
2800
2801
2802
2803
2804
2805
2806
2807
2808
2809
2810
2811
2812
2813
2814
2815
2816
2817
2818
2819
2820
2821
2822
2823
2824
2825
2826
2827
2828
2829
2830
2831
2832
2833
2834
2835
2836
2837
2838
2839
2840
2841
2842
2843
2844
2845
2846
2847
2848
2849
2850
2851
2852
2853
2854
2855
2856
2857
2858
2859
2860
2861
2862
2863
2864
2865
2866
2867
2868
2869
2870
2871
2872
2873
2874
2875
2876
2877
2878
2879
2880
2881
2882
def
delete
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP DELETE operation.
## Example
```python
from fastapi import APIRouter, FastAPI
app = FastAPI()
router = APIRouter()
@router.delete("/items/{item_id}")
def delete_item(item_id: str):
return {"message": "Item deleted"}
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"DELETE"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
options
options
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP OPTIONS operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
options
(
"/items/"
)
def
get_item_options
():
return
{
"additions"
:
[
"Aji"
,
"Guacamole"
]}
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
2884
2885
2886
2887
2888
2889
2890
2891
2892
2893
2894
2895
2896
2897
2898
2899
2900
2901
2902
2903
2904
2905
2906
2907
2908
2909
2910
2911
2912
2913
2914
2915
2916
2917
2918
2919
2920
2921
2922
2923
2924
2925
2926
2927
2928
2929
2930
2931
2932
2933
2934
2935
2936
2937
2938
2939
2940
2941
2942
2943
2944
2945
2946
2947
2948
2949
2950
2951
2952
2953
2954
2955
2956
2957
2958
2959
2960
2961
2962
2963
2964
2965
2966
2967
2968
2969
2970
2971
2972
2973
2974
2975
2976
2977
2978
2979
2980
2981
2982
2983
2984
2985
2986
2987
2988
2989
2990
2991
2992
2993
2994
2995
2996
2997
2998
2999
3000
3001
3002
3003
3004
3005
3006
3007
3008
3009
3010
3011
3012
3013
3014
3015
3016
3017
3018
3019
3020
3021
3022
3023
3024
3025
3026
3027
3028
3029
3030
3031
3032
3033
3034
3035
3036
3037
3038
3039
3040
3041
3042
3043
3044
3045
3046
3047
3048
3049
3050
3051
3052
3053
3054
3055
3056
3057
3058
3059
3060
3061
3062
3063
3064
3065
3066
3067
3068
3069
3070
3071
3072
3073
3074
3075
3076
3077
3078
3079
3080
3081
3082
3083
3084
3085
3086
3087
3088
3089
3090
3091
3092
3093
3094
3095
3096
3097
3098
3099
3100
3101
3102
3103
3104
3105
3106
3107
3108
3109
3110
3111
3112
3113
3114
3115
3116
3117
3118
3119
3120
3121
3122
3123
3124
3125
3126
3127
3128
3129
3130
3131
3132
3133
3134
3135
3136
3137
3138
3139
3140
3141
3142
3143
3144
3145
3146
3147
3148
3149
3150
3151
3152
3153
3154
3155
3156
3157
3158
3159
3160
3161
3162
3163
3164
3165
3166
3167
3168
3169
3170
3171
3172
3173
3174
3175
3176
3177
3178
3179
3180
3181
3182
3183
3184
3185
3186
3187
3188
3189
3190
3191
3192
3193
3194
3195
3196
3197
3198
3199
3200
3201
3202
3203
3204
3205
3206
3207
3208
3209
3210
3211
3212
3213
3214
3215
3216
3217
3218
3219
3220
3221
3222
3223
3224
3225
3226
3227
3228
3229
3230
3231
3232
3233
3234
3235
3236
3237
3238
3239
3240
3241
3242
3243
3244
3245
3246
3247
3248
3249
3250
3251
3252
3253
3254
3255
3256
3257
3258
3259
def
options
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP OPTIONS operation.
## Example
```python
from fastapi import APIRouter, FastAPI
app = FastAPI()
router = APIRouter()
@router.options("/items/")
def get_item_options():
return {"additions": ["Aji", "Guacamole"]}
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"OPTIONS"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
head
head
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP HEAD operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
head
(
"/items/"
,
status_code
=
204
)
def
get_items_headers
(
response
:
Response
):
response
.
headers
[
"X-Cat-Dog"
]
=
"Alone in the world"
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
3261
3262
3263
3264
3265
3266
3267
3268
3269
3270
3271
3272
3273
3274
3275
3276
3277
3278
3279
3280
3281
3282
3283
3284
3285
3286
3287
3288
3289
3290
3291
3292
3293
3294
3295
3296
3297
3298
3299
3300
3301
3302
3303
3304
3305
3306
3307
3308
3309
3310
3311
3312
3313
3314
3315
3316
3317
3318
3319
3320
3321
3322
3323
3324
3325
3326
3327
3328
3329
3330
3331
3332
3333
3334
3335
3336
3337
3338
3339
3340
3341
3342
3343
3344
3345
3346
3347
3348
3349
3350
3351
3352
3353
3354
3355
3356
3357
3358
3359
3360
3361
3362
3363
3364
3365
3366
3367
3368
3369
3370
3371
3372
3373
3374
3375
3376
3377
3378
3379
3380
3381
3382
3383
3384
3385
3386
3387
3388
3389
3390
3391
3392
3393
3394
3395
3396
3397
3398
3399
3400
3401
3402
3403
3404
3405
3406
3407
3408
3409
3410
3411
3412
3413
3414
3415
3416
3417
3418
3419
3420
3421
3422
3423
3424
3425
3426
3427
3428
3429
3430
3431
3432
3433
3434
3435
3436
3437
3438
3439
3440
3441
3442
3443
3444
3445
3446
3447
3448
3449
3450
3451
3452
3453
3454
3455
3456
3457
3458
3459
3460
3461
3462
3463
3464
3465
3466
3467
3468
3469
3470
3471
3472
3473
3474
3475
3476
3477
3478
3479
3480
3481
3482
3483
3484
3485
3486
3487
3488
3489
3490
3491
3492
3493
3494
3495
3496
3497
3498
3499
3500
3501
3502
3503
3504
3505
3506
3507
3508
3509
3510
3511
3512
3513
3514
3515
3516
3517
3518
3519
3520
3521
3522
3523
3524
3525
3526
3527
3528
3529
3530
3531
3532
3533
3534
3535
3536
3537
3538
3539
3540
3541
3542
3543
3544
3545
3546
3547
3548
3549
3550
3551
3552
3553
3554
3555
3556
3557
3558
3559
3560
3561
3562
3563
3564
3565
3566
3567
3568
3569
3570
3571
3572
3573
3574
3575
3576
3577
3578
3579
3580
3581
3582
3583
3584
3585
3586
3587
3588
3589
3590
3591
3592
3593
3594
3595
3596
3597
3598
3599
3600
3601
3602
3603
3604
3605
3606
3607
3608
3609
3610
3611
3612
3613
3614
3615
3616
3617
3618
3619
3620
3621
3622
3623
3624
3625
3626
3627
3628
3629
3630
3631
3632
3633
3634
3635
3636
3637
3638
3639
3640
3641
def
head
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP HEAD operation.
## Example
```python
from fastapi import APIRouter, FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
router = APIRouter()
@router.head("/items/", status_code=204)
def get_items_headers(response: Response):
response.headers["X-Cat-Dog"] = "Alone in the world"
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"HEAD"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
patch
patch
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP PATCH operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
patch
(
"/items/"
)
def
update_item
(
item
:
Item
):
return
{
"message"
:
"Item updated in place"
}
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
3643
3644
3645
3646
3647
3648
3649
3650
3651
3652
3653
3654
3655
3656
3657
3658
3659
3660
3661
3662
3663
3664
3665
3666
3667
3668
3669
3670
3671
3672
3673
3674
3675
3676
3677
3678
3679
3680
3681
3682
3683
3684
3685
3686
3687
3688
3689
3690
3691
3692
3693
3694
3695
3696
3697
3698
3699
3700
3701
3702
3703
3704
3705
3706
3707
3708
3709
3710
3711
3712
3713
3714
3715
3716
3717
3718
3719
3720
3721
3722
3723
3724
3725
3726
3727
3728
3729
3730
3731
3732
3733
3734
3735
3736
3737
3738
3739
3740
3741
3742
3743
3744
3745
3746
3747
3748
3749
3750
3751
3752
3753
3754
3755
3756
3757
3758
3759
3760
3761
3762
3763
3764
3765
3766
3767
3768
3769
3770
3771
3772
3773
3774
3775
3776
3777
3778
3779
3780
3781
3782
3783
3784
3785
3786
3787
3788
3789
3790
3791
3792
3793
3794
3795
3796
3797
3798
3799
3800
3801
3802
3803
3804
3805
3806
3807
3808
3809
3810
3811
3812
3813
3814
3815
3816
3817
3818
3819
3820
3821
3822
3823
3824
3825
3826
3827
3828
3829
3830
3831
3832
3833
3834
3835
3836
3837
3838
3839
3840
3841
3842
3843
3844
3845
3846
3847
3848
3849
3850
3851
3852
3853
3854
3855
3856
3857
3858
3859
3860
3861
3862
3863
3864
3865
3866
3867
3868
3869
3870
3871
3872
3873
3874
3875
3876
3877
3878
3879
3880
3881
3882
3883
3884
3885
3886
3887
3888
3889
3890
3891
3892
3893
3894
3895
3896
3897
3898
3899
3900
3901
3902
3903
3904
3905
3906
3907
3908
3909
3910
3911
3912
3913
3914
3915
3916
3917
3918
3919
3920
3921
3922
3923
3924
3925
3926
3927
3928
3929
3930
3931
3932
3933
3934
3935
3936
3937
3938
3939
3940
3941
3942
3943
3944
3945
3946
3947
3948
3949
3950
3951
3952
3953
3954
3955
3956
3957
3958
3959
3960
3961
3962
3963
3964
3965
3966
3967
3968
3969
3970
3971
3972
3973
3974
3975
3976
3977
3978
3979
3980
3981
3982
3983
3984
3985
3986
3987
3988
3989
3990
3991
3992
3993
3994
3995
3996
3997
3998
3999
4000
4001
4002
4003
4004
4005
4006
4007
4008
4009
4010
4011
4012
4013
4014
4015
4016
4017
4018
4019
4020
4021
4022
4023
def
patch
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP PATCH operation.
## Example
```python
from fastapi import APIRouter, FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
router = APIRouter()
@router.patch("/items/")
def update_item(item: Item):
return {"message": "Item updated in place"}
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"PATCH"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
trace
trace
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP TRACE operation.
Example
from
fastapi
import
APIRouter
,
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
router
=
APIRouter
()
@router
.
trace
(
"/items/
{item_id}
"
)
def
trace_item
(
item_id
:
str
):
return
None
app
.
include_router
(
router
)
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/routing.py
4025
4026
4027
4028
4029
4030
4031
4032
4033
4034
4035
4036
4037
4038
4039
4040
4041
4042
4043
4044
4045
4046
4047
4048
4049
4050
4051
4052
4053
4054
4055
4056
4057
4058
4059
4060
4061
4062
4063
4064
4065
4066
4067
4068
4069
4070
4071
4072
4073
4074
4075
4076
4077
4078
4079
4080
4081
4082
4083
4084
4085
4086
4087
4088
4089
4090
4091
4092
4093
4094
4095
4096
4097
4098
4099
4100
4101
4102
4103
4104
4105
4106
4107
4108
4109
4110
4111
4112
4113
4114
4115
4116
4117
4118
4119
4120
4121
4122
4123
4124
4125
4126
4127
4128
4129
4130
4131
4132
4133
4134
4135
4136
4137
4138
4139
4140
4141
4142
4143
4144
4145
4146
4147
4148
4149
4150
4151
4152
4153
4154
4155
4156
4157
4158
4159
4160
4161
4162
4163
4164
4165
4166
4167
4168
4169
4170
4171
4172
4173
4174
4175
4176
4177
4178
4179
4180
4181
4182
4183
4184
4185
4186
4187
4188
4189
4190
4191
4192
4193
4194
4195
4196
4197
4198
4199
4200
4201
4202
4203
4204
4205
4206
4207
4208
4209
4210
4211
4212
4213
4214
4215
4216
4217
4218
4219
4220
4221
4222
4223
4224
4225
4226
4227
4228
4229
4230
4231
4232
4233
4234
4235
4236
4237
4238
4239
4240
4241
4242
4243
4244
4245
4246
4247
4248
4249
4250
4251
4252
4253
4254
4255
4256
4257
4258
4259
4260
4261
4262
4263
4264
4265
4266
4267
4268
4269
4270
4271
4272
4273
4274
4275
4276
4277
4278
4279
4280
4281
4282
4283
4284
4285
4286
4287
4288
4289
4290
4291
4292
4293
4294
4295
4296
4297
4298
4299
4300
4301
4302
4303
4304
4305
4306
4307
4308
4309
4310
4311
4312
4313
4314
4315
4316
4317
4318
4319
4320
4321
4322
4323
4324
4325
4326
4327
4328
4329
4330
4331
4332
4333
4334
4335
4336
4337
4338
4339
4340
4341
4342
4343
4344
4345
4346
4347
4348
4349
4350
4351
4352
4353
4354
4355
4356
4357
4358
4359
4360
4361
4362
4363
4364
4365
4366
4367
4368
4369
4370
4371
4372
4373
4374
4375
4376
4377
4378
4379
4380
4381
4382
4383
4384
4385
4386
4387
4388
4389
4390
4391
4392
4393
4394
4395
4396
4397
4398
4399
4400
4401
4402
4403
4404
4405
def
trace
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
params
.
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP TRACE operation.
## Example
```python
from fastapi import APIRouter, FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
router = APIRouter()
@router.trace("/items/{item_id}")
def trace_item(item_id: str):
return None
app.include_router(router)
```
"""
return
self
.
api_route
(
path
=
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
methods
=
[
"TRACE"
],
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
on_event
on_event
(
event_type
)
Add an event handler for the router.
on_event
is deprecated, use
lifespan
event handlers instead.
Read more about it in the
FastAPI docs for Lifespan Events
.
PARAMETER
DESCRIPTION
event_type
The type of event.
startup
or
shutdown
.
TYPE:
str
Source code in
fastapi/routing.py
4407
4408
4409
4410
4411
4412
4413
4414
4415
4416
4417
4418
4419
4420
4421
4422
4423
4424
4425
4426
4427
4428
4429
4430
4431
4432
4433
4434
4435
4436
4437
4438
4439
@deprecated
(
"""
on_event is deprecated, use lifespan event handlers instead.
Read more about it in the
[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
"""
)
def
on_event
(
self
,
event_type
:
Annotated
[
str
,
Doc
(
"""
The type of event. `startup` or `shutdown`.
"""
),
],
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add an event handler for the router.
`on_event` is deprecated, use `lifespan` event handlers instead.
Read more about it in the
[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).
"""
def
decorator
(
func
:
DecoratedCallable
)
->
DecoratedCallable
:
self
.
add_event_handler
(
event_type
,
func
)
return
func
return
decorator

## 084_REFERENCE_BACKGROUND
Background Tasks -BackgroundTasks¬∂
---

Background Tasks -
BackgroundTasks
You can declare a parameter in a
path operation function
or dependency function with the type
BackgroundTasks
, and then you can use it to schedule the execution of background tasks after the response is sent.
You can import it directly from
fastapi
:
from
fastapi
import
BackgroundTasks
fastapi.BackgroundTasks
BackgroundTasks
(
tasks
=
None
)
Bases:
BackgroundTasks
A collection of background tasks that will be called after a response has been
sent to the client.
Read more about it in the
FastAPI docs for Background Tasks
.
Example
from
fastapi
import
BackgroundTasks
,
FastAPI
app
=
FastAPI
()
def
write_notification
(
email
:
str
,
message
=
""
):
with
open
(
"log.txt"
,
mode
=
"w"
)
as
email_file
:
content
=
f
"notification for
{
email
}
:
{
message
}
"
email_file
.
write
(
content
)
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
):
background_tasks
.
add_task
(
write_notification
,
email
,
message
=
"some notification"
)
return
{
"message"
:
"Notification sent in the background"
}
Source code in
starlette/background.py
32
33
def
__init__
(
self
,
tasks
:
typing
.
Sequence
[
BackgroundTask
]
|
None
=
None
):
self
.
tasks
=
list
(
tasks
)
if
tasks
else
[]
func
instance-attribute
func
=
func
args
instance-attribute
args
=
args
kwargs
instance-attribute
kwargs
=
kwargs
is_async
instance-attribute
is_async
=
is_async_callable
(
func
)
tasks
instance-attribute
tasks
=
list
(
tasks
)
if
tasks
else
[]
add_task
add_task
(
func
,
*
args
,
**
kwargs
)
Add a function to be called in the background after the response is sent.
Read more about it in the
FastAPI docs for Background Tasks
.
PARAMETER
DESCRIPTION
func
The function to call after the response is sent.
It can be a regular
def
function or an
async def
function.
TYPE:
Callable
[
P
,
Any
]
Source code in
fastapi/background.py
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
def
add_task
(
self
,
func
:
Annotated
[
Callable
[
P
,
Any
],
Doc
(
"""
The function to call after the response is sent.
It can be a regular `def` function or an `async def` function.
"""
),
],
*
args
:
P
.
args
,
**
kwargs
:
P
.
kwargs
,
)
->
None
:
"""
Add a function to be called in the background after the response is sent.
Read more about it in the
[FastAPI docs for Background Tasks](https://fastapi.tiangolo.com/tutorial/background-tasks/).
"""
return
super
()
.
add_task
(
func
,
*
args
,
**
kwargs
)

## 085_REFERENCE_DEPENDENCIES
Dependencies -Depends()andSecurity()¬∂
---

Dependencies -
Depends()
and
Security()
Depends()
Dependencies are handled mainly with the special function
Depends()
that takes a callable.
Here is the reference for it and its parameters.
You can import it directly from
fastapi
:
from
fastapi
import
Depends
fastapi.Depends
Depends
(
dependency
=
None
,
*
,
use_cache
=
True
)
Declare a FastAPI dependency.
It takes a single "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you.
Read more about it in the
FastAPI docs for Dependencies
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
PARAMETER
DESCRIPTION
dependency
A "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you, just pass the object
directly.
TYPE:
Optional
[
Callable
[...,
Any
]]
DEFAULT:
None
use_cache
By default, after a dependency is called the first time in a request, if
the dependency is declared again for the rest of the request (for example
if the dependency is needed by several dependencies), the value will be
re-used for the rest of the request.
Set
use_cache
to
False
to disable this behavior and ensure the
dependency is called again (if declared more than once) in the same request.
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/param_functions.py
2220
2221
2222
2223
2224
2225
2226
2227
2228
2229
2230
2231
2232
2233
2234
2235
2236
2237
2238
2239
2240
2241
2242
2243
2244
2245
2246
2247
2248
2249
2250
2251
2252
2253
2254
2255
2256
2257
2258
2259
2260
2261
2262
2263
2264
2265
2266
2267
2268
2269
2270
2271
2272
2273
2274
2275
2276
2277
def
Depends
(
## noqa: N802
dependency
:
Annotated
[
Optional
[
Callable
[
...
,
Any
]],
Doc
(
"""
A "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you, just pass the object
directly.
"""
),
]
=
None
,
*
,
use_cache
:
Annotated
[
bool
,
Doc
(
"""
By default, after a dependency is called the first time in a request, if
the dependency is declared again for the rest of the request (for example
if the dependency is needed by several dependencies), the value will be
re-used for the rest of the request.
Set `use_cache` to `False` to disable this behavior and ensure the
dependency is called again (if declared more than once) in the same request.
"""
),
]
=
True
,
)
->
Any
:
"""
Declare a FastAPI dependency.
It takes a single "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you.
Read more about it in the
[FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/).
**Example**
```python
from typing import Annotated
from fastapi import Depends, FastAPI
app = FastAPI()
async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
return {"q": q, "skip": skip, "limit": limit}
@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
return commons
```
"""
return
params
.
Depends
(
dependency
=
dependency
,
use_cache
=
use_cache
)
Security()
For many scenarios, you can handle security (authorization, authentication, etc.) with dependencies, using
Depends()
.
But when you want to also declare OAuth2 scopes, you can use
Security()
instead of
Depends()
.
You can import
Security()
directly from
fastapi
:
from
fastapi
import
Security
fastapi.Security
Security
(
dependency
=
None
,
*
,
scopes
=
None
,
use_cache
=
True
)
Declare a FastAPI Security dependency.
The only difference with a regular dependency is that it can declare OAuth2
scopes that will be integrated with OpenAPI and the automatic UI docs (by default
at
/docs
).
It takes a single "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you.
Read more about it in the
FastAPI docs for Security
and
in the
FastAPI docs for OAuth2 scopes
.
Example
from
typing
import
Annotated
from
fastapi
import
Security
,
FastAPI
from
.db
import
User
from
.security
import
get_current_active_user
app
=
FastAPI
()
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Security
(
get_current_active_user
,
scopes
=
[
"items"
])]
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
PARAMETER
DESCRIPTION
dependency
A "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you, just pass the object
directly.
TYPE:
Optional
[
Callable
[...,
Any
]]
DEFAULT:
None
scopes
OAuth2 scopes required for the
path operation
that uses this Security
dependency.
The term "scope" comes from the OAuth2 specification, it seems to be
intentionally vague and interpretable. It normally refers to permissions,
in cases to roles.
These scopes are integrated with OpenAPI (and the API docs at
/docs
).
So they are visible in the OpenAPI specification.
)
TYPE:
Optional
[
Sequence
[
str
]]
DEFAULT:
None
use_cache
By default, after a dependency is called the first time in a request, if
the dependency is declared again for the rest of the request (for example
if the dependency is needed by several dependencies), the value will be
re-used for the rest of the request.
Set
use_cache
to
False
to disable this behavior and ensure the
dependency is called again (if declared more than once) in the same request.
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/param_functions.py
2280
2281
2282
2283
2284
2285
2286
2287
2288
2289
2290
2291
2292
2293
2294
2295
2296
2297
2298
2299
2300
2301
2302
2303
2304
2305
2306
2307
2308
2309
2310
2311
2312
2313
2314
2315
2316
2317
2318
2319
2320
2321
2322
2323
2324
2325
2326
2327
2328
2329
2330
2331
2332
2333
2334
2335
2336
2337
2338
2339
2340
2341
2342
2343
2344
2345
2346
2347
2348
2349
2350
2351
2352
2353
2354
2355
2356
2357
2358
2359
2360
def
Security
(
## noqa: N802
dependency
:
Annotated
[
Optional
[
Callable
[
...
,
Any
]],
Doc
(
"""
A "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you, just pass the object
directly.
"""
),
]
=
None
,
*
,
scopes
:
Annotated
[
Optional
[
Sequence
[
str
]],
Doc
(
"""
OAuth2 scopes required for the *path operation* that uses this Security
dependency.
The term "scope" comes from the OAuth2 specification, it seems to be
intentionally vague and interpretable. It normally refers to permissions,
in cases to roles.
These scopes are integrated with OpenAPI (and the API docs at `/docs`).
So they are visible in the OpenAPI specification.
)
"""
),
]
=
None
,
use_cache
:
Annotated
[
bool
,
Doc
(
"""
By default, after a dependency is called the first time in a request, if
the dependency is declared again for the rest of the request (for example
if the dependency is needed by several dependencies), the value will be
re-used for the rest of the request.
Set `use_cache` to `False` to disable this behavior and ensure the
dependency is called again (if declared more than once) in the same request.
"""
),
]
=
True
,
)
->
Any
:
"""
Declare a FastAPI Security dependency.
The only difference with a regular dependency is that it can declare OAuth2
scopes that will be integrated with OpenAPI and the automatic UI docs (by default
at `/docs`).
It takes a single "dependable" callable (like a function).
Don't call it directly, FastAPI will call it for you.
Read more about it in the
[FastAPI docs for Security](https://fastapi.tiangolo.com/tutorial/security/) and
in the
[FastAPI docs for OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).
**Example**
```python
from typing import Annotated
from fastapi import Security, FastAPI
from .db import User
from .security import get_current_active_user
app = FastAPI()
@app.get("/users/me/items/")
async def read_own_items(
current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])]
):
return [{"item_id": "Foo", "owner": current_user.username}]
```
"""
return
params
.
Security
(
dependency
=
dependency
,
scopes
=
scopes
,
use_cache
=
use_cache
)

## 086_REFERENCE_ENCODERS
Encoders -jsonable_encoder¬∂
---

Encoders -
jsonable_encoder
fastapi.encoders.jsonable_encoder
jsonable_encoder
(
obj
,
include
=
None
,
exclude
=
None
,
by_alias
=
True
,
exclude_unset
=
False
,
exclude_defaults
=
False
,
exclude_none
=
False
,
custom_encoder
=
None
,
sqlalchemy_safe
=
True
,
)
Convert any object to something that can be encoded in JSON.
This is used internally by FastAPI to make sure anything you return can be
encoded as JSON before it is sent to the client.
You can also use it yourself, for example to convert objects before saving them
in a database that supports only JSON.
Read more about it in the
FastAPI docs for JSON Compatible Encoder
.
PARAMETER
DESCRIPTION
obj
The input object to convert to JSON.
TYPE:
Any
include
Pydantic's
include
parameter, passed to Pydantic models to set the
fields to include.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
exclude
Pydantic's
exclude
parameter, passed to Pydantic models to set the
fields to exclude.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
by_alias
Pydantic's
by_alias
parameter, passed to Pydantic models to define if
the output should use the alias names (when provided) or the Python
attribute names. In an API, if you set an alias, it's probably because you
want to use it in the result, so you probably want to leave this set to
True
.
TYPE:
bool
DEFAULT:
True
exclude_unset
Pydantic's
exclude_unset
parameter, passed to Pydantic models to define
if it should exclude from the output the fields that were not explicitly
set (and that only had their default values).
TYPE:
bool
DEFAULT:
False
exclude_defaults
Pydantic's
exclude_defaults
parameter, passed to Pydantic models to define
if it should exclude from the output the fields that had the same default
value, even when they were explicitly set.
TYPE:
bool
DEFAULT:
False
exclude_none
Pydantic's
exclude_none
parameter, passed to Pydantic models to define
if it should exclude from the output any fields that have a
None
value.
TYPE:
bool
DEFAULT:
False
custom_encoder
Pydantic's
custom_encoder
parameter, passed to Pydantic models to define
a custom encoder.
TYPE:
Optional
[
Dict
[
Any
,
Callable
[[
Any
],
Any
]]]
DEFAULT:
None
sqlalchemy_safe
Exclude from the output any fields that start with the name
_sa
.
This is mainly a hack for compatibility with SQLAlchemy objects, they
store internal SQLAlchemy-specific state in attributes named with
_sa
,
and those objects can't (and shouldn't be) serialized to JSON.
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/encoders.py
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
def
jsonable_encoder
(
obj
:
Annotated
[
Any
,
Doc
(
"""
The input object to convert to JSON.
"""
),
],
include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Pydantic's `include` parameter, passed to Pydantic models to set the
fields to include.
"""
),
]
=
None
,
exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Pydantic's `exclude` parameter, passed to Pydantic models to set the
fields to exclude.
"""
),
]
=
None
,
by_alias
:
Annotated
[
bool
,
Doc
(
"""
Pydantic's `by_alias` parameter, passed to Pydantic models to define if
the output should use the alias names (when provided) or the Python
attribute names. In an API, if you set an alias, it's probably because you
want to use it in the result, so you probably want to leave this set to
`True`.
"""
),
]
=
True
,
exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Pydantic's `exclude_unset` parameter, passed to Pydantic models to define
if it should exclude from the output the fields that were not explicitly
set (and that only had their default values).
"""
),
]
=
False
,
exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define
if it should exclude from the output the fields that had the same default
value, even when they were explicitly set.
"""
),
]
=
False
,
exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Pydantic's `exclude_none` parameter, passed to Pydantic models to define
if it should exclude from the output any fields that have a `None` value.
"""
),
]
=
False
,
custom_encoder
:
Annotated
[
Optional
[
Dict
[
Any
,
Callable
[[
Any
],
Any
]]],
Doc
(
"""
Pydantic's `custom_encoder` parameter, passed to Pydantic models to define
a custom encoder.
"""
),
]
=
None
,
sqlalchemy_safe
:
Annotated
[
bool
,
Doc
(
"""
Exclude from the output any fields that start with the name `_sa`.
This is mainly a hack for compatibility with SQLAlchemy objects, they
store internal SQLAlchemy-specific state in attributes named with `_sa`,
and those objects can't (and shouldn't be) serialized to JSON.
"""
),
]
=
True
,
)
->
Any
:
"""
Convert any object to something that can be encoded in JSON.
This is used internally by FastAPI to make sure anything you return can be
encoded as JSON before it is sent to the client.
You can also use it yourself, for example to convert objects before saving them
in a database that supports only JSON.
Read more about it in the
[FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).
"""
custom_encoder
=
custom_encoder
or
{}
if
custom_encoder
:
if
type
(
obj
)
in
custom_encoder
:
return
custom_encoder
[
type
(
obj
)](
obj
)
else
:
for
encoder_type
,
encoder_instance
in
custom_encoder
.
items
():
if
isinstance
(
obj
,
encoder_type
):
return
encoder_instance
(
obj
)
if
include
is
not
None
and
not
isinstance
(
include
,
(
set
,
dict
)):
include
=
set
(
include
)
if
exclude
is
not
None
and
not
isinstance
(
exclude
,
(
set
,
dict
)):
exclude
=
set
(
exclude
)
if
isinstance
(
obj
,
BaseModel
):
## TODO: remove when deprecating Pydantic v1
encoders
:
Dict
[
Any
,
Any
]
=
{}
if
not
PYDANTIC_V2
:
encoders
=
getattr
(
obj
.
__config__
,
"json_encoders"
,
{})
## type: ignore[attr-defined]
if
custom_encoder
:
encoders
.
update
(
custom_encoder
)
obj_dict
=
_model_dump
(
obj
,
mode
=
"json"
,
include
=
include
,
exclude
=
exclude
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_none
=
exclude_none
,
exclude_defaults
=
exclude_defaults
,
)
if
"__root__"
in
obj_dict
:
obj_dict
=
obj_dict
[
"__root__"
]
return
jsonable_encoder
(
obj_dict
,
exclude_none
=
exclude_none
,
exclude_defaults
=
exclude_defaults
,
## TODO: remove when deprecating Pydantic v1
custom_encoder
=
encoders
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)
if
dataclasses
.
is_dataclass
(
obj
):
obj_dict
=
dataclasses
.
asdict
(
obj
)
return
jsonable_encoder
(
obj_dict
,
include
=
include
,
exclude
=
exclude
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
custom_encoder
=
custom_encoder
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)
if
isinstance
(
obj
,
Enum
):
return
obj
.
value
if
isinstance
(
obj
,
PurePath
):
return
str
(
obj
)
if
isinstance
(
obj
,
(
str
,
int
,
float
,
type
(
None
))):
return
obj
if
isinstance
(
obj
,
UndefinedType
):
return
None
if
isinstance
(
obj
,
dict
):
encoded_dict
=
{}
allowed_keys
=
set
(
obj
.
keys
())
if
include
is
not
None
:
allowed_keys
&=
set
(
include
)
if
exclude
is
not
None
:
allowed_keys
-=
set
(
exclude
)
for
key
,
value
in
obj
.
items
():
if
(
(
not
sqlalchemy_safe
or
(
not
isinstance
(
key
,
str
))
or
(
not
key
.
startswith
(
"_sa"
))
)
and
(
value
is
not
None
or
not
exclude_none
)
and
key
in
allowed_keys
):
encoded_key
=
jsonable_encoder
(
key
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_none
=
exclude_none
,
custom_encoder
=
custom_encoder
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)
encoded_value
=
jsonable_encoder
(
value
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_none
=
exclude_none
,
custom_encoder
=
custom_encoder
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)
encoded_dict
[
encoded_key
]
=
encoded_value
return
encoded_dict
if
isinstance
(
obj
,
(
list
,
set
,
frozenset
,
GeneratorType
,
tuple
,
deque
)):
encoded_list
=
[]
for
item
in
obj
:
encoded_list
.
append
(
jsonable_encoder
(
item
,
include
=
include
,
exclude
=
exclude
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
custom_encoder
=
custom_encoder
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)
)
return
encoded_list
if
type
(
obj
)
in
ENCODERS_BY_TYPE
:
return
ENCODERS_BY_TYPE
[
type
(
obj
)](
obj
)
for
encoder
,
classes_tuple
in
encoders_by_class_tuples
.
items
():
if
isinstance
(
obj
,
classes_tuple
):
return
encoder
(
obj
)
try
:
data
=
dict
(
obj
)
except
Exception
as
e
:
errors
:
List
[
Exception
]
=
[]
errors
.
append
(
e
)
try
:
data
=
vars
(
obj
)
except
Exception
as
e
:
errors
.
append
(
e
)
raise
ValueError
(
errors
)
from
e
return
jsonable_encoder
(
data
,
include
=
include
,
exclude
=
exclude
,
by_alias
=
by_alias
,
exclude_unset
=
exclude_unset
,
exclude_defaults
=
exclude_defaults
,
exclude_none
=
exclude_none
,
custom_encoder
=
custom_encoder
,
sqlalchemy_safe
=
sqlalchemy_safe
,
)

## 087_REFERENCE_EXCEPTIONS
Exceptions -HTTPExceptionandWebSocketException¬∂
---

Exceptions -
HTTPException
and
WebSocketException
These are the exceptions that you can raise to show errors to the client.
When you raise an exception, as would happen with normal Python, the rest of the execution is aborted. This way you can raise these exceptions from anywhere in the code to abort a request and show the error to the client.
You can use:
HTTPException
WebSocketException
These exceptions can be imported directly from
fastapi
:
from
fastapi
import
HTTPException
,
WebSocketException
fastapi.HTTPException
HTTPException
(
status_code
,
detail
=
None
,
headers
=
None
)
Bases:
HTTPException
An HTTP exception you can raise in your own code to show errors to the client.
This is for client errors, invalid authentication, invalid data, etc. Not for server
errors in your code.
Read more about it in the
FastAPI docs for Handling Errors
.
Example
from
fastapi
import
FastAPI
,
HTTPException
app
=
FastAPI
()
items
=
{
"foo"
:
"The Foo Wrestlers"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
items
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"item"
:
items
[
item_id
]}
PARAMETER
DESCRIPTION
status_code
HTTP status code to send to the client.
TYPE:
int
detail
Any data to be sent to the client in the
detail
key of the JSON
response.
TYPE:
Any
DEFAULT:
None
headers
Any headers to send to the client in the response.
TYPE:
Optional
[
Dict
[
str
,
str
]]
DEFAULT:
None
Source code in
fastapi/exceptions.py
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
def
__init__
(
self
,
status_code
:
Annotated
[
int
,
Doc
(
"""
HTTP status code to send to the client.
"""
),
],
detail
:
Annotated
[
Any
,
Doc
(
"""
Any data to be sent to the client in the `detail` key of the JSON
response.
"""
),
]
=
None
,
headers
:
Annotated
[
Optional
[
Dict
[
str
,
str
]],
Doc
(
"""
Any headers to send to the client in the response.
"""
),
]
=
None
,
)
->
None
:
super
()
.
__init__
(
status_code
=
status_code
,
detail
=
detail
,
headers
=
headers
)
status_code
instance-attribute
status_code
=
status_code
detail
instance-attribute
detail
=
detail
headers
instance-attribute
headers
=
headers
fastapi.WebSocketException
WebSocketException
(
code
,
reason
=
None
)
Bases:
WebSocketException
A WebSocket exception you can raise in your own code to show errors to the client.
This is for client errors, invalid authentication, invalid data, etc. Not for server
errors in your code.
Read more about it in the
FastAPI docs for WebSockets
.
Example
from
typing
import
Annotated
from
fastapi
import
(
Cookie
,
FastAPI
,
WebSocket
,
WebSocketException
,
status
,
)
app
=
FastAPI
()
@app
.
websocket
(
"/items/
{item_id}
/ws"
)
async
def
websocket_endpoint
(
*
,
websocket
:
WebSocket
,
session
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
,
item_id
:
str
,
):
if
session
is
None
:
raise
WebSocketException
(
code
=
status
.
WS_1008_POLICY_VIOLATION
)
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Session cookie is:
{
session
}
"
)
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
, for item ID:
{
item_id
}
"
)
PARAMETER
DESCRIPTION
code
A closing code from the
valid codes defined in the specification
.
TYPE:
int
reason
The reason to close the WebSocket connection.
It is UTF-8-encoded data. The interpretation of the reason is up to the
application, it is not specified by the WebSocket specification.
It could contain text that could be human-readable or interpretable
by the client code, etc.
TYPE:
Union
[
str
, None]
DEFAULT:
None
Source code in
fastapi/exceptions.py
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
def
__init__
(
self
,
code
:
Annotated
[
int
,
Doc
(
"""
A closing code from the
[valid codes defined in the specification](https://datatracker.ietf.org/doc/html/rfc6455#section-7.4.1).
"""
),
],
reason
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
The reason to close the WebSocket connection.
It is UTF-8-encoded data. The interpretation of the reason is up to the
application, it is not specified by the WebSocket specification.
It could contain text that could be human-readable or interpretable
by the client code, etc.
"""
),
]
=
None
,
)
->
None
:
super
()
.
__init__
(
code
=
code
,
reason
=
reason
)
code
instance-attribute
code
=
code
reason
instance-attribute
reason
=
reason
or
''

## 088_REFERENCE_FASTAPI
FastAPIclass¬∂
---

FastAPI
class
Here's the reference information for the
FastAPI
class, with all its parameters, attributes and methods.
You can import the
FastAPI
class directly from
fastapi
:
from
fastapi
import
FastAPI
fastapi.FastAPI
FastAPI
(
*
,
debug
=
False
,
routes
=
None
,
title
=
"FastAPI"
,
summary
=
None
,
description
=
""
,
version
=
"0.1.0"
,
openapi_url
=
"/openapi.json"
,
openapi_tags
=
None
,
servers
=
None
,
dependencies
=
None
,
default_response_class
=
Default
(
JSONResponse
),
redirect_slashes
=
True
,
docs_url
=
"/docs"
,
redoc_url
=
"/redoc"
,
swagger_ui_oauth2_redirect_url
=
"/docs/oauth2-redirect"
,
swagger_ui_init_oauth
=
None
,
middleware
=
None
,
exception_handlers
=
None
,
on_startup
=
None
,
on_shutdown
=
None
,
lifespan
=
None
,
terms_of_service
=
None
,
contact
=
None
,
license_info
=
None
,
openapi_prefix
=
""
,
root_path
=
""
,
root_path_in_servers
=
True
,
responses
=
None
,
callbacks
=
None
,
webhooks
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
swagger_ui_parameters
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
),
separate_input_output_schemas
=
True
,
**
extra
)
Bases:
Starlette
FastAPI
app class, the main entrypoint to use FastAPI.
Read more in the
FastAPI docs for First Steps
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
PARAMETER
DESCRIPTION
debug
Boolean indicating if debug tracebacks should be returned on server
errors.
Read more in the
Starlette docs for Applications
.
TYPE:
bool
DEFAULT:
False
routes
You normally wouldn't use this parameter with FastAPI, it is inherited
from Starlette and supported for compatibility.
In FastAPI, you normally would use the
path operation methods
,
like
app.get()
,
app.post()
, etc.
Note
: you probably shouldn't use this parameter, it is inherited
from Starlette and supported for compatibility.
A list of routes to serve incoming HTTP and WebSocket requests.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
title
The title of the API.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
title
=
"ChimichangApp"
)
TYPE:
str
DEFAULT:
'FastAPI'
summary
A short summary of the API.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
summary
=
"Deadpond's favorite app. Nuff said."
)
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description of the API. Supports Markdown (using
CommonMark syntax
).
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
description
=
"""
ChimichangApp API helps you do awesome stuff. üöÄ
## Items
You can **read items**.
## Users
You will be able to:
* **Create users** (_not implemented_).
* **Read users** (_not implemented_).
"""
)
TYPE:
str
DEFAULT:
''
version
The version of the API.
Note
This is the version of your application, not the version of
the OpenAPI specification nor the version of FastAPI being used.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
version
=
"0.0.1"
)
TYPE:
str
DEFAULT:
'0.1.0'
openapi_url
The URL where the OpenAPI schema will be served from.
If you set it to
None
, no OpenAPI schema will be served publicly, and
the default automatic endpoints
/docs
and
/redoc
will also be
disabled.
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
openapi_url
=
"/api/v1/openapi.json"
)
TYPE:
Optional
[
str
]
DEFAULT:
'/openapi.json'
openapi_tags
A list of tags used by OpenAPI, these are the same
tags
you can set
in the
path operations
, like:
@app.get("/users/", tags=["users"])
@app.get("/items/", tags=["items"])
The order of the tags can be used to specify the order shown in
tools like Swagger UI, used in the automatic path
/docs
.
It's not required to specify all the tags used.
The tags that are not declared MAY be organized randomly or based
on the tools' logic. Each tag name in the list MUST be unique.
The value of each item is a
dict
containing:
name
: The name of the tag.
description
: A short description of the tag.
CommonMark syntax
MAY be used for rich
text representation.
externalDocs
: Additional external documentation for this tag. If
provided, it would contain a
dict
with:
description
: A short description of the target documentation.
CommonMark syntax
MAY be used for
rich text representation.
url
: The URL for the target documentation. Value MUST be in
the form of a URL.
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
tags_metadata
=
[
{
"name"
:
"users"
,
"description"
:
"Operations with users. The **login** logic is also here."
,
},
{
"name"
:
"items"
,
"description"
:
"Manage items. So _fancy_ they have their own docs."
,
"externalDocs"
:
{
"description"
:
"Items external docs"
,
"url"
:
"https://fastapi.tiangolo.com/"
,
},
},
]
app
=
FastAPI
(
openapi_tags
=
tags_metadata
)
TYPE:
Optional
[
List
[
Dict
[
str
,
Any
]]]
DEFAULT:
None
servers
A
list
of
dict
s with connectivity information to a target server.
You would use it, for example, if your application is served from
different domains and you want to use the same Swagger UI in the
browser to interact with each of them (instead of having multiple
browser tabs open). Or if you want to leave fixed the possible URLs.
If the servers
list
is not provided, or is an empty
list
, the
default value would be a
dict
with a
url
value of
/
.
Each item in the
list
is a
dict
containing:
url
: A URL to the target host. This URL supports Server Variables
and MAY be relative, to indicate that the host location is relative
to the location where the OpenAPI document is being served. Variable
substitutions will be made when a variable is named in
{
brackets
}
.
description
: An optional string describing the host designated by
the URL.
CommonMark syntax
MAY be used for
rich text representation.
variables
: A
dict
between a variable name and its value. The value
is used for substitution in the server's URL template.
Read more in the
FastAPI docs for Behind a Proxy
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
servers
=
[
{
"url"
:
"https://stag.example.com"
,
"description"
:
"Staging environment"
},
{
"url"
:
"https://prod.example.com"
,
"description"
:
"Production environment"
},
]
)
TYPE:
Optional
[
List
[
Dict
[
str
,
Union
[
str
,
Any
]]]]
DEFAULT:
None
dependencies
A list of global dependencies, they will be applied to each
path operation
, including in sub-routers.
Read more about it in the
FastAPI docs for Global Dependencies
.
Example
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
func_dep_1
,
func_dep_2
app
=
FastAPI
(
dependencies
=
[
Depends
(
func_dep_1
),
Depends
(
func_dep_2
)])
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
default_response_class
The default response class to be used.
Read more in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
Example
from
fastapi
import
FastAPI
from
fastapi.responses
import
ORJSONResponse
app
=
FastAPI
(
default_response_class
=
ORJSONResponse
)
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
redirect_slashes
Whether to detect and redirect slashes in URLs when the client doesn't
use the same format.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
redirect_slashes
=
True
)
## the default
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item_id"
:
"Foo"
}]
With this app, if a client goes to
/items
(without a trailing slash),
they will be automatically redirected with an HTTP status code of 307
to
/items/
.
TYPE:
bool
DEFAULT:
True
docs_url
The path to the automatic interactive API documentation.
It is handled in the browser by Swagger UI.
The default URL is
/docs
. You can disable it by setting it to
None
.
If
openapi_url
is set to
None
, this will be automatically disabled.
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
docs_url
=
"/documentation"
,
redoc_url
=
None
)
TYPE:
Optional
[
str
]
DEFAULT:
'/docs'
redoc_url
The path to the alternative automatic interactive API documentation
provided by ReDoc.
The default URL is
/redoc
. You can disable it by setting it to
None
.
If
openapi_url
is set to
None
, this will be automatically disabled.
Read more in the
FastAPI docs for Metadata and Docs URLs
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
docs_url
=
"/documentation"
,
redoc_url
=
"redocumentation"
)
TYPE:
Optional
[
str
]
DEFAULT:
'/redoc'
swagger_ui_oauth2_redirect_url
The OAuth2 redirect endpoint for the Swagger UI.
By default it is
/docs/oauth2-redirect
.
This is only used if you use OAuth2 (with the "Authorize" button)
with Swagger UI.
TYPE:
Optional
[
str
]
DEFAULT:
'/docs/oauth2-redirect'
swagger_ui_init_oauth
OAuth2 configuration for the Swagger UI, by default shown at
/docs
.
Read more about the available configuration options in the
Swagger UI docs
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
middleware
List of middleware to be added when creating the application.
In FastAPI you would normally do this with
app.add_middleware()
instead.
Read more in the
FastAPI docs for Middleware
.
TYPE:
Optional
[
Sequence
[
Middleware
]]
DEFAULT:
None
exception_handlers
A dictionary with handlers for exceptions.
In FastAPI, you would normally use the decorator
@app.exception_handler()
.
Read more in the
FastAPI docs for Handling Errors
.
TYPE:
Optional
[
Dict
[
Union
[
int
,
Type
[
Exception
]],
Callable
[[
Request
,
Any
],
Coroutine
[
Any
,
Any
,
Response
]]]]
DEFAULT:
None
on_startup
A list of startup event handler functions.
You should instead use the
lifespan
handlers.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Sequence
[
Callable
[[],
Any
]]]
DEFAULT:
None
on_shutdown
A list of shutdown event handler functions.
You should instead use the
lifespan
handlers.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Sequence
[
Callable
[[],
Any
]]]
DEFAULT:
None
lifespan
A
Lifespan
context manager handler. This replaces
startup
and
shutdown
functions with a single context manager.
Read more in the
FastAPI docs for
lifespan
.
TYPE:
Optional
[
Lifespan
[
AppType
]]
DEFAULT:
None
terms_of_service
A URL to the Terms of Service for your API.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more at the
FastAPI docs for Metadata and Docs URLs
.
Example
app
=
FastAPI
(
terms_of_service
=
"http://example.com/terms/"
)
TYPE:
Optional
[
str
]
DEFAULT:
None
contact
A dictionary with the contact information for the exposed API.
It can contain several fields.
name
: (
str
) The name of the contact person/organization.
url
: (
str
) A URL pointing to the contact information. MUST be in
the format of a URL.
email
: (
str
) The email address of the contact person/organization.
MUST be in the format of an email address.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more at the
FastAPI docs for Metadata and Docs URLs
.
Example
app
=
FastAPI
(
contact
=
{
"name"
:
"Deadpoolio the Amazing"
,
"url"
:
"http://x-force.example.com/contact/"
,
"email"
:
"dp@x-force.example.com"
,
}
)
TYPE:
Optional
[
Dict
[
str
,
Union
[
str
,
Any
]]]
DEFAULT:
None
license_info
A dictionary with the license information for the exposed API.
It can contain several fields.
name
: (
str
)
REQUIRED
(if a
license_info
is set). The
license name used for the API.
identifier
: (
str
) An
SPDX
license expression
for the API. The
identifier
field is mutually exclusive of the
url
field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.
url
: (
str
) A URL to the license used for the API. This MUST be
the format of a URL.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more at the
FastAPI docs for Metadata and Docs URLs
.
Example
app
=
FastAPI
(
license_info
=
{
"name"
:
"Apache 2.0"
,
"url"
:
"https://www.apache.org/licenses/LICENSE-2.0.html"
,
}
)
TYPE:
Optional
[
Dict
[
str
,
Union
[
str
,
Any
]]]
DEFAULT:
None
openapi_prefix
"openapi_prefix" has been deprecated in favor of "root_path", which
follows more closely the ASGI standard, is simpler, and more
automatic. A URL prefix for the OpenAPI URL.
TYPE:
str
DEFAULT:
''
root_path
A path prefix handled by a proxy that is not seen by the application
but is seen by external clients, which affects things like Swagger UI.
Read more about it at the
FastAPI docs for Behind a Proxy
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
root_path
=
"/api/v1"
)
TYPE:
str
DEFAULT:
''
root_path_in_servers
To disable automatically generating the URLs in the
servers
field
in the autogenerated OpenAPI using the
root_path
.
Read more about it in the
FastAPI docs for Behind a Proxy
.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
(
root_path_in_servers
=
False
)
TYPE:
bool
DEFAULT:
True
responses
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Additional Responses in OpenAPI
.
And in the
FastAPI docs for Bigger Applications
.
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
callbacks
OpenAPI callbacks that should apply to all
path operations
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
webhooks
Add OpenAPI webhooks. This is similar to
callbacks
but it doesn't
depend on specific
path operations
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Note
: This is available since OpenAPI 3.1.0, FastAPI 0.99.0.
Read more about it in the
FastAPI docs for OpenAPI Webhooks
.
TYPE:
Optional
[
APIRouter
]
DEFAULT:
None
deprecated
Mark all
path operations
as deprecated. You probably don't need it,
but it's available.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
bool
]
DEFAULT:
None
include_in_schema
To include (or not) all the
path operations
in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
swagger_ui_parameters
Parameters to configure Swagger UI, the autogenerated interactive API
documentation (by default at
/docs
).
Read more about it in the
FastAPI docs about how to Configure Swagger UI
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
separate_input_output_schemas
Whether to generate separate OpenAPI schemas for request body and
response body when the results would be more precise.
This is particularly useful when automatically generating clients.
For example, if you have a model like:
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
tags
:
list
[
str
]
=
[]
When
Item
is used for input, a request body,
tags
is not required,
the client doesn't have to provide it.
But when using
Item
for output, for a response body,
tags
is always
available because it has a default value, even if it's just an empty
list. So, the client should be able to always expect it.
In this case, there would be two different schemas, one for input and
another one for output.
TYPE:
bool
DEFAULT:
True
**extra
Extra keyword arguments to be stored in the app, not used by FastAPI
anywhere.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/applications.py
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812
813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
890
891
892
893
894
895
896
897
898
899
900
901
902
903
904
905
906
907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924
925
926
927
928
929
930
931
932
933
934
935
936
937
938
939
940
941
942
943
944
945
946
947
948
949
950
951
952
953
954
955
956
957
958
959
960
961
962
963
964
def
__init__
(
self
:
AppType
,
*
,
debug
:
Annotated
[
bool
,
Doc
(
"""
Boolean indicating if debug tracebacks should be returned on server
errors.
Read more in the
[Starlette docs for Applications](https://www.starlette.io/applications/#instantiating-the-application).
"""
),
]
=
False
,
routes
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
**Note**: you probably shouldn't use this parameter, it is inherited
from Starlette and supported for compatibility.
---
A list of routes to serve incoming HTTP and WebSocket requests.
"""
),
deprecated
(
"""
You normally wouldn't use this parameter with FastAPI, it is inherited
from Starlette and supported for compatibility.
In FastAPI, you normally would use the *path operation methods*,
like `app.get()`, `app.post()`, etc.
"""
),
]
=
None
,
title
:
Annotated
[
str
,
Doc
(
"""
The title of the API.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(title="ChimichangApp")
```
"""
),
]
=
"FastAPI"
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A short summary of the API.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(summary="Deadpond's favorite app. Nuff said.")
```
"""
),
]
=
None
,
description
:
Annotated
[
str
,
Doc
(
'''
A description of the API. Supports Markdown (using
[CommonMark syntax](https://commonmark.org/)).
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(
description="""
ChimichangApp API helps you do awesome stuff. üöÄ
## Items
You can **read items**.
## Users
You will be able to:
* **Create users** (_not implemented_).
* **Read users** (_not implemented_).
"""
)
```
'''
),
]
=
""
,
version
:
Annotated
[
str
,
Doc
(
"""
The version of the API.
**Note** This is the version of your application, not the version of
the OpenAPI specification nor the version of FastAPI being used.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(version="0.0.1")
```
"""
),
]
=
"0.1.0"
,
openapi_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The URL where the OpenAPI schema will be served from.
If you set it to `None`, no OpenAPI schema will be served publicly, and
the default automatic endpoints `/docs` and `/redoc` will also be
disabled.
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#openapi-url).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(openapi_url="/api/v1/openapi.json")
```
"""
),
]
=
"/openapi.json"
,
openapi_tags
:
Annotated
[
Optional
[
List
[
Dict
[
str
,
Any
]]],
Doc
(
"""
A list of tags used by OpenAPI, these are the same `tags` you can set
in the *path operations*, like:
* `@app.get("/users/", tags=["users"])`
* `@app.get("/items/", tags=["items"])`
The order of the tags can be used to specify the order shown in
tools like Swagger UI, used in the automatic path `/docs`.
It's not required to specify all the tags used.
The tags that are not declared MAY be organized randomly or based
on the tools' logic. Each tag name in the list MUST be unique.
The value of each item is a `dict` containing:
* `name`: The name of the tag.
* `description`: A short description of the tag.
[CommonMark syntax](https://commonmark.org/) MAY be used for rich
text representation.
* `externalDocs`: Additional external documentation for this tag. If
provided, it would contain a `dict` with:
* `description`: A short description of the target documentation.
[CommonMark syntax](https://commonmark.org/) MAY be used for
rich text representation.
* `url`: The URL for the target documentation. Value MUST be in
the form of a URL.
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-tags).
**Example**
```python
from fastapi import FastAPI
tags_metadata = [
{
"name": "users",
"description": "Operations with users. The **login** logic is also here.",
},
{
"name": "items",
"description": "Manage items. So _fancy_ they have their own docs.",
"externalDocs": {
"description": "Items external docs",
"url": "https://fastapi.tiangolo.com/",
},
},
]
app = FastAPI(openapi_tags=tags_metadata)
```
"""
),
]
=
None
,
servers
:
Annotated
[
Optional
[
List
[
Dict
[
str
,
Union
[
str
,
Any
]]]],
Doc
(
"""
A `list` of `dict`s with connectivity information to a target server.
You would use it, for example, if your application is served from
different domains and you want to use the same Swagger UI in the
browser to interact with each of them (instead of having multiple
browser tabs open). Or if you want to leave fixed the possible URLs.
If the servers `list` is not provided, or is an empty `list`, the
default value would be a `dict` with a `url` value of `/`.
Each item in the `list` is a `dict` containing:
* `url`: A URL to the target host. This URL supports Server Variables
and MAY be relative, to indicate that the host location is relative
to the location where the OpenAPI document is being served. Variable
substitutions will be made when a variable is named in `{`brackets`}`.
* `description`: An optional string describing the host designated by
the URL. [CommonMark syntax](https://commonmark.org/) MAY be used for
rich text representation.
* `variables`: A `dict` between a variable name and its value. The value
is used for substitution in the server's URL template.
Read more in the
[FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#additional-servers).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(
servers=[
{"url": "https://stag.example.com", "description": "Staging environment"},
{"url": "https://prod.example.com", "description": "Production environment"},
]
)
```
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of global dependencies, they will be applied to each
*path operation*, including in sub-routers.
Read more about it in the
[FastAPI docs for Global Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/global-dependencies/).
**Example**
```python
from fastapi import Depends, FastAPI
from .dependencies import func_dep_1, func_dep_2
app = FastAPI(dependencies=[Depends(func_dep_1), Depends(func_dep_2)])
```
"""
),
]
=
None
,
default_response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
The default response class to be used.
Read more in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
**Example**
```python
from fastapi import FastAPI
from fastapi.responses import ORJSONResponse
app = FastAPI(default_response_class=ORJSONResponse)
```
"""
),
]
=
Default
(
JSONResponse
),
redirect_slashes
:
Annotated
[
bool
,
Doc
(
"""
Whether to detect and redirect slashes in URLs when the client doesn't
use the same format.
**Example**
```python
from fastapi import FastAPI
app = FastAPI(redirect_slashes=True) # the default
@app.get("/items/")
async def read_items():
return [{"item_id": "Foo"}]
```
With this app, if a client goes to `/items` (without a trailing slash),
they will be automatically redirected with an HTTP status code of 307
to `/items/`.
"""
),
]
=
True
,
docs_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The path to the automatic interactive API documentation.
It is handled in the browser by Swagger UI.
The default URL is `/docs`. You can disable it by setting it to `None`.
If `openapi_url` is set to `None`, this will be automatically disabled.
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(docs_url="/documentation", redoc_url=None)
```
"""
),
]
=
"/docs"
,
redoc_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The path to the alternative automatic interactive API documentation
provided by ReDoc.
The default URL is `/redoc`. You can disable it by setting it to `None`.
If `openapi_url` is set to `None`, this will be automatically disabled.
Read more in the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(docs_url="/documentation", redoc_url="redocumentation")
```
"""
),
]
=
"/redoc"
,
swagger_ui_oauth2_redirect_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The OAuth2 redirect endpoint for the Swagger UI.
By default it is `/docs/oauth2-redirect`.
This is only used if you use OAuth2 (with the "Authorize" button)
with Swagger UI.
"""
),
]
=
"/docs/oauth2-redirect"
,
swagger_ui_init_oauth
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
OAuth2 configuration for the Swagger UI, by default shown at `/docs`.
Read more about the available configuration options in the
[Swagger UI docs](https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/).
"""
),
]
=
None
,
middleware
:
Annotated
[
Optional
[
Sequence
[
Middleware
]],
Doc
(
"""
List of middleware to be added when creating the application.
In FastAPI you would normally do this with `app.add_middleware()`
instead.
Read more in the
[FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).
"""
),
]
=
None
,
exception_handlers
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
Type
[
Exception
]],
Callable
[[
Request
,
Any
],
Coroutine
[
Any
,
Any
,
Response
]],
]
],
Doc
(
"""
A dictionary with handlers for exceptions.
In FastAPI, you would normally use the decorator
`@app.exception_handler()`.
Read more in the
[FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).
"""
),
]
=
None
,
on_startup
:
Annotated
[
Optional
[
Sequence
[
Callable
[[],
Any
]]],
Doc
(
"""
A list of startup event handler functions.
You should instead use the `lifespan` handlers.
Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
on_shutdown
:
Annotated
[
Optional
[
Sequence
[
Callable
[[],
Any
]]],
Doc
(
"""
A list of shutdown event handler functions.
You should instead use the `lifespan` handlers.
Read more in the
[FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
lifespan
:
Annotated
[
Optional
[
Lifespan
[
AppType
]],
Doc
(
"""
A `Lifespan` context manager handler. This replaces `startup` and
`shutdown` functions with a single context manager.
Read more in the
[FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
"""
),
]
=
None
,
terms_of_service
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A URL to the Terms of Service for your API.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more at the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
app = FastAPI(terms_of_service="http://example.com/terms/")
```
"""
),
]
=
None
,
contact
:
Annotated
[
Optional
[
Dict
[
str
,
Union
[
str
,
Any
]]],
Doc
(
"""
A dictionary with the contact information for the exposed API.
It can contain several fields.
* `name`: (`str`) The name of the contact person/organization.
* `url`: (`str`) A URL pointing to the contact information. MUST be in
the format of a URL.
* `email`: (`str`) The email address of the contact person/organization.
MUST be in the format of an email address.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more at the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
app = FastAPI(
contact={
"name": "Deadpoolio the Amazing",
"url": "http://x-force.example.com/contact/",
"email": "dp@x-force.example.com",
}
)
```
"""
),
]
=
None
,
license_info
:
Annotated
[
Optional
[
Dict
[
str
,
Union
[
str
,
Any
]]],
Doc
(
"""
A dictionary with the license information for the exposed API.
It can contain several fields.
* `name`: (`str`) **REQUIRED** (if a `license_info` is set). The
license name used for the API.
* `identifier`: (`str`) An [SPDX](https://spdx.dev/) license expression
for the API. The `identifier` field is mutually exclusive of the `url`
field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.
* `url`: (`str`) A URL to the license used for the API. This MUST be
the format of a URL.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more at the
[FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).
**Example**
```python
app = FastAPI(
license_info={
"name": "Apache 2.0",
"url": "https://www.apache.org/licenses/LICENSE-2.0.html",
}
)
```
"""
),
]
=
None
,
openapi_prefix
:
Annotated
[
str
,
Doc
(
"""
A URL prefix for the OpenAPI URL.
"""
),
deprecated
(
"""
"openapi_prefix" has been deprecated in favor of "root_path", which
follows more closely the ASGI standard, is simpler, and more
automatic.
"""
),
]
=
""
,
root_path
:
Annotated
[
str
,
Doc
(
"""
A path prefix handled by a proxy that is not seen by the application
but is seen by external clients, which affects things like Swagger UI.
Read more about it at the
[FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(root_path="/api/v1")
```
"""
),
]
=
""
,
root_path_in_servers
:
Annotated
[
bool
,
Doc
(
"""
To disable automatically generating the URLs in the `servers` field
in the autogenerated OpenAPI using the `root_path`.
Read more about it in the
[FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#disable-automatic-server-from-root_path).
**Example**
```python
from fastapi import FastAPI
app = FastAPI(root_path_in_servers=False)
```
"""
),
]
=
True
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
And in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
OpenAPI callbacks that should apply to all *path operations*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
webhooks
:
Annotated
[
Optional
[
routing
.
APIRouter
],
Doc
(
"""
Add OpenAPI webhooks. This is similar to `callbacks` but it doesn't
depend on specific *path operations*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
**Note**: This is available since OpenAPI 3.1.0, FastAPI 0.99.0.
Read more about it in the
[FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark all *path operations* as deprecated. You probably don't need it,
but it's available.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) all the *path operations* in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
swagger_ui_parameters
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Parameters to configure Swagger UI, the autogenerated interactive API
documentation (by default at `/docs`).
Read more about it in the
[FastAPI docs about how to Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
separate_input_output_schemas
:
Annotated
[
bool
,
Doc
(
"""
Whether to generate separate OpenAPI schemas for request body and
response body when the results would be more precise.
This is particularly useful when automatically generating clients.
For example, if you have a model like:
```python
from pydantic import BaseModel
class Item(BaseModel):
name: str
tags: list[str] = []
```
When `Item` is used for input, a request body, `tags` is not required,
the client doesn't have to provide it.
But when using `Item` for output, for a response body, `tags` is always
available because it has a default value, even if it's just an empty
list. So, the client should be able to always expect it.
In this case, there would be two different schemas, one for input and
another one for output.
"""
),
]
=
True
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Extra keyword arguments to be stored in the app, not used by FastAPI
anywhere.
"""
),
],
)
->
None
:
self
.
debug
=
debug
self
.
title
=
title
self
.
summary
=
summary
self
.
description
=
description
self
.
version
=
version
self
.
terms_of_service
=
terms_of_service
self
.
contact
=
contact
self
.
license_info
=
license_info
self
.
openapi_url
=
openapi_url
self
.
openapi_tags
=
openapi_tags
self
.
root_path_in_servers
=
root_path_in_servers
self
.
docs_url
=
docs_url
self
.
redoc_url
=
redoc_url
self
.
swagger_ui_oauth2_redirect_url
=
swagger_ui_oauth2_redirect_url
self
.
swagger_ui_init_oauth
=
swagger_ui_init_oauth
self
.
swagger_ui_parameters
=
swagger_ui_parameters
self
.
servers
=
servers
or
[]
self
.
separate_input_output_schemas
=
separate_input_output_schemas
self
.
extra
=
extra
self
.
openapi_version
:
Annotated
[
str
,
Doc
(
"""
The version string of OpenAPI.
FastAPI will generate OpenAPI version 3.1.0, and will output that as
the OpenAPI version. But some tools, even though they might be
compatible with OpenAPI 3.1.0, might not recognize it as a valid.
So you could override this value to trick those tools into using
the generated OpenAPI. Have in mind that this is a hack. But if you
avoid using features added in OpenAPI 3.1.0, it might work for your
use case.
This is not passed as a parameter to the `FastAPI` class to avoid
giving the false idea that FastAPI would generate a different OpenAPI
schema. It is only available as an attribute.
**Example**
```python
from fastapi import FastAPI
app = FastAPI()
app.openapi_version = "3.0.2"
```
"""
),
]
=
"3.1.0"
self
.
openapi_schema
:
Optional
[
Dict
[
str
,
Any
]]
=
None
if
self
.
openapi_url
:
assert
self
.
title
,
"A title must be provided for OpenAPI, e.g.: 'My API'"
assert
self
.
version
,
"A version must be provided for OpenAPI, e.g.: '2.1.0'"
## TODO: remove when discarding the openapi_prefix parameter
if
openapi_prefix
:
logger
.
warning
(
'"openapi_prefix" has been deprecated in favor of "root_path", which '
"follows more closely the ASGI standard, is simpler, and more "
"automatic. Check the docs at "
"https://fastapi.tiangolo.com/advanced/sub-applications/"
)
self
.
webhooks
:
Annotated
[
routing
.
APIRouter
,
Doc
(
"""
The `app.webhooks` attribute is an `APIRouter` with the *path
operations* that will be used just for documentation of webhooks.
Read more about it in the
[FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).
"""
),
]
=
webhooks
or
routing
.
APIRouter
()
self
.
root_path
=
root_path
or
openapi_prefix
self
.
state
:
Annotated
[
State
,
Doc
(
"""
A state object for the application. This is the same object for the
entire application, it doesn't change from request to request.
You normally wouldn't use this in FastAPI, for most of the cases you
would instead use FastAPI dependencies.
This is simply inherited from Starlette.
Read more about it in the
[Starlette docs for Applications](https://www.starlette.io/applications/#storing-state-on-the-app-instance).
"""
),
]
=
State
()
self
.
dependency_overrides
:
Annotated
[
Dict
[
Callable
[
...
,
Any
],
Callable
[
...
,
Any
]],
Doc
(
"""
A dictionary with overrides for the dependencies.
Each key is the original dependency callable, and the value is the
actual dependency that should be called.
This is for testing, to replace expensive dependencies with testing
versions.
Read more about it in the
[FastAPI docs for Testing Dependencies with Overrides](https://fastapi.tiangolo.com/advanced/testing-dependencies/).
"""
),
]
=
{}
self
.
router
:
routing
.
APIRouter
=
routing
.
APIRouter
(
routes
=
routes
,
redirect_slashes
=
redirect_slashes
,
dependency_overrides_provider
=
self
,
on_startup
=
on_startup
,
on_shutdown
=
on_shutdown
,
lifespan
=
lifespan
,
default_response_class
=
default_response_class
,
dependencies
=
dependencies
,
callbacks
=
callbacks
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
responses
=
responses
,
generate_unique_id_function
=
generate_unique_id_function
,
)
self
.
exception_handlers
:
Dict
[
Any
,
Callable
[[
Request
,
Any
],
Union
[
Response
,
Awaitable
[
Response
]]]
]
=
{}
if
exception_handlers
is
None
else
dict
(
exception_handlers
)
self
.
exception_handlers
.
setdefault
(
HTTPException
,
http_exception_handler
)
self
.
exception_handlers
.
setdefault
(
RequestValidationError
,
request_validation_exception_handler
)
self
.
exception_handlers
.
setdefault
(
WebSocketRequestValidationError
,
## Starlette still has incorrect type specification for the handlers
websocket_request_validation_exception_handler
,
## type: ignore
)
self
.
user_middleware
:
List
[
Middleware
]
=
(
[]
if
middleware
is
None
else
list
(
middleware
)
)
self
.
middleware_stack
:
Union
[
ASGIApp
,
None
]
=
None
self
.
setup
()
openapi_version
instance-attribute
openapi_version
=
'3.1.0'
The version string of OpenAPI.
FastAPI will generate OpenAPI version 3.1.0, and will output that as
the OpenAPI version. But some tools, even though they might be
compatible with OpenAPI 3.1.0, might not recognize it as a valid.
So you could override this value to trick those tools into using
the generated OpenAPI. Have in mind that this is a hack. But if you
avoid using features added in OpenAPI 3.1.0, it might work for your
use case.
This is not passed as a parameter to the
FastAPI
class to avoid
giving the false idea that FastAPI would generate a different OpenAPI
schema. It is only available as an attribute.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
app
.
openapi_version
=
"3.0.2"
webhooks
instance-attribute
webhooks
=
webhooks
or
APIRouter
()
The
app.webhooks
attribute is an
APIRouter
with the
path
operations
that will be used just for documentation of webhooks.
Read more about it in the
FastAPI docs for OpenAPI Webhooks
.
state
instance-attribute
state
=
State
()
A state object for the application. This is the same object for the
entire application, it doesn't change from request to request.
You normally wouldn't use this in FastAPI, for most of the cases you
would instead use FastAPI dependencies.
This is simply inherited from Starlette.
Read more about it in the
Starlette docs for Applications
.
dependency_overrides
instance-attribute
dependency_overrides
=
{}
A dictionary with overrides for the dependencies.
Each key is the original dependency callable, and the value is the
actual dependency that should be called.
This is for testing, to replace expensive dependencies with testing
versions.
Read more about it in the
FastAPI docs for Testing Dependencies with Overrides
.
openapi
openapi
()
Generate the OpenAPI schema of the application. This is called by FastAPI
internally.
The first time it is called it stores the result in the attribute
app.openapi_schema
, and next times it is called, it just returns that same
result. To avoid the cost of generating the schema every time.
If you need to modify the generated OpenAPI schema, you could modify it.
Read more in the
FastAPI docs for OpenAPI
.
Source code in
fastapi/applications.py
966
967
968
969
970
971
972
973
974
975
976
977
978
979
980
981
982
983
984
985
986
987
988
989
990
991
992
993
994
995
996
def
openapi
(
self
)
->
Dict
[
str
,
Any
]:
"""
Generate the OpenAPI schema of the application. This is called by FastAPI
internally.
The first time it is called it stores the result in the attribute
`app.openapi_schema`, and next times it is called, it just returns that same
result. To avoid the cost of generating the schema every time.
If you need to modify the generated OpenAPI schema, you could modify it.
Read more in the
[FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).
"""
if
not
self
.
openapi_schema
:
self
.
openapi_schema
=
get_openapi
(
title
=
self
.
title
,
version
=
self
.
version
,
openapi_version
=
self
.
openapi_version
,
summary
=
self
.
summary
,
description
=
self
.
description
,
terms_of_service
=
self
.
terms_of_service
,
contact
=
self
.
contact
,
license_info
=
self
.
license_info
,
routes
=
self
.
routes
,
webhooks
=
self
.
webhooks
.
routes
,
tags
=
self
.
openapi_tags
,
servers
=
self
.
servers
,
separate_input_output_schemas
=
self
.
separate_input_output_schemas
,
)
return
self
.
openapi_schema
websocket
websocket
(
path
,
name
=
None
,
*
,
dependencies
=
None
)
Decorate a WebSocket function.
Read more about it in the
FastAPI docs for WebSockets
.
Example
from
fastapi
import
FastAPI
,
WebSocket
app
=
FastAPI
()
@app
.
websocket
(
"/ws"
)
async
def
websocket_endpoint
(
websocket
:
WebSocket
):
await
websocket
.
accept
()
while
True
:
data
=
await
websocket
.
receive_text
()
await
websocket
.
send_text
(
f
"Message text was:
{
data
}
"
)
PARAMETER
DESCRIPTION
path
WebSocket path.
TYPE:
str
name
A name for the WebSocket. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be used for this
WebSocket.
Read more about it in the
FastAPI docs for WebSockets
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
Source code in
fastapi/applications.py
1190
1191
1192
1193
1194
1195
1196
1197
1198
1199
1200
1201
1202
1203
1204
1205
1206
1207
1208
1209
1210
1211
1212
1213
1214
1215
1216
1217
1218
1219
1220
1221
1222
1223
1224
1225
1226
1227
1228
1229
1230
1231
1232
1233
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243
1244
1245
1246
1247
1248
1249
1250
1251
1252
1253
def
websocket
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
WebSocket path.
"""
),
],
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A name for the WebSocket. Only used internally.
"""
),
]
=
None
,
*
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be used for this
WebSocket.
Read more about it in the
[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
"""
),
]
=
None
,
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Decorate a WebSocket function.
Read more about it in the
[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
**Example**
```python
from fastapi import FastAPI, WebSocket
app = FastAPI()
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
await websocket.accept()
while True:
data = await websocket.receive_text()
await websocket.send_text(f"Message text was: {data}")
```
"""
def
decorator
(
func
:
DecoratedCallable
)
->
DecoratedCallable
:
self
.
add_api_websocket_route
(
path
,
func
,
name
=
name
,
dependencies
=
dependencies
,
)
return
func
return
decorator
include_router
include_router
(
router
,
*
,
prefix
=
""
,
tags
=
None
,
dependencies
=
None
,
responses
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
default_response_class
=
Default
(
JSONResponse
),
callbacks
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Include an
APIRouter
in the same app.
Read more about it in the
FastAPI docs for Bigger Applications
.
Example
from
fastapi
import
FastAPI
from
.users
import
users_router
app
=
FastAPI
()
app
.
include_router
(
users_router
)
PARAMETER
DESCRIPTION
router
The
APIRouter
to include.
TYPE:
APIRouter
prefix
An optional path prefix for the router.
TYPE:
str
DEFAULT:
''
tags
A list of tags to be applied to all the
path operations
in this
router.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to all the
path operations
in this router.
Read more about it in the
FastAPI docs for Bigger Applications - Multiple Files
.
Example
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_token_header
from
.internal
import
admin
app
=
FastAPI
()
app
.
include_router
(
admin
.
router
,
dependencies
=
[
Depends
(
get_token_header
)],
)
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
responses
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Additional Responses in OpenAPI
.
And in the
FastAPI docs for Bigger Applications
.
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark all the
path operations
in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Example
from
fastapi
import
FastAPI
from
.internal
import
old_api
app
=
FastAPI
()
app
.
include_router
(
old_api
.
router
,
deprecated
=
True
,
)
TYPE:
Optional
[
bool
]
DEFAULT:
None
include_in_schema
Include (or not) all the
path operations
in this router in the
generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Example
from
fastapi
import
FastAPI
from
.internal
import
old_api
app
=
FastAPI
()
app
.
include_router
(
old_api
.
router
,
include_in_schema
=
False
,
)
TYPE:
bool
DEFAULT:
True
default_response_class
Default response class to be used for the
path operations
in this
router.
Read more in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
Example
from
fastapi
import
FastAPI
from
fastapi.responses
import
ORJSONResponse
from
.internal
import
old_api
app
=
FastAPI
()
app
.
include_router
(
old_api
.
router
,
default_response_class
=
ORJSONResponse
,
)
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
1255
1256
1257
1258
1259
1260
1261
1262
1263
1264
1265
1266
1267
1268
1269
1270
1271
1272
1273
1274
1275
1276
1277
1278
1279
1280
1281
1282
1283
1284
1285
1286
1287
1288
1289
1290
1291
1292
1293
1294
1295
1296
1297
1298
1299
1300
1301
1302
1303
1304
1305
1306
1307
1308
1309
1310
1311
1312
1313
1314
1315
1316
1317
1318
1319
1320
1321
1322
1323
1324
1325
1326
1327
1328
1329
1330
1331
1332
1333
1334
1335
1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352
1353
1354
1355
1356
1357
1358
1359
1360
1361
1362
1363
1364
1365
1366
1367
1368
1369
1370
1371
1372
1373
1374
1375
1376
1377
1378
1379
1380
1381
1382
1383
1384
1385
1386
1387
1388
1389
1390
1391
1392
1393
1394
1395
1396
1397
1398
1399
1400
1401
1402
1403
1404
1405
1406
1407
1408
1409
1410
1411
1412
1413
1414
1415
1416
1417
1418
1419
1420
1421
1422
1423
1424
1425
1426
1427
1428
1429
1430
1431
1432
1433
1434
1435
1436
1437
1438
1439
1440
1441
1442
1443
1444
1445
1446
1447
1448
1449
1450
1451
1452
1453
1454
1455
1456
1457
1458
def
include_router
(
self
,
router
:
Annotated
[
routing
.
APIRouter
,
Doc
(
"The `APIRouter` to include."
)],
*
,
prefix
:
Annotated
[
str
,
Doc
(
"An optional path prefix for the router."
)]
=
""
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to all the *path operations* in this
router.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to all the
*path operations* in this router.
Read more about it in the
[FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
**Example**
```python
from fastapi import Depends, FastAPI
from .dependencies import get_token_header
from .internal import admin
app = FastAPI()
app.include_router(
admin.router,
dependencies=[Depends(get_token_header)],
)
```
"""
),
]
=
None
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses to be shown in OpenAPI.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
And in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark all the *path operations* in this router as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
**Example**
```python
from fastapi import FastAPI
from .internal import old_api
app = FastAPI()
app.include_router(
old_api.router,
deprecated=True,
)
```
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include (or not) all the *path operations* in this router in the
generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
**Example**
```python
from fastapi import FastAPI
from .internal import old_api
app = FastAPI()
app.include_router(
old_api.router,
include_in_schema=False,
)
```
"""
),
]
=
True
,
default_response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Default response class to be used for the *path operations* in this
router.
Read more in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
**Example**
```python
from fastapi import FastAPI
from fastapi.responses import ORJSONResponse
from .internal import old_api
app = FastAPI()
app.include_router(
old_api.router,
default_response_class=ORJSONResponse,
)
```
"""
),
]
=
Default
(
JSONResponse
),
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
None
:
"""
Include an `APIRouter` in the same app.
Read more about it in the
[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).
## Example
```python
from fastapi import FastAPI
from .users import users_router
app = FastAPI()
app.include_router(users_router)
```
"""
self
.
router
.
include_router
(
router
,
prefix
=
prefix
,
tags
=
tags
,
dependencies
=
dependencies
,
responses
=
responses
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
default_response_class
=
default_response_class
,
callbacks
=
callbacks
,
generate_unique_id_function
=
generate_unique_id_function
,
)
get
get
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP GET operation.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
def
read_items
():
return
[{
"name"
:
"Empanada"
},
{
"name"
:
"Arepa"
}]
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
1460
1461
1462
1463
1464
1465
1466
1467
1468
1469
1470
1471
1472
1473
1474
1475
1476
1477
1478
1479
1480
1481
1482
1483
1484
1485
1486
1487
1488
1489
1490
1491
1492
1493
1494
1495
1496
1497
1498
1499
1500
1501
1502
1503
1504
1505
1506
1507
1508
1509
1510
1511
1512
1513
1514
1515
1516
1517
1518
1519
1520
1521
1522
1523
1524
1525
1526
1527
1528
1529
1530
1531
1532
1533
1534
1535
1536
1537
1538
1539
1540
1541
1542
1543
1544
1545
1546
1547
1548
1549
1550
1551
1552
1553
1554
1555
1556
1557
1558
1559
1560
1561
1562
1563
1564
1565
1566
1567
1568
1569
1570
1571
1572
1573
1574
1575
1576
1577
1578
1579
1580
1581
1582
1583
1584
1585
1586
1587
1588
1589
1590
1591
1592
1593
1594
1595
1596
1597
1598
1599
1600
1601
1602
1603
1604
1605
1606
1607
1608
1609
1610
1611
1612
1613
1614
1615
1616
1617
1618
1619
1620
1621
1622
1623
1624
1625
1626
1627
1628
1629
1630
1631
1632
1633
1634
1635
1636
1637
1638
1639
1640
1641
1642
1643
1644
1645
1646
1647
1648
1649
1650
1651
1652
1653
1654
1655
1656
1657
1658
1659
1660
1661
1662
1663
1664
1665
1666
1667
1668
1669
1670
1671
1672
1673
1674
1675
1676
1677
1678
1679
1680
1681
1682
1683
1684
1685
1686
1687
1688
1689
1690
1691
1692
1693
1694
1695
1696
1697
1698
1699
1700
1701
1702
1703
1704
1705
1706
1707
1708
1709
1710
1711
1712
1713
1714
1715
1716
1717
1718
1719
1720
1721
1722
1723
1724
1725
1726
1727
1728
1729
1730
1731
1732
1733
1734
1735
1736
1737
1738
1739
1740
1741
1742
1743
1744
1745
1746
1747
1748
1749
1750
1751
1752
1753
1754
1755
1756
1757
1758
1759
1760
1761
1762
1763
1764
1765
1766
1767
1768
1769
1770
1771
1772
1773
1774
1775
1776
1777
1778
1779
1780
1781
1782
1783
1784
1785
1786
1787
1788
1789
1790
1791
1792
1793
1794
1795
1796
1797
1798
1799
1800
1801
1802
1803
1804
1805
1806
1807
1808
1809
1810
1811
1812
1813
1814
1815
1816
1817
1818
1819
1820
1821
1822
1823
1824
1825
1826
1827
1828
1829
1830
1831
def
get
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP GET operation.
## Example
```python
from fastapi import FastAPI
app = FastAPI()
@app.get("/items/")
def read_items():
return [{"name": "Empanada"}, {"name": "Arepa"}]
```
"""
return
self
.
router
.
get
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
put
put
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP PUT operation.
Example
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
def
replace_item
(
item_id
:
str
,
item
:
Item
):
return
{
"message"
:
"Item replaced"
,
"id"
:
item_id
}
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
1833
1834
1835
1836
1837
1838
1839
1840
1841
1842
1843
1844
1845
1846
1847
1848
1849
1850
1851
1852
1853
1854
1855
1856
1857
1858
1859
1860
1861
1862
1863
1864
1865
1866
1867
1868
1869
1870
1871
1872
1873
1874
1875
1876
1877
1878
1879
1880
1881
1882
1883
1884
1885
1886
1887
1888
1889
1890
1891
1892
1893
1894
1895
1896
1897
1898
1899
1900
1901
1902
1903
1904
1905
1906
1907
1908
1909
1910
1911
1912
1913
1914
1915
1916
1917
1918
1919
1920
1921
1922
1923
1924
1925
1926
1927
1928
1929
1930
1931
1932
1933
1934
1935
1936
1937
1938
1939
1940
1941
1942
1943
1944
1945
1946
1947
1948
1949
1950
1951
1952
1953
1954
1955
1956
1957
1958
1959
1960
1961
1962
1963
1964
1965
1966
1967
1968
1969
1970
1971
1972
1973
1974
1975
1976
1977
1978
1979
1980
1981
1982
1983
1984
1985
1986
1987
1988
1989
1990
1991
1992
1993
1994
1995
1996
1997
1998
1999
2000
2001
2002
2003
2004
2005
2006
2007
2008
2009
2010
2011
2012
2013
2014
2015
2016
2017
2018
2019
2020
2021
2022
2023
2024
2025
2026
2027
2028
2029
2030
2031
2032
2033
2034
2035
2036
2037
2038
2039
2040
2041
2042
2043
2044
2045
2046
2047
2048
2049
2050
2051
2052
2053
2054
2055
2056
2057
2058
2059
2060
2061
2062
2063
2064
2065
2066
2067
2068
2069
2070
2071
2072
2073
2074
2075
2076
2077
2078
2079
2080
2081
2082
2083
2084
2085
2086
2087
2088
2089
2090
2091
2092
2093
2094
2095
2096
2097
2098
2099
2100
2101
2102
2103
2104
2105
2106
2107
2108
2109
2110
2111
2112
2113
2114
2115
2116
2117
2118
2119
2120
2121
2122
2123
2124
2125
2126
2127
2128
2129
2130
2131
2132
2133
2134
2135
2136
2137
2138
2139
2140
2141
2142
2143
2144
2145
2146
2147
2148
2149
2150
2151
2152
2153
2154
2155
2156
2157
2158
2159
2160
2161
2162
2163
2164
2165
2166
2167
2168
2169
2170
2171
2172
2173
2174
2175
2176
2177
2178
2179
2180
2181
2182
2183
2184
2185
2186
2187
2188
2189
2190
2191
2192
2193
2194
2195
2196
2197
2198
2199
2200
2201
2202
2203
2204
2205
2206
2207
2208
2209
def
put
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP PUT operation.
## Example
```python
from fastapi import FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
@app.put("/items/{item_id}")
def replace_item(item_id: str, item: Item):
return {"message": "Item replaced", "id": item_id}
```
"""
return
self
.
router
.
put
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
post
post
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP POST operation.
Example
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
def
create_item
(
item
:
Item
):
return
{
"message"
:
"Item created"
}
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
2211
2212
2213
2214
2215
2216
2217
2218
2219
2220
2221
2222
2223
2224
2225
2226
2227
2228
2229
2230
2231
2232
2233
2234
2235
2236
2237
2238
2239
2240
2241
2242
2243
2244
2245
2246
2247
2248
2249
2250
2251
2252
2253
2254
2255
2256
2257
2258
2259
2260
2261
2262
2263
2264
2265
2266
2267
2268
2269
2270
2271
2272
2273
2274
2275
2276
2277
2278
2279
2280
2281
2282
2283
2284
2285
2286
2287
2288
2289
2290
2291
2292
2293
2294
2295
2296
2297
2298
2299
2300
2301
2302
2303
2304
2305
2306
2307
2308
2309
2310
2311
2312
2313
2314
2315
2316
2317
2318
2319
2320
2321
2322
2323
2324
2325
2326
2327
2328
2329
2330
2331
2332
2333
2334
2335
2336
2337
2338
2339
2340
2341
2342
2343
2344
2345
2346
2347
2348
2349
2350
2351
2352
2353
2354
2355
2356
2357
2358
2359
2360
2361
2362
2363
2364
2365
2366
2367
2368
2369
2370
2371
2372
2373
2374
2375
2376
2377
2378
2379
2380
2381
2382
2383
2384
2385
2386
2387
2388
2389
2390
2391
2392
2393
2394
2395
2396
2397
2398
2399
2400
2401
2402
2403
2404
2405
2406
2407
2408
2409
2410
2411
2412
2413
2414
2415
2416
2417
2418
2419
2420
2421
2422
2423
2424
2425
2426
2427
2428
2429
2430
2431
2432
2433
2434
2435
2436
2437
2438
2439
2440
2441
2442
2443
2444
2445
2446
2447
2448
2449
2450
2451
2452
2453
2454
2455
2456
2457
2458
2459
2460
2461
2462
2463
2464
2465
2466
2467
2468
2469
2470
2471
2472
2473
2474
2475
2476
2477
2478
2479
2480
2481
2482
2483
2484
2485
2486
2487
2488
2489
2490
2491
2492
2493
2494
2495
2496
2497
2498
2499
2500
2501
2502
2503
2504
2505
2506
2507
2508
2509
2510
2511
2512
2513
2514
2515
2516
2517
2518
2519
2520
2521
2522
2523
2524
2525
2526
2527
2528
2529
2530
2531
2532
2533
2534
2535
2536
2537
2538
2539
2540
2541
2542
2543
2544
2545
2546
2547
2548
2549
2550
2551
2552
2553
2554
2555
2556
2557
2558
2559
2560
2561
2562
2563
2564
2565
2566
2567
2568
2569
2570
2571
2572
2573
2574
2575
2576
2577
2578
2579
2580
2581
2582
2583
2584
2585
2586
2587
def
post
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP POST operation.
## Example
```python
from fastapi import FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
@app.post("/items/")
def create_item(item: Item):
return {"message": "Item created"}
```
"""
return
self
.
router
.
post
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
delete
delete
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP DELETE operation.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
delete
(
"/items/
{item_id}
"
)
def
delete_item
(
item_id
:
str
):
return
{
"message"
:
"Item deleted"
}
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
2589
2590
2591
2592
2593
2594
2595
2596
2597
2598
2599
2600
2601
2602
2603
2604
2605
2606
2607
2608
2609
2610
2611
2612
2613
2614
2615
2616
2617
2618
2619
2620
2621
2622
2623
2624
2625
2626
2627
2628
2629
2630
2631
2632
2633
2634
2635
2636
2637
2638
2639
2640
2641
2642
2643
2644
2645
2646
2647
2648
2649
2650
2651
2652
2653
2654
2655
2656
2657
2658
2659
2660
2661
2662
2663
2664
2665
2666
2667
2668
2669
2670
2671
2672
2673
2674
2675
2676
2677
2678
2679
2680
2681
2682
2683
2684
2685
2686
2687
2688
2689
2690
2691
2692
2693
2694
2695
2696
2697
2698
2699
2700
2701
2702
2703
2704
2705
2706
2707
2708
2709
2710
2711
2712
2713
2714
2715
2716
2717
2718
2719
2720
2721
2722
2723
2724
2725
2726
2727
2728
2729
2730
2731
2732
2733
2734
2735
2736
2737
2738
2739
2740
2741
2742
2743
2744
2745
2746
2747
2748
2749
2750
2751
2752
2753
2754
2755
2756
2757
2758
2759
2760
2761
2762
2763
2764
2765
2766
2767
2768
2769
2770
2771
2772
2773
2774
2775
2776
2777
2778
2779
2780
2781
2782
2783
2784
2785
2786
2787
2788
2789
2790
2791
2792
2793
2794
2795
2796
2797
2798
2799
2800
2801
2802
2803
2804
2805
2806
2807
2808
2809
2810
2811
2812
2813
2814
2815
2816
2817
2818
2819
2820
2821
2822
2823
2824
2825
2826
2827
2828
2829
2830
2831
2832
2833
2834
2835
2836
2837
2838
2839
2840
2841
2842
2843
2844
2845
2846
2847
2848
2849
2850
2851
2852
2853
2854
2855
2856
2857
2858
2859
2860
2861
2862
2863
2864
2865
2866
2867
2868
2869
2870
2871
2872
2873
2874
2875
2876
2877
2878
2879
2880
2881
2882
2883
2884
2885
2886
2887
2888
2889
2890
2891
2892
2893
2894
2895
2896
2897
2898
2899
2900
2901
2902
2903
2904
2905
2906
2907
2908
2909
2910
2911
2912
2913
2914
2915
2916
2917
2918
2919
2920
2921
2922
2923
2924
2925
2926
2927
2928
2929
2930
2931
2932
2933
2934
2935
2936
2937
2938
2939
2940
2941
2942
2943
2944
2945
2946
2947
2948
2949
2950
2951
2952
2953
2954
2955
2956
2957
2958
2959
2960
def
delete
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP DELETE operation.
## Example
```python
from fastapi import FastAPI
app = FastAPI()
@app.delete("/items/{item_id}")
def delete_item(item_id: str):
return {"message": "Item deleted"}
```
"""
return
self
.
router
.
delete
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
options
options
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP OPTIONS operation.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
options
(
"/items/"
)
def
get_item_options
():
return
{
"additions"
:
[
"Aji"
,
"Guacamole"
]}
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
2962
2963
2964
2965
2966
2967
2968
2969
2970
2971
2972
2973
2974
2975
2976
2977
2978
2979
2980
2981
2982
2983
2984
2985
2986
2987
2988
2989
2990
2991
2992
2993
2994
2995
2996
2997
2998
2999
3000
3001
3002
3003
3004
3005
3006
3007
3008
3009
3010
3011
3012
3013
3014
3015
3016
3017
3018
3019
3020
3021
3022
3023
3024
3025
3026
3027
3028
3029
3030
3031
3032
3033
3034
3035
3036
3037
3038
3039
3040
3041
3042
3043
3044
3045
3046
3047
3048
3049
3050
3051
3052
3053
3054
3055
3056
3057
3058
3059
3060
3061
3062
3063
3064
3065
3066
3067
3068
3069
3070
3071
3072
3073
3074
3075
3076
3077
3078
3079
3080
3081
3082
3083
3084
3085
3086
3087
3088
3089
3090
3091
3092
3093
3094
3095
3096
3097
3098
3099
3100
3101
3102
3103
3104
3105
3106
3107
3108
3109
3110
3111
3112
3113
3114
3115
3116
3117
3118
3119
3120
3121
3122
3123
3124
3125
3126
3127
3128
3129
3130
3131
3132
3133
3134
3135
3136
3137
3138
3139
3140
3141
3142
3143
3144
3145
3146
3147
3148
3149
3150
3151
3152
3153
3154
3155
3156
3157
3158
3159
3160
3161
3162
3163
3164
3165
3166
3167
3168
3169
3170
3171
3172
3173
3174
3175
3176
3177
3178
3179
3180
3181
3182
3183
3184
3185
3186
3187
3188
3189
3190
3191
3192
3193
3194
3195
3196
3197
3198
3199
3200
3201
3202
3203
3204
3205
3206
3207
3208
3209
3210
3211
3212
3213
3214
3215
3216
3217
3218
3219
3220
3221
3222
3223
3224
3225
3226
3227
3228
3229
3230
3231
3232
3233
3234
3235
3236
3237
3238
3239
3240
3241
3242
3243
3244
3245
3246
3247
3248
3249
3250
3251
3252
3253
3254
3255
3256
3257
3258
3259
3260
3261
3262
3263
3264
3265
3266
3267
3268
3269
3270
3271
3272
3273
3274
3275
3276
3277
3278
3279
3280
3281
3282
3283
3284
3285
3286
3287
3288
3289
3290
3291
3292
3293
3294
3295
3296
3297
3298
3299
3300
3301
3302
3303
3304
3305
3306
3307
3308
3309
3310
3311
3312
3313
3314
3315
3316
3317
3318
3319
3320
3321
3322
3323
3324
3325
3326
3327
3328
3329
3330
3331
3332
3333
def
options
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP OPTIONS operation.
## Example
```python
from fastapi import FastAPI
app = FastAPI()
@app.options("/items/")
def get_item_options():
return {"additions": ["Aji", "Guacamole"]}
```
"""
return
self
.
router
.
options
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
head
head
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP HEAD operation.
Example
from
fastapi
import
FastAPI
,
Response
app
=
FastAPI
()
@app
.
head
(
"/items/"
,
status_code
=
204
)
def
get_items_headers
(
response
:
Response
):
response
.
headers
[
"X-Cat-Dog"
]
=
"Alone in the world"
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
3335
3336
3337
3338
3339
3340
3341
3342
3343
3344
3345
3346
3347
3348
3349
3350
3351
3352
3353
3354
3355
3356
3357
3358
3359
3360
3361
3362
3363
3364
3365
3366
3367
3368
3369
3370
3371
3372
3373
3374
3375
3376
3377
3378
3379
3380
3381
3382
3383
3384
3385
3386
3387
3388
3389
3390
3391
3392
3393
3394
3395
3396
3397
3398
3399
3400
3401
3402
3403
3404
3405
3406
3407
3408
3409
3410
3411
3412
3413
3414
3415
3416
3417
3418
3419
3420
3421
3422
3423
3424
3425
3426
3427
3428
3429
3430
3431
3432
3433
3434
3435
3436
3437
3438
3439
3440
3441
3442
3443
3444
3445
3446
3447
3448
3449
3450
3451
3452
3453
3454
3455
3456
3457
3458
3459
3460
3461
3462
3463
3464
3465
3466
3467
3468
3469
3470
3471
3472
3473
3474
3475
3476
3477
3478
3479
3480
3481
3482
3483
3484
3485
3486
3487
3488
3489
3490
3491
3492
3493
3494
3495
3496
3497
3498
3499
3500
3501
3502
3503
3504
3505
3506
3507
3508
3509
3510
3511
3512
3513
3514
3515
3516
3517
3518
3519
3520
3521
3522
3523
3524
3525
3526
3527
3528
3529
3530
3531
3532
3533
3534
3535
3536
3537
3538
3539
3540
3541
3542
3543
3544
3545
3546
3547
3548
3549
3550
3551
3552
3553
3554
3555
3556
3557
3558
3559
3560
3561
3562
3563
3564
3565
3566
3567
3568
3569
3570
3571
3572
3573
3574
3575
3576
3577
3578
3579
3580
3581
3582
3583
3584
3585
3586
3587
3588
3589
3590
3591
3592
3593
3594
3595
3596
3597
3598
3599
3600
3601
3602
3603
3604
3605
3606
3607
3608
3609
3610
3611
3612
3613
3614
3615
3616
3617
3618
3619
3620
3621
3622
3623
3624
3625
3626
3627
3628
3629
3630
3631
3632
3633
3634
3635
3636
3637
3638
3639
3640
3641
3642
3643
3644
3645
3646
3647
3648
3649
3650
3651
3652
3653
3654
3655
3656
3657
3658
3659
3660
3661
3662
3663
3664
3665
3666
3667
3668
3669
3670
3671
3672
3673
3674
3675
3676
3677
3678
3679
3680
3681
3682
3683
3684
3685
3686
3687
3688
3689
3690
3691
3692
3693
3694
3695
3696
3697
3698
3699
3700
3701
3702
3703
3704
3705
3706
def
head
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP HEAD operation.
## Example
```python
from fastapi import FastAPI, Response
app = FastAPI()
@app.head("/items/", status_code=204)
def get_items_headers(response: Response):
response.headers["X-Cat-Dog"] = "Alone in the world"
```
"""
return
self
.
router
.
head
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
patch
patch
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP PATCH operation.
Example
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
patch
(
"/items/"
)
def
update_item
(
item
:
Item
):
return
{
"message"
:
"Item updated in place"
}
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
3708
3709
3710
3711
3712
3713
3714
3715
3716
3717
3718
3719
3720
3721
3722
3723
3724
3725
3726
3727
3728
3729
3730
3731
3732
3733
3734
3735
3736
3737
3738
3739
3740
3741
3742
3743
3744
3745
3746
3747
3748
3749
3750
3751
3752
3753
3754
3755
3756
3757
3758
3759
3760
3761
3762
3763
3764
3765
3766
3767
3768
3769
3770
3771
3772
3773
3774
3775
3776
3777
3778
3779
3780
3781
3782
3783
3784
3785
3786
3787
3788
3789
3790
3791
3792
3793
3794
3795
3796
3797
3798
3799
3800
3801
3802
3803
3804
3805
3806
3807
3808
3809
3810
3811
3812
3813
3814
3815
3816
3817
3818
3819
3820
3821
3822
3823
3824
3825
3826
3827
3828
3829
3830
3831
3832
3833
3834
3835
3836
3837
3838
3839
3840
3841
3842
3843
3844
3845
3846
3847
3848
3849
3850
3851
3852
3853
3854
3855
3856
3857
3858
3859
3860
3861
3862
3863
3864
3865
3866
3867
3868
3869
3870
3871
3872
3873
3874
3875
3876
3877
3878
3879
3880
3881
3882
3883
3884
3885
3886
3887
3888
3889
3890
3891
3892
3893
3894
3895
3896
3897
3898
3899
3900
3901
3902
3903
3904
3905
3906
3907
3908
3909
3910
3911
3912
3913
3914
3915
3916
3917
3918
3919
3920
3921
3922
3923
3924
3925
3926
3927
3928
3929
3930
3931
3932
3933
3934
3935
3936
3937
3938
3939
3940
3941
3942
3943
3944
3945
3946
3947
3948
3949
3950
3951
3952
3953
3954
3955
3956
3957
3958
3959
3960
3961
3962
3963
3964
3965
3966
3967
3968
3969
3970
3971
3972
3973
3974
3975
3976
3977
3978
3979
3980
3981
3982
3983
3984
3985
3986
3987
3988
3989
3990
3991
3992
3993
3994
3995
3996
3997
3998
3999
4000
4001
4002
4003
4004
4005
4006
4007
4008
4009
4010
4011
4012
4013
4014
4015
4016
4017
4018
4019
4020
4021
4022
4023
4024
4025
4026
4027
4028
4029
4030
4031
4032
4033
4034
4035
4036
4037
4038
4039
4040
4041
4042
4043
4044
4045
4046
4047
4048
4049
4050
4051
4052
4053
4054
4055
4056
4057
4058
4059
4060
4061
4062
4063
4064
4065
4066
4067
4068
4069
4070
4071
4072
4073
4074
4075
4076
4077
4078
4079
4080
4081
4082
4083
4084
def
patch
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP PATCH operation.
## Example
```python
from fastapi import FastAPI
from pydantic import BaseModel
class Item(BaseModel):
name: str
description: str | None = None
app = FastAPI()
@app.patch("/items/")
def update_item(item: Item):
return {"message": "Item updated in place"}
```
"""
return
self
.
router
.
patch
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
trace
trace
(
path
,
*
,
response_model
=
Default
(
None
),
status_code
=
None
,
tags
=
None
,
dependencies
=
None
,
summary
=
None
,
description
=
None
,
response_description
=
"Successful Response"
,
responses
=
None
,
deprecated
=
None
,
operation_id
=
None
,
response_model_include
=
None
,
response_model_exclude
=
None
,
response_model_by_alias
=
True
,
response_model_exclude_unset
=
False
,
response_model_exclude_defaults
=
False
,
response_model_exclude_none
=
False
,
include_in_schema
=
True
,
response_class
=
Default
(
JSONResponse
),
name
=
None
,
callbacks
=
None
,
openapi_extra
=
None
,
generate_unique_id_function
=
Default
(
generate_unique_id
)
)
Add a
path operation
using an HTTP TRACE operation.
Example
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
trace
(
"/items/
{item_id}
"
)
def
trace_item
(
item_id
:
str
):
return
None
PARAMETER
DESCRIPTION
path
The URL path to be used for this
path operation
.
For example, in
http://example.com/items
, the path is
/items
.
TYPE:
str
response_model
The type to use for the response.
It could be any valid Pydantic
field
type. So, it doesn't have to
be a Pydantic model, it could be other things, like a
list
,
dict
,
etc.
It will be used for:
Documentation: the generated OpenAPI (and the UI at
/docs
) will
show it as the response (JSON Schema).
Serialization: you could return an arbitrary object and the
response_model
would be used to serialize that object into the
corresponding JSON.
Filtering: the JSON sent to the client will only contain the data
(fields) defined in the
response_model
. If you returned an object
that contains an attribute
password
but the
response_model
does
not include that field, the JSON sent to the client would not have
that
password
.
Validation: whatever you return will be serialized with the
response_model
, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
FastAPI docs for Response Model
.
TYPE:
Any
DEFAULT:
Default
(None)
status_code
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
FastAPI docs for Response Status Code
.
TYPE:
Optional
[
int
]
DEFAULT:
None
tags
A list of tags to be applied to the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
List
[
Union
[
str
,
Enum
]]]
DEFAULT:
None
dependencies
A list of dependencies (using
Depends()
) to be applied to the
path operation
.
Read more about it in the
FastAPI docs for Dependencies in path operation decorators
.
TYPE:
Optional
[
Sequence
[
Depends
]]
DEFAULT:
None
summary
A summary for the
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
A description for the
path operation
.
If not provided, it will be extracted automatically from the docstring
of the
path operation function
.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Path Operation Configuration
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_description
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
str
DEFAULT:
'Successful Response'
responses
Additional responses that could be returned by this
path operation
.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]]
DEFAULT:
None
deprecated
Mark this
path operation
as deprecated.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
bool
]
DEFAULT:
None
operation_id
Custom operation ID to be used by this
path operation
.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
generate_unique_id_function
in the
FastAPI
class.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Optional
[
str
]
DEFAULT:
None
response_model_include
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_exclude
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
Optional
[
IncEx
]
DEFAULT:
None
response_model_by_alias
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
True
response_model_exclude_unset
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
response_model_exclude_defaults
in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_defaults
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from
response_model_exclude_unset
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When
True
, default values are omitted from the response.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
response_model_exclude_none
Configuration passed to Pydantic to define if the response data should
exclude fields set to
None
.
This is much simpler (less smart) than
response_model_exclude_unset
and
response_model_exclude_defaults
. You probably want to use one of
those two instead of this one, as those allow returning
None
values
when it makes sense.
Read more about it in the
FastAPI docs for Response Model - Return Type
.
TYPE:
bool
DEFAULT:
False
include_in_schema
Include this
path operation
in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for Query Parameters and String Validations
.
TYPE:
bool
DEFAULT:
True
response_class
Response class to be used for this
path operation
.
This will not be used if you return a response directly.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
TYPE:
Type
[
Response
]
DEFAULT:
Default
(
JSONResponse
)
name
Name for this
path operation
. Only used internally.
TYPE:
Optional
[
str
]
DEFAULT:
None
callbacks
List of
path operations
that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Read more about it in the
FastAPI docs for OpenAPI Callbacks
.
TYPE:
Optional
[
List
[
BaseRoute
]]
DEFAULT:
None
openapi_extra
Extra metadata to be included in the OpenAPI schema for this
path
operation
.
Read more about it in the
FastAPI docs for Path Operation Advanced Configuration
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
generate_unique_id_function
Customize the function used to generate unique IDs for the
path
operations
shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
FastAPI docs about how to Generate Clients
.
TYPE:
Callable
[[
APIRoute
],
str
]
DEFAULT:
Default
(
generate_unique_id
)
Source code in
fastapi/applications.py
4086
4087
4088
4089
4090
4091
4092
4093
4094
4095
4096
4097
4098
4099
4100
4101
4102
4103
4104
4105
4106
4107
4108
4109
4110
4111
4112
4113
4114
4115
4116
4117
4118
4119
4120
4121
4122
4123
4124
4125
4126
4127
4128
4129
4130
4131
4132
4133
4134
4135
4136
4137
4138
4139
4140
4141
4142
4143
4144
4145
4146
4147
4148
4149
4150
4151
4152
4153
4154
4155
4156
4157
4158
4159
4160
4161
4162
4163
4164
4165
4166
4167
4168
4169
4170
4171
4172
4173
4174
4175
4176
4177
4178
4179
4180
4181
4182
4183
4184
4185
4186
4187
4188
4189
4190
4191
4192
4193
4194
4195
4196
4197
4198
4199
4200
4201
4202
4203
4204
4205
4206
4207
4208
4209
4210
4211
4212
4213
4214
4215
4216
4217
4218
4219
4220
4221
4222
4223
4224
4225
4226
4227
4228
4229
4230
4231
4232
4233
4234
4235
4236
4237
4238
4239
4240
4241
4242
4243
4244
4245
4246
4247
4248
4249
4250
4251
4252
4253
4254
4255
4256
4257
4258
4259
4260
4261
4262
4263
4264
4265
4266
4267
4268
4269
4270
4271
4272
4273
4274
4275
4276
4277
4278
4279
4280
4281
4282
4283
4284
4285
4286
4287
4288
4289
4290
4291
4292
4293
4294
4295
4296
4297
4298
4299
4300
4301
4302
4303
4304
4305
4306
4307
4308
4309
4310
4311
4312
4313
4314
4315
4316
4317
4318
4319
4320
4321
4322
4323
4324
4325
4326
4327
4328
4329
4330
4331
4332
4333
4334
4335
4336
4337
4338
4339
4340
4341
4342
4343
4344
4345
4346
4347
4348
4349
4350
4351
4352
4353
4354
4355
4356
4357
4358
4359
4360
4361
4362
4363
4364
4365
4366
4367
4368
4369
4370
4371
4372
4373
4374
4375
4376
4377
4378
4379
4380
4381
4382
4383
4384
4385
4386
4387
4388
4389
4390
4391
4392
4393
4394
4395
4396
4397
4398
4399
4400
4401
4402
4403
4404
4405
4406
4407
4408
4409
4410
4411
4412
4413
4414
4415
4416
4417
4418
4419
4420
4421
4422
4423
4424
4425
4426
4427
4428
4429
4430
4431
4432
4433
4434
4435
4436
4437
4438
4439
4440
4441
4442
4443
4444
4445
4446
4447
4448
4449
4450
4451
4452
4453
4454
4455
4456
4457
def
trace
(
self
,
path
:
Annotated
[
str
,
Doc
(
"""
The URL path to be used for this *path operation*.
For example, in `http://example.com/items`, the path is `/items`.
"""
),
],
*
,
response_model
:
Annotated
[
Any
,
Doc
(
"""
The type to use for the response.
It could be any valid Pydantic *field* type. So, it doesn't have to
be a Pydantic model, it could be other things, like a `list`, `dict`,
etc.
It will be used for:
* Documentation: the generated OpenAPI (and the UI at `/docs`) will
show it as the response (JSON Schema).
* Serialization: you could return an arbitrary object and the
`response_model` would be used to serialize that object into the
corresponding JSON.
* Filtering: the JSON sent to the client will only contain the data
(fields) defined in the `response_model`. If you returned an object
that contains an attribute `password` but the `response_model` does
not include that field, the JSON sent to the client would not have
that `password`.
* Validation: whatever you return will be serialized with the
`response_model`, converting any data as necessary to generate the
corresponding JSON. But if the data in the object returned is not
valid, that would mean a violation of the contract with the client,
so it's an error from the API developer. So, FastAPI will raise an
error and return a 500 error code (Internal Server Error).
Read more about it in the
[FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
"""
),
]
=
Default
(
None
),
status_code
:
Annotated
[
Optional
[
int
],
Doc
(
"""
The default status code to be used for the response.
You could override the status code by returning a response directly.
Read more about it in the
[FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
"""
),
]
=
None
,
tags
:
Annotated
[
Optional
[
List
[
Union
[
str
,
Enum
]]],
Doc
(
"""
A list of tags to be applied to the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
"""
),
]
=
None
,
dependencies
:
Annotated
[
Optional
[
Sequence
[
Depends
]],
Doc
(
"""
A list of dependencies (using `Depends()`) to be applied to the
*path operation*.
Read more about it in the
[FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
"""
),
]
=
None
,
summary
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A summary for the *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
A description for the *path operation*.
If not provided, it will be extracted automatically from the docstring
of the *path operation function*.
It can contain Markdown.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
"""
),
]
=
None
,
response_description
:
Annotated
[
str
,
Doc
(
"""
The description for the default response.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
"Successful Response"
,
responses
:
Annotated
[
Optional
[
Dict
[
Union
[
int
,
str
],
Dict
[
str
,
Any
]]],
Doc
(
"""
Additional responses that could be returned by this *path operation*.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Optional
[
bool
],
Doc
(
"""
Mark this *path operation* as deprecated.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
operation_id
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Custom operation ID to be used by this *path operation*.
By default, it is generated automatically.
If you provide a custom operation ID, you need to make sure it is
unique for the whole API.
You can customize the
operation ID generation with the parameter
`generate_unique_id_function` in the `FastAPI` class.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
None
,
response_model_include
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to include only certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_exclude
:
Annotated
[
Optional
[
IncEx
],
Doc
(
"""
Configuration passed to Pydantic to exclude certain fields in the
response data.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
None
,
response_model_by_alias
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response model
should be serialized by alias when an alias is used.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
"""
),
]
=
True
,
response_model_exclude_unset
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that were not set and
have their default values. This is different from
`response_model_exclude_defaults` in that if the fields are set,
they will be included in the response, even if the value is the same
as the default.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_defaults
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data
should have all the fields, including the ones that have the same value
as the default. This is different from `response_model_exclude_unset`
in that if the fields are set but contain the same default values,
they will be excluded from the response.
When `True`, default values are omitted from the response.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
"""
),
]
=
False
,
response_model_exclude_none
:
Annotated
[
bool
,
Doc
(
"""
Configuration passed to Pydantic to define if the response data should
exclude fields set to `None`.
This is much simpler (less smart) than `response_model_exclude_unset`
and `response_model_exclude_defaults`. You probably want to use one of
those two instead of this one, as those allow returning `None` values
when it makes sense.
Read more about it in the
[FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
"""
),
]
=
False
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
Include this *path operation* in the generated OpenAPI schema.
This affects the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).
"""
),
]
=
True
,
response_class
:
Annotated
[
Type
[
Response
],
Doc
(
"""
Response class to be used for this *path operation*.
This will not be used if you return a response directly.
Read more about it in the
[FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
"""
),
]
=
Default
(
JSONResponse
),
name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Name for this *path operation*. Only used internally.
"""
),
]
=
None
,
callbacks
:
Annotated
[
Optional
[
List
[
BaseRoute
]],
Doc
(
"""
List of *path operations* that will be used as OpenAPI callbacks.
This is only for OpenAPI documentation, the callbacks won't be used
directly.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Read more about it in the
[FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
"""
),
]
=
None
,
openapi_extra
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Extra metadata to be included in the OpenAPI schema for this *path
operation*.
Read more about it in the
[FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
"""
),
]
=
None
,
generate_unique_id_function
:
Annotated
[
Callable
[[
routing
.
APIRoute
],
str
],
Doc
(
"""
Customize the function used to generate unique IDs for the *path
operations* shown in the generated OpenAPI.
This is particularly useful when automatically generating clients or
SDKs for your API.
Read more about it in the
[FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
"""
),
]
=
Default
(
generate_unique_id
),
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a *path operation* using an HTTP TRACE operation.
## Example
```python
from fastapi import FastAPI
app = FastAPI()
@app.trace("/items/{item_id}")
def trace_item(item_id: str):
return None
```
"""
return
self
.
router
.
trace
(
path
,
response_model
=
response_model
,
status_code
=
status_code
,
tags
=
tags
,
dependencies
=
dependencies
,
summary
=
summary
,
description
=
description
,
response_description
=
response_description
,
responses
=
responses
,
deprecated
=
deprecated
,
operation_id
=
operation_id
,
response_model_include
=
response_model_include
,
response_model_exclude
=
response_model_exclude
,
response_model_by_alias
=
response_model_by_alias
,
response_model_exclude_unset
=
response_model_exclude_unset
,
response_model_exclude_defaults
=
response_model_exclude_defaults
,
response_model_exclude_none
=
response_model_exclude_none
,
include_in_schema
=
include_in_schema
,
response_class
=
response_class
,
name
=
name
,
callbacks
=
callbacks
,
openapi_extra
=
openapi_extra
,
generate_unique_id_function
=
generate_unique_id_function
,
)
on_event
on_event
(
event_type
)
Add an event handler for the application.
on_event
is deprecated, use
lifespan
event handlers instead.
Read more about it in the
FastAPI docs for Lifespan Events
.
PARAMETER
DESCRIPTION
event_type
The type of event.
startup
or
shutdown
.
TYPE:
str
Source code in
fastapi/applications.py
4468
4469
4470
4471
4472
4473
4474
4475
4476
4477
4478
4479
4480
4481
4482
4483
4484
4485
4486
4487
4488
4489
4490
4491
4492
4493
4494
4495
@deprecated
(
"""
on_event is deprecated, use lifespan event handlers instead.
Read more about it in the
[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
"""
)
def
on_event
(
self
,
event_type
:
Annotated
[
str
,
Doc
(
"""
The type of event. `startup` or `shutdown`.
"""
),
],
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add an event handler for the application.
`on_event` is deprecated, use `lifespan` event handlers instead.
Read more about it in the
[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).
"""
return
self
.
router
.
on_event
(
event_type
)
middleware
middleware
(
middleware_type
)
Add a middleware to the application.
Read more about it in the
FastAPI docs for Middleware
.
Example
import
time
from
typing
import
Awaitable
,
Callable
from
fastapi
import
FastAPI
,
Request
,
Response
app
=
FastAPI
()
@app
.
middleware
(
"http"
)
async
def
add_process_time_header
(
request
:
Request
,
call_next
:
Callable
[[
Request
],
Awaitable
[
Response
]]
)
->
Response
:
start_time
=
time
.
time
()
response
=
await
call_next
(
request
)
process_time
=
time
.
time
()
-
start_time
response
.
headers
[
"X-Process-Time"
]
=
str
(
process_time
)
return
response
PARAMETER
DESCRIPTION
middleware_type
The type of middleware. Currently only supports
http
.
TYPE:
str
Source code in
fastapi/applications.py
4497
4498
4499
4500
4501
4502
4503
4504
4505
4506
4507
4508
4509
4510
4511
4512
4513
4514
4515
4516
4517
4518
4519
4520
4521
4522
4523
4524
4525
4526
4527
4528
4529
4530
4531
4532
4533
4534
4535
4536
4537
4538
4539
4540
4541
def
middleware
(
self
,
middleware_type
:
Annotated
[
str
,
Doc
(
"""
The type of middleware. Currently only supports `http`.
"""
),
],
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add a middleware to the application.
Read more about it in the
[FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).
## Example
```python
import time
from typing import Awaitable, Callable
from fastapi import FastAPI, Request, Response
app = FastAPI()
@app.middleware("http")
async def add_process_time_header(
request: Request, call_next: Callable[[Request], Awaitable[Response]]
) -> Response:
start_time = time.time()
response = await call_next(request)
process_time = time.time() - start_time
response.headers["X-Process-Time"] = str(process_time)
return response
```
"""
def
decorator
(
func
:
DecoratedCallable
)
->
DecoratedCallable
:
self
.
add_middleware
(
BaseHTTPMiddleware
,
dispatch
=
func
)
return
func
return
decorator
exception_handler
exception_handler
(
exc_class_or_status_code
)
Add an exception handler to the app.
Read more about it in the
FastAPI docs for Handling Errors
.
Example
from
fastapi
import
FastAPI
,
Request
from
fastapi.responses
import
JSONResponse
class
UnicornException
(
Exception
):
def
__init__
(
self
,
name
:
str
):
self
.
name
=
name
app
=
FastAPI
()
@app
.
exception_handler
(
UnicornException
)
async
def
unicorn_exception_handler
(
request
:
Request
,
exc
:
UnicornException
):
return
JSONResponse
(
status_code
=
418
,
content
=
{
"message"
:
f
"Oops!
{
exc
.
name
}
did something. There goes a rainbow..."
},
)
PARAMETER
DESCRIPTION
exc_class_or_status_code
The Exception class this would handle, or a status code.
TYPE:
Union
[
int
,
Type
[
Exception
]]
Source code in
fastapi/applications.py
4543
4544
4545
4546
4547
4548
4549
4550
4551
4552
4553
4554
4555
4556
4557
4558
4559
4560
4561
4562
4563
4564
4565
4566
4567
4568
4569
4570
4571
4572
4573
4574
4575
4576
4577
4578
4579
4580
4581
4582
4583
4584
4585
4586
4587
4588
def
exception_handler
(
self
,
exc_class_or_status_code
:
Annotated
[
Union
[
int
,
Type
[
Exception
]],
Doc
(
"""
The Exception class this would handle, or a status code.
"""
),
],
)
->
Callable
[[
DecoratedCallable
],
DecoratedCallable
]:
"""
Add an exception handler to the app.
Read more about it in the
[FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).
## Example
```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
class UnicornException(Exception):
def __init__(self, name: str):
self.name = name
app = FastAPI()
@app.exception_handler(UnicornException)
async def unicorn_exception_handler(request: Request, exc: UnicornException):
return JSONResponse(
status_code=418,
content={"message": f"Oops! {exc.name} did something. There goes a rainbow..."},
)
```
"""
def
decorator
(
func
:
DecoratedCallable
)
->
DecoratedCallable
:
self
.
add_exception_handler
(
exc_class_or_status_code
,
func
)
return
func
return
decorator

## 089_REFERENCE_HTTPCONNECTION
HTTPConnectionclass¬∂
---

HTTPConnection
class
When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an
HTTPConnection
instead of a
Request
or a
WebSocket
.
You can import it from
fastapi.requests
:
from
fastapi.requests
import
HTTPConnection
fastapi.requests.HTTPConnection
HTTPConnection
(
scope
,
receive
=
None
)
Bases:
Mapping
[
str
,
Any
]
A base class for incoming HTTP connections, that is used to provide
any functionality that is common to both
Request
and
WebSocket
.
Source code in
starlette/requests.py
76
77
78
def
__init__
(
self
,
scope
:
Scope
,
receive
:
Receive
|
None
=
None
)
->
None
:
assert
scope
[
"type"
]
in
(
"http"
,
"websocket"
)
self
.
scope
=
scope
scope
instance-attribute
scope
=
scope
app
property
app
url
property
url
base_url
property
base_url
headers
property
headers
query_params
property
query_params
path_params
property
path_params
cookies
property
cookies
client
property
client
session
property
session
auth
property
auth
user
property
user
state
property
state
url_for
url_for
(
name
,
/
,
**
path_params
)
Source code in
starlette/requests.py
182
183
184
185
186
187
def
url_for
(
self
,
name
:
str
,
/
,
**
path_params
:
typing
.
Any
)
->
URL
:
url_path_provider
:
Router
|
Starlette
|
None
=
self
.
scope
.
get
(
"router"
)
or
self
.
scope
.
get
(
"app"
)
if
url_path_provider
is
None
:
raise
RuntimeError
(
"The `url_for` method can only be used inside a Starlette application or with a router."
)
url_path
=
url_path_provider
.
url_path_for
(
name
,
**
path_params
)
return
url_path
.
make_absolute_url
(
base_url
=
self
.
base_url
)

## 090_REFERENCE_MIDDLEWARE
Middleware¬∂
---

Middleware
There are several middlewares available provided by Starlette directly.
Read more about them in the
FastAPI docs for Middleware
.
fastapi.middleware.cors.CORSMiddleware
CORSMiddleware
(
app
,
allow_origins
=
(),
allow_methods
=
(
"GET"
,),
allow_headers
=
(),
allow_credentials
=
False
,
allow_origin_regex
=
None
,
expose_headers
=
(),
max_age
=
600
,
)
Source code in
starlette/middleware/cors.py
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
def
__init__
(
self
,
app
:
ASGIApp
,
allow_origins
:
typing
.
Sequence
[
str
]
=
(),
allow_methods
:
typing
.
Sequence
[
str
]
=
(
"GET"
,),
allow_headers
:
typing
.
Sequence
[
str
]
=
(),
allow_credentials
:
bool
=
False
,
allow_origin_regex
:
str
|
None
=
None
,
expose_headers
:
typing
.
Sequence
[
str
]
=
(),
max_age
:
int
=
600
,
)
->
None
:
if
"*"
in
allow_methods
:
allow_methods
=
ALL_METHODS
compiled_allow_origin_regex
=
None
if
allow_origin_regex
is
not
None
:
compiled_allow_origin_regex
=
re
.
compile
(
allow_origin_regex
)
allow_all_origins
=
"*"
in
allow_origins
allow_all_headers
=
"*"
in
allow_headers
preflight_explicit_allow_origin
=
not
allow_all_origins
or
allow_credentials
simple_headers
=
{}
if
allow_all_origins
:
simple_headers
[
"Access-Control-Allow-Origin"
]
=
"*"
if
allow_credentials
:
simple_headers
[
"Access-Control-Allow-Credentials"
]
=
"true"
if
expose_headers
:
simple_headers
[
"Access-Control-Expose-Headers"
]
=
", "
.
join
(
expose_headers
)
preflight_headers
=
{}
if
preflight_explicit_allow_origin
:
## The origin value will be set in preflight_response() if it is allowed.
preflight_headers
[
"Vary"
]
=
"Origin"
else
:
preflight_headers
[
"Access-Control-Allow-Origin"
]
=
"*"
preflight_headers
.
update
(
{
"Access-Control-Allow-Methods"
:
", "
.
join
(
allow_methods
),
"Access-Control-Max-Age"
:
str
(
max_age
),
}
)
allow_headers
=
sorted
(
SAFELISTED_HEADERS
|
set
(
allow_headers
))
if
allow_headers
and
not
allow_all_headers
:
preflight_headers
[
"Access-Control-Allow-Headers"
]
=
", "
.
join
(
allow_headers
)
if
allow_credentials
:
preflight_headers
[
"Access-Control-Allow-Credentials"
]
=
"true"
self
.
app
=
app
self
.
allow_origins
=
allow_origins
self
.
allow_methods
=
allow_methods
self
.
allow_headers
=
[
h
.
lower
()
for
h
in
allow_headers
]
self
.
allow_all_origins
=
allow_all_origins
self
.
allow_all_headers
=
allow_all_headers
self
.
preflight_explicit_allow_origin
=
preflight_explicit_allow_origin
self
.
allow_origin_regex
=
compiled_allow_origin_regex
self
.
simple_headers
=
simple_headers
self
.
preflight_headers
=
preflight_headers
app
instance-attribute
app
=
app
allow_origins
instance-attribute
allow_origins
=
allow_origins
allow_methods
instance-attribute
allow_methods
=
allow_methods
allow_headers
instance-attribute
allow_headers
=
[
lower
()
for
h
in
allow_headers
]
allow_all_origins
instance-attribute
allow_all_origins
=
allow_all_origins
allow_all_headers
instance-attribute
allow_all_headers
=
allow_all_headers
preflight_explicit_allow_origin
instance-attribute
preflight_explicit_allow_origin
=
(
preflight_explicit_allow_origin
)
allow_origin_regex
instance-attribute
allow_origin_regex
=
compiled_allow_origin_regex
simple_headers
instance-attribute
simple_headers
=
simple_headers
preflight_headers
instance-attribute
preflight_headers
=
preflight_headers
is_allowed_origin
is_allowed_origin
(
origin
)
Source code in
starlette/middleware/cors.py
95
96
97
98
99
100
101
102
def
is_allowed_origin
(
self
,
origin
:
str
)
->
bool
:
if
self
.
allow_all_origins
:
return
True
if
self
.
allow_origin_regex
is
not
None
and
self
.
allow_origin_regex
.
fullmatch
(
origin
):
return
True
return
origin
in
self
.
allow_origins
preflight_response
preflight_response
(
request_headers
)
Source code in
starlette/middleware/cors.py
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
def
preflight_response
(
self
,
request_headers
:
Headers
)
->
Response
:
requested_origin
=
request_headers
[
"origin"
]
requested_method
=
request_headers
[
"access-control-request-method"
]
requested_headers
=
request_headers
.
get
(
"access-control-request-headers"
)
headers
=
dict
(
self
.
preflight_headers
)
failures
=
[]
if
self
.
is_allowed_origin
(
origin
=
requested_origin
):
if
self
.
preflight_explicit_allow_origin
:
## The "else" case is already accounted for in self.preflight_headers
## and the value would be "*".
headers
[
"Access-Control-Allow-Origin"
]
=
requested_origin
else
:
failures
.
append
(
"origin"
)
if
requested_method
not
in
self
.
allow_methods
:
failures
.
append
(
"method"
)
## If we allow all headers, then we have to mirror back any requested
## headers in the response.
if
self
.
allow_all_headers
and
requested_headers
is
not
None
:
headers
[
"Access-Control-Allow-Headers"
]
=
requested_headers
elif
requested_headers
is
not
None
:
for
header
in
[
h
.
lower
()
for
h
in
requested_headers
.
split
(
","
)]:
if
header
.
strip
()
not
in
self
.
allow_headers
:
failures
.
append
(
"headers"
)
break
## We don't strictly need to use 400 responses here, since its up to
## the browser to enforce the CORS policy, but its more informative
## if we do.
if
failures
:
failure_text
=
"Disallowed CORS "
+
", "
.
join
(
failures
)
return
PlainTextResponse
(
failure_text
,
status_code
=
400
,
headers
=
headers
)
return
PlainTextResponse
(
"OK"
,
status_code
=
200
,
headers
=
headers
)
simple_response
async
simple_response
(
scope
,
receive
,
send
,
request_headers
)
Source code in
starlette/middleware/cors.py
142
143
144
async
def
simple_response
(
self
,
scope
:
Scope
,
receive
:
Receive
,
send
:
Send
,
request_headers
:
Headers
)
->
None
:
send
=
functools
.
partial
(
self
.
send
,
send
=
send
,
request_headers
=
request_headers
)
await
self
.
app
(
scope
,
receive
,
send
)
send
async
send
(
message
,
send
,
request_headers
)
Source code in
starlette/middleware/cors.py
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
async
def
send
(
self
,
message
:
Message
,
send
:
Send
,
request_headers
:
Headers
)
->
None
:
if
message
[
"type"
]
!=
"http.response.start"
:
await
send
(
message
)
return
message
.
setdefault
(
"headers"
,
[])
headers
=
MutableHeaders
(
scope
=
message
)
headers
.
update
(
self
.
simple_headers
)
origin
=
request_headers
[
"Origin"
]
has_cookie
=
"cookie"
in
request_headers
## If request includes any cookie headers, then we must respond
## with the specific origin instead of '*'.
if
self
.
allow_all_origins
and
has_cookie
:
self
.
allow_explicit_origin
(
headers
,
origin
)
## If we only allow specific origins, then we have to mirror back
## the Origin header in the response.
elif
not
self
.
allow_all_origins
and
self
.
is_allowed_origin
(
origin
=
origin
):
self
.
allow_explicit_origin
(
headers
,
origin
)
await
send
(
message
)
allow_explicit_origin
staticmethod
allow_explicit_origin
(
headers
,
origin
)
Source code in
starlette/middleware/cors.py
169
170
171
172
@staticmethod
def
allow_explicit_origin
(
headers
:
MutableHeaders
,
origin
:
str
)
->
None
:
headers
[
"Access-Control-Allow-Origin"
]
=
origin
headers
.
add_vary_header
(
"Origin"
)
It can be imported from
fastapi
:
from
fastapi.middleware.cors
import
CORSMiddleware
fastapi.middleware.gzip.GZipMiddleware
GZipMiddleware
(
app
,
minimum_size
=
500
,
compresslevel
=
9
)
Source code in
starlette/middleware/gzip.py
12
13
14
15
def
__init__
(
self
,
app
:
ASGIApp
,
minimum_size
:
int
=
500
,
compresslevel
:
int
=
9
)
->
None
:
self
.
app
=
app
self
.
minimum_size
=
minimum_size
self
.
compresslevel
=
compresslevel
app
instance-attribute
app
=
app
minimum_size
instance-attribute
minimum_size
=
minimum_size
compresslevel
instance-attribute
compresslevel
=
compresslevel
It can be imported from
fastapi
:
from
fastapi.middleware.gzip
import
GZipMiddleware
fastapi.middleware.httpsredirect.HTTPSRedirectMiddleware
HTTPSRedirectMiddleware
(
app
)
Source code in
starlette/middleware/httpsredirect.py
7
8
def
__init__
(
self
,
app
:
ASGIApp
)
->
None
:
self
.
app
=
app
app
instance-attribute
app
=
app
It can be imported from
fastapi
:
from
fastapi.middleware.httpsredirect
import
HTTPSRedirectMiddleware
fastapi.middleware.trustedhost.TrustedHostMiddleware
TrustedHostMiddleware
(
app
,
allowed_hosts
=
None
,
www_redirect
=
True
)
Source code in
starlette/middleware/trustedhost.py
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
def
__init__
(
self
,
app
:
ASGIApp
,
allowed_hosts
:
typing
.
Sequence
[
str
]
|
None
=
None
,
www_redirect
:
bool
=
True
,
)
->
None
:
if
allowed_hosts
is
None
:
allowed_hosts
=
[
"*"
]
for
pattern
in
allowed_hosts
:
assert
"*"
not
in
pattern
[
1
:],
ENFORCE_DOMAIN_WILDCARD
if
pattern
.
startswith
(
"*"
)
and
pattern
!=
"*"
:
assert
pattern
.
startswith
(
"*."
),
ENFORCE_DOMAIN_WILDCARD
self
.
app
=
app
self
.
allowed_hosts
=
list
(
allowed_hosts
)
self
.
allow_any
=
"*"
in
allowed_hosts
self
.
www_redirect
=
www_redirect
app
instance-attribute
app
=
app
allowed_hosts
instance-attribute
allowed_hosts
=
list
(
allowed_hosts
)
allow_any
instance-attribute
allow_any
=
'*'
in
allowed_hosts
www_redirect
instance-attribute
www_redirect
=
www_redirect
It can be imported from
fastapi
:
from
fastapi.middleware.trustedhost
import
TrustedHostMiddleware
fastapi.middleware.wsgi.WSGIMiddleware
WSGIMiddleware
(
app
)
Source code in
starlette/middleware/wsgi.py
74
75
def
__init__
(
self
,
app
:
typing
.
Callable
[
...
,
typing
.
Any
])
->
None
:
self
.
app
=
app
app
instance-attribute
app
=
app
It can be imported from
fastapi
:
from
fastapi.middleware.wsgi
import
WSGIMiddleware

## 091_REFERENCE_OPENAPI
OpenAPI¬∂
---

OpenAPI
There are several utilities to handle OpenAPI.
You normally don't need to use them unless you have a specific advanced use case that requires it.

## 092_REFERENCE_OPENAPI_DOCS
OpenAPIdocs¬∂
---

OpenAPI
docs
Utilities to handle OpenAPI automatic UI documentation, including Swagger UI (by default at
/docs
) and ReDoc (by default at
/redoc
).
fastapi.openapi.docs.get_swagger_ui_html
get_swagger_ui_html
(
*
,
openapi_url
,
title
,
swagger_js_url
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css"
,
swagger_favicon_url
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
oauth2_redirect_url
=
None
,
init_oauth
=
None
,
swagger_ui_parameters
=
None
)
Generate and return the HTML that loads Swagger UI for the interactive
API docs (normally served at
/docs
).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load Swagger UI's JavaScript and CSS.
Read more about it in the
FastAPI docs for Configure Swagger UI
and the
FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)
.
PARAMETER
DESCRIPTION
openapi_url
The OpenAPI URL that Swagger UI should load and use.
This is normally done automatically by FastAPI using the default URL
/openapi.json
.
TYPE:
str
title
The HTML
<title>
content, normally shown in the browser tab.
TYPE:
str
swagger_js_url
The URL to use to load the Swagger UI JavaScript.
It is normally set to a CDN URL.
TYPE:
str
DEFAULT:
'https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js'
swagger_css_url
The URL to use to load the Swagger UI CSS.
It is normally set to a CDN URL.
TYPE:
str
DEFAULT:
'https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css'
swagger_favicon_url
The URL of the favicon to use. It is normally shown in the browser tab.
TYPE:
str
DEFAULT:
'https://fastapi.tiangolo.com/img/favicon.png'
oauth2_redirect_url
The OAuth2 redirect URL, it is normally automatically handled by FastAPI.
TYPE:
Optional
[
str
]
DEFAULT:
None
init_oauth
A dictionary with Swagger UI OAuth2 initialization configurations.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
swagger_ui_parameters
Configuration parameters for Swagger UI.
It defaults to
swagger_ui_default_parameters
.
TYPE:
Optional
[
Dict
[
str
,
Any
]]
DEFAULT:
None
Source code in
fastapi/openapi/docs.py
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
def
get_swagger_ui_html
(
*
,
openapi_url
:
Annotated
[
str
,
Doc
(
"""
The OpenAPI URL that Swagger UI should load and use.
This is normally done automatically by FastAPI using the default URL
`/openapi.json`.
"""
),
],
title
:
Annotated
[
str
,
Doc
(
"""
The HTML `<title>` content, normally shown in the browser tab.
"""
),
],
swagger_js_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the Swagger UI JavaScript.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"
,
swagger_css_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the Swagger UI CSS.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css"
,
swagger_favicon_url
:
Annotated
[
str
,
Doc
(
"""
The URL of the favicon to use. It is normally shown in the browser tab.
"""
),
]
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
oauth2_redirect_url
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The OAuth2 redirect URL, it is normally automatically handled by FastAPI.
"""
),
]
=
None
,
init_oauth
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
A dictionary with Swagger UI OAuth2 initialization configurations.
"""
),
]
=
None
,
swagger_ui_parameters
:
Annotated
[
Optional
[
Dict
[
str
,
Any
]],
Doc
(
"""
Configuration parameters for Swagger UI.
It defaults to [swagger_ui_default_parameters][fastapi.openapi.docs.swagger_ui_default_parameters].
"""
),
]
=
None
,
)
->
HTMLResponse
:
"""
Generate and return the HTML that loads Swagger UI for the interactive
API docs (normally served at `/docs`).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load Swagger UI's JavaScript and CSS.
Read more about it in the
[FastAPI docs for Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/)
and the [FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
"""
current_swagger_ui_parameters
=
swagger_ui_default_parameters
.
copy
()
if
swagger_ui_parameters
:
current_swagger_ui_parameters
.
update
(
swagger_ui_parameters
)
html
=
f
"""
<!DOCTYPE html>
<html>
<head>
<link type="text/css" rel="stylesheet" href="
{
swagger_css_url
}
">
<link rel="shortcut icon" href="
{
swagger_favicon_url
}
">
<title>
{
title
}
</title>
</head>
<body>
<div id="swagger-ui">
</div>
<script src="
{
swagger_js_url
}
"></script>
<!-- `SwaggerUIBundle` is now available on the page -->
<script>
const ui = SwaggerUIBundle(
{{
url: '
{
openapi_url
}
',
"""
for
key
,
value
in
current_swagger_ui_parameters
.
items
():
html
+=
f
"
{
json
.
dumps
(
key
)
}
:
{
json
.
dumps
(
jsonable_encoder
(
value
))
}
,
\n
"
if
oauth2_redirect_url
:
html
+=
f
"oauth2RedirectUrl: window.location.origin + '
{
oauth2_redirect_url
}
',"
html
+=
"""
presets: [
SwaggerUIBundle.presets.apis,
SwaggerUIBundle.SwaggerUIStandalonePreset
],
})"""
if
init_oauth
:
html
+=
f
"""
ui.initOAuth(
{
json
.
dumps
(
jsonable_encoder
(
init_oauth
))
}
)
"""
html
+=
"""
</script>
</body>
</html>
"""
return
HTMLResponse
(
html
)
fastapi.openapi.docs.get_redoc_html
get_redoc_html
(
*
,
openapi_url
,
title
,
redoc_js_url
=
"https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js"
,
redoc_favicon_url
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
with_google_fonts
=
True
)
Generate and return the HTML response that loads ReDoc for the alternative
API docs (normally served at
/redoc
).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load ReDoc's JavaScript and CSS.
Read more about it in the
FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)
.
PARAMETER
DESCRIPTION
openapi_url
The OpenAPI URL that ReDoc should load and use.
This is normally done automatically by FastAPI using the default URL
/openapi.json
.
TYPE:
str
title
The HTML
<title>
content, normally shown in the browser tab.
TYPE:
str
redoc_js_url
The URL to use to load the ReDoc JavaScript.
It is normally set to a CDN URL.
TYPE:
str
DEFAULT:
'https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js'
redoc_favicon_url
The URL of the favicon to use. It is normally shown in the browser tab.
TYPE:
str
DEFAULT:
'https://fastapi.tiangolo.com/img/favicon.png'
with_google_fonts
Load and use Google Fonts.
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/openapi/docs.py
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
def
get_redoc_html
(
*
,
openapi_url
:
Annotated
[
str
,
Doc
(
"""
The OpenAPI URL that ReDoc should load and use.
This is normally done automatically by FastAPI using the default URL
`/openapi.json`.
"""
),
],
title
:
Annotated
[
str
,
Doc
(
"""
The HTML `<title>` content, normally shown in the browser tab.
"""
),
],
redoc_js_url
:
Annotated
[
str
,
Doc
(
"""
The URL to use to load the ReDoc JavaScript.
It is normally set to a CDN URL.
"""
),
]
=
"https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js"
,
redoc_favicon_url
:
Annotated
[
str
,
Doc
(
"""
The URL of the favicon to use. It is normally shown in the browser tab.
"""
),
]
=
"https://fastapi.tiangolo.com/img/favicon.png"
,
with_google_fonts
:
Annotated
[
bool
,
Doc
(
"""
Load and use Google Fonts.
"""
),
]
=
True
,
)
->
HTMLResponse
:
"""
Generate and return the HTML response that loads ReDoc for the alternative
API docs (normally served at `/redoc`).
You would only call this function yourself if you needed to override some parts,
for example the URLs to use to load ReDoc's JavaScript and CSS.
Read more about it in the
[FastAPI docs for Custom Docs UI Static Assets (Self-Hosting)](https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/).
"""
html
=
f
"""
<!DOCTYPE html>
<html>
<head>
<title>
{
title
}
</title>
<!-- needed for adaptive design -->
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
"""
if
with_google_fonts
:
html
+=
"""
<link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
"""
html
+=
f
"""
<link rel="shortcut icon" href="
{
redoc_favicon_url
}
">
<!--
ReDoc doesn't change outer page styles
-->
<style>
body
{{
margin: 0;
padding: 0;
}}
</style>
</head>
<body>
<noscript>
ReDoc requires Javascript to function. Please enable it to browse the documentation.
</noscript>
<redoc spec-url="
{
openapi_url
}
"></redoc>
<script src="
{
redoc_js_url
}
"> </script>
</body>
</html>
"""
return
HTMLResponse
(
html
)
fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html
get_swagger_ui_oauth2_redirect_html
()
Generate the HTML response with the OAuth2 redirection for Swagger UI.
You normally don't need to use or change this.
Source code in
fastapi/openapi/docs.py
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
def
get_swagger_ui_oauth2_redirect_html
()
->
HTMLResponse
:
"""
Generate the HTML response with the OAuth2 redirection for Swagger UI.
You normally don't need to use or change this.
"""
## copied from https://github.com/swagger-api/swagger-ui/blob/v4.14.0/dist/oauth2-redirect.html
html
=
"""
<!doctype html>
<html lang="en-US">
<head>
<title>Swagger UI: OAuth2 Redirect</title>
</head>
<body>
<script>
'use strict';
function run () {
var oauth2 = window.opener.swaggerUIRedirectOauth2;
var sentState = oauth2.state;
var redirectUrl = oauth2.redirectUrl;
var isValid, qp, arr;
if (/code|token|error/.test(window.location.hash)) {
qp = window.location.hash.substring(1).replace('?', '&');
} else {
qp = location.search.substring(1);
}
arr = qp.split("&");
arr.forEach(function (v,i,_arr) { _arr[i] = '"' + v.replace('=', '":"') + '"';});
qp = qp ? JSON.parse('{' + arr.join() + '}',
function (key, value) {
return key === "" ? value : decodeURIComponent(value);
}
) :
{}
;
isValid = qp.state === sentState;
if ((
oauth2.auth.schema.get("flow") === "accessCode" ||
oauth2.auth.schema.get("flow") === "authorizationCode" ||
oauth2.auth.schema.get("flow") === "authorization_code"
) && !oauth2.auth.code) {
if (!isValid) {
oauth2.errCb({
authId: oauth2.auth.name,
source: "auth",
level: "warning",
message: "Authorization may be unsafe, passed state was changed in server. The passed state wasn't returned from auth server."
});
}
if (qp.code) {
delete oauth2.state;
oauth2.auth.code = qp.code;
oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});
} else {
let oauthErrorMsg;
if (qp.error) {
oauthErrorMsg = "["+qp.error+"]: " +
(qp.error_description ? qp.error_description+ ". " : "no accessCode received from the server. ") +
(qp.error_uri ? "More info: "+qp.error_uri : "");
}
oauth2.errCb({
authId: oauth2.auth.name,
source: "auth",
level: "error",
message: oauthErrorMsg || "[Authorization failed]: no accessCode received from the server."
});
}
} else {
oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});
}
window.close();
}
if (document.readyState !== 'loading') {
run();
} else {
document.addEventListener('DOMContentLoaded', function () {
run();
});
}
</script>
</body>
</html>
"""
return
HTMLResponse
(
content
=
html
)
fastapi.openapi.docs.swagger_ui_default_parameters
module-attribute
swagger_ui_default_parameters
=
{
"dom_id"
:
"#swagger-ui"
,
"layout"
:
"BaseLayout"
,
"deepLinking"
:
True
,
"showExtensions"
:
True
,
"showCommonExtensions"
:
True
,
}
Default configurations for Swagger UI.
You can use it as a template to add any other configurations needed.

## 093_REFERENCE_OPENAPI_MODELS
OpenAPImodels¬∂
---

OpenAPI
models
OpenAPI Pydantic models used to generate and validate the generated OpenAPI.
fastapi.openapi.models
SchemaOrBool
module-attribute
SchemaOrBool
=
Union
[
Schema
,
bool
]
SecurityScheme
module-attribute
SecurityScheme
=
Union
[
APIKey
,
HTTPBase
,
OAuth2
,
OpenIdConnect
,
HTTPBearer
]
BaseModelWithConfig
Bases:
BaseModel
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Contact
Bases:
BaseModelWithConfig
name
class-attribute
instance-attribute
name
=
None
url
class-attribute
instance-attribute
url
=
None
email
class-attribute
instance-attribute
email
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
License
Bases:
BaseModelWithConfig
name
instance-attribute
name
identifier
class-attribute
instance-attribute
identifier
=
None
url
class-attribute
instance-attribute
url
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Info
Bases:
BaseModelWithConfig
title
instance-attribute
title
summary
class-attribute
instance-attribute
summary
=
None
description
class-attribute
instance-attribute
description
=
None
termsOfService
class-attribute
instance-attribute
termsOfService
=
None
contact
class-attribute
instance-attribute
contact
=
None
license
class-attribute
instance-attribute
license
=
None
version
instance-attribute
version
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
ServerVariable
Bases:
BaseModelWithConfig
enum
class-attribute
instance-attribute
enum
=
None
default
instance-attribute
default
description
class-attribute
instance-attribute
description
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Server
Bases:
BaseModelWithConfig
url
instance-attribute
url
description
class-attribute
instance-attribute
description
=
None
variables
class-attribute
instance-attribute
variables
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Reference
Bases:
BaseModel
ref
class-attribute
instance-attribute
ref
=
Field
(
alias
=
'$ref'
)
Discriminator
Bases:
BaseModel
propertyName
instance-attribute
propertyName
mapping
class-attribute
instance-attribute
mapping
=
None
XML
Bases:
BaseModelWithConfig
name
class-attribute
instance-attribute
name
=
None
namespace
class-attribute
instance-attribute
namespace
=
None
prefix
class-attribute
instance-attribute
prefix
=
None
attribute
class-attribute
instance-attribute
attribute
=
None
wrapped
class-attribute
instance-attribute
wrapped
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
ExternalDocumentation
Bases:
BaseModelWithConfig
description
class-attribute
instance-attribute
description
=
None
url
instance-attribute
url
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Schema
Bases:
BaseModelWithConfig
schema_
class-attribute
instance-attribute
schema_
=
Field
(
default
=
None
,
alias
=
'$schema'
)
vocabulary
class-attribute
instance-attribute
vocabulary
=
Field
(
default
=
None
,
alias
=
'$vocabulary'
)
id
class-attribute
instance-attribute
id
=
Field
(
default
=
None
,
alias
=
'$id'
)
anchor
class-attribute
instance-attribute
anchor
=
Field
(
default
=
None
,
alias
=
'$anchor'
)
dynamicAnchor
class-attribute
instance-attribute
dynamicAnchor
=
Field
(
default
=
None
,
alias
=
'$dynamicAnchor'
)
ref
class-attribute
instance-attribute
ref
=
Field
(
default
=
None
,
alias
=
'$ref'
)
dynamicRef
class-attribute
instance-attribute
dynamicRef
=
Field
(
default
=
None
,
alias
=
'$dynamicRef'
)
defs
class-attribute
instance-attribute
defs
=
Field
(
default
=
None
,
alias
=
'$defs'
)
comment
class-attribute
instance-attribute
comment
=
Field
(
default
=
None
,
alias
=
'$comment'
)
allOf
class-attribute
instance-attribute
allOf
=
None
anyOf
class-attribute
instance-attribute
anyOf
=
None
oneOf
class-attribute
instance-attribute
oneOf
=
None
not_
class-attribute
instance-attribute
not_
=
Field
(
default
=
None
,
alias
=
'not'
)
if_
class-attribute
instance-attribute
if_
=
Field
(
default
=
None
,
alias
=
'if'
)
then
class-attribute
instance-attribute
then
=
None
else_
class-attribute
instance-attribute
else_
=
Field
(
default
=
None
,
alias
=
'else'
)
dependentSchemas
class-attribute
instance-attribute
dependentSchemas
=
None
prefixItems
class-attribute
instance-attribute
prefixItems
=
None
items
class-attribute
instance-attribute
items
=
None
contains
class-attribute
instance-attribute
contains
=
None
properties
class-attribute
instance-attribute
properties
=
None
patternProperties
class-attribute
instance-attribute
patternProperties
=
None
additionalProperties
class-attribute
instance-attribute
additionalProperties
=
None
propertyNames
class-attribute
instance-attribute
propertyNames
=
None
unevaluatedItems
class-attribute
instance-attribute
unevaluatedItems
=
None
unevaluatedProperties
class-attribute
instance-attribute
unevaluatedProperties
=
None
type
class-attribute
instance-attribute
type
=
None
enum
class-attribute
instance-attribute
enum
=
None
const
class-attribute
instance-attribute
const
=
None
multipleOf
class-attribute
instance-attribute
multipleOf
=
Field
(
default
=
None
,
gt
=
0
)
maximum
class-attribute
instance-attribute
maximum
=
None
exclusiveMaximum
class-attribute
instance-attribute
exclusiveMaximum
=
None
minimum
class-attribute
instance-attribute
minimum
=
None
exclusiveMinimum
class-attribute
instance-attribute
exclusiveMinimum
=
None
maxLength
class-attribute
instance-attribute
maxLength
=
Field
(
default
=
None
,
ge
=
0
)
minLength
class-attribute
instance-attribute
minLength
=
Field
(
default
=
None
,
ge
=
0
)
pattern
class-attribute
instance-attribute
pattern
=
None
maxItems
class-attribute
instance-attribute
maxItems
=
Field
(
default
=
None
,
ge
=
0
)
minItems
class-attribute
instance-attribute
minItems
=
Field
(
default
=
None
,
ge
=
0
)
uniqueItems
class-attribute
instance-attribute
uniqueItems
=
None
maxContains
class-attribute
instance-attribute
maxContains
=
Field
(
default
=
None
,
ge
=
0
)
minContains
class-attribute
instance-attribute
minContains
=
Field
(
default
=
None
,
ge
=
0
)
maxProperties
class-attribute
instance-attribute
maxProperties
=
Field
(
default
=
None
,
ge
=
0
)
minProperties
class-attribute
instance-attribute
minProperties
=
Field
(
default
=
None
,
ge
=
0
)
required
class-attribute
instance-attribute
required
=
None
dependentRequired
class-attribute
instance-attribute
dependentRequired
=
None
format
class-attribute
instance-attribute
format
=
None
contentEncoding
class-attribute
instance-attribute
contentEncoding
=
None
contentMediaType
class-attribute
instance-attribute
contentMediaType
=
None
contentSchema
class-attribute
instance-attribute
contentSchema
=
None
title
class-attribute
instance-attribute
title
=
None
description
class-attribute
instance-attribute
description
=
None
default
class-attribute
instance-attribute
default
=
None
deprecated
class-attribute
instance-attribute
deprecated
=
None
readOnly
class-attribute
instance-attribute
readOnly
=
None
writeOnly
class-attribute
instance-attribute
writeOnly
=
None
examples
class-attribute
instance-attribute
examples
=
None
discriminator
class-attribute
instance-attribute
discriminator
=
None
xml
class-attribute
instance-attribute
xml
=
None
externalDocs
class-attribute
instance-attribute
externalDocs
=
None
example
class-attribute
instance-attribute
example
=
None
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Example
Bases:
TypedDict
summary
instance-attribute
summary
description
instance-attribute
description
value
instance-attribute
value
externalValue
instance-attribute
externalValue
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
ParameterInType
Bases:
Enum
query
class-attribute
instance-attribute
query
=
'query'
header
class-attribute
instance-attribute
header
=
'header'
path
class-attribute
instance-attribute
path
=
'path'
cookie
class-attribute
instance-attribute
cookie
=
'cookie'
Encoding
Bases:
BaseModelWithConfig
contentType
class-attribute
instance-attribute
contentType
=
None
headers
class-attribute
instance-attribute
headers
=
None
style
class-attribute
instance-attribute
style
=
None
explode
class-attribute
instance-attribute
explode
=
None
allowReserved
class-attribute
instance-attribute
allowReserved
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
MediaType
Bases:
BaseModelWithConfig
schema_
class-attribute
instance-attribute
schema_
=
Field
(
default
=
None
,
alias
=
'schema'
)
example
class-attribute
instance-attribute
example
=
None
examples
class-attribute
instance-attribute
examples
=
None
encoding
class-attribute
instance-attribute
encoding
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
ParameterBase
Bases:
BaseModelWithConfig
description
class-attribute
instance-attribute
description
=
None
required
class-attribute
instance-attribute
required
=
None
deprecated
class-attribute
instance-attribute
deprecated
=
None
style
class-attribute
instance-attribute
style
=
None
explode
class-attribute
instance-attribute
explode
=
None
allowReserved
class-attribute
instance-attribute
allowReserved
=
None
schema_
class-attribute
instance-attribute
schema_
=
Field
(
default
=
None
,
alias
=
'schema'
)
example
class-attribute
instance-attribute
example
=
None
examples
class-attribute
instance-attribute
examples
=
None
content
class-attribute
instance-attribute
content
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Parameter
Bases:
ParameterBase
name
instance-attribute
name
in_
class-attribute
instance-attribute
in_
=
Field
(
alias
=
'in'
)
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
required
class-attribute
instance-attribute
required
=
None
deprecated
class-attribute
instance-attribute
deprecated
=
None
style
class-attribute
instance-attribute
style
=
None
explode
class-attribute
instance-attribute
explode
=
None
allowReserved
class-attribute
instance-attribute
allowReserved
=
None
schema_
class-attribute
instance-attribute
schema_
=
Field
(
default
=
None
,
alias
=
'schema'
)
example
class-attribute
instance-attribute
example
=
None
examples
class-attribute
instance-attribute
examples
=
None
content
class-attribute
instance-attribute
content
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Header
Bases:
ParameterBase
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
required
class-attribute
instance-attribute
required
=
None
deprecated
class-attribute
instance-attribute
deprecated
=
None
style
class-attribute
instance-attribute
style
=
None
explode
class-attribute
instance-attribute
explode
=
None
allowReserved
class-attribute
instance-attribute
allowReserved
=
None
schema_
class-attribute
instance-attribute
schema_
=
Field
(
default
=
None
,
alias
=
'schema'
)
example
class-attribute
instance-attribute
example
=
None
examples
class-attribute
instance-attribute
examples
=
None
content
class-attribute
instance-attribute
content
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
RequestBody
Bases:
BaseModelWithConfig
description
class-attribute
instance-attribute
description
=
None
content
instance-attribute
content
required
class-attribute
instance-attribute
required
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Link
Bases:
BaseModelWithConfig
operationRef
class-attribute
instance-attribute
operationRef
=
None
operationId
class-attribute
instance-attribute
operationId
=
None
parameters
class-attribute
instance-attribute
parameters
=
None
requestBody
class-attribute
instance-attribute
requestBody
=
None
description
class-attribute
instance-attribute
description
=
None
server
class-attribute
instance-attribute
server
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Response
Bases:
BaseModelWithConfig
description
instance-attribute
description
headers
class-attribute
instance-attribute
headers
=
None
content
class-attribute
instance-attribute
content
=
None
links
class-attribute
instance-attribute
links
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Operation
Bases:
BaseModelWithConfig
tags
class-attribute
instance-attribute
tags
=
None
summary
class-attribute
instance-attribute
summary
=
None
description
class-attribute
instance-attribute
description
=
None
externalDocs
class-attribute
instance-attribute
externalDocs
=
None
operationId
class-attribute
instance-attribute
operationId
=
None
parameters
class-attribute
instance-attribute
parameters
=
None
requestBody
class-attribute
instance-attribute
requestBody
=
None
responses
class-attribute
instance-attribute
responses
=
None
callbacks
class-attribute
instance-attribute
callbacks
=
None
deprecated
class-attribute
instance-attribute
deprecated
=
None
security
class-attribute
instance-attribute
security
=
None
servers
class-attribute
instance-attribute
servers
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
PathItem
Bases:
BaseModelWithConfig
ref
class-attribute
instance-attribute
ref
=
Field
(
default
=
None
,
alias
=
'$ref'
)
summary
class-attribute
instance-attribute
summary
=
None
description
class-attribute
instance-attribute
description
=
None
get
class-attribute
instance-attribute
get
=
None
put
class-attribute
instance-attribute
put
=
None
post
class-attribute
instance-attribute
post
=
None
delete
class-attribute
instance-attribute
delete
=
None
options
class-attribute
instance-attribute
options
=
None
head
class-attribute
instance-attribute
head
=
None
patch
class-attribute
instance-attribute
patch
=
None
trace
class-attribute
instance-attribute
trace
=
None
servers
class-attribute
instance-attribute
servers
=
None
parameters
class-attribute
instance-attribute
parameters
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
SecuritySchemeType
Bases:
Enum
apiKey
class-attribute
instance-attribute
apiKey
=
'apiKey'
http
class-attribute
instance-attribute
http
=
'http'
oauth2
class-attribute
instance-attribute
oauth2
=
'oauth2'
openIdConnect
class-attribute
instance-attribute
openIdConnect
=
'openIdConnect'
SecurityBase
Bases:
BaseModelWithConfig
type_
class-attribute
instance-attribute
type_
=
Field
(
alias
=
'type'
)
description
class-attribute
instance-attribute
description
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
APIKeyIn
Bases:
Enum
query
class-attribute
instance-attribute
query
=
'query'
header
class-attribute
instance-attribute
header
=
'header'
cookie
class-attribute
instance-attribute
cookie
=
'cookie'
APIKey
Bases:
SecurityBase
type_
class-attribute
instance-attribute
type_
=
Field
(
default
=
apiKey
,
alias
=
'type'
)
in_
class-attribute
instance-attribute
in_
=
Field
(
alias
=
'in'
)
name
instance-attribute
name
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
HTTPBase
Bases:
SecurityBase
type_
class-attribute
instance-attribute
type_
=
Field
(
default
=
http
,
alias
=
'type'
)
scheme
instance-attribute
scheme
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
HTTPBearer
Bases:
HTTPBase
scheme
class-attribute
instance-attribute
scheme
=
'bearer'
bearerFormat
class-attribute
instance-attribute
bearerFormat
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
type_
class-attribute
instance-attribute
type_
=
Field
(
default
=
http
,
alias
=
'type'
)
description
class-attribute
instance-attribute
description
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlow
Bases:
BaseModelWithConfig
refreshUrl
class-attribute
instance-attribute
refreshUrl
=
None
scopes
class-attribute
instance-attribute
scopes
=
{}
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlowImplicit
Bases:
OAuthFlow
authorizationUrl
instance-attribute
authorizationUrl
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
refreshUrl
class-attribute
instance-attribute
refreshUrl
=
None
scopes
class-attribute
instance-attribute
scopes
=
{}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlowPassword
Bases:
OAuthFlow
tokenUrl
instance-attribute
tokenUrl
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
refreshUrl
class-attribute
instance-attribute
refreshUrl
=
None
scopes
class-attribute
instance-attribute
scopes
=
{}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlowClientCredentials
Bases:
OAuthFlow
tokenUrl
instance-attribute
tokenUrl
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
refreshUrl
class-attribute
instance-attribute
refreshUrl
=
None
scopes
class-attribute
instance-attribute
scopes
=
{}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlowAuthorizationCode
Bases:
OAuthFlow
authorizationUrl
instance-attribute
authorizationUrl
tokenUrl
instance-attribute
tokenUrl
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
refreshUrl
class-attribute
instance-attribute
refreshUrl
=
None
scopes
class-attribute
instance-attribute
scopes
=
{}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuthFlows
Bases:
BaseModelWithConfig
implicit
class-attribute
instance-attribute
implicit
=
None
password
class-attribute
instance-attribute
password
=
None
clientCredentials
class-attribute
instance-attribute
clientCredentials
=
None
authorizationCode
class-attribute
instance-attribute
authorizationCode
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OAuth2
Bases:
SecurityBase
type_
class-attribute
instance-attribute
type_
=
Field
(
default
=
oauth2
,
alias
=
'type'
)
flows
instance-attribute
flows
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OpenIdConnect
Bases:
SecurityBase
type_
class-attribute
instance-attribute
type_
=
Field
(
default
=
openIdConnect
,
alias
=
'type'
)
openIdConnectUrl
instance-attribute
openIdConnectUrl
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
description
class-attribute
instance-attribute
description
=
None
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Components
Bases:
BaseModelWithConfig
schemas
class-attribute
instance-attribute
schemas
=
None
responses
class-attribute
instance-attribute
responses
=
None
parameters
class-attribute
instance-attribute
parameters
=
None
examples
class-attribute
instance-attribute
examples
=
None
requestBodies
class-attribute
instance-attribute
requestBodies
=
None
headers
class-attribute
instance-attribute
headers
=
None
securitySchemes
class-attribute
instance-attribute
securitySchemes
=
None
links
class-attribute
instance-attribute
links
=
None
callbacks
class-attribute
instance-attribute
callbacks
=
None
pathItems
class-attribute
instance-attribute
pathItems
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
Tag
Bases:
BaseModelWithConfig
name
instance-attribute
name
description
class-attribute
instance-attribute
description
=
None
externalDocs
class-attribute
instance-attribute
externalDocs
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'
OpenAPI
Bases:
BaseModelWithConfig
openapi
instance-attribute
openapi
info
instance-attribute
info
jsonSchemaDialect
class-attribute
instance-attribute
jsonSchemaDialect
=
None
servers
class-attribute
instance-attribute
servers
=
None
paths
class-attribute
instance-attribute
paths
=
None
webhooks
class-attribute
instance-attribute
webhooks
=
None
components
class-attribute
instance-attribute
components
=
None
security
class-attribute
instance-attribute
security
=
None
tags
class-attribute
instance-attribute
tags
=
None
externalDocs
class-attribute
instance-attribute
externalDocs
=
None
model_config
class-attribute
instance-attribute
model_config
=
{
'extra'
:
'allow'
}
Config
extra
class-attribute
instance-attribute
extra
=
'allow'

## 094_REFERENCE_PARAMETERS
Request Parameters¬∂
---

Request Parameters
Here's the reference information for the request parameters.
These are the special functions that you can put in
path operation function
parameters or dependency functions with
Annotated
to get data from the request.
It includes:
Query()
Path()
Body()
Cookie()
Header()
Form()
File()
You can import them all directly from
fastapi
:
from
fastapi
import
Body
,
Cookie
,
File
,
Form
,
Header
,
Path
,
Query
fastapi.Query
Query
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
def
Query
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
Query
(
default
=
default
,
default_factory
=
default_factory
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.Path
Path
(
default
=...
,
*
,
default_factory
=
_Unset
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
Declare a path parameter for a
path operation
.
Read more about it in the
FastAPI docs for Path Parameters and Numeric Validations
.
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
):
return
{
"item_id"
:
item_id
}
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Any
DEFAULT:
...
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
def
Path
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
...
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
"""
Declare a path parameter for a *path operation*.
Read more about it in the
[FastAPI docs for Path Parameters and Numeric Validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/).
```python
from typing import Annotated
from fastapi import FastAPI, Path
app = FastAPI()
@app.get("/items/{item_id}")
async def read_items(
item_id: Annotated[int, Path(title="The ID of the item to get")],
):
return {"item_id": item_id}
```
"""
return
params
.
Path
(
default
=
default
,
default_factory
=
default_factory
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.Body
Body
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
embed
=
None
,
media_type
=
"application/json"
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
embed
When
embed
is
True
, the parameter will be expected in a JSON body as a
key instead of being the JSON body itself.
This happens automatically when more than one
Body
parameter is declared.
Read more about it in the
FastAPI docs for Body - Multiple Parameters
.
TYPE:
Union
[
bool
, None]
DEFAULT:
None
media_type
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
TYPE:
str
DEFAULT:
'application/json'
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
1263
1264
1265
1266
1267
1268
1269
1270
1271
1272
1273
1274
1275
1276
1277
1278
1279
1280
1281
1282
1283
1284
1285
1286
1287
1288
1289
1290
1291
1292
1293
1294
1295
1296
1297
1298
1299
1300
1301
1302
1303
1304
1305
1306
1307
1308
1309
1310
1311
1312
1313
1314
1315
1316
1317
1318
1319
1320
1321
1322
1323
1324
1325
1326
1327
1328
1329
1330
1331
1332
1333
1334
1335
1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352
1353
1354
1355
1356
1357
1358
1359
1360
1361
1362
1363
1364
1365
1366
1367
1368
1369
1370
1371
1372
1373
1374
1375
1376
1377
1378
1379
1380
1381
1382
1383
1384
1385
1386
1387
1388
1389
1390
1391
1392
1393
1394
1395
1396
1397
1398
1399
1400
1401
1402
1403
1404
1405
1406
1407
1408
1409
1410
1411
1412
1413
1414
1415
1416
1417
1418
1419
1420
1421
1422
1423
1424
1425
1426
1427
1428
1429
1430
1431
1432
1433
1434
1435
1436
1437
1438
1439
1440
1441
1442
1443
1444
1445
1446
1447
1448
1449
1450
1451
1452
1453
1454
1455
1456
1457
1458
1459
1460
1461
1462
1463
1464
1465
1466
1467
1468
1469
1470
1471
1472
1473
1474
1475
1476
1477
1478
1479
1480
1481
1482
1483
1484
1485
1486
1487
1488
1489
1490
1491
1492
1493
1494
1495
1496
1497
1498
1499
1500
1501
1502
1503
1504
1505
1506
1507
1508
1509
1510
1511
1512
1513
1514
1515
1516
1517
1518
1519
1520
1521
1522
1523
1524
1525
1526
1527
1528
1529
1530
1531
1532
1533
1534
1535
1536
1537
1538
1539
1540
1541
1542
1543
1544
1545
1546
1547
1548
1549
1550
1551
1552
1553
1554
1555
1556
1557
1558
1559
1560
1561
1562
1563
1564
1565
1566
1567
1568
1569
1570
1571
1572
1573
1574
1575
1576
1577
1578
1579
1580
1581
1582
1583
1584
1585
1586
1587
1588
1589
def
Body
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
embed
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
When `embed` is `True`, the parameter will be expected in a JSON body as a
key instead of being the JSON body itself.
This happens automatically when more than one `Body` parameter is declared.
Read more about it in the
[FastAPI docs for Body - Multiple Parameters](https://fastapi.tiangolo.com/tutorial/body-multiple-params/#embed-a-single-body-parameter).
"""
),
]
=
None
,
media_type
:
Annotated
[
str
,
Doc
(
"""
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
"""
),
]
=
"application/json"
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
Body
(
default
=
default
,
default_factory
=
default_factory
,
embed
=
embed
,
media_type
=
media_type
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.Cookie
Cookie
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
959
960
961
962
963
964
965
966
967
968
969
970
971
972
973
974
975
976
977
978
979
980
981
982
983
984
985
986
987
988
989
990
991
992
993
994
995
996
997
998
999
1000
1001
1002
1003
1004
1005
1006
1007
1008
1009
1010
1011
1012
1013
1014
1015
1016
1017
1018
1019
1020
1021
1022
1023
1024
1025
1026
1027
1028
1029
1030
1031
1032
1033
1034
1035
1036
1037
1038
1039
1040
1041
1042
1043
1044
1045
1046
1047
1048
1049
1050
1051
1052
1053
1054
1055
1056
1057
1058
1059
1060
1061
1062
1063
1064
1065
1066
1067
1068
1069
1070
1071
1072
1073
1074
1075
1076
1077
1078
1079
1080
1081
1082
1083
1084
1085
1086
1087
1088
1089
1090
1091
1092
1093
1094
1095
1096
1097
1098
1099
1100
1101
1102
1103
1104
1105
1106
1107
1108
1109
1110
1111
1112
1113
1114
1115
1116
1117
1118
1119
1120
1121
1122
1123
1124
1125
1126
1127
1128
1129
1130
1131
1132
1133
1134
1135
1136
1137
1138
1139
1140
1141
1142
1143
1144
1145
1146
1147
1148
1149
1150
1151
1152
1153
1154
1155
1156
1157
1158
1159
1160
1161
1162
1163
1164
1165
1166
1167
1168
1169
1170
1171
1172
1173
1174
1175
1176
1177
1178
1179
1180
1181
1182
1183
1184
1185
1186
1187
1188
1189
1190
1191
1192
1193
1194
1195
1196
1197
1198
1199
1200
1201
1202
1203
1204
1205
1206
1207
1208
1209
1210
1211
1212
1213
1214
1215
1216
1217
1218
1219
1220
1221
1222
1223
1224
1225
1226
1227
1228
1229
1230
1231
1232
1233
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243
1244
1245
1246
1247
1248
1249
1250
1251
1252
1253
1254
1255
1256
1257
1258
1259
1260
def
Cookie
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
Cookie
(
default
=
default
,
default_factory
=
default_factory
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.Header
Header
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
convert_underscores
=
True
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
convert_underscores
Automatically convert underscores to hyphens in the parameter field name.
Read more about it in the
FastAPI docs for Header Parameters
TYPE:
bool
DEFAULT:
True
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812
813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
890
891
892
893
894
895
896
897
898
899
900
901
902
903
904
905
906
907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924
925
926
927
928
929
930
931
932
933
934
935
936
937
938
939
940
941
942
943
944
945
946
947
948
949
950
951
952
953
954
955
956
def
Header
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
convert_underscores
:
Annotated
[
bool
,
Doc
(
"""
Automatically convert underscores to hyphens in the parameter field name.
Read more about it in the
[FastAPI docs for Header Parameters](https://fastapi.tiangolo.com/tutorial/header-params/#automatic-conversion)
"""
),
]
=
True
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
Header
(
default
=
default
,
default_factory
=
default_factory
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
convert_underscores
=
convert_underscores
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.Form
Form
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
media_type
=
"application/x-www-form-urlencoded"
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
media_type
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
TYPE:
str
DEFAULT:
'application/x-www-form-urlencoded'
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
1592
1593
1594
1595
1596
1597
1598
1599
1600
1601
1602
1603
1604
1605
1606
1607
1608
1609
1610
1611
1612
1613
1614
1615
1616
1617
1618
1619
1620
1621
1622
1623
1624
1625
1626
1627
1628
1629
1630
1631
1632
1633
1634
1635
1636
1637
1638
1639
1640
1641
1642
1643
1644
1645
1646
1647
1648
1649
1650
1651
1652
1653
1654
1655
1656
1657
1658
1659
1660
1661
1662
1663
1664
1665
1666
1667
1668
1669
1670
1671
1672
1673
1674
1675
1676
1677
1678
1679
1680
1681
1682
1683
1684
1685
1686
1687
1688
1689
1690
1691
1692
1693
1694
1695
1696
1697
1698
1699
1700
1701
1702
1703
1704
1705
1706
1707
1708
1709
1710
1711
1712
1713
1714
1715
1716
1717
1718
1719
1720
1721
1722
1723
1724
1725
1726
1727
1728
1729
1730
1731
1732
1733
1734
1735
1736
1737
1738
1739
1740
1741
1742
1743
1744
1745
1746
1747
1748
1749
1750
1751
1752
1753
1754
1755
1756
1757
1758
1759
1760
1761
1762
1763
1764
1765
1766
1767
1768
1769
1770
1771
1772
1773
1774
1775
1776
1777
1778
1779
1780
1781
1782
1783
1784
1785
1786
1787
1788
1789
1790
1791
1792
1793
1794
1795
1796
1797
1798
1799
1800
1801
1802
1803
1804
1805
1806
1807
1808
1809
1810
1811
1812
1813
1814
1815
1816
1817
1818
1819
1820
1821
1822
1823
1824
1825
1826
1827
1828
1829
1830
1831
1832
1833
1834
1835
1836
1837
1838
1839
1840
1841
1842
1843
1844
1845
1846
1847
1848
1849
1850
1851
1852
1853
1854
1855
1856
1857
1858
1859
1860
1861
1862
1863
1864
1865
1866
1867
1868
1869
1870
1871
1872
1873
1874
1875
1876
1877
1878
1879
1880
1881
1882
1883
1884
1885
1886
1887
1888
1889
1890
1891
1892
1893
1894
1895
1896
1897
1898
1899
1900
1901
1902
1903
def
Form
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
media_type
:
Annotated
[
str
,
Doc
(
"""
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
"""
),
]
=
"application/x-www-form-urlencoded"
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
Form
(
default
=
default
,
default_factory
=
default_factory
,
media_type
=
media_type
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)
fastapi.File
File
(
default
=
Undefined
,
*
,
default_factory
=
_Unset
,
media_type
=
"multipart/form-data"
,
alias
=
None
,
alias_priority
=
_Unset
,
validation_alias
=
None
,
serialization_alias
=
None
,
title
=
None
,
description
=
None
,
gt
=
None
,
ge
=
None
,
lt
=
None
,
le
=
None
,
min_length
=
None
,
max_length
=
None
,
pattern
=
None
,
regex
=
None
,
discriminator
=
None
,
strict
=
_Unset
,
multiple_of
=
_Unset
,
allow_inf_nan
=
_Unset
,
max_digits
=
_Unset
,
decimal_places
=
_Unset
,
examples
=
None
,
example
=
_Unset
,
openapi_examples
=
None
,
deprecated
=
None
,
include_in_schema
=
True
,
json_schema_extra
=
None
,
**
extra
)
PARAMETER
DESCRIPTION
default
Default value if the parameter field is not set.
TYPE:
Any
DEFAULT:
Undefined
default_factory
A callable to generate the default value.
This doesn't affect
Path
parameters as the value is always required.
The parameter is available only for compatibility.
TYPE:
Union
[
Callable
[[],
Any
], None]
DEFAULT:
_Unset
media_type
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
TYPE:
str
DEFAULT:
'multipart/form-data'
alias
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
TYPE:
Optional
[
str
]
DEFAULT:
None
alias_priority
Priority of the alias. This affects whether an alias generator is used.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
validation_alias
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
TYPE:
Union
[
str
, None]
DEFAULT:
None
serialization_alias
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
TYPE:
Union
[
str
, None]
DEFAULT:
None
title
Human-readable title.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Human-readable description.
TYPE:
Optional
[
str
]
DEFAULT:
None
gt
Greater than. If set, value must be greater than this. Only applicable to
numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
ge
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
lt
Less than. If set, value must be less than this. Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
le
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
TYPE:
Optional
[
float
]
DEFAULT:
None
min_length
Minimum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
max_length
Maximum length for strings.
TYPE:
Optional
[
int
]
DEFAULT:
None
pattern
RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
regex
Deprecated in FastAPI 0.100.0 and Pydantic v2, use
pattern
instead. RegEx pattern for strings.
TYPE:
Optional
[
str
]
DEFAULT:
None
discriminator
Parameter field name for discriminating the type in a tagged union.
TYPE:
Union
[
str
, None]
DEFAULT:
None
strict
If
True
, strict validation is applied to the field.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
multiple_of
Value must be a multiple of this. Only applicable to numbers.
TYPE:
Union
[
float
, None]
DEFAULT:
_Unset
allow_inf_nan
Allow
inf
,
-inf
,
nan
. Only applicable to numbers.
TYPE:
Union
[
bool
, None]
DEFAULT:
_Unset
max_digits
Maximum number of allow digits for strings.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
decimal_places
Maximum number of decimal places allowed for numbers.
TYPE:
Union
[
int
, None]
DEFAULT:
_Unset
examples
Example values for this field.
TYPE:
Optional
[
List
[
Any
]]
DEFAULT:
None
example
Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
TYPE:
Optional
[
Any
]
DEFAULT:
_Unset
openapi_examples
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at
/docs
).
Swagger UI (that provides the
/docs
interface) has better support for the
OpenAPI-specific examples than the JSON Schema
examples
, that's the main
use case for this.
Read more about it in the
FastAPI docs for Declare Request Example Data
.
TYPE:
Optional
[
Dict
[
str
,
Example
]]
DEFAULT:
None
deprecated
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Union
[
deprecated
,
str
,
bool
, None]
DEFAULT:
None
include_in_schema
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
bool
DEFAULT:
True
json_schema_extra
Any additional JSON schema data.
TYPE:
Union
[
Dict
[
str
,
Any
], None]
DEFAULT:
None
**extra
The
extra
kwargs is deprecated. Use
json_schema_extra
instead. Include extra fields used by the JSON Schema.
TYPE:
Any
DEFAULT:
{}
Source code in
fastapi/param_functions.py
1906
1907
1908
1909
1910
1911
1912
1913
1914
1915
1916
1917
1918
1919
1920
1921
1922
1923
1924
1925
1926
1927
1928
1929
1930
1931
1932
1933
1934
1935
1936
1937
1938
1939
1940
1941
1942
1943
1944
1945
1946
1947
1948
1949
1950
1951
1952
1953
1954
1955
1956
1957
1958
1959
1960
1961
1962
1963
1964
1965
1966
1967
1968
1969
1970
1971
1972
1973
1974
1975
1976
1977
1978
1979
1980
1981
1982
1983
1984
1985
1986
1987
1988
1989
1990
1991
1992
1993
1994
1995
1996
1997
1998
1999
2000
2001
2002
2003
2004
2005
2006
2007
2008
2009
2010
2011
2012
2013
2014
2015
2016
2017
2018
2019
2020
2021
2022
2023
2024
2025
2026
2027
2028
2029
2030
2031
2032
2033
2034
2035
2036
2037
2038
2039
2040
2041
2042
2043
2044
2045
2046
2047
2048
2049
2050
2051
2052
2053
2054
2055
2056
2057
2058
2059
2060
2061
2062
2063
2064
2065
2066
2067
2068
2069
2070
2071
2072
2073
2074
2075
2076
2077
2078
2079
2080
2081
2082
2083
2084
2085
2086
2087
2088
2089
2090
2091
2092
2093
2094
2095
2096
2097
2098
2099
2100
2101
2102
2103
2104
2105
2106
2107
2108
2109
2110
2111
2112
2113
2114
2115
2116
2117
2118
2119
2120
2121
2122
2123
2124
2125
2126
2127
2128
2129
2130
2131
2132
2133
2134
2135
2136
2137
2138
2139
2140
2141
2142
2143
2144
2145
2146
2147
2148
2149
2150
2151
2152
2153
2154
2155
2156
2157
2158
2159
2160
2161
2162
2163
2164
2165
2166
2167
2168
2169
2170
2171
2172
2173
2174
2175
2176
2177
2178
2179
2180
2181
2182
2183
2184
2185
2186
2187
2188
2189
2190
2191
2192
2193
2194
2195
2196
2197
2198
2199
2200
2201
2202
2203
2204
2205
2206
2207
2208
2209
2210
2211
2212
2213
2214
2215
2216
2217
def
File
(
## noqa: N802
default
:
Annotated
[
Any
,
Doc
(
"""
Default value if the parameter field is not set.
"""
),
]
=
Undefined
,
*
,
default_factory
:
Annotated
[
Union
[
Callable
[[],
Any
],
None
],
Doc
(
"""
A callable to generate the default value.
This doesn't affect `Path` parameters as the value is always required.
The parameter is available only for compatibility.
"""
),
]
=
_Unset
,
media_type
:
Annotated
[
str
,
Doc
(
"""
The media type of this parameter field. Changing it would affect the
generated OpenAPI, but currently it doesn't affect the parsing of the data.
"""
),
]
=
"multipart/form-data"
,
alias
:
Annotated
[
Optional
[
str
],
Doc
(
"""
An alternative name for the parameter field.
This will be used to extract the data and for the generated OpenAPI.
It is particularly useful when you can't use the name you want because it
is a Python reserved keyword or similar.
"""
),
]
=
None
,
alias_priority
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Priority of the alias. This affects whether an alias generator is used.
"""
),
]
=
_Unset
,
## TODO: update when deprecating Pydantic v1, import these types
## validation_alias: str | AliasPath | AliasChoices | None
validation_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Whitelist' validation step. The parameter field will be the single one
allowed by the alias or set of aliases defined.
"""
),
]
=
None
,
serialization_alias
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
'Blacklist' validation step. The vanilla parameter field will be the
single one of the alias' or set of aliases' fields and all the other
fields will be ignored at serialization time.
"""
),
]
=
None
,
title
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable title.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Human-readable description.
"""
),
]
=
None
,
gt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than. If set, value must be greater than this. Only applicable to
numbers.
"""
),
]
=
None
,
ge
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Greater than or equal. If set, value must be greater than or equal to
this. Only applicable to numbers.
"""
),
]
=
None
,
lt
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than. If set, value must be less than this. Only applicable to numbers.
"""
),
]
=
None
,
le
:
Annotated
[
Optional
[
float
],
Doc
(
"""
Less than or equal. If set, value must be less than or equal to this.
Only applicable to numbers.
"""
),
]
=
None
,
min_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Minimum length for strings.
"""
),
]
=
None
,
max_length
:
Annotated
[
Optional
[
int
],
Doc
(
"""
Maximum length for strings.
"""
),
]
=
None
,
pattern
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
]
=
None
,
regex
:
Annotated
[
Optional
[
str
],
Doc
(
"""
RegEx pattern for strings.
"""
),
deprecated
(
"Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
),
]
=
None
,
discriminator
:
Annotated
[
Union
[
str
,
None
],
Doc
(
"""
Parameter field name for discriminating the type in a tagged union.
"""
),
]
=
None
,
strict
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
If `True`, strict validation is applied to the field.
"""
),
]
=
_Unset
,
multiple_of
:
Annotated
[
Union
[
float
,
None
],
Doc
(
"""
Value must be a multiple of this. Only applicable to numbers.
"""
),
]
=
_Unset
,
allow_inf_nan
:
Annotated
[
Union
[
bool
,
None
],
Doc
(
"""
Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
"""
),
]
=
_Unset
,
max_digits
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of allow digits for strings.
"""
),
]
=
_Unset
,
decimal_places
:
Annotated
[
Union
[
int
,
None
],
Doc
(
"""
Maximum number of decimal places allowed for numbers.
"""
),
]
=
_Unset
,
examples
:
Annotated
[
Optional
[
List
[
Any
]],
Doc
(
"""
Example values for this field.
"""
),
]
=
None
,
example
:
Annotated
[
Optional
[
Any
],
deprecated
(
"Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
"although still supported. Use examples instead."
),
]
=
_Unset
,
openapi_examples
:
Annotated
[
Optional
[
Dict
[
str
,
Example
]],
Doc
(
"""
OpenAPI-specific examples.
It will be added to the generated OpenAPI (e.g. visible at `/docs`).
Swagger UI (that provides the `/docs` interface) has better support for the
OpenAPI-specific examples than the JSON Schema `examples`, that's the main
use case for this.
Read more about it in the
[FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
"""
),
]
=
None
,
deprecated
:
Annotated
[
Union
[
deprecated
,
str
,
bool
,
None
],
Doc
(
"""
Mark this parameter field as deprecated.
It will affect the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
include_in_schema
:
Annotated
[
bool
,
Doc
(
"""
To include (or not) this parameter field in the generated OpenAPI.
You probably don't need it, but it's available.
This affects the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
True
,
json_schema_extra
:
Annotated
[
Union
[
Dict
[
str
,
Any
],
None
],
Doc
(
"""
Any additional JSON schema data.
"""
),
]
=
None
,
**
extra
:
Annotated
[
Any
,
Doc
(
"""
Include extra fields used by the JSON Schema.
"""
),
deprecated
(
"""
The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
"""
),
],
)
->
Any
:
return
params
.
File
(
default
=
default
,
default_factory
=
default_factory
,
media_type
=
media_type
,
alias
=
alias
,
alias_priority
=
alias_priority
,
validation_alias
=
validation_alias
,
serialization_alias
=
serialization_alias
,
title
=
title
,
description
=
description
,
gt
=
gt
,
ge
=
ge
,
lt
=
lt
,
le
=
le
,
min_length
=
min_length
,
max_length
=
max_length
,
pattern
=
pattern
,
regex
=
regex
,
discriminator
=
discriminator
,
strict
=
strict
,
multiple_of
=
multiple_of
,
allow_inf_nan
=
allow_inf_nan
,
max_digits
=
max_digits
,
decimal_places
=
decimal_places
,
example
=
example
,
examples
=
examples
,
openapi_examples
=
openapi_examples
,
deprecated
=
deprecated
,
include_in_schema
=
include_in_schema
,
json_schema_extra
=
json_schema_extra
,
**
extra
,
)

## 095_REFERENCE_REQUEST
Requestclass¬∂
---

Request
class
You can declare a parameter in a
path operation function
or dependency to be of type
Request
and then you can access the raw request object directly, without any validation, etc.
You can import it directly from
fastapi
:
from
fastapi
import
Request
Tip
When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an
HTTPConnection
instead of a
Request
or a
WebSocket
.
fastapi.Request
Request
(
scope
,
receive
=
empty_receive
,
send
=
empty_send
)
Bases:
HTTPConnection
Source code in
starlette/requests.py
201
202
203
204
205
206
207
208
def
__init__
(
self
,
scope
:
Scope
,
receive
:
Receive
=
empty_receive
,
send
:
Send
=
empty_send
):
super
()
.
__init__
(
scope
)
assert
scope
[
"type"
]
==
"http"
self
.
_receive
=
receive
self
.
_send
=
send
self
.
_stream_consumed
=
False
self
.
_is_disconnected
=
False
self
.
_form
=
None
scope
instance-attribute
scope
=
scope
app
property
app
url
property
url
base_url
property
base_url
headers
property
headers
query_params
property
query_params
path_params
property
path_params
cookies
property
cookies
client
property
client
session
property
session
auth
property
auth
user
property
user
state
property
state
method
property
method
receive
property
receive
url_for
url_for
(
name
,
/
,
**
path_params
)
Source code in
starlette/requests.py
182
183
184
185
186
187
def
url_for
(
self
,
name
:
str
,
/
,
**
path_params
:
typing
.
Any
)
->
URL
:
url_path_provider
:
Router
|
Starlette
|
None
=
self
.
scope
.
get
(
"router"
)
or
self
.
scope
.
get
(
"app"
)
if
url_path_provider
is
None
:
raise
RuntimeError
(
"The `url_for` method can only be used inside a Starlette application or with a router."
)
url_path
=
url_path_provider
.
url_path_for
(
name
,
**
path_params
)
return
url_path
.
make_absolute_url
(
base_url
=
self
.
base_url
)
stream
async
stream
()
Source code in
starlette/requests.py
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
async
def
stream
(
self
)
->
typing
.
AsyncGenerator
[
bytes
,
None
]:
if
hasattr
(
self
,
"_body"
):
yield
self
.
_body
yield
b
""
return
if
self
.
_stream_consumed
:
raise
RuntimeError
(
"Stream consumed"
)
while
not
self
.
_stream_consumed
:
message
=
await
self
.
_receive
()
if
message
[
"type"
]
==
"http.request"
:
body
=
message
.
get
(
"body"
,
b
""
)
if
not
message
.
get
(
"more_body"
,
False
):
self
.
_stream_consumed
=
True
if
body
:
yield
body
elif
message
[
"type"
]
==
"http.disconnect"
:
## pragma: no branch
self
.
_is_disconnected
=
True
raise
ClientDisconnect
()
yield
b
""
body
async
body
()
Source code in
starlette/requests.py
238
239
240
241
242
243
244
async
def
body
(
self
)
->
bytes
:
if
not
hasattr
(
self
,
"_body"
):
chunks
:
list
[
bytes
]
=
[]
async
for
chunk
in
self
.
stream
():
chunks
.
append
(
chunk
)
self
.
_body
=
b
""
.
join
(
chunks
)
return
self
.
_body
json
async
json
()
Source code in
starlette/requests.py
246
247
248
249
250
async
def
json
(
self
)
->
typing
.
Any
:
if
not
hasattr
(
self
,
"_json"
):
## pragma: no branch
body
=
await
self
.
body
()
self
.
_json
=
json
.
loads
(
body
)
return
self
.
_json
form
form
(
*
,
max_files
=
1000
,
max_fields
=
1000
,
max_part_size
=
1024
*
1024
)
Source code in
starlette/requests.py
287
288
289
290
291
292
293
294
295
296
def
form
(
self
,
*
,
max_files
:
int
|
float
=
1000
,
max_fields
:
int
|
float
=
1000
,
max_part_size
:
int
=
1024
*
1024
,
)
->
AwaitableOrContextManager
[
FormData
]:
return
AwaitableOrContextManagerWrapper
(
self
.
_get_form
(
max_files
=
max_files
,
max_fields
=
max_fields
,
max_part_size
=
max_part_size
)
)
close
async
close
()
Source code in
starlette/requests.py
298
299
300
async
def
close
(
self
)
->
None
:
if
self
.
_form
is
not
None
:
## pragma: no branch
await
self
.
_form
.
close
()
is_disconnected
async
is_disconnected
()
Source code in
starlette/requests.py
302
303
304
305
306
307
308
309
310
311
312
313
314
async
def
is_disconnected
(
self
)
->
bool
:
if
not
self
.
_is_disconnected
:
message
:
Message
=
{}
## If message isn't immediately available, move on
with
anyio
.
CancelScope
()
as
cs
:
cs
.
cancel
()
message
=
await
self
.
_receive
()
if
message
.
get
(
"type"
)
==
"http.disconnect"
:
self
.
_is_disconnected
=
True
return
self
.
_is_disconnected
send_push_promise
async
send_push_promise
(
path
)
Source code in
starlette/requests.py
316
317
318
319
320
321
322
async
def
send_push_promise
(
self
,
path
:
str
)
->
None
:
if
"http.response.push"
in
self
.
scope
.
get
(
"extensions"
,
{}):
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
for
name
in
SERVER_PUSH_HEADERS_TO_COPY
:
for
value
in
self
.
headers
.
getlist
(
name
):
raw_headers
.
append
((
name
.
encode
(
"latin-1"
),
value
.
encode
(
"latin-1"
)))
await
self
.
_send
({
"type"
:
"http.response.push"
,
"path"
:
path
,
"headers"
:
raw_headers
})

## 096_REFERENCE_RESPONSE
Responseclass¬∂
---

Response
class
You can declare a parameter in a
path operation function
or dependency to be of type
Response
and then you can set data for the response like headers or cookies.
You can also use it directly to create an instance of it and return it from your
path operations
.
You can import it directly from
fastapi
:
from
fastapi
import
Response
fastapi.Response
Response
(
content
=
None
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Source code in
starlette/responses.py
33
34
35
36
37
38
39
40
41
42
43
44
45
46
def
__init__
(
self
,
content
:
typing
.
Any
=
None
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
self
.
status_code
=
status_code
if
media_type
is
not
None
:
self
.
media_type
=
media_type
self
.
background
=
background
self
.
body
=
self
.
render
(
content
)
self
.
init_headers
(
headers
)
media_type
class-attribute
instance-attribute
media_type
=
None
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
background
instance-attribute
background
=
background
body
instance-attribute
body
=
render
(
content
)
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)

## 097_REFERENCE_RESPONSES
Custom Response Classes - File, HTML, Redirect, Streaming, etc.¬∂
---

Custom Response Classes - File, HTML, Redirect, Streaming, etc.
There are several custom response classes you can use to create an instance and return them directly from your
path operations
.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
You can import them directly from
fastapi.responses
:
from
fastapi.responses
import
(
FileResponse
,
HTMLResponse
,
JSONResponse
,
ORJSONResponse
,
PlainTextResponse
,
RedirectResponse
,
Response
,
StreamingResponse
,
UJSONResponse
,
)
FastAPI Responses
There are a couple of custom FastAPI response classes, you can use them to optimize JSON performance.
fastapi.responses.UJSONResponse
UJSONResponse
(
content
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
JSONResponse
JSON response using the high-performance ujson library to serialize data to JSON.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
Source code in
starlette/responses.py
174
175
176
177
178
179
180
181
182
def
__init__
(
self
,
content
:
typing
.
Any
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
super
()
.
__init__
(
content
,
status_code
,
headers
,
media_type
,
background
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
'application/json'
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
fastapi/responses.py
31
32
33
def
render
(
self
,
content
:
Any
)
->
bytes
:
assert
ujson
is
not
None
,
"ujson must be installed to use UJSONResponse"
return
ujson
.
dumps
(
content
,
ensure_ascii
=
False
)
.
encode
(
"utf-8"
)
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.ORJSONResponse
ORJSONResponse
(
content
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
JSONResponse
JSON response using the high-performance orjson library to serialize data to JSON.
Read more about it in the
FastAPI docs for Custom Response - HTML, Stream, File, others
.
Source code in
starlette/responses.py
174
175
176
177
178
179
180
181
182
def
__init__
(
self
,
content
:
typing
.
Any
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
super
()
.
__init__
(
content
,
status_code
,
headers
,
media_type
,
background
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
'application/json'
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
fastapi/responses.py
44
45
46
47
48
def
render
(
self
,
content
:
Any
)
->
bytes
:
assert
orjson
is
not
None
,
"orjson must be installed to use ORJSONResponse"
return
orjson
.
dumps
(
content
,
option
=
orjson
.
OPT_NON_STR_KEYS
|
orjson
.
OPT_SERIALIZE_NUMPY
)
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
Starlette Responses
fastapi.responses.FileResponse
FileResponse
(
path
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
filename
=
None
,
stat_result
=
None
,
method
=
None
,
content_disposition_type
=
"attachment"
,
)
Bases:
Response
Source code in
starlette/responses.py
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
def
__init__
(
self
,
path
:
str
|
os
.
PathLike
[
str
],
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
filename
:
str
|
None
=
None
,
stat_result
:
os
.
stat_result
|
None
=
None
,
method
:
str
|
None
=
None
,
content_disposition_type
:
str
=
"attachment"
,
)
->
None
:
self
.
path
=
path
self
.
status_code
=
status_code
self
.
filename
=
filename
if
method
is
not
None
:
warnings
.
warn
(
"The 'method' parameter is not used, and it will be removed."
,
DeprecationWarning
,
)
if
media_type
is
None
:
media_type
=
guess_type
(
filename
or
path
)[
0
]
or
"text/plain"
self
.
media_type
=
media_type
self
.
background
=
background
self
.
init_headers
(
headers
)
self
.
headers
.
setdefault
(
"accept-ranges"
,
"bytes"
)
if
self
.
filename
is
not
None
:
content_disposition_filename
=
quote
(
self
.
filename
)
if
content_disposition_filename
!=
self
.
filename
:
content_disposition
=
f
"
{
content_disposition_type
}
; filename*=utf-8''
{
content_disposition_filename
}
"
else
:
content_disposition
=
f
'
{
content_disposition_type
}
; filename="
{
self
.
filename
}
"'
self
.
headers
.
setdefault
(
"content-disposition"
,
content_disposition
)
self
.
stat_result
=
stat_result
if
stat_result
is
not
None
:
self
.
set_stat_headers
(
stat_result
)
chunk_size
class-attribute
instance-attribute
chunk_size
=
64
*
1024
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
instance-attribute
media_type
=
media_type
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.HTMLResponse
HTMLResponse
(
content
=
None
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
Response
Source code in
starlette/responses.py
33
34
35
36
37
38
39
40
41
42
43
44
45
46
def
__init__
(
self
,
content
:
typing
.
Any
=
None
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
self
.
status_code
=
status_code
if
media_type
is
not
None
:
self
.
media_type
=
media_type
self
.
background
=
background
self
.
body
=
self
.
render
(
content
)
self
.
init_headers
(
headers
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
'text/html'
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.JSONResponse
JSONResponse
(
content
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
Response
Source code in
starlette/responses.py
174
175
176
177
178
179
180
181
182
def
__init__
(
self
,
content
:
typing
.
Any
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
super
()
.
__init__
(
content
,
status_code
,
headers
,
media_type
,
background
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
'application/json'
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
184
185
186
187
188
189
190
191
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
:
return
json
.
dumps
(
content
,
ensure_ascii
=
False
,
allow_nan
=
False
,
indent
=
None
,
separators
=
(
","
,
":"
),
)
.
encode
(
"utf-8"
)
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.PlainTextResponse
PlainTextResponse
(
content
=
None
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
Response
Source code in
starlette/responses.py
33
34
35
36
37
38
39
40
41
42
43
44
45
46
def
__init__
(
self
,
content
:
typing
.
Any
=
None
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
self
.
status_code
=
status_code
if
media_type
is
not
None
:
self
.
media_type
=
media_type
self
.
background
=
background
self
.
body
=
self
.
render
(
content
)
self
.
init_headers
(
headers
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
'text/plain'
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.RedirectResponse
RedirectResponse
(
url
,
status_code
=
307
,
headers
=
None
,
background
=
None
)
Bases:
Response
Source code in
starlette/responses.py
195
196
197
198
199
200
201
202
203
def
__init__
(
self
,
url
:
str
|
URL
,
status_code
:
int
=
307
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
super
()
.
__init__
(
content
=
b
""
,
status_code
=
status_code
,
headers
=
headers
,
background
=
background
)
self
.
headers
[
"location"
]
=
quote
(
str
(
url
),
safe
=
":/%#?=@[]!$&'()*+,;"
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
None
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.Response
Response
(
content
=
None
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Source code in
starlette/responses.py
33
34
35
36
37
38
39
40
41
42
43
44
45
46
def
__init__
(
self
,
content
:
typing
.
Any
=
None
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
self
.
status_code
=
status_code
if
media_type
is
not
None
:
self
.
media_type
=
media_type
self
.
background
=
background
self
.
body
=
self
.
render
(
content
)
self
.
init_headers
(
headers
)
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
class-attribute
instance-attribute
media_type
=
None
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)
fastapi.responses.StreamingResponse
StreamingResponse
(
content
,
status_code
=
200
,
headers
=
None
,
media_type
=
None
,
background
=
None
,
)
Bases:
Response
Source code in
starlette/responses.py
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
def
__init__
(
self
,
content
:
ContentStream
,
status_code
:
int
=
200
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
None
:
if
isinstance
(
content
,
typing
.
AsyncIterable
):
self
.
body_iterator
=
content
else
:
self
.
body_iterator
=
iterate_in_threadpool
(
content
)
self
.
status_code
=
status_code
self
.
media_type
=
self
.
media_type
if
media_type
is
None
else
media_type
self
.
background
=
background
self
.
init_headers
(
headers
)
body_iterator
instance-attribute
body_iterator
charset
class-attribute
instance-attribute
charset
=
'utf-8'
status_code
instance-attribute
status_code
=
status_code
media_type
instance-attribute
media_type
=
(
media_type
if
media_type
is
None
else
media_type
)
body
instance-attribute
body
=
render
(
content
)
background
instance-attribute
background
=
background
headers
property
headers
render
render
(
content
)
Source code in
starlette/responses.py
48
49
50
51
52
53
def
render
(
self
,
content
:
typing
.
Any
)
->
bytes
|
memoryview
:
if
content
is
None
:
return
b
""
if
isinstance
(
content
,
(
bytes
,
memoryview
)):
return
content
return
content
.
encode
(
self
.
charset
)
## type: ignore
init_headers
init_headers
(
headers
=
None
)
Source code in
starlette/responses.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
def
init_headers
(
self
,
headers
:
typing
.
Mapping
[
str
,
str
]
|
None
=
None
)
->
None
:
if
headers
is
None
:
raw_headers
:
list
[
tuple
[
bytes
,
bytes
]]
=
[]
populate_content_length
=
True
populate_content_type
=
True
else
:
raw_headers
=
[(
k
.
lower
()
.
encode
(
"latin-1"
),
v
.
encode
(
"latin-1"
))
for
k
,
v
in
headers
.
items
()]
keys
=
[
h
[
0
]
for
h
in
raw_headers
]
populate_content_length
=
b
"content-length"
not
in
keys
populate_content_type
=
b
"content-type"
not
in
keys
body
=
getattr
(
self
,
"body"
,
None
)
if
(
body
is
not
None
and
populate_content_length
and
not
(
self
.
status_code
<
200
or
self
.
status_code
in
(
204
,
304
))
):
content_length
=
str
(
len
(
body
))
raw_headers
.
append
((
b
"content-length"
,
content_length
.
encode
(
"latin-1"
)))
content_type
=
self
.
media_type
if
content_type
is
not
None
and
populate_content_type
:
if
content_type
.
startswith
(
"text/"
)
and
"charset="
not
in
content_type
.
lower
():
content_type
+=
"; charset="
+
self
.
charset
raw_headers
.
append
((
b
"content-type"
,
content_type
.
encode
(
"latin-1"
)))
self
.
raw_headers
=
raw_headers
set_cookie
set_cookie
(
key
,
value
=
""
,
max_age
=
None
,
expires
=
None
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
def
set_cookie
(
self
,
key
:
str
,
value
:
str
=
""
,
max_age
:
int
|
None
=
None
,
expires
:
datetime
|
str
|
int
|
None
=
None
,
path
:
str
|
None
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
cookie
:
http
.
cookies
.
BaseCookie
[
str
]
=
http
.
cookies
.
SimpleCookie
()
cookie
[
key
]
=
value
if
max_age
is
not
None
:
cookie
[
key
][
"max-age"
]
=
max_age
if
expires
is
not
None
:
if
isinstance
(
expires
,
datetime
):
cookie
[
key
][
"expires"
]
=
format_datetime
(
expires
,
usegmt
=
True
)
else
:
cookie
[
key
][
"expires"
]
=
expires
if
path
is
not
None
:
cookie
[
key
][
"path"
]
=
path
if
domain
is
not
None
:
cookie
[
key
][
"domain"
]
=
domain
if
secure
:
cookie
[
key
][
"secure"
]
=
True
if
httponly
:
cookie
[
key
][
"httponly"
]
=
True
if
samesite
is
not
None
:
assert
samesite
.
lower
()
in
[
"strict"
,
"lax"
,
"none"
,
],
"samesite must be either 'strict', 'lax' or 'none'"
cookie
[
key
][
"samesite"
]
=
samesite
cookie_val
=
cookie
.
output
(
header
=
""
)
.
strip
()
self
.
raw_headers
.
append
((
b
"set-cookie"
,
cookie_val
.
encode
(
"latin-1"
)))
delete_cookie
delete_cookie
(
key
,
path
=
"/"
,
domain
=
None
,
secure
=
False
,
httponly
=
False
,
samesite
=
"lax"
,
)
Source code in
starlette/responses.py
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
def
delete_cookie
(
self
,
key
:
str
,
path
:
str
=
"/"
,
domain
:
str
|
None
=
None
,
secure
:
bool
=
False
,
httponly
:
bool
=
False
,
samesite
:
typing
.
Literal
[
"lax"
,
"strict"
,
"none"
]
|
None
=
"lax"
,
)
->
None
:
self
.
set_cookie
(
key
,
max_age
=
0
,
expires
=
0
,
path
=
path
,
domain
=
domain
,
secure
=
secure
,
httponly
=
httponly
,
samesite
=
samesite
,
)

## 098_REFERENCE_SECURITY
Security Tools¬∂
---

Security Tools
When you need to declare dependencies with OAuth2 scopes you use
Security()
.
But you still need to define what is the dependable, the callable that you pass as a parameter to
Depends()
or
Security()
.
There are multiple tools that you can use to create those dependables, and they get integrated into OpenAPI so they are shown in the automatic docs UI, they can be used by automatically generated clients and SDKs, etc.
You can import them from
fastapi.security
:
from
fastapi.security
import
(
APIKeyCookie
,
APIKeyHeader
,
APIKeyQuery
,
HTTPAuthorizationCredentials
,
HTTPBasic
,
HTTPBasicCredentials
,
HTTPBearer
,
HTTPDigest
,
OAuth2
,
OAuth2AuthorizationCodeBearer
,
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
,
OAuth2PasswordRequestFormStrict
,
OpenIdConnect
,
SecurityScopes
,
)
API Key Security Schemes
fastapi.security.APIKeyCookie
APIKeyCookie
(
*
,
name
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
APIKeyBase
API key authentication using a cookie.
This defines the name of the cookie that should be provided in the request with
the API key and integrates that into the OpenAPI documentation. It extracts
the key value sent in the cookie automatically and provides it as the dependency
result. But it doesn't define how to set that cookie.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be a string containing the key value.
Example
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
APIKeyCookie
app
=
FastAPI
()
cookie_scheme
=
APIKeyCookie
(
name
=
"session"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
session
:
str
=
Depends
(
cookie_scheme
)):
return
{
"session"
:
session
}
PARAMETER
DESCRIPTION
name
Cookie name.
TYPE:
str
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the cookie is not provided,
APIKeyCookie
will
automatically cancel the request and send the client an error.
If
auto_error
is set to
False
, when the cookie is not available,
instead of erroring out, the dependency result will be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a cookie or
in an HTTP Bearer token).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/api_key.py
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
def
__init__
(
self
,
*
,
name
:
Annotated
[
str
,
Doc
(
"Cookie name."
)],
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the cookie is not provided, `APIKeyCookie` will
automatically cancel the request and send the client an error.
If `auto_error` is set to `False`, when the cookie is not available,
instead of erroring out, the dependency result will be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a cookie or
in an HTTP Bearer token).
"""
),
]
=
True
,
):
self
.
model
:
APIKey
=
APIKey
(
**
{
"in"
:
APIKeyIn
.
cookie
},
## type: ignore[arg-type]
name
=
name
,
description
=
description
,
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
APIKey
(
**
{
"in"
:
cookie
},
name
=
name
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
check_api_key
staticmethod
check_api_key
(
api_key
,
auto_error
)
Source code in
fastapi/security/api_key.py
12
13
14
15
16
17
18
19
20
@staticmethod
def
check_api_key
(
api_key
:
Optional
[
str
],
auto_error
:
bool
)
->
Optional
[
str
]:
if
not
api_key
:
if
auto_error
:
raise
HTTPException
(
status_code
=
HTTP_403_FORBIDDEN
,
detail
=
"Not authenticated"
)
return
None
return
api_key
fastapi.security.APIKeyHeader
APIKeyHeader
(
*
,
name
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
APIKeyBase
API key authentication using a header.
This defines the name of the header that should be provided in the request with
the API key and integrates that into the OpenAPI documentation. It extracts
the key value sent in the header automatically and provides it as the dependency
result. But it doesn't define how to send that key to the client.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be a string containing the key value.
Example
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
APIKeyHeader
app
=
FastAPI
()
header_scheme
=
APIKeyHeader
(
name
=
"x-key"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
key
:
str
=
Depends
(
header_scheme
)):
return
{
"key"
:
key
}
PARAMETER
DESCRIPTION
name
Header name.
TYPE:
str
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the header is not provided,
APIKeyHeader
will
automatically cancel the request and send the client an error.
If
auto_error
is set to
False
, when the header is not available,
instead of erroring out, the dependency result will be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a header or
in an HTTP Bearer token).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/api_key.py
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
def
__init__
(
self
,
*
,
name
:
Annotated
[
str
,
Doc
(
"Header name."
)],
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the header is not provided, `APIKeyHeader` will
automatically cancel the request and send the client an error.
If `auto_error` is set to `False`, when the header is not available,
instead of erroring out, the dependency result will be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a header or
in an HTTP Bearer token).
"""
),
]
=
True
,
):
self
.
model
:
APIKey
=
APIKey
(
**
{
"in"
:
APIKeyIn
.
header
},
## type: ignore[arg-type]
name
=
name
,
description
=
description
,
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
APIKey
(
**
{
"in"
:
header
},
name
=
name
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
check_api_key
staticmethod
check_api_key
(
api_key
,
auto_error
)
Source code in
fastapi/security/api_key.py
12
13
14
15
16
17
18
19
20
@staticmethod
def
check_api_key
(
api_key
:
Optional
[
str
],
auto_error
:
bool
)
->
Optional
[
str
]:
if
not
api_key
:
if
auto_error
:
raise
HTTPException
(
status_code
=
HTTP_403_FORBIDDEN
,
detail
=
"Not authenticated"
)
return
None
return
api_key
fastapi.security.APIKeyQuery
APIKeyQuery
(
*
,
name
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
APIKeyBase
API key authentication using a query parameter.
This defines the name of the query parameter that should be provided in the request
with the API key and integrates that into the OpenAPI documentation. It extracts
the key value sent in the query parameter automatically and provides it as the
dependency result. But it doesn't define how to send that API key to the client.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be a string containing the key value.
Example
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
APIKeyQuery
app
=
FastAPI
()
query_scheme
=
APIKeyQuery
(
name
=
"api_key"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
api_key
:
str
=
Depends
(
query_scheme
)):
return
{
"api_key"
:
api_key
}
PARAMETER
DESCRIPTION
name
Query parameter name.
TYPE:
str
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the query parameter is not provided,
APIKeyQuery
will
automatically cancel the request and send the client an error.
If
auto_error
is set to
False
, when the query parameter is not
available, instead of erroring out, the dependency result will be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a query
parameter or in an HTTP Bearer token).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/api_key.py
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
def
__init__
(
self
,
*
,
name
:
Annotated
[
str
,
Doc
(
"Query parameter name."
),
],
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the query parameter is not provided, `APIKeyQuery` will
automatically cancel the request and send the client an error.
If `auto_error` is set to `False`, when the query parameter is not
available, instead of erroring out, the dependency result will be
`None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in a query
parameter or in an HTTP Bearer token).
"""
),
]
=
True
,
):
self
.
model
:
APIKey
=
APIKey
(
**
{
"in"
:
APIKeyIn
.
query
},
## type: ignore[arg-type]
name
=
name
,
description
=
description
,
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
APIKey
(
**
{
"in"
:
query
},
name
=
name
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
check_api_key
staticmethod
check_api_key
(
api_key
,
auto_error
)
Source code in
fastapi/security/api_key.py
12
13
14
15
16
17
18
19
20
@staticmethod
def
check_api_key
(
api_key
:
Optional
[
str
],
auto_error
:
bool
)
->
Optional
[
str
]:
if
not
api_key
:
if
auto_error
:
raise
HTTPException
(
status_code
=
HTTP_403_FORBIDDEN
,
detail
=
"Not authenticated"
)
return
None
return
api_key
HTTP Authentication Schemes
fastapi.security.HTTPBasic
HTTPBasic
(
*
,
scheme_name
=
None
,
realm
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
HTTPBase
HTTP Basic authentication.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be an
HTTPBasicCredentials
object containing the
username
and the
password
.
Read more about it in the
FastAPI docs for HTTP Basic Auth
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPBasic
,
HTTPBasicCredentials
app
=
FastAPI
()
security
=
HTTPBasic
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
Annotated
[
HTTPBasicCredentials
,
Depends
(
security
)]):
return
{
"username"
:
credentials
.
username
,
"password"
:
credentials
.
password
}
PARAMETER
DESCRIPTION
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
realm
HTTP Basic authentication realm.
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the HTTP Basic authentication is not provided (a
header),
HTTPBasic
will automatically cancel the request and send the
client an error.
If
auto_error
is set to
False
, when the HTTP Basic authentication
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in HTTP Basic
authentication or in an HTTP Bearer token).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/http.py
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
def
__init__
(
self
,
*
,
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
realm
:
Annotated
[
Optional
[
str
],
Doc
(
"""
HTTP Basic authentication realm.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the HTTP Basic authentication is not provided (a
header), `HTTPBasic` will automatically cancel the request and send the
client an error.
If `auto_error` is set to `False`, when the HTTP Basic authentication
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in HTTP Basic
authentication or in an HTTP Bearer token).
"""
),
]
=
True
,
):
self
.
model
=
HTTPBaseModel
(
scheme
=
"basic"
,
description
=
description
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
realm
=
realm
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
HTTPBase
(
scheme
=
'basic'
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
realm
instance-attribute
realm
=
realm
auto_error
instance-attribute
auto_error
=
auto_error
fastapi.security.HTTPBearer
HTTPBearer
(
*
,
bearerFormat
=
None
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
HTTPBase
HTTP Bearer token authentication.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be an
HTTPAuthorizationCredentials
object containing
the
scheme
and the
credentials
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPAuthorizationCredentials
,
HTTPBearer
app
=
FastAPI
()
security
=
HTTPBearer
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
Annotated
[
HTTPAuthorizationCredentials
,
Depends
(
security
)]
):
return
{
"scheme"
:
credentials
.
scheme
,
"credentials"
:
credentials
.
credentials
}
PARAMETER
DESCRIPTION
bearerFormat
Bearer token format.
TYPE:
Optional
[
str
]
DEFAULT:
None
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the HTTP Bearer token is not provided (in an
Authorization
header),
HTTPBearer
will automatically cancel the
request and send the client an error.
If
auto_error
is set to
False
, when the HTTP Bearer token
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in an HTTP
Bearer token or in a cookie).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/http.py
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
def
__init__
(
self
,
*
,
bearerFormat
:
Annotated
[
Optional
[
str
],
Doc
(
"Bearer token format."
)]
=
None
,
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the HTTP Bearer token is not provided (in an
`Authorization` header), `HTTPBearer` will automatically cancel the
request and send the client an error.
If `auto_error` is set to `False`, when the HTTP Bearer token
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in an HTTP
Bearer token or in a cookie).
"""
),
]
=
True
,
):
self
.
model
=
HTTPBearerModel
(
bearerFormat
=
bearerFormat
,
description
=
description
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
HTTPBearer
(
bearerFormat
=
bearerFormat
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
fastapi.security.HTTPDigest
HTTPDigest
(
*
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
HTTPBase
HTTP Digest authentication.
Usage
Create an instance object and use that object as the dependency in
Depends()
.
The dependency result will be an
HTTPAuthorizationCredentials
object containing
the
scheme
and the
credentials
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
HTTPAuthorizationCredentials
,
HTTPDigest
app
=
FastAPI
()
security
=
HTTPDigest
()
@app
.
get
(
"/users/me"
)
def
read_current_user
(
credentials
:
Annotated
[
HTTPAuthorizationCredentials
,
Depends
(
security
)]
):
return
{
"scheme"
:
credentials
.
scheme
,
"credentials"
:
credentials
.
credentials
}
PARAMETER
DESCRIPTION
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if the HTTP Digest is not provided,
HTTPDigest
will
automatically cancel the request and send the client an error.
If
auto_error
is set to
False
, when the HTTP Digest is not
available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in HTTP
Digest or in a cookie).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/http.py
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
def
__init__
(
self
,
*
,
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if the HTTP Digest is not provided, `HTTPDigest` will
automatically cancel the request and send the client an error.
If `auto_error` is set to `False`, when the HTTP Digest is not
available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, in HTTP
Digest or in a cookie).
"""
),
]
=
True
,
):
self
.
model
=
HTTPBaseModel
(
scheme
=
"digest"
,
description
=
description
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
HTTPBase
(
scheme
=
'digest'
,
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
HTTP Credentials
fastapi.security.HTTPAuthorizationCredentials
Bases:
BaseModel
The HTTP authorization credentials in the result of using
HTTPBearer
or
HTTPDigest
in a dependency.
The HTTP authorization header value is split by the first space.
The first part is the
scheme
, the second part is the
credentials
.
For example, in an HTTP Bearer token scheme, the client will send a header
like:
Authorization: Bearer deadbeef12346
In this case:
scheme
will have the value
"Bearer"
credentials
will have the value
"deadbeef12346"
scheme
instance-attribute
scheme
The HTTP authorization scheme extracted from the header value.
credentials
instance-attribute
credentials
The HTTP authorization credentials extracted from the header value.
fastapi.security.HTTPBasicCredentials
Bases:
BaseModel
The HTTP Basic credentials given as the result of using
HTTPBasic
in a
dependency.
Read more about it in the
FastAPI docs for HTTP Basic Auth
.
username
instance-attribute
username
The HTTP Basic username.
password
instance-attribute
password
The HTTP Basic password.
OAuth2 Authentication
fastapi.security.OAuth2
OAuth2
(
*
,
flows
=
OAuthFlows
(),
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
SecurityBase
This is the base class for OAuth2 authentication, an instance of it would be used
as a dependency. All other OAuth2 classes inherit from it and customize it for
each OAuth2 flow.
You normally would not create a new class inheriting from it but use one of the
existing subclasses, and maybe compose them if you want to support multiple flows.
Read more about it in the
FastAPI docs for Security
.
PARAMETER
DESCRIPTION
flows
The dictionary of OAuth2 flows.
TYPE:
Union
[
OAuthFlows
,
Dict
[
str
,
Dict
[
str
,
Any
]]]
DEFAULT:
OAuthFlows
()
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If
auto_error
is set to
False
, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/oauth2.py
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
def
__init__
(
self
,
*
,
flows
:
Annotated
[
Union
[
OAuthFlowsModel
,
Dict
[
str
,
Dict
[
str
,
Any
]]],
Doc
(
"""
The dictionary of OAuth2 flows.
"""
),
]
=
OAuthFlowsModel
(),
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If `auto_error` is set to `False`, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
"""
),
]
=
True
,
):
self
.
model
=
OAuth2Model
(
flows
=
cast
(
OAuthFlowsModel
,
flows
),
description
=
description
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
OAuth2
(
flows
=
cast
(
OAuthFlows
,
flows
),
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
fastapi.security.OAuth2AuthorizationCodeBearer
OAuth2AuthorizationCodeBearer
(
authorizationUrl
,
tokenUrl
,
refreshUrl
=
None
,
scheme_name
=
None
,
scopes
=
None
,
description
=
None
,
auto_error
=
True
,
)
Bases:
OAuth2
OAuth2 flow for authentication using a bearer token obtained with an OAuth2 code
flow. An instance of it would be used as a dependency.
PARAMETER
DESCRIPTION
tokenUrl
The URL to obtain the OAuth2 token.
TYPE:
str
refreshUrl
The URL to refresh the token and obtain a new one.
TYPE:
Optional
[
str
]
DEFAULT:
None
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
scopes
The OAuth2 scopes that would be required by the
path operations
that
use this dependency.
TYPE:
Optional
[
Dict
[
str
,
str
]]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If
auto_error
is set to
False
, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/oauth2.py
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
def
__init__
(
self
,
authorizationUrl
:
str
,
tokenUrl
:
Annotated
[
str
,
Doc
(
"""
The URL to obtain the OAuth2 token.
"""
),
],
refreshUrl
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The URL to refresh the token and obtain a new one.
"""
),
]
=
None
,
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
scopes
:
Annotated
[
Optional
[
Dict
[
str
,
str
]],
Doc
(
"""
The OAuth2 scopes that would be required by the *path operations* that
use this dependency.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If `auto_error` is set to `False`, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
"""
),
]
=
True
,
):
if
not
scopes
:
scopes
=
{}
flows
=
OAuthFlowsModel
(
authorizationCode
=
cast
(
Any
,
{
"authorizationUrl"
:
authorizationUrl
,
"tokenUrl"
:
tokenUrl
,
"refreshUrl"
:
refreshUrl
,
"scopes"
:
scopes
,
},
)
)
super
()
.
__init__
(
flows
=
flows
,
scheme_name
=
scheme_name
,
description
=
description
,
auto_error
=
auto_error
,
)
model
instance-attribute
model
=
OAuth2
(
flows
=
cast
(
OAuthFlows
,
flows
),
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
fastapi.security.OAuth2PasswordBearer
OAuth2PasswordBearer
(
tokenUrl
,
scheme_name
=
None
,
scopes
=
None
,
description
=
None
,
auto_error
=
True
,
refreshUrl
=
None
,
)
Bases:
OAuth2
OAuth2 flow for authentication using a bearer token obtained with a password.
An instance of it would be used as a dependency.
Read more about it in the
FastAPI docs for Simple OAuth2 with Password and Bearer
.
PARAMETER
DESCRIPTION
tokenUrl
The URL to obtain the OAuth2 token. This would be the
path operation
that has
OAuth2PasswordRequestForm
as a dependency.
TYPE:
str
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
scopes
The OAuth2 scopes that would be required by the
path operations
that
use this dependency.
TYPE:
Optional
[
Dict
[
str
,
str
]]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If
auto_error
is set to
False
, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
TYPE:
bool
DEFAULT:
True
refreshUrl
The URL to refresh the token and obtain a new one.
TYPE:
Optional
[
str
]
DEFAULT:
None
Source code in
fastapi/security/oauth2.py
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
def
__init__
(
self
,
tokenUrl
:
Annotated
[
str
,
Doc
(
"""
The URL to obtain the OAuth2 token. This would be the *path operation*
that has `OAuth2PasswordRequestForm` as a dependency.
"""
),
],
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
scopes
:
Annotated
[
Optional
[
Dict
[
str
,
str
]],
Doc
(
"""
The OAuth2 scopes that would be required by the *path operations* that
use this dependency.
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if no HTTP Authorization header is provided, required for
OAuth2 authentication, it will automatically cancel the request and
send the client an error.
If `auto_error` is set to `False`, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OAuth2
or in a cookie).
"""
),
]
=
True
,
refreshUrl
:
Annotated
[
Optional
[
str
],
Doc
(
"""
The URL to refresh the token and obtain a new one.
"""
),
]
=
None
,
):
if
not
scopes
:
scopes
=
{}
flows
=
OAuthFlowsModel
(
password
=
cast
(
Any
,
{
"tokenUrl"
:
tokenUrl
,
"refreshUrl"
:
refreshUrl
,
"scopes"
:
scopes
,
},
)
)
super
()
.
__init__
(
flows
=
flows
,
scheme_name
=
scheme_name
,
description
=
description
,
auto_error
=
auto_error
,
)
model
instance-attribute
model
=
OAuth2
(
flows
=
cast
(
OAuthFlows
,
flows
),
description
=
description
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error
OAuth2 Password Form
fastapi.security.OAuth2PasswordRequestForm
OAuth2PasswordRequestForm
(
*
,
grant_type
=
None
,
username
,
password
,
scope
=
""
,
client_id
=
None
,
client_secret
=
None
)
This is a dependency class to collect the
username
and
password
as form data
for an OAuth2 password flow.
The OAuth2 specification dictates that for a password flow the data should be
collected using form data (instead of JSON) and that it should have the specific
fields
username
and
password
.
All the initialization parameters are extracted from the request.
Read more about it in the
FastAPI docs for Simple OAuth2 with Password and Bearer
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordRequestForm
app
=
FastAPI
()
@app
.
post
(
"/login"
)
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
data
=
{}
data
[
"scopes"
]
=
[]
for
scope
in
form_data
.
scopes
:
data
[
"scopes"
]
.
append
(
scope
)
if
form_data
.
client_id
:
data
[
"client_id"
]
=
form_data
.
client_id
if
form_data
.
client_secret
:
data
[
"client_secret"
]
=
form_data
.
client_secret
return
data
Note that for OAuth2 the scope
items:read
is a single scope in an opaque string.
You could have custom internal logic to separate it by colon characters (
:
) or
similar, and get the two parts
items
and
read
. Many applications do that to
group and organize permissions, you could do it as well in your application, just
know that that it is application specific, it's not part of the specification.
PARAMETER
DESCRIPTION
grant_type
The OAuth2 spec says it is required and MUST be the fixed string
"password". Nevertheless, this dependency class is permissive and
allows not passing it. If you want to enforce it, use instead the
OAuth2PasswordRequestFormStrict
dependency.
TYPE:
Union
[
str
, None]
DEFAULT:
None
username
username
string. The OAuth2 spec requires the exact field name
username
.
TYPE:
str
password
password
string. The OAuth2 spec requires the exact field name
`password".
TYPE:
str
scope
A single string with actually several scopes separated by spaces. Each
scope is also a string.
For example, a single string with:
```python
"items:read items:write users:read profile openid"
````
would represent the scopes:
items:read
items:write
users:read
profile
openid
TYPE:
str
DEFAULT:
''
client_id
If there's a
client_id
, it can be sent as part of the form fields.
But the OAuth2 specification recommends sending the
client_id
and
client_secret
(if any) using HTTP Basic auth.
TYPE:
Union
[
str
, None]
DEFAULT:
None
client_secret
If there's a
client_password
(and a
client_id
), they can be sent
as part of the form fields. But the OAuth2 specification recommends
sending the
client_id
and
client_secret
(if any) using HTTP Basic
auth.
TYPE:
Union
[
str
, None]
DEFAULT:
None
Source code in
fastapi/security/oauth2.py
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
def
__init__
(
self
,
*
,
grant_type
:
Annotated
[
Union
[
str
,
None
],
Form
(
pattern
=
"^password$"
),
Doc
(
"""
The OAuth2 spec says it is required and MUST be the fixed string
"password". Nevertheless, this dependency class is permissive and
allows not passing it. If you want to enforce it, use instead the
`OAuth2PasswordRequestFormStrict` dependency.
"""
),
]
=
None
,
username
:
Annotated
[
str
,
Form
(),
Doc
(
"""
`username` string. The OAuth2 spec requires the exact field name
`username`.
"""
),
],
password
:
Annotated
[
str
,
Form
(
json_schema_extra
=
{
"format"
:
"password"
}),
Doc
(
"""
`password` string. The OAuth2 spec requires the exact field name
`password".
"""
),
],
scope
:
Annotated
[
str
,
Form
(),
Doc
(
"""
A single string with actually several scopes separated by spaces. Each
scope is also a string.
For example, a single string with:
```python
"items:read items:write users:read profile openid"
````
would represent the scopes:
* `items:read`
* `items:write`
* `users:read`
* `profile`
* `openid`
"""
),
]
=
""
,
client_id
:
Annotated
[
Union
[
str
,
None
],
Form
(),
Doc
(
"""
If there's a `client_id`, it can be sent as part of the form fields.
But the OAuth2 specification recommends sending the `client_id` and
`client_secret` (if any) using HTTP Basic auth.
"""
),
]
=
None
,
client_secret
:
Annotated
[
Union
[
str
,
None
],
Form
(
json_schema_extra
=
{
"format"
:
"password"
}),
Doc
(
"""
If there's a `client_password` (and a `client_id`), they can be sent
as part of the form fields. But the OAuth2 specification recommends
sending the `client_id` and `client_secret` (if any) using HTTP Basic
auth.
"""
),
]
=
None
,
):
self
.
grant_type
=
grant_type
self
.
username
=
username
self
.
password
=
password
self
.
scopes
=
scope
.
split
()
self
.
client_id
=
client_id
self
.
client_secret
=
client_secret
grant_type
instance-attribute
grant_type
=
grant_type
username
instance-attribute
username
=
username
password
instance-attribute
password
=
password
scopes
instance-attribute
scopes
=
split
()
client_id
instance-attribute
client_id
=
client_id
client_secret
instance-attribute
client_secret
=
client_secret
fastapi.security.OAuth2PasswordRequestFormStrict
OAuth2PasswordRequestFormStrict
(
grant_type
,
username
,
password
,
scope
=
""
,
client_id
=
None
,
client_secret
=
None
,
)
Bases:
OAuth2PasswordRequestForm
This is a dependency class to collect the
username
and
password
as form data
for an OAuth2 password flow.
The OAuth2 specification dictates that for a password flow the data should be
collected using form data (instead of JSON) and that it should have the specific
fields
username
and
password
.
All the initialization parameters are extracted from the request.
The only difference between
OAuth2PasswordRequestFormStrict
and
OAuth2PasswordRequestForm
is that
OAuth2PasswordRequestFormStrict
requires the
client to send the form field
grant_type
with the value
"password"
, which
is required in the OAuth2 specification (it seems that for no particular reason),
while for
OAuth2PasswordRequestForm
grant_type
is optional.
Read more about it in the
FastAPI docs for Simple OAuth2 with Password and Bearer
.
Example
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordRequestForm
app
=
FastAPI
()
@app
.
post
(
"/login"
)
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestFormStrict
,
Depends
()]):
data
=
{}
data
[
"scopes"
]
=
[]
for
scope
in
form_data
.
scopes
:
data
[
"scopes"
]
.
append
(
scope
)
if
form_data
.
client_id
:
data
[
"client_id"
]
=
form_data
.
client_id
if
form_data
.
client_secret
:
data
[
"client_secret"
]
=
form_data
.
client_secret
return
data
Note that for OAuth2 the scope
items:read
is a single scope in an opaque string.
You could have custom internal logic to separate it by colon characters (
:
) or
similar, and get the two parts
items
and
read
. Many applications do that to
group and organize permissions, you could do it as well in your application, just
know that that it is application specific, it's not part of the specification.
the OAuth2 spec says it is required and MUST be the fixed string "password".
This dependency is strict about it. If you want to be permissive, use instead the
OAuth2PasswordRequestForm dependency class.
username: username string. The OAuth2 spec requires the exact field name "username".
password: password string. The OAuth2 spec requires the exact field name "password".
scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.
"items:read items:write users:read profile openid"
client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)
using HTTP Basic auth, as: client_id:client_secret
client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)
using HTTP Basic auth, as: client_id:client_secret
PARAMETER
DESCRIPTION
grant_type
The OAuth2 spec says it is required and MUST be the fixed string
"password". This dependency is strict about it. If you want to be
permissive, use instead the
OAuth2PasswordRequestForm
dependency
class.
TYPE:
str
username
username
string. The OAuth2 spec requires the exact field name
username
.
TYPE:
str
password
password
string. The OAuth2 spec requires the exact field name
`password".
TYPE:
str
scope
A single string with actually several scopes separated by spaces. Each
scope is also a string.
For example, a single string with:
```python
"items:read items:write users:read profile openid"
````
would represent the scopes:
items:read
items:write
users:read
profile
openid
TYPE:
str
DEFAULT:
''
client_id
If there's a
client_id
, it can be sent as part of the form fields.
But the OAuth2 specification recommends sending the
client_id
and
client_secret
(if any) using HTTP Basic auth.
TYPE:
Union
[
str
, None]
DEFAULT:
None
client_secret
If there's a
client_password
(and a
client_id
), they can be sent
as part of the form fields. But the OAuth2 specification recommends
sending the
client_id
and
client_secret
(if any) using HTTP Basic
auth.
TYPE:
Union
[
str
, None]
DEFAULT:
None
Source code in
fastapi/security/oauth2.py
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
def
__init__
(
self
,
grant_type
:
Annotated
[
str
,
Form
(
pattern
=
"^password$"
),
Doc
(
"""
The OAuth2 spec says it is required and MUST be the fixed string
"password". This dependency is strict about it. If you want to be
permissive, use instead the `OAuth2PasswordRequestForm` dependency
class.
"""
),
],
username
:
Annotated
[
str
,
Form
(),
Doc
(
"""
`username` string. The OAuth2 spec requires the exact field name
`username`.
"""
),
],
password
:
Annotated
[
str
,
Form
(),
Doc
(
"""
`password` string. The OAuth2 spec requires the exact field name
`password".
"""
),
],
scope
:
Annotated
[
str
,
Form
(),
Doc
(
"""
A single string with actually several scopes separated by spaces. Each
scope is also a string.
For example, a single string with:
```python
"items:read items:write users:read profile openid"
````
would represent the scopes:
* `items:read`
* `items:write`
* `users:read`
* `profile`
* `openid`
"""
),
]
=
""
,
client_id
:
Annotated
[
Union
[
str
,
None
],
Form
(),
Doc
(
"""
If there's a `client_id`, it can be sent as part of the form fields.
But the OAuth2 specification recommends sending the `client_id` and
`client_secret` (if any) using HTTP Basic auth.
"""
),
]
=
None
,
client_secret
:
Annotated
[
Union
[
str
,
None
],
Form
(),
Doc
(
"""
If there's a `client_password` (and a `client_id`), they can be sent
as part of the form fields. But the OAuth2 specification recommends
sending the `client_id` and `client_secret` (if any) using HTTP Basic
auth.
"""
),
]
=
None
,
):
super
()
.
__init__
(
grant_type
=
grant_type
,
username
=
username
,
password
=
password
,
scope
=
scope
,
client_id
=
client_id
,
client_secret
=
client_secret
,
)
grant_type
instance-attribute
grant_type
=
grant_type
username
instance-attribute
username
=
username
password
instance-attribute
password
=
password
scopes
instance-attribute
scopes
=
split
()
client_id
instance-attribute
client_id
=
client_id
client_secret
instance-attribute
client_secret
=
client_secret
OAuth2 Security Scopes in Dependencies
fastapi.security.SecurityScopes
SecurityScopes
(
scopes
=
None
)
This is a special class that you can define in a parameter in a dependency to
obtain the OAuth2 scopes required by all the dependencies in the same chain.
This way, multiple dependencies can have different scopes, even when used in the
same
path operation
. And with this, you can access all the scopes required in
all those dependencies in a single place.
Read more about it in the
FastAPI docs for OAuth2 scopes
.
PARAMETER
DESCRIPTION
scopes
This will be filled by FastAPI.
TYPE:
Optional
[
List
[
str
]]
DEFAULT:
None
Source code in
fastapi/security/oauth2.py
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
def
__init__
(
self
,
scopes
:
Annotated
[
Optional
[
List
[
str
]],
Doc
(
"""
This will be filled by FastAPI.
"""
),
]
=
None
,
):
self
.
scopes
:
Annotated
[
List
[
str
],
Doc
(
"""
The list of all the scopes required by dependencies.
"""
),
]
=
scopes
or
[]
self
.
scope_str
:
Annotated
[
str
,
Doc
(
"""
All the scopes required by all the dependencies in a single string
separated by spaces, as defined in the OAuth2 specification.
"""
),
]
=
" "
.
join
(
self
.
scopes
)
scopes
instance-attribute
scopes
=
scopes
or
[]
The list of all the scopes required by dependencies.
scope_str
instance-attribute
scope_str
=
join
(
scopes
)
All the scopes required by all the dependencies in a single string
separated by spaces, as defined in the OAuth2 specification.
OpenID Connect
fastapi.security.OpenIdConnect
OpenIdConnect
(
*
,
openIdConnectUrl
,
scheme_name
=
None
,
description
=
None
,
auto_error
=
True
)
Bases:
SecurityBase
OpenID Connect authentication class. An instance of it would be used as a
dependency.
PARAMETER
DESCRIPTION
openIdConnectUrl
The OpenID Connect URL.
TYPE:
str
scheme_name
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
description
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at
/docs
).
TYPE:
Optional
[
str
]
DEFAULT:
None
auto_error
By default, if no HTTP Authorization header is provided, required for
OpenID Connect authentication, it will automatically cancel the request
and send the client an error.
If
auto_error
is set to
False
, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be
None
.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OpenID
Connect or in a cookie).
TYPE:
bool
DEFAULT:
True
Source code in
fastapi/security/open_id_connect_url.py
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
def
__init__
(
self
,
*
,
openIdConnectUrl
:
Annotated
[
str
,
Doc
(
"""
The OpenID Connect URL.
"""
),
],
scheme_name
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme name.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
description
:
Annotated
[
Optional
[
str
],
Doc
(
"""
Security scheme description.
It will be included in the generated OpenAPI (e.g. visible at `/docs`).
"""
),
]
=
None
,
auto_error
:
Annotated
[
bool
,
Doc
(
"""
By default, if no HTTP Authorization header is provided, required for
OpenID Connect authentication, it will automatically cancel the request
and send the client an error.
If `auto_error` is set to `False`, when the HTTP Authorization header
is not available, instead of erroring out, the dependency result will
be `None`.
This is useful when you want to have optional authentication.
It is also useful when you want to have authentication that can be
provided in one of multiple optional ways (for example, with OpenID
Connect or in a cookie).
"""
),
]
=
True
,
):
self
.
model
=
OpenIdConnectModel
(
openIdConnectUrl
=
openIdConnectUrl
,
description
=
description
)
self
.
scheme_name
=
scheme_name
or
self
.
__class__
.
__name__
self
.
auto_error
=
auto_error
model
instance-attribute
model
=
OpenIdConnect
(
openIdConnectUrl
=
openIdConnectUrl
,
description
=
description
,
)
scheme_name
instance-attribute
scheme_name
=
scheme_name
or
__name__
auto_error
instance-attribute
auto_error
=
auto_error

## 099_REFERENCE_STATICFILES
Static Files -StaticFiles¬∂
---

Static Files -
StaticFiles
You can use the
StaticFiles
class to serve static files, like JavaScript, CSS, images, etc.
Read more about it in the
FastAPI docs for Static Files
.
You can import it directly from
fastapi.staticfiles
:
from
fastapi.staticfiles
import
StaticFiles
fastapi.staticfiles.StaticFiles
StaticFiles
(
*
,
directory
=
None
,
packages
=
None
,
html
=
False
,
check_dir
=
True
,
follow_symlink
=
False
)
Source code in
starlette/staticfiles.py
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
def
__init__
(
self
,
*
,
directory
:
PathLike
|
None
=
None
,
packages
:
list
[
str
|
tuple
[
str
,
str
]]
|
None
=
None
,
html
:
bool
=
False
,
check_dir
:
bool
=
True
,
follow_symlink
:
bool
=
False
,
)
->
None
:
self
.
directory
=
directory
self
.
packages
=
packages
self
.
all_directories
=
self
.
get_directories
(
directory
,
packages
)
self
.
html
=
html
self
.
config_checked
=
False
self
.
follow_symlink
=
follow_symlink
if
check_dir
and
directory
is
not
None
and
not
os
.
path
.
isdir
(
directory
):
raise
RuntimeError
(
f
"Directory '
{
directory
}
' does not exist"
)
directory
instance-attribute
directory
=
directory
packages
instance-attribute
packages
=
packages
all_directories
instance-attribute
all_directories
=
get_directories
(
directory
,
packages
)
html
instance-attribute
html
=
html
config_checked
instance-attribute
config_checked
=
False
follow_symlink
instance-attribute
follow_symlink
=
follow_symlink
get_directories
get_directories
(
directory
=
None
,
packages
=
None
)
Given
directory
and
packages
arguments, return a list of all the
directories that should be used for serving static files from.
Source code in
starlette/staticfiles.py
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
def
get_directories
(
self
,
directory
:
PathLike
|
None
=
None
,
packages
:
list
[
str
|
tuple
[
str
,
str
]]
|
None
=
None
,
)
->
list
[
PathLike
]:
"""
Given `directory` and `packages` arguments, return a list of all the
directories that should be used for serving static files from.
"""
directories
=
[]
if
directory
is
not
None
:
directories
.
append
(
directory
)
for
package
in
packages
or
[]:
if
isinstance
(
package
,
tuple
):
package
,
statics_dir
=
package
else
:
statics_dir
=
"statics"
spec
=
importlib
.
util
.
find_spec
(
package
)
assert
spec
is
not
None
,
f
"Package
{
package
!r}
could not be found."
assert
spec
.
origin
is
not
None
,
f
"Package
{
package
!r}
could not be found."
package_directory
=
os
.
path
.
normpath
(
os
.
path
.
join
(
spec
.
origin
,
".."
,
statics_dir
))
assert
os
.
path
.
isdir
(
package_directory
),
(
f
"Directory '
{
statics_dir
!r}
' in package
{
package
!r}
could not be found."
)
directories
.
append
(
package_directory
)
return
directories
get_path
get_path
(
scope
)
Given the ASGI scope, return the
path
string to serve up,
with OS specific path separators, and any '..', '.' components removed.
Source code in
starlette/staticfiles.py
101
102
103
104
105
106
107
def
get_path
(
self
,
scope
:
Scope
)
->
str
:
"""
Given the ASGI scope, return the `path` string to serve up,
with OS specific path separators, and any '..', '.' components removed.
"""
route_path
=
get_route_path
(
scope
)
return
os
.
path
.
normpath
(
os
.
path
.
join
(
*
route_path
.
split
(
"/"
)))
get_response
async
get_response
(
path
,
scope
)
Returns an HTTP response, given the incoming path, method and request headers.
Source code in
starlette/staticfiles.py
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
async
def
get_response
(
self
,
path
:
str
,
scope
:
Scope
)
->
Response
:
"""
Returns an HTTP response, given the incoming path, method and request headers.
"""
if
scope
[
"method"
]
not
in
(
"GET"
,
"HEAD"
):
raise
HTTPException
(
status_code
=
405
)
try
:
full_path
,
stat_result
=
await
anyio
.
to_thread
.
run_sync
(
self
.
lookup_path
,
path
)
except
PermissionError
:
raise
HTTPException
(
status_code
=
401
)
except
OSError
as
exc
:
## Filename is too long, so it can't be a valid static file.
if
exc
.
errno
==
errno
.
ENAMETOOLONG
:
raise
HTTPException
(
status_code
=
404
)
raise
exc
if
stat_result
and
stat
.
S_ISREG
(
stat_result
.
st_mode
):
## We have a static file to serve.
return
self
.
file_response
(
full_path
,
stat_result
,
scope
)
elif
stat_result
and
stat
.
S_ISDIR
(
stat_result
.
st_mode
)
and
self
.
html
:
## We're in HTML mode, and have got a directory URL.
## Check if we have 'index.html' file to serve.
index_path
=
os
.
path
.
join
(
path
,
"index.html"
)
full_path
,
stat_result
=
await
anyio
.
to_thread
.
run_sync
(
self
.
lookup_path
,
index_path
)
if
stat_result
is
not
None
and
stat
.
S_ISREG
(
stat_result
.
st_mode
):
if
not
scope
[
"path"
]
.
endswith
(
"/"
):
## Directory URLs should redirect to always end in "/".
url
=
URL
(
scope
=
scope
)
url
=
url
.
replace
(
path
=
url
.
path
+
"/"
)
return
RedirectResponse
(
url
=
url
)
return
self
.
file_response
(
full_path
,
stat_result
,
scope
)
if
self
.
html
:
## Check for '404.html' if we're in HTML mode.
full_path
,
stat_result
=
await
anyio
.
to_thread
.
run_sync
(
self
.
lookup_path
,
"404.html"
)
if
stat_result
and
stat
.
S_ISREG
(
stat_result
.
st_mode
):
return
FileResponse
(
full_path
,
stat_result
=
stat_result
,
status_code
=
404
)
raise
HTTPException
(
status_code
=
404
)
lookup_path
lookup_path
(
path
)
Source code in
starlette/staticfiles.py
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
def
lookup_path
(
self
,
path
:
str
)
->
tuple
[
str
,
os
.
stat_result
|
None
]:
for
directory
in
self
.
all_directories
:
joined_path
=
os
.
path
.
join
(
directory
,
path
)
if
self
.
follow_symlink
:
full_path
=
os
.
path
.
abspath
(
joined_path
)
directory
=
os
.
path
.
abspath
(
directory
)
else
:
full_path
=
os
.
path
.
realpath
(
joined_path
)
directory
=
os
.
path
.
realpath
(
directory
)
if
os
.
path
.
commonpath
([
full_path
,
directory
])
!=
str
(
directory
):
## Don't allow misbehaving clients to break out of the static files directory.
continue
try
:
return
full_path
,
os
.
stat
(
full_path
)
except
(
FileNotFoundError
,
NotADirectoryError
):
continue
return
""
,
None
file_response
file_response
(
full_path
,
stat_result
,
scope
,
status_code
=
200
)
Source code in
starlette/staticfiles.py
169
170
171
172
173
174
175
176
177
178
179
180
181
def
file_response
(
self
,
full_path
:
PathLike
,
stat_result
:
os
.
stat_result
,
scope
:
Scope
,
status_code
:
int
=
200
,
)
->
Response
:
request_headers
=
Headers
(
scope
=
scope
)
response
=
FileResponse
(
full_path
,
status_code
=
status_code
,
stat_result
=
stat_result
)
if
self
.
is_not_modified
(
response
.
headers
,
request_headers
):
return
NotModifiedResponse
(
response
.
headers
)
return
response
check_config
async
check_config
()
Perform a one-off configuration check that StaticFiles is actually
pointed at a directory, so that we can raise loud errors rather than
just returning 404 responses.
Source code in
starlette/staticfiles.py
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
async
def
check_config
(
self
)
->
None
:
"""
Perform a one-off configuration check that StaticFiles is actually
pointed at a directory, so that we can raise loud errors rather than
just returning 404 responses.
"""
if
self
.
directory
is
None
:
return
try
:
stat_result
=
await
anyio
.
to_thread
.
run_sync
(
os
.
stat
,
self
.
directory
)
except
FileNotFoundError
:
raise
RuntimeError
(
f
"StaticFiles directory '
{
self
.
directory
}
' does not exist."
)
if
not
(
stat
.
S_ISDIR
(
stat_result
.
st_mode
)
or
stat
.
S_ISLNK
(
stat_result
.
st_mode
)):
raise
RuntimeError
(
f
"StaticFiles path '
{
self
.
directory
}
' is not a directory."
)
is_not_modified
is_not_modified
(
response_headers
,
request_headers
)
Given the request and response headers, return
True
if an HTTP
"Not Modified" response could be returned instead.
Source code in
starlette/staticfiles.py
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
def
is_not_modified
(
self
,
response_headers
:
Headers
,
request_headers
:
Headers
)
->
bool
:
"""
Given the request and response headers, return `True` if an HTTP
"Not Modified" response could be returned instead.
"""
try
:
if_none_match
=
request_headers
[
"if-none-match"
]
etag
=
response_headers
[
"etag"
]
if
etag
in
[
tag
.
strip
(
" W/"
)
for
tag
in
if_none_match
.
split
(
","
)]:
return
True
except
KeyError
:
pass
try
:
if_modified_since
=
parsedate
(
request_headers
[
"if-modified-since"
])
last_modified
=
parsedate
(
response_headers
[
"last-modified"
])
if
if_modified_since
is
not
None
and
last_modified
is
not
None
and
if_modified_since
>=
last_modified
:
return
True
except
KeyError
:
pass
return
False

## 100_REFERENCE_STATUS
Status Codes¬∂
---

Status Codes
You can import the
status
module from
fastapi
:
from
fastapi
import
status
status
is provided directly by Starlette.
It contains a group of named constants (variables) with integer status codes.
For example:
200:
status.HTTP_200_OK
403:
status.HTTP_403_FORBIDDEN
etc.
It can be convenient to quickly access HTTP (and WebSocket) status codes in your app, using autocompletion for the name without having to remember the integer status codes by memory.
Read more about it in the
FastAPI docs about Response Status Code
.
Example
from
fastapi
import
FastAPI
,
status
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
status_code
=
status
.
HTTP_418_IM_A_TEAPOT
)
def
read_items
():
return
[{
"name"
:
"Plumbus"
},
{
"name"
:
"Portal Gun"
}]
fastapi.status
HTTP codes
See HTTP Status Code Registry:
https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
And RFC 2324 - https://tools.ietf.org/html/rfc2324
HTTP_100_CONTINUE
module-attribute
HTTP_100_CONTINUE
=
100
HTTP_101_SWITCHING_PROTOCOLS
module-attribute
HTTP_101_SWITCHING_PROTOCOLS
=
101
HTTP_102_PROCESSING
module-attribute
HTTP_102_PROCESSING
=
102
HTTP_103_EARLY_HINTS
module-attribute
HTTP_103_EARLY_HINTS
=
103
HTTP_200_OK
module-attribute
HTTP_200_OK
=
200
HTTP_201_CREATED
module-attribute
HTTP_201_CREATED
=
201
HTTP_202_ACCEPTED
module-attribute
HTTP_202_ACCEPTED
=
202
HTTP_203_NON_AUTHORITATIVE_INFORMATION
module-attribute
HTTP_203_NON_AUTHORITATIVE_INFORMATION
=
203
HTTP_204_NO_CONTENT
module-attribute
HTTP_204_NO_CONTENT
=
204
HTTP_205_RESET_CONTENT
module-attribute
HTTP_205_RESET_CONTENT
=
205
HTTP_206_PARTIAL_CONTENT
module-attribute
HTTP_206_PARTIAL_CONTENT
=
206
HTTP_207_MULTI_STATUS
module-attribute
HTTP_207_MULTI_STATUS
=
207
HTTP_208_ALREADY_REPORTED
module-attribute
HTTP_208_ALREADY_REPORTED
=
208
HTTP_226_IM_USED
module-attribute
HTTP_226_IM_USED
=
226
HTTP_300_MULTIPLE_CHOICES
module-attribute
HTTP_300_MULTIPLE_CHOICES
=
300
HTTP_301_MOVED_PERMANENTLY
module-attribute
HTTP_301_MOVED_PERMANENTLY
=
301
HTTP_302_FOUND
module-attribute
HTTP_302_FOUND
=
302
HTTP_303_SEE_OTHER
module-attribute
HTTP_303_SEE_OTHER
=
303
HTTP_304_NOT_MODIFIED
module-attribute
HTTP_304_NOT_MODIFIED
=
304
HTTP_305_USE_PROXY
module-attribute
HTTP_305_USE_PROXY
=
305
HTTP_306_RESERVED
module-attribute
HTTP_306_RESERVED
=
306
HTTP_307_TEMPORARY_REDIRECT
module-attribute
HTTP_307_TEMPORARY_REDIRECT
=
307
HTTP_308_PERMANENT_REDIRECT
module-attribute
HTTP_308_PERMANENT_REDIRECT
=
308
HTTP_400_BAD_REQUEST
module-attribute
HTTP_400_BAD_REQUEST
=
400
HTTP_401_UNAUTHORIZED
module-attribute
HTTP_401_UNAUTHORIZED
=
401
HTTP_402_PAYMENT_REQUIRED
module-attribute
HTTP_402_PAYMENT_REQUIRED
=
402
HTTP_403_FORBIDDEN
module-attribute
HTTP_403_FORBIDDEN
=
403
HTTP_404_NOT_FOUND
module-attribute
HTTP_404_NOT_FOUND
=
404
HTTP_405_METHOD_NOT_ALLOWED
module-attribute
HTTP_405_METHOD_NOT_ALLOWED
=
405
HTTP_406_NOT_ACCEPTABLE
module-attribute
HTTP_406_NOT_ACCEPTABLE
=
406
HTTP_407_PROXY_AUTHENTICATION_REQUIRED
module-attribute
HTTP_407_PROXY_AUTHENTICATION_REQUIRED
=
407
HTTP_408_REQUEST_TIMEOUT
module-attribute
HTTP_408_REQUEST_TIMEOUT
=
408
HTTP_409_CONFLICT
module-attribute
HTTP_409_CONFLICT
=
409
HTTP_410_GONE
module-attribute
HTTP_410_GONE
=
410
HTTP_411_LENGTH_REQUIRED
module-attribute
HTTP_411_LENGTH_REQUIRED
=
411
HTTP_412_PRECONDITION_FAILED
module-attribute
HTTP_412_PRECONDITION_FAILED
=
412
HTTP_413_REQUEST_ENTITY_TOO_LARGE
module-attribute
HTTP_413_REQUEST_ENTITY_TOO_LARGE
=
413
HTTP_414_REQUEST_URI_TOO_LONG
module-attribute
HTTP_414_REQUEST_URI_TOO_LONG
=
414
HTTP_415_UNSUPPORTED_MEDIA_TYPE
module-attribute
HTTP_415_UNSUPPORTED_MEDIA_TYPE
=
415
HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE
module-attribute
HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE
=
416
HTTP_417_EXPECTATION_FAILED
module-attribute
HTTP_417_EXPECTATION_FAILED
=
417
HTTP_418_IM_A_TEAPOT
module-attribute
HTTP_418_IM_A_TEAPOT
=
418
HTTP_421_MISDIRECTED_REQUEST
module-attribute
HTTP_421_MISDIRECTED_REQUEST
=
421
HTTP_422_UNPROCESSABLE_ENTITY
module-attribute
HTTP_422_UNPROCESSABLE_ENTITY
=
422
HTTP_423_LOCKED
module-attribute
HTTP_423_LOCKED
=
423
HTTP_424_FAILED_DEPENDENCY
module-attribute
HTTP_424_FAILED_DEPENDENCY
=
424
HTTP_425_TOO_EARLY
module-attribute
HTTP_425_TOO_EARLY
=
425
HTTP_426_UPGRADE_REQUIRED
module-attribute
HTTP_426_UPGRADE_REQUIRED
=
426
HTTP_428_PRECONDITION_REQUIRED
module-attribute
HTTP_428_PRECONDITION_REQUIRED
=
428
HTTP_429_TOO_MANY_REQUESTS
module-attribute
HTTP_429_TOO_MANY_REQUESTS
=
429
HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE
module-attribute
HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE
=
431
HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS
module-attribute
HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS
=
451
HTTP_500_INTERNAL_SERVER_ERROR
module-attribute
HTTP_500_INTERNAL_SERVER_ERROR
=
500
HTTP_501_NOT_IMPLEMENTED
module-attribute
HTTP_501_NOT_IMPLEMENTED
=
501
HTTP_502_BAD_GATEWAY
module-attribute
HTTP_502_BAD_GATEWAY
=
502
HTTP_503_SERVICE_UNAVAILABLE
module-attribute
HTTP_503_SERVICE_UNAVAILABLE
=
503
HTTP_504_GATEWAY_TIMEOUT
module-attribute
HTTP_504_GATEWAY_TIMEOUT
=
504
HTTP_505_HTTP_VERSION_NOT_SUPPORTED
module-attribute
HTTP_505_HTTP_VERSION_NOT_SUPPORTED
=
505
HTTP_506_VARIANT_ALSO_NEGOTIATES
module-attribute
HTTP_506_VARIANT_ALSO_NEGOTIATES
=
506
HTTP_507_INSUFFICIENT_STORAGE
module-attribute
HTTP_507_INSUFFICIENT_STORAGE
=
507
HTTP_508_LOOP_DETECTED
module-attribute
HTTP_508_LOOP_DETECTED
=
508
HTTP_510_NOT_EXTENDED
module-attribute
HTTP_510_NOT_EXTENDED
=
510
HTTP_511_NETWORK_AUTHENTICATION_REQUIRED
module-attribute
HTTP_511_NETWORK_AUTHENTICATION_REQUIRED
=
511
WebSocket codes
https://www.iana.org/assignments/websocket/websocket.xml#close-code-number
https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
WS_1000_NORMAL_CLOSURE
module-attribute
WS_1000_NORMAL_CLOSURE
=
1000
WS_1001_GOING_AWAY
module-attribute
WS_1001_GOING_AWAY
=
1001
WS_1002_PROTOCOL_ERROR
module-attribute
WS_1002_PROTOCOL_ERROR
=
1002
WS_1003_UNSUPPORTED_DATA
module-attribute
WS_1003_UNSUPPORTED_DATA
=
1003
WS_1005_NO_STATUS_RCVD
module-attribute
WS_1005_NO_STATUS_RCVD
=
1005
WS_1006_ABNORMAL_CLOSURE
module-attribute
WS_1006_ABNORMAL_CLOSURE
=
1006
WS_1007_INVALID_FRAME_PAYLOAD_DATA
module-attribute
WS_1007_INVALID_FRAME_PAYLOAD_DATA
=
1007
WS_1008_POLICY_VIOLATION
module-attribute
WS_1008_POLICY_VIOLATION
=
1008
WS_1009_MESSAGE_TOO_BIG
module-attribute
WS_1009_MESSAGE_TOO_BIG
=
1009
WS_1010_MANDATORY_EXT
module-attribute
WS_1010_MANDATORY_EXT
=
1010
WS_1011_INTERNAL_ERROR
module-attribute
WS_1011_INTERNAL_ERROR
=
1011
WS_1012_SERVICE_RESTART
module-attribute
WS_1012_SERVICE_RESTART
=
1012
WS_1013_TRY_AGAIN_LATER
module-attribute
WS_1013_TRY_AGAIN_LATER
=
1013
WS_1014_BAD_GATEWAY
module-attribute
WS_1014_BAD_GATEWAY
=
1014
WS_1015_TLS_HANDSHAKE
module-attribute
WS_1015_TLS_HANDSHAKE
=
1015

## 101_REFERENCE_TEMPLATING
Templating -Jinja2Templates¬∂
---

Templating -
Jinja2Templates
You can use the
Jinja2Templates
class to render Jinja templates.
Read more about it in the
FastAPI docs for Templates
.
You can import it directly from
fastapi.templating
:
from
fastapi.templating
import
Jinja2Templates
fastapi.templating.Jinja2Templates
Jinja2Templates
(
directory
:
(
str
|
PathLike
[
str
]
|
Sequence
[
str
|
PathLike
[
str
]]
),
*
,
context_processors
:
(
list
[
Callable
[[
Request
],
dict
[
str
,
Any
]]]
|
None
)
=
None
,
**
env_options
:
Any
)
Jinja2Templates
(
*
,
env
:
Environment
,
context_processors
:
(
list
[
Callable
[[
Request
],
dict
[
str
,
Any
]]]
|
None
)
=
None
)
Jinja2Templates
(
directory
=
None
,
*
,
context_processors
=
None
,
env
=
None
,
**
env_options
)
templates = Jinja2Templates("templates")
return templates.TemplateResponse("index.html", {"request": request})
Source code in
starlette/templating.py
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
def
__init__
(
self
,
directory
:
str
|
PathLike
[
str
]
|
typing
.
Sequence
[
str
|
PathLike
[
str
]]
|
None
=
None
,
*
,
context_processors
:
list
[
typing
.
Callable
[[
Request
],
dict
[
str
,
typing
.
Any
]]]
|
None
=
None
,
env
:
jinja2
.
Environment
|
None
=
None
,
**
env_options
:
typing
.
Any
,
)
->
None
:
if
env_options
:
warnings
.
warn
(
"Extra environment options are deprecated. Use a preconfigured jinja2.Environment instead."
,
DeprecationWarning
,
)
assert
jinja2
is
not
None
,
"jinja2 must be installed to use Jinja2Templates"
assert
bool
(
directory
)
^
bool
(
env
),
"either 'directory' or 'env' arguments must be passed"
self
.
context_processors
=
context_processors
or
[]
if
directory
is
not
None
:
self
.
env
=
self
.
_create_env
(
directory
,
**
env_options
)
elif
env
is
not
None
:
## pragma: no branch
self
.
env
=
env
self
.
_setup_env_defaults
(
self
.
env
)
context_processors
instance-attribute
context_processors
=
context_processors
or
[]
env
instance-attribute
env
=
_create_env
(
directory
,
**
env_options
)
get_template
get_template
(
name
)
Source code in
starlette/templating.py
130
131
def
get_template
(
self
,
name
:
str
)
->
jinja2
.
Template
:
return
self
.
env
.
get_template
(
name
)
TemplateResponse
TemplateResponse
(
request
:
Request
,
name
:
str
,
context
:
dict
[
str
,
Any
]
|
None
=
None
,
status_code
:
int
=
200
,
headers
:
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
_TemplateResponse
TemplateResponse
(
name
:
str
,
context
:
dict
[
str
,
Any
]
|
None
=
None
,
status_code
:
int
=
200
,
headers
:
Mapping
[
str
,
str
]
|
None
=
None
,
media_type
:
str
|
None
=
None
,
background
:
BackgroundTask
|
None
=
None
,
)
->
_TemplateResponse
TemplateResponse
(
*
args
,
**
kwargs
)
Source code in
starlette/templating.py
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
def
TemplateResponse
(
self
,
*
args
:
typing
.
Any
,
**
kwargs
:
typing
.
Any
)
->
_TemplateResponse
:
if
args
:
if
isinstance
(
args
[
0
],
str
):
## the first argument is template name (old style)
warnings
.
warn
(
"The `name` is not the first parameter anymore. "
"The first parameter should be the `Request` instance.
\n
"
'Replace `TemplateResponse(name, {"request": request})` by `TemplateResponse(request, name)`.'
,
DeprecationWarning
,
)
name
=
args
[
0
]
context
=
args
[
1
]
if
len
(
args
)
>
1
else
kwargs
.
get
(
"context"
,
{})
status_code
=
args
[
2
]
if
len
(
args
)
>
2
else
kwargs
.
get
(
"status_code"
,
200
)
headers
=
args
[
3
]
if
len
(
args
)
>
3
else
kwargs
.
get
(
"headers"
)
media_type
=
args
[
4
]
if
len
(
args
)
>
4
else
kwargs
.
get
(
"media_type"
)
background
=
args
[
5
]
if
len
(
args
)
>
5
else
kwargs
.
get
(
"background"
)
if
"request"
not
in
context
:
raise
ValueError
(
'context must include a "request" key'
)
request
=
context
[
"request"
]
else
:
## the first argument is a request instance (new style)
request
=
args
[
0
]
name
=
args
[
1
]
if
len
(
args
)
>
1
else
kwargs
[
"name"
]
context
=
args
[
2
]
if
len
(
args
)
>
2
else
kwargs
.
get
(
"context"
,
{})
status_code
=
args
[
3
]
if
len
(
args
)
>
3
else
kwargs
.
get
(
"status_code"
,
200
)
headers
=
args
[
4
]
if
len
(
args
)
>
4
else
kwargs
.
get
(
"headers"
)
media_type
=
args
[
5
]
if
len
(
args
)
>
5
else
kwargs
.
get
(
"media_type"
)
background
=
args
[
6
]
if
len
(
args
)
>
6
else
kwargs
.
get
(
"background"
)
else
:
## all arguments are kwargs
if
"request"
not
in
kwargs
:
warnings
.
warn
(
"The `TemplateResponse` now requires the `request` argument.
\n
"
'Replace `TemplateResponse(name, {"context": context})` by `TemplateResponse(request, name)`.'
,
DeprecationWarning
,
)
if
"request"
not
in
kwargs
.
get
(
"context"
,
{}):
raise
ValueError
(
'context must include a "request" key'
)
context
=
kwargs
.
get
(
"context"
,
{})
request
=
kwargs
.
get
(
"request"
,
context
.
get
(
"request"
))
name
=
typing
.
cast
(
str
,
kwargs
[
"name"
])
status_code
=
kwargs
.
get
(
"status_code"
,
200
)
headers
=
kwargs
.
get
(
"headers"
)
media_type
=
kwargs
.
get
(
"media_type"
)
background
=
kwargs
.
get
(
"background"
)
context
.
setdefault
(
"request"
,
request
)
for
context_processor
in
self
.
context_processors
:
context
.
update
(
context_processor
(
request
))
template
=
self
.
get_template
(
name
)
return
_TemplateResponse
(
template
,
context
,
status_code
=
status_code
,
headers
=
headers
,
media_type
=
media_type
,
background
=
background
,
)

## 102_REFERENCE_TESTCLIENT
Test Client -TestClient¬∂
---

Test Client -
TestClient
You can use the
TestClient
class to test FastAPI applications without creating an actual HTTP and socket connection, just communicating directly with the FastAPI code.
Read more about it in the
FastAPI docs for Testing
.
You can import it directly from
fastapi.testclient
:
from
fastapi.testclient
import
TestClient
fastapi.testclient.TestClient
TestClient
(
app
,
base_url
=
"http://testserver"
,
raise_server_exceptions
=
True
,
root_path
=
""
,
backend
=
"asyncio"
,
backend_options
=
None
,
cookies
=
None
,
headers
=
None
,
follow_redirects
=
True
,
client
=
(
"testclient"
,
50000
),
)
Bases:
Client
Source code in
starlette/testclient.py
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
def
__init__
(
self
,
app
:
ASGIApp
,
base_url
:
str
=
"http://testserver"
,
raise_server_exceptions
:
bool
=
True
,
root_path
:
str
=
""
,
backend
:
typing
.
Literal
[
"asyncio"
,
"trio"
]
=
"asyncio"
,
backend_options
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
headers
:
dict
[
str
,
str
]
|
None
=
None
,
follow_redirects
:
bool
=
True
,
client
:
tuple
[
str
,
int
]
=
(
"testclient"
,
50000
),
)
->
None
:
self
.
async_backend
=
_AsyncBackend
(
backend
=
backend
,
backend_options
=
backend_options
or
{})
if
_is_asgi3
(
app
):
asgi_app
=
app
else
:
app
=
typing
.
cast
(
ASGI2App
,
app
)
## type: ignore[assignment]
asgi_app
=
_WrapASGI2
(
app
)
## type: ignore[arg-type]
self
.
app
=
asgi_app
self
.
app_state
:
dict
[
str
,
typing
.
Any
]
=
{}
transport
=
_TestClientTransport
(
self
.
app
,
portal_factory
=
self
.
_portal_factory
,
raise_server_exceptions
=
raise_server_exceptions
,
root_path
=
root_path
,
app_state
=
self
.
app_state
,
client
=
client
,
)
if
headers
is
None
:
headers
=
{}
headers
.
setdefault
(
"user-agent"
,
"testclient"
)
super
()
.
__init__
(
base_url
=
base_url
,
headers
=
headers
,
transport
=
transport
,
follow_redirects
=
follow_redirects
,
cookies
=
cookies
,
)
headers
property
writable
headers
HTTP headers to include when sending requests.
follow_redirects
instance-attribute
follow_redirects
=
follow_redirects
max_redirects
instance-attribute
max_redirects
=
max_redirects
is_closed
property
is_closed
Check if the client being closed
trust_env
property
trust_env
timeout
property
writable
timeout
event_hooks
property
writable
event_hooks
auth
property
writable
auth
Authentication class used when none is passed at the request-level.
See also
Authentication
.
base_url
property
writable
base_url
Base URL to use when sending requests with relative URLs.
cookies
property
writable
cookies
Cookie values to include when sending requests.
params
property
writable
params
Query parameters to include in the URL when sending requests.
task
instance-attribute
task
portal
class-attribute
instance-attribute
portal
=
None
async_backend
instance-attribute
async_backend
=
_AsyncBackend
(
backend
=
backend
,
backend_options
=
backend_options
or
{}
)
app
instance-attribute
app
=
asgi_app
app_state
instance-attribute
app_state
=
{}
build_request
build_request
(
method
,
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Build and return a request instance.
The
params
,
headers
and
cookies
arguments
are merged with any values set on the client.
The
url
argument is merged with any
base_url
set on the client.
See also:
Request instances
Source code in
httpx/_client.py
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
def
build_request
(
self
,
method
:
str
,
url
:
URL
|
str
,
*
,
content
:
RequestContent
|
None
=
None
,
data
:
RequestData
|
None
=
None
,
files
:
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
|
None
=
None
,
params
:
QueryParamTypes
|
None
=
None
,
headers
:
HeaderTypes
|
None
=
None
,
cookies
:
CookieTypes
|
None
=
None
,
timeout
:
TimeoutTypes
|
UseClientDefault
=
USE_CLIENT_DEFAULT
,
extensions
:
RequestExtensions
|
None
=
None
,
)
->
Request
:
"""
Build and return a request instance.
* The `params`, `headers` and `cookies` arguments
are merged with any values set on the client.
* The `url` argument is merged with any `base_url` set on the client.
See also: [Request instances][0]
[0]: /advanced/clients/#request-instances
"""
url
=
self
.
_merge_url
(
url
)
headers
=
self
.
_merge_headers
(
headers
)
cookies
=
self
.
_merge_cookies
(
cookies
)
params
=
self
.
_merge_queryparams
(
params
)
extensions
=
{}
if
extensions
is
None
else
extensions
if
"timeout"
not
in
extensions
:
timeout
=
(
self
.
timeout
if
isinstance
(
timeout
,
UseClientDefault
)
else
Timeout
(
timeout
)
)
extensions
=
dict
(
**
extensions
,
timeout
=
timeout
.
as_dict
())
return
Request
(
method
,
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
extensions
=
extensions
,
)
stream
stream
(
method
,
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Alternative to
httpx.request()
that streams the response body
instead of loading it into memory at once.
Parameters
: See
httpx.request
.
See also:
Streaming Responses
Source code in
httpx/_client.py
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
@contextmanager
def
stream
(
self
,
method
:
str
,
url
:
URL
|
str
,
*
,
content
:
RequestContent
|
None
=
None
,
data
:
RequestData
|
None
=
None
,
files
:
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
|
None
=
None
,
params
:
QueryParamTypes
|
None
=
None
,
headers
:
HeaderTypes
|
None
=
None
,
cookies
:
CookieTypes
|
None
=
None
,
auth
:
AuthTypes
|
UseClientDefault
|
None
=
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
UseClientDefault
=
USE_CLIENT_DEFAULT
,
timeout
:
TimeoutTypes
|
UseClientDefault
=
USE_CLIENT_DEFAULT
,
extensions
:
RequestExtensions
|
None
=
None
,
)
->
typing
.
Iterator
[
Response
]:
"""
Alternative to `httpx.request()` that streams the response body
instead of loading it into memory at once.
**Parameters**: See `httpx.request`.
See also: [Streaming Responses][0]
[0]: /quickstart#streaming-responses
"""
request
=
self
.
build_request
(
method
=
method
,
url
=
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
timeout
=
timeout
,
extensions
=
extensions
,
)
response
=
self
.
send
(
request
=
request
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
stream
=
True
,
)
try
:
yield
response
finally
:
response
.
close
()
send
send
(
request
,
*
,
stream
=
False
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
)
Send a request.
The request is sent as-is, unmodified.
Typically you'll want to build one with
Client.build_request()
so that any client-level configuration is merged into the request,
but passing an explicit
httpx.Request()
is supported as well.
See also:
Request instances
Source code in
httpx/_client.py
891
892
893
894
895
896
897
898
899
900
901
902
903
904
905
906
907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924
925
926
927
928
929
930
931
932
933
934
935
936
937
938
939
940
def
send
(
self
,
request
:
Request
,
*
,
stream
:
bool
=
False
,
auth
:
AuthTypes
|
UseClientDefault
|
None
=
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
UseClientDefault
=
USE_CLIENT_DEFAULT
,
)
->
Response
:
"""
Send a request.
The request is sent as-is, unmodified.
Typically you'll want to build one with `Client.build_request()`
so that any client-level configuration is merged into the request,
but passing an explicit `httpx.Request()` is supported as well.
See also: [Request instances][0]
[0]: /advanced/clients/#request-instances
"""
if
self
.
_state
==
ClientState
.
CLOSED
:
raise
RuntimeError
(
"Cannot send a request, as the client has been closed."
)
self
.
_state
=
ClientState
.
OPENED
follow_redirects
=
(
self
.
follow_redirects
if
isinstance
(
follow_redirects
,
UseClientDefault
)
else
follow_redirects
)
self
.
_set_timeout
(
request
)
auth
=
self
.
_build_request_auth
(
request
,
auth
)
response
=
self
.
_send_handling_auth
(
request
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
history
=
[],
)
try
:
if
not
stream
:
response
.
read
()
return
response
except
BaseException
as
exc
:
response
.
close
()
raise
exc
close
close
()
Close transport and proxies.
Source code in
httpx/_client.py
1276
1277
1278
1279
1280
1281
1282
1283
1284
1285
1286
def
close
(
self
)
->
None
:
"""
Close transport and proxies.
"""
if
self
.
_state
!=
ClientState
.
CLOSED
:
self
.
_state
=
ClientState
.
CLOSED
self
.
_transport
.
close
()
for
transport
in
self
.
_mounts
.
values
():
if
transport
is
not
None
:
transport
.
close
()
request
request
(
method
,
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
def
request
(
## type: ignore[override]
self
,
method
:
str
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
content
:
httpx
.
_types
.
RequestContent
|
None
=
None
,
data
:
_RequestData
|
None
=
None
,
files
:
httpx
.
_types
.
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
=
None
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
if
timeout
is
not
httpx
.
USE_CLIENT_DEFAULT
:
warnings
.
warn
(
"You should not use the 'timeout' argument with the TestClient. "
"See https://github.com/encode/starlette/issues/1108 for more information."
,
DeprecationWarning
,
)
url
=
self
.
_merge_url
(
url
)
return
super
()
.
request
(
method
,
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
get
get
(
url
,
*
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
def
get
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
get
(
url
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
options
options
(
url
,
*
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
def
options
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
options
(
url
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
head
head
(
url
,
*
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
def
head
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
head
(
url
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
post
post
(
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
def
post
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
content
:
httpx
.
_types
.
RequestContent
|
None
=
None
,
data
:
_RequestData
|
None
=
None
,
files
:
httpx
.
_types
.
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
=
None
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
post
(
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
put
put
(
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
def
put
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
content
:
httpx
.
_types
.
RequestContent
|
None
=
None
,
data
:
_RequestData
|
None
=
None
,
files
:
httpx
.
_types
.
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
=
None
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
put
(
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
patch
patch
(
url
,
*
,
content
=
None
,
data
=
None
,
files
=
None
,
json
=
None
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
def
patch
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
content
:
httpx
.
_types
.
RequestContent
|
None
=
None
,
data
:
_RequestData
|
None
=
None
,
files
:
httpx
.
_types
.
RequestFiles
|
None
=
None
,
json
:
typing
.
Any
=
None
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
patch
(
url
,
content
=
content
,
data
=
data
,
files
=
files
,
json
=
json
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
delete
delete
(
url
,
*
,
params
=
None
,
headers
=
None
,
cookies
=
None
,
auth
=
USE_CLIENT_DEFAULT
,
follow_redirects
=
USE_CLIENT_DEFAULT
,
timeout
=
USE_CLIENT_DEFAULT
,
extensions
=
None
)
Source code in
starlette/testclient.py
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
def
delete
(
## type: ignore[override]
self
,
url
:
httpx
.
_types
.
URLTypes
,
*
,
params
:
httpx
.
_types
.
QueryParamTypes
|
None
=
None
,
headers
:
httpx
.
_types
.
HeaderTypes
|
None
=
None
,
cookies
:
httpx
.
_types
.
CookieTypes
|
None
=
None
,
auth
:
httpx
.
_types
.
AuthTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
follow_redirects
:
bool
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
timeout
:
httpx
.
_types
.
TimeoutTypes
|
httpx
.
_client
.
UseClientDefault
=
httpx
.
_client
.
USE_CLIENT_DEFAULT
,
extensions
:
dict
[
str
,
typing
.
Any
]
|
None
=
None
,
)
->
httpx
.
Response
:
return
super
()
.
delete
(
url
,
params
=
params
,
headers
=
headers
,
cookies
=
cookies
,
auth
=
auth
,
follow_redirects
=
follow_redirects
,
timeout
=
timeout
,
extensions
=
extensions
,
)
websocket_connect
websocket_connect
(
url
,
subprotocols
=
None
,
**
kwargs
)
Source code in
starlette/testclient.py
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
def
websocket_connect
(
self
,
url
:
str
,
subprotocols
:
typing
.
Sequence
[
str
]
|
None
=
None
,
**
kwargs
:
typing
.
Any
,
)
->
WebSocketTestSession
:
url
=
urljoin
(
"ws://testserver"
,
url
)
headers
=
kwargs
.
get
(
"headers"
,
{})
headers
.
setdefault
(
"connection"
,
"upgrade"
)
headers
.
setdefault
(
"sec-websocket-key"
,
"testserver=="
)
headers
.
setdefault
(
"sec-websocket-version"
,
"13"
)
if
subprotocols
is
not
None
:
headers
.
setdefault
(
"sec-websocket-protocol"
,
", "
.
join
(
subprotocols
))
kwargs
[
"headers"
]
=
headers
try
:
super
()
.
request
(
"GET"
,
url
,
**
kwargs
)
except
_Upgrade
as
exc
:
session
=
exc
.
session
else
:
raise
RuntimeError
(
"Expected WebSocket upgrade"
)
## pragma: no cover
return
session
lifespan
async
lifespan
()
Source code in
starlette/testclient.py
693
694
695
696
697
698
async
def
lifespan
(
self
)
->
None
:
scope
=
{
"type"
:
"lifespan"
,
"state"
:
self
.
app_state
}
try
:
await
self
.
app
(
scope
,
self
.
stream_receive
.
receive
,
self
.
stream_send
.
send
)
finally
:
await
self
.
stream_send
.
send
(
None
)
wait_startup
async
wait_startup
()
Source code in
starlette/testclient.py
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
async
def
wait_startup
(
self
)
->
None
:
await
self
.
stream_receive
.
send
({
"type"
:
"lifespan.startup"
})
async
def
receive
()
->
typing
.
Any
:
message
=
await
self
.
stream_send
.
receive
()
if
message
is
None
:
self
.
task
.
result
()
return
message
message
=
await
receive
()
assert
message
[
"type"
]
in
(
"lifespan.startup.complete"
,
"lifespan.startup.failed"
,
)
if
message
[
"type"
]
==
"lifespan.startup.failed"
:
await
receive
()
wait_shutdown
async
wait_shutdown
()
Source code in
starlette/testclient.py
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
async
def
wait_shutdown
(
self
)
->
None
:
async
def
receive
()
->
typing
.
Any
:
message
=
await
self
.
stream_send
.
receive
()
if
message
is
None
:
self
.
task
.
result
()
return
message
await
self
.
stream_receive
.
send
({
"type"
:
"lifespan.shutdown"
})
message
=
await
receive
()
assert
message
[
"type"
]
in
(
"lifespan.shutdown.complete"
,
"lifespan.shutdown.failed"
,
)
if
message
[
"type"
]
==
"lifespan.shutdown.failed"
:
await
receive
()

## 103_REFERENCE_UPLOADFILE
UploadFileclass¬∂
---

UploadFile
class
You can define
path operation function
parameters to be of the type
UploadFile
to receive files from the request.
You can import it directly from
fastapi
:
from
fastapi
import
UploadFile
fastapi.UploadFile
UploadFile
(
file
,
*
,
size
=
None
,
filename
=
None
,
headers
=
None
)
Bases:
UploadFile
A file uploaded in a request.
Define it as a
path operation function
(or dependency) parameter.
If you are using a regular
def
function, you can use the
upload_file.file
attribute to access the raw standard Python file (blocking, not async), useful and
needed for non-async code.
Read more about it in the
FastAPI docs for Request Files
.
Example
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Source code in
starlette/datastructures.py
414
415
416
417
418
419
420
421
422
423
424
425
def
__init__
(
self
,
file
:
typing
.
BinaryIO
,
*
,
size
:
int
|
None
=
None
,
filename
:
str
|
None
=
None
,
headers
:
Headers
|
None
=
None
,
)
->
None
:
self
.
filename
=
filename
self
.
file
=
file
self
.
size
=
size
self
.
headers
=
headers
or
Headers
()
file
instance-attribute
file
The standard Python file object (non-async).
filename
instance-attribute
filename
The original file name.
size
instance-attribute
size
The size of the file in bytes.
headers
instance-attribute
headers
The headers of the request.
content_type
instance-attribute
content_type
The content type of the request, from the headers.
read
async
read
(
size
=-
1
)
Read some bytes from the file.
To be awaitable, compatible with async, this is run in threadpool.
PARAMETER
DESCRIPTION
size
The number of bytes to read from the file.
TYPE:
int
DEFAULT:
-1
Source code in
fastapi/datastructures.py
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
async
def
read
(
self
,
size
:
Annotated
[
int
,
Doc
(
"""
The number of bytes to read from the file.
"""
),
]
=
-
1
,
)
->
bytes
:
"""
Read some bytes from the file.
To be awaitable, compatible with async, this is run in threadpool.
"""
return
await
super
()
.
read
(
size
)
write
async
write
(
data
)
Write some bytes to the file.
You normally wouldn't use this from a file you read in a request.
To be awaitable, compatible with async, this is run in threadpool.
PARAMETER
DESCRIPTION
data
The bytes to write to the file.
TYPE:
bytes
Source code in
fastapi/datastructures.py
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
async
def
write
(
self
,
data
:
Annotated
[
bytes
,
Doc
(
"""
The bytes to write to the file.
"""
),
],
)
->
None
:
"""
Write some bytes to the file.
You normally wouldn't use this from a file you read in a request.
To be awaitable, compatible with async, this is run in threadpool.
"""
return
await
super
()
.
write
(
data
)
seek
async
seek
(
offset
)
Move to a position in the file.
Any next read or write will be done from that position.
To be awaitable, compatible with async, this is run in threadpool.
PARAMETER
DESCRIPTION
offset
The position in bytes to seek to in the file.
TYPE:
int
Source code in
fastapi/datastructures.py
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
async
def
seek
(
self
,
offset
:
Annotated
[
int
,
Doc
(
"""
The position in bytes to seek to in the file.
"""
),
],
)
->
None
:
"""
Move to a position in the file.
Any next read or write will be done from that position.
To be awaitable, compatible with async, this is run in threadpool.
"""
return
await
super
()
.
seek
(
offset
)
close
async
close
()
Close the file.
To be awaitable, compatible with async, this is run in threadpool.
Source code in
fastapi/datastructures.py
133
134
135
136
137
138
139
async
def
close
(
self
)
->
None
:
"""
Close the file.
To be awaitable, compatible with async, this is run in threadpool.
"""
return
await
super
()
.
close
()

## 104_REFERENCE_WEBSOCKETS
WebSockets¬∂
---

WebSockets
When defining WebSockets, you normally declare a parameter of type
WebSocket
and with it you can read data from the client and send data to it.
It is provided directly by Starlette, but you can import it from
fastapi
:
from
fastapi
import
WebSocket
Tip
When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an
HTTPConnection
instead of a
Request
or a
WebSocket
.
fastapi.WebSocket
WebSocket
(
scope
,
receive
,
send
)
Bases:
HTTPConnection
Source code in
starlette/websockets.py
26
27
28
29
30
31
32
def
__init__
(
self
,
scope
:
Scope
,
receive
:
Receive
,
send
:
Send
)
->
None
:
super
()
.
__init__
(
scope
)
assert
scope
[
"type"
]
==
"websocket"
self
.
_receive
=
receive
self
.
_send
=
send
self
.
client_state
=
WebSocketState
.
CONNECTING
self
.
application_state
=
WebSocketState
.
CONNECTING
scope
instance-attribute
scope
=
scope
app
property
app
url
property
url
base_url
property
base_url
headers
property
headers
query_params
property
query_params
path_params
property
path_params
cookies
property
cookies
client
property
client
state
property
state
client_state
instance-attribute
client_state
=
CONNECTING
application_state
instance-attribute
application_state
=
CONNECTING
url_for
url_for
(
name
,
/
,
**
path_params
)
Source code in
starlette/requests.py
182
183
184
185
186
187
def
url_for
(
self
,
name
:
str
,
/
,
**
path_params
:
typing
.
Any
)
->
URL
:
url_path_provider
:
Router
|
Starlette
|
None
=
self
.
scope
.
get
(
"router"
)
or
self
.
scope
.
get
(
"app"
)
if
url_path_provider
is
None
:
raise
RuntimeError
(
"The `url_for` method can only be used inside a Starlette application or with a router."
)
url_path
=
url_path_provider
.
url_path_for
(
name
,
**
path_params
)
return
url_path
.
make_absolute_url
(
base_url
=
self
.
base_url
)
receive
async
receive
()
Receive ASGI websocket messages, ensuring valid state transitions.
Source code in
starlette/websockets.py
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
async
def
receive
(
self
)
->
Message
:
"""
Receive ASGI websocket messages, ensuring valid state transitions.
"""
if
self
.
client_state
==
WebSocketState
.
CONNECTING
:
message
=
await
self
.
_receive
()
message_type
=
message
[
"type"
]
if
message_type
!=
"websocket.connect"
:
raise
RuntimeError
(
f
'Expected ASGI message "websocket.connect", but got
{
message_type
!r}
'
)
self
.
client_state
=
WebSocketState
.
CONNECTED
return
message
elif
self
.
client_state
==
WebSocketState
.
CONNECTED
:
message
=
await
self
.
_receive
()
message_type
=
message
[
"type"
]
if
message_type
not
in
{
"websocket.receive"
,
"websocket.disconnect"
}:
raise
RuntimeError
(
f
'Expected ASGI message "websocket.receive" or "websocket.disconnect", but got
{
message_type
!r}
'
)
if
message_type
==
"websocket.disconnect"
:
self
.
client_state
=
WebSocketState
.
DISCONNECTED
return
message
else
:
raise
RuntimeError
(
'Cannot call "receive" once a disconnect message has been received.'
)
send
async
send
(
message
)
Send ASGI websocket messages, ensuring valid state transitions.
Source code in
starlette/websockets.py
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
async
def
send
(
self
,
message
:
Message
)
->
None
:
"""
Send ASGI websocket messages, ensuring valid state transitions.
"""
if
self
.
application_state
==
WebSocketState
.
CONNECTING
:
message_type
=
message
[
"type"
]
if
message_type
not
in
{
"websocket.accept"
,
"websocket.close"
,
"websocket.http.response.start"
}:
raise
RuntimeError
(
'Expected ASGI message "websocket.accept", "websocket.close" or "websocket.http.response.start", '
f
"but got
{
message_type
!r}
"
)
if
message_type
==
"websocket.close"
:
self
.
application_state
=
WebSocketState
.
DISCONNECTED
elif
message_type
==
"websocket.http.response.start"
:
self
.
application_state
=
WebSocketState
.
RESPONSE
else
:
self
.
application_state
=
WebSocketState
.
CONNECTED
await
self
.
_send
(
message
)
elif
self
.
application_state
==
WebSocketState
.
CONNECTED
:
message_type
=
message
[
"type"
]
if
message_type
not
in
{
"websocket.send"
,
"websocket.close"
}:
raise
RuntimeError
(
f
'Expected ASGI message "websocket.send" or "websocket.close", but got
{
message_type
!r}
'
)
if
message_type
==
"websocket.close"
:
self
.
application_state
=
WebSocketState
.
DISCONNECTED
try
:
await
self
.
_send
(
message
)
except
OSError
:
self
.
application_state
=
WebSocketState
.
DISCONNECTED
raise
WebSocketDisconnect
(
code
=
1006
)
elif
self
.
application_state
==
WebSocketState
.
RESPONSE
:
message_type
=
message
[
"type"
]
if
message_type
!=
"websocket.http.response.body"
:
raise
RuntimeError
(
f
'Expected ASGI message "websocket.http.response.body", but got
{
message_type
!r}
'
)
if
not
message
.
get
(
"more_body"
,
False
):
self
.
application_state
=
WebSocketState
.
DISCONNECTED
await
self
.
_send
(
message
)
else
:
raise
RuntimeError
(
'Cannot call "send" once a close message has been sent.'
)
accept
async
accept
(
subprotocol
=
None
,
headers
=
None
)
Source code in
starlette/websockets.py
99
100
101
102
103
104
105
106
107
108
109
async
def
accept
(
self
,
subprotocol
:
str
|
None
=
None
,
headers
:
typing
.
Iterable
[
tuple
[
bytes
,
bytes
]]
|
None
=
None
,
)
->
None
:
headers
=
headers
or
[]
if
self
.
client_state
==
WebSocketState
.
CONNECTING
:
## pragma: no branch
## If we haven't yet seen the 'connect' message, then wait for it first.
await
self
.
receive
()
await
self
.
send
({
"type"
:
"websocket.accept"
,
"subprotocol"
:
subprotocol
,
"headers"
:
headers
})
receive_text
async
receive_text
()
Source code in
starlette/websockets.py
115
116
117
118
119
120
async
def
receive_text
(
self
)
->
str
:
if
self
.
application_state
!=
WebSocketState
.
CONNECTED
:
raise
RuntimeError
(
'WebSocket is not connected. Need to call "accept" first.'
)
message
=
await
self
.
receive
()
self
.
_raise_on_disconnect
(
message
)
return
typing
.
cast
(
str
,
message
[
"text"
])
receive_bytes
async
receive_bytes
()
Source code in
starlette/websockets.py
122
123
124
125
126
127
async
def
receive_bytes
(
self
)
->
bytes
:
if
self
.
application_state
!=
WebSocketState
.
CONNECTED
:
raise
RuntimeError
(
'WebSocket is not connected. Need to call "accept" first.'
)
message
=
await
self
.
receive
()
self
.
_raise_on_disconnect
(
message
)
return
typing
.
cast
(
bytes
,
message
[
"bytes"
])
receive_json
async
receive_json
(
mode
=
'text'
)
Source code in
starlette/websockets.py
129
130
131
132
133
134
135
136
137
138
139
140
141
async
def
receive_json
(
self
,
mode
:
str
=
"text"
)
->
typing
.
Any
:
if
mode
not
in
{
"text"
,
"binary"
}:
raise
RuntimeError
(
'The "mode" argument should be "text" or "binary".'
)
if
self
.
application_state
!=
WebSocketState
.
CONNECTED
:
raise
RuntimeError
(
'WebSocket is not connected. Need to call "accept" first.'
)
message
=
await
self
.
receive
()
self
.
_raise_on_disconnect
(
message
)
if
mode
==
"text"
:
text
=
message
[
"text"
]
else
:
text
=
message
[
"bytes"
]
.
decode
(
"utf-8"
)
return
json
.
loads
(
text
)
iter_text
async
iter_text
()
Source code in
starlette/websockets.py
143
144
145
146
147
148
async
def
iter_text
(
self
)
->
typing
.
AsyncIterator
[
str
]:
try
:
while
True
:
yield
await
self
.
receive_text
()
except
WebSocketDisconnect
:
pass
iter_bytes
async
iter_bytes
()
Source code in
starlette/websockets.py
150
151
152
153
154
155
async
def
iter_bytes
(
self
)
->
typing
.
AsyncIterator
[
bytes
]:
try
:
while
True
:
yield
await
self
.
receive_bytes
()
except
WebSocketDisconnect
:
pass
iter_json
async
iter_json
()
Source code in
starlette/websockets.py
157
158
159
160
161
162
async
def
iter_json
(
self
)
->
typing
.
AsyncIterator
[
typing
.
Any
]:
try
:
while
True
:
yield
await
self
.
receive_json
()
except
WebSocketDisconnect
:
pass
send_text
async
send_text
(
data
)
Source code in
starlette/websockets.py
164
165
async
def
send_text
(
self
,
data
:
str
)
->
None
:
await
self
.
send
({
"type"
:
"websocket.send"
,
"text"
:
data
})
send_bytes
async
send_bytes
(
data
)
Source code in
starlette/websockets.py
167
168
async
def
send_bytes
(
self
,
data
:
bytes
)
->
None
:
await
self
.
send
({
"type"
:
"websocket.send"
,
"bytes"
:
data
})
send_json
async
send_json
(
data
,
mode
=
'text'
)
Source code in
starlette/websockets.py
170
171
172
173
174
175
176
177
async
def
send_json
(
self
,
data
:
typing
.
Any
,
mode
:
str
=
"text"
)
->
None
:
if
mode
not
in
{
"text"
,
"binary"
}:
raise
RuntimeError
(
'The "mode" argument should be "text" or "binary".'
)
text
=
json
.
dumps
(
data
,
separators
=
(
","
,
":"
),
ensure_ascii
=
False
)
if
mode
==
"text"
:
await
self
.
send
({
"type"
:
"websocket.send"
,
"text"
:
text
})
else
:
await
self
.
send
({
"type"
:
"websocket.send"
,
"bytes"
:
text
.
encode
(
"utf-8"
)})
close
async
close
(
code
=
1000
,
reason
=
None
)
Source code in
starlette/websockets.py
179
180
async
def
close
(
self
,
code
:
int
=
1000
,
reason
:
str
|
None
=
None
)
->
None
:
await
self
.
send
({
"type"
:
"websocket.close"
,
"code"
:
code
,
"reason"
:
reason
or
""
})
When a client disconnects, a
WebSocketDisconnect
exception is raised, you can catch it.
You can import it directly form
fastapi
:
from
fastapi
import
WebSocketDisconnect
fastapi.WebSocketDisconnect
WebSocketDisconnect
(
code
=
1000
,
reason
=
None
)
Bases:
Exception
Source code in
starlette/websockets.py
20
21
22
def
__init__
(
self
,
code
:
int
=
1000
,
reason
:
str
|
None
=
None
)
->
None
:
self
.
code
=
code
self
.
reason
=
reason
or
""
code
instance-attribute
code
=
code
reason
instance-attribute
reason
=
reason
or
''
WebSockets - additional classes
Additional classes for handling WebSockets.
Provided directly by Starlette, but you can import it from
fastapi
:
from
fastapi.websockets
import
WebSocketDisconnect
,
WebSocketState
fastapi.websockets.WebSocketDisconnect
WebSocketDisconnect
(
code
=
1000
,
reason
=
None
)
Bases:
Exception
Source code in
starlette/websockets.py
20
21
22
def
__init__
(
self
,
code
:
int
=
1000
,
reason
:
str
|
None
=
None
)
->
None
:
self
.
code
=
code
self
.
reason
=
reason
or
""
code
instance-attribute
code
=
code
reason
instance-attribute
reason
=
reason
or
''
fastapi.websockets.WebSocketState
Bases:
Enum
CONNECTING
class-attribute
instance-attribute
CONNECTING
=
0
CONNECTED
class-attribute
instance-attribute
CONNECTED
=
1
DISCONNECTED
class-attribute
instance-attribute
DISCONNECTED
=
2
RESPONSE
class-attribute
instance-attribute
RESPONSE
=
3

## 105_RELEASE_NOTES
Release Notes¬∂
---

Release Notes
Latest Changes
Docs
üìù Update Speakeasy URL to Speakeasy Sandbox. PR
## 13697
by
@ndimares
.
Translations
üåê Add Russian translation for
docs/ru/docs/advanced/index.md
. PR
## 13797
by
@NavesSapnis
.
0.115.13
Fixes
üêõ Fix truncating the model's description with form feed (
\f
) character for Pydantic V2. PR
## 13698
by
@YuriiMotov
.
Refactors
‚ú® Add
refreshUrl
parameter in
OAuth2PasswordBearer
. PR
## 11460
by
@snosratiershad
.
üö∏ Set format to password for fields
password
and
client_secret
in
OAuth2PasswordRequestForm
, make docs show password fields for passwords. PR
## 11032
by
@Thodoris1999
.
‚úÖ Simplify tests for
settings
. PR
## 13505
by
@valentinDruzhinin
.
‚úÖ Simplify tests for
validate_response_recursive
. PR
## 13507
by
@valentinDruzhinin
.
Upgrades
‚¨ÜÔ∏è Update ReDoc to version 2.x. PR
## 9700
by
@joakimnordling
.
Docs
üìù Add annotations to HTTP middleware example. PR
## 11530
by
@Kilo59
.
üìù Clarify in CORS docs that wildcards and credentials are mutually exclusive. PR
## 9829
by
@dfioravanti
.
‚úèÔ∏è Fix typo in docstring. PR
## 13532
by
@comp64
.
üìù Clarify guidance on using
async def
without
await
. PR
## 13642
by
@swastikpradhan1999
.
üìù Update exclude-parameters-from-openapi documentation links. PR
## 13600
by
@timonrieger
.
üìù Clarify the middleware execution order in docs. PR
## 13699
by
@YuriiMotov
.
üç± Update Drawio diagrams SVGs, single file per diagram, sans-serif font. PR
## 13706
by
@tiangolo
.
üìù Update docs for "Help FastAPI", simplify and reduce "sponsor" section. PR
## 13670
by
@tiangolo
.
üìù Remove unnecessary bullet from docs. PR
## 13641
by
@Adamowoc
.
‚úèÔ∏è Fix syntax error in
docs/en/docs/tutorial/handling-errors.md
. PR
## 13623
by
@gsheni
.
üìù Fix typo in documentation. PR
## 13599
by
@Taoup
.
üìù Fix liblab client generation doc link. PR
## 13571
by
@EFord36
.
‚úèÔ∏è Fix talk information typo. PR
## 13544
by
@blueswen
.
üìù Add External Link: Taiwanese talk on FastAPI with observability . PR
## 13527
by
@blueswen
.
Translations
üåê Add Russian Translation for
docs/ru/docs/advanced/response-change-status-code.md
. PR
## 13791
by
@NavesSapnis
.
üåê Add Persian translation for
docs/fa/docs/learn/index.md
. PR
## 13518
by
@Mohammad222PR
.
üåê Add Korean translation for
docs/ko/docs/advanced/sub-applications.md
. PR
## 4543
by
@NinaHwang
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/schema-extra-example.md
. PR
## 13769
by
@valentinDruzhinin
.
‚úèÔ∏è Remove redundant words in docs/zh/docs/python-types.md. PR
## 13774
by
@CharleeWa
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/query-param-models.md
. PR
## 13748
by
@valentinDruzhinin
.
üåê Add Bengali translation for
docs/bn/docs/environment-variables.md
. PR
## 13629
by
@SakibSibly
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/query-params-str-validations.md
page. PR
## 13546
by
@valentinDruzhinin
.
üåê Add Russian translation for
docs/ru/docs/tutorial/cookie-param-models.md
. PR
## 13616
by
@EgorOnishchuk
.
üåê Add Korean translation for
docs/ko/docs/tutorial/extra-models.md
. PR
## 13063
by
@timothy-jeong
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/path-params-numeric-validations.md
page. PR
## 13548
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/middleware.md
page. PR
## 13520
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/background-tasks.md
page. PR
## 13502
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/cors.md
page. PR
## 13519
by
@valentinDruzhinin
.
üåê Update Korean translation for
docs/ko/docs/advanced/events.md
. PR
## 13487
by
@bom1215
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/handling-errors.md
page. PR
## 13420
by
@valentinDruzhinin
.
üåê Add Russian translation for
docs/ru/docs/tutorial/request-form-models.md
. PR
## 13552
by
@EgorOnishchuk
.
üìù Fix internal anchor link in Spanish deployment docs. PR
## 13737
by
@fabianfalon
.
üåê Update Korean translation for
docs/ko/docs/virtual-environments.md
. PR
## 13630
by
@sungchan1
.
üåê Add Russian translation for
docs/ru/docs/tutorial/header-param-models.md
. PR
## 13526
by
@minaton-ru
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/index.md
. PR
## 13374
by
@Zhongheng-Cheng
.
üåê Update Chinese translation for
docs/zh/docs/deployment/manually.md
. PR
## 13324
by
@Zhongheng-Cheng
.
üåê Update Chinese translation for
docs/zh/docs/deployment/server-workers.md
. PR
## 13292
by
@Zhongheng-Cheng
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/first-steps.md
. PR
## 13348
by
@Zhongheng-Cheng
.
Internal
üî® Resolve Pydantic deprecation warnings in internal script. PR
## 13696
by
@emmanuel-ferdman
.
üîß Update sponsors: remove Porter. PR
## 13783
by
@tiangolo
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 13781
by
@pre-commit-ci[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 13757
by
@pre-commit-ci[bot]
.
‚¨Ü Bump griffe-typingdoc from 0.2.7 to 0.2.8. PR
## 13751
by
@dependabot[bot]
.
üç± Update sponsors: Dribia badge size. PR
## 13773
by
@tiangolo
.
üîß Update sponsors: add Dribia. PR
## 13771
by
@tiangolo
.
‚¨Ü Bump typer from 0.15.3 to 0.16.0. PR
## 13752
by
@dependabot[bot]
.
üë• Update FastAPI GitHub topic repositories. PR
## 13754
by
@tiangolo
.
üë• Update FastAPI People - Sponsors. PR
## 13750
by
@tiangolo
.
üë• Update FastAPI People - Contributors and Translators. PR
## 13749
by
@tiangolo
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 13736
by
@pre-commit-ci[bot]
.
üîß Update sponsors: Add InterviewPal. PR
## 13728
by
@tiangolo
.
üîß Remove Google Analytics. PR
## 13727
by
@tiangolo
.
üîß Update sponsors: remove MongoDB. PR
## 13725
by
@tiangolo
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 13711
by
@pre-commit-ci[bot]
.
üîß Update sponsors: add Subtotal. PR
## 13701
by
@tiangolo
.
üîß Update sponsors: remove deepset / Haystack. PR
## 13700
by
@tiangolo
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 13688
by
@pre-commit-ci[bot]
.
üë• Update FastAPI People - Experts. PR
## 13671
by
@tiangolo
.
‚¨Ü Bump typer from 0.12.5 to 0.15.3. PR
## 13666
by
@dependabot[bot]
.
‚¨Ü Bump sqlmodel from 0.0.23 to 0.0.24. PR
## 13665
by
@dependabot[bot]
.
üîß Update Sponsors: Zuplo logo and alt text. PR
## 13645
by
@martyndavies
.
üë• Update FastAPI GitHub topic repositories. PR
## 13667
by
@tiangolo
.
üîß Update links for LinkedIn and bottom. PR
## 13669
by
@tiangolo
.
üîß Update sponsors: remove Bump.sh and Coherence. PR
## 13668
by
@tiangolo
.
üë• Update FastAPI People - Sponsors. PR
## 13664
by
@tiangolo
.
üë• Update FastAPI People - Contributors and Translators. PR
## 13662
by
@tiangolo
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 13656
by
@pre-commit-ci[bot]
.
‚úÖ Use
inline-snapshot
to support different Pydantic versions in the test suite. PR
## 12534
by
@15r10nk
.
‚¨Ü Bump astral-sh/setup-uv from 5 to 6. PR
## 13648
by
@dependabot[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 13634
by
@pre-commit-ci[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 13619
by
@pre-commit-ci[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 13594
by
@pre-commit-ci[bot]
.
üë• Update FastAPI People - Experts. PR
## 13568
by
@tiangolo
.
üë• Update FastAPI GitHub topic repositories. PR
## 13565
by
@tiangolo
.
üë• Update FastAPI People - Sponsors. PR
## 13559
by
@tiangolo
.
üë• Update FastAPI People - Contributors and Translators. PR
## 13558
by
@tiangolo
.
‚¨Ü Bump dirty-equals from 0.8.0 to 0.9.0. PR
## 13561
by
@dependabot[bot]
.
üîß Clean up
docs/en/mkdocs.yml
configuration file. PR
## 13542
by
@svlandeg
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12986
by
@pre-commit-ci[bot]
.
0.115.12
Fixes
üêõ Fix
convert_underscores=False
for header Pydantic models. PR
## 13515
by
@tiangolo
.
Docs
üìù Update
docs/en/docs/tutorial/middleware.md
. PR
## 13444
by
@Rishat-F
.
üë• Update FastAPI People - Experts. PR
## 13493
by
@tiangolo
.
Translations
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/metadata.md
page. PR
## 13459
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/response-status-code.md
page. PR
## 13462
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/cookie-param-models.md
page. PR
## 13460
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/header-param-models.md
page. PR
## 13461
by
@valentinDruzhinin
.
üåê Add Japanese translation for
docs/ja/docs/virtual-environments.md
. PR
## 13304
by
@k94-ishi
.
üåê Add Korean translation for
docs/ko/docs/tutorial/security/oauth2-jwt.md
. PR
## 13333
by
@yes0ng
.
üåê Add Vietnamese translation for
docs/vi/docs/deployment/cloud.md
. PR
## 13407
by
@ptt3199
.
Internal
‚¨Ü Bump pydantic-ai from 0.0.15 to 0.0.30. PR
## 13438
by
@dependabot[bot]
.
‚¨Ü Bump sqlmodel from 0.0.22 to 0.0.23. PR
## 13437
by
@dependabot[bot]
.
‚¨Ü Bump black from 24.10.0 to 25.1.0. PR
## 13436
by
@dependabot[bot]
.
‚¨Ü Bump ruff to 0.9.4. PR
## 13299
by
@dependabot[bot]
.
üîß Update sponsors: pause TestDriven. PR
## 13446
by
@tiangolo
.
0.115.11
Fixes
üêõ Add docs examples and tests (support) for
Annotated
custom validations, like
AfterValidator
, revert
## 13440
. PR
## 13442
by
@tiangolo
.
New docs:
Query Parameters and String Validations - Custom Validation
.
Translations
üåê Add Russian translation for
docs/ru/docs/tutorial/middleware.md
. PR
## 13412
by
@alv2017
.
Internal
üë• Update FastAPI GitHub topic repositories. PR
## 13439
by
@tiangolo
.
üë• Update FastAPI People - Contributors and Translators. PR
## 13432
by
@tiangolo
.
üë• Update FastAPI People - Sponsors. PR
## 13433
by
@tiangolo
.
0.115.10
Fixes
‚ôªÔ∏è Update internal annotation usage for compatibility with Pydantic 2.11. PR
## 13314
by
@Viicos
.
Upgrades
‚¨ÜÔ∏è Bump Starlette to allow up to 0.46.0:
>=0.40.0,<0.47.0
. PR
## 13426
by
@musicinmybrain
.
Translations
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/debugging.md
. PR
## 13370
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/query-params.md
. PR
## 13362
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/path-params.md
. PR
## 13354
by
@valentinDruzhinin
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/cookie-param-models.md
. PR
## 13330
by
@k94-ishi
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/body-multiple-params.md
. PR
## 13408
by
@valentinDruzhinin
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/query-param-models.md
. PR
## 13323
by
@k94-ishi
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/body-nested-models.md
. PR
## 13409
by
@valentinDruzhinin
.
üåê Add Vietnamese translation for
docs/vi/docs/deployment/versions.md
. PR
## 13406
by
@ptt3199
.
üåê Add Vietnamese translation for
docs/vi/docs/deployment/index.md
. PR
## 13405
by
@ptt3199
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/request-forms.md
. PR
## 13383
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/testing.md
. PR
## 13371
by
@valentinDruzhinin
.
0.115.9
Fixes
üêõ Ensure that
HTTPDigest
only raises an exception when
auto_error is True
. PR
## 2939
by
@arthurio
.
Refactors
‚úÖ Simplify tests for
query_params_str_validations
. PR
## 13218
by
@alv2017
.
‚úÖ Simplify tests for
app_testing
. PR
## 13220
by
@alv2017
.
‚úÖ Simplify tests for
dependency_testing
. PR
## 13223
by
@alv2017
.
Docs
üç± Update sponsors: CodeRabbit logo. PR
## 13424
by
@tiangolo
.
ü©∫ Unify the badges across all tutorial translations. PR
## 13329
by
@svlandeg
.
üìù Fix typos in virtual environments documentation. PR
## 13396
by
@bullet-ant
.
üêõ Fix issue with Swagger theme change example in the official tutorial. PR
## 13289
by
@Zerohertz
.
üìù Add more precise description of HTTP status code range in docs. PR
## 13347
by
@DanielYang59
.
üî• Remove manual type annotations in JWT tutorial to avoid typing expectations (JWT doesn't provide more types). PR
## 13378
by
@tiangolo
.
üìù Update docs for Query Params and String Validations, remove obsolete Ellipsis docs (
...
). PR
## 13377
by
@tiangolo
.
‚úèÔ∏è Remove duplicate title in docs
body-multiple-params
. PR
## 13345
by
@DanielYang59
.
üìù Fix test badge. PR
## 13313
by
@esadek
.
Translations
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/header-params.md
. PR
## 13381
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/request-files.md
. PR
## 13395
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/request-form-models.md
. PR
## 13384
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/request-forms-and-files.md
. PR
## 13386
by
@valentinDruzhinin
.
üåê Update Korean translation for
docs/ko/docs/help-fastapi.md
. PR
## 13262
by
@Zerohertz
.
üåê Add Korean translation for
docs/ko/docs/advanced/custom-response.md
. PR
## 13265
by
@11kkw
.
üåê Update Korean translation for
docs/ko/docs/tutorial/security/simple-oauth2.md
. PR
## 13335
by
@yes0ng
.
üåê Add Russian translation for
docs/ru/docs/advanced/response-cookies.md
. PR
## 13327
by
@Stepakinoyan
.
üåê Add Vietnamese translation for
docs/vi/docs/tutorial/static-files.md
. PR
## 11291
by
@ptt3199
.
üåê Add Korean translation for
docs/ko/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 13257
by
@11kkw
.
üåê Add Vietnamese translation for
docs/vi/docs/virtual-environments.md
. PR
## 13282
by
@ptt3199
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/static-files.md
. PR
## 13285
by
@valentinDruzhinin
.
üåê Add Vietnamese translation for
docs/vi/docs/environment-variables.md
. PR
## 13287
by
@ptt3199
.
üåê Add Vietnamese translation for
docs/vi/docs/fastapi-cli.md
. PR
## 13294
by
@ptt3199
.
üåê Add Ukrainian translation for
docs/uk/docs/features.md
. PR
## 13308
by
@valentinDruzhinin
.
üåê Add Ukrainian translation for
docs/uk/docs/learn/index.md
. PR
## 13306
by
@valentinDruzhinin
.
üåê Update Portuguese Translation for
docs/pt/docs/deployment/https.md
. PR
## 13317
by
@Joao-Pedro-P-Holanda
.
üåê Update Portuguese Translation for
docs/pt/docs/index.md
. PR
## 13328
by
@ceb10n
.
üåê Add Russian translation for
docs/ru/docs/advanced/websockets.md
. PR
## 13279
by
@Rishat-F
.
Internal
‚úÖ Fix a minor bug in the test
tests/test_modules_same_name_body/test_main.py
. PR
## 13411
by
@alv2017
.
üë∑ Use
wrangler-action
v3. PR
## 13415
by
@joakimnordling
.
üîß Update sponsors: add CodeRabbit. PR
## 13402
by
@tiangolo
.
üîß Update team: Add Ludovico. PR
## 13390
by
@tiangolo
.
üîß Update sponsors: Add LambdaTest. PR
## 13389
by
@tiangolo
.
‚¨Ü Bump cloudflare/wrangler-action from 3.13 to 3.14. PR
## 13350
by
@dependabot[bot]
.
‚¨Ü Bump mkdocs-material from 9.5.18 to 9.6.1. PR
## 13301
by
@dependabot[bot]
.
‚¨Ü Bump pillow from 11.0.0 to 11.1.0. PR
## 13300
by
@dependabot[bot]
.
üë• Update FastAPI People - Sponsors. PR
## 13295
by
@tiangolo
.
üë• Update FastAPI People - Experts. PR
## 13303
by
@tiangolo
.
üë• Update FastAPI GitHub topic repositories. PR
## 13302
by
@tiangolo
.
üë• Update FastAPI People - Contributors and Translators. PR
## 13293
by
@tiangolo
.
‚¨Ü Bump inline-snapshot from 0.18.1 to 0.19.3. PR
## 13298
by
@dependabot[bot]
.
üîß Update sponsors, add Permit. PR
## 13288
by
@tiangolo
.
0.115.8
Fixes
üêõ Fix
OAuth2PasswordRequestForm
and
OAuth2PasswordRequestFormStrict
fixed
grant_type
"password" RegEx. PR
## 9783
by
@skarfie123
.
Refactors
‚úÖ Simplify tests for body_multiple_params . PR
## 13237
by
@alejsdev
.
‚ôªÔ∏è Move duplicated code portion to a static method in the
APIKeyBase
super class. PR
## 3142
by
@ShahriyarR
.
‚úÖ Simplify tests for request_files. PR
## 13182
by
@alejsdev
.
Docs
üìù Change the word "unwrap" to "unpack" in
docs/en/docs/tutorial/extra-models.md
. PR
## 13061
by
@timothy-jeong
.
üìù Update Request Body's
tutorial002
to deal with
tax=0
case. PR
## 13230
by
@togogh
.
üë• Update FastAPI People - Experts. PR
## 13269
by
@tiangolo
.
Translations
üåê Add Japanese translation for
docs/ja/docs/environment-variables.md
. PR
## 13226
by
@k94-ishi
.
üåê Add Russian translation for
docs/ru/docs/advanced/async-tests.md
. PR
## 13227
by
@Rishat-F
.
üåê Update Russian translation for
docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 13252
by
@Rishat-F
.
üåê Add Russian translation for
docs/ru/docs/tutorial/bigger-applications.md
. PR
## 13154
by
@alv2017
.
Internal
‚¨ÜÔ∏è Add support for Python 3.13. PR
## 13274
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade AnyIO max version for tests, new range:
>=3.2.1,<5.0.0
. PR
## 13273
by
@tiangolo
.
üîß Update Sponsors badges. PR
## 13271
by
@tiangolo
.
‚ôªÔ∏è Fix
notify_translations.py
empty env var handling for PR label events vs workflow_dispatch. PR
## 13272
by
@tiangolo
.
‚ôªÔ∏è Refactor and move
scripts/notify_translations.py
, no need for a custom GitHub Action. PR
## 13270
by
@tiangolo
.
üî® Update FastAPI People Experts script, refactor and optimize data fetching to handle rate limits. PR
## 13267
by
@tiangolo
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.12.3 to 1.12.4. PR
## 13251
by
@dependabot[bot]
.
0.115.7
Upgrades
‚¨ÜÔ∏è Upgrade
python-multipart
to >=0.0.18. PR
## 13219
by
@DanielKusyDev
.
‚¨ÜÔ∏è Bump Starlette to allow up to 0.45.0:
>=0.40.0,<0.46.0
. PR
## 13117
by
@Kludex
.
‚¨ÜÔ∏è Upgrade
jinja2
to >=3.1.5. PR
## 13194
by
@DanielKusyDev
.
Refactors
‚úÖ Simplify tests for websockets. PR
## 13202
by
@alejsdev
.
‚úÖ Simplify tests for request_form_models . PR
## 13183
by
@alejsdev
.
‚úÖ Simplify tests for separate_openapi_schemas. PR
## 13201
by
@alejsdev
.
‚úÖ Simplify tests for security. PR
## 13200
by
@alejsdev
.
‚úÖ Simplify tests for schema_extra_example. PR
## 13197
by
@alejsdev
.
‚úÖ Simplify tests for request_model. PR
## 13195
by
@alejsdev
.
‚úÖ Simplify tests for request_forms_and_files. PR
## 13185
by
@alejsdev
.
‚úÖ Simplify tests for request_forms. PR
## 13184
by
@alejsdev
.
‚úÖ Simplify tests for path_query_params. PR
## 13181
by
@alejsdev
.
‚úÖ Simplify tests for path_operation_configurations. PR
## 13180
by
@alejsdev
.
‚úÖ Simplify tests for header_params. PR
## 13179
by
@alejsdev
.
‚úÖ Simplify tests for extra_models. PR
## 13178
by
@alejsdev
.
‚úÖ Simplify tests for extra_data_types. PR
## 13177
by
@alejsdev
.
‚úÖ Simplify tests for cookie_params. PR
## 13176
by
@alejsdev
.
‚úÖ Simplify tests for dependencies. PR
## 13174
by
@alejsdev
.
‚úÖ Simplify tests for body_updates. PR
## 13172
by
@alejsdev
.
‚úÖ Simplify tests for body_nested_models. PR
## 13171
by
@alejsdev
.
‚úÖ Simplify tests for body_multiple_params. PR
## 13170
by
@alejsdev
.
‚úÖ Simplify tests for body_fields. PR
## 13169
by
@alejsdev
.
‚úÖ Simplify tests for body. PR
## 13168
by
@alejsdev
.
‚úÖ Simplify tests for bigger_applications. PR
## 13167
by
@alejsdev
.
‚úÖ Simplify tests for background_tasks. PR
## 13166
by
@alejsdev
.
‚úÖ Simplify tests for additional_status_codes. PR
## 13149
by
@tiangolo
.
Docs
‚úèÔ∏è Update Strawberry integration docs. PR
## 13155
by
@kinuax
.
üî• Remove unused Peewee tutorial files. PR
## 13158
by
@alejsdev
.
üìù Update image in body-nested-model docs. PR
## 11063
by
@untilhamza
.
üìù Update
fastapi-cli
UI examples in docs. PR
## 13107
by
@Zhongheng-Cheng
.
üë∑ Add new GitHub Action to update contributors, translators, and translation reviewers. PR
## 13136
by
@tiangolo
.
‚úèÔ∏è Fix typo in
docs/en/docs/virtual-environments.md
. PR
## 13124
by
@tiangolo
.
‚úèÔ∏è Fix error in
docs/en/docs/contributing.md
. PR
## 12899
by
@kingsubin
.
üìù Minor corrections in
docs/en/docs/tutorial/sql-databases.md
. PR
## 13081
by
@alv2017
.
üìù Update includes in
docs/ru/docs/tutorial/query-param-models.md
. PR
## 12994
by
@alejsdev
.
‚úèÔ∏è Fix typo in README installation instructions. PR
## 13011
by
@dave-hay
.
üìù Update docs for
fastapi-cli
. PR
## 13031
by
@tiangolo
.
Translations
üåê Update Portuguese Translation for
docs/pt/docs/tutorial/request-forms.md
. PR
## 13216
by
@Joao-Pedro-P-Holanda
.
üåê Update Portuguese translation for
docs/pt/docs/advanced/settings.md
. PR
## 13209
by
@ceb10n
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/security/oauth2-jwt.md
. PR
## 13205
by
@ceb10n
.
üåê Add Indonesian translation for
docs/id/docs/index.md
. PR
## 13191
by
@gerry-sabar
.
üåê Add Indonesian translation for
docs/id/docs/tutorial/static-files.md
. PR
## 13092
by
@guspan-tanadi
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/security/get-current-user.md
. PR
## 13188
by
@ceb10n
.
üåê Remove Wrong Portuguese translations location for
docs/pt/docs/advanced/benchmarks.md
. PR
## 13187
by
@ceb10n
.
üåê Update Portuguese translations. PR
## 13156
by
@nillvitor
.
üåê Update Russian translation for
docs/ru/docs/tutorial/security/first-steps.md
. PR
## 13159
by
@Yarous
.
‚úèÔ∏è Delete unnecessary backspace in
docs/ja/docs/tutorial/path-params-numeric-validations.md
. PR
## 12238
by
@FakeDocument
.
üåê Update Chinese translation for
docs/zh/docs/fastapi-cli.md
. PR
## 13102
by
@Zhongheng-Cheng
.
üåê Add new Spanish translations for all docs with new LLM-assisted system using PydanticAI. PR
## 13122
by
@tiangolo
.
üåê Update existing Spanish translations using the new LLM-assisted system using PydanticAI. PR
## 13118
by
@tiangolo
.
üåê Update Chinese translation for
docs/zh/docs/advanced/security/oauth2-scopes.md
. PR
## 13110
by
@ChenPu2002
.
üåê Add Indonesian translation for
docs/id/docs/tutorial/path-params.md
. PR
## 13086
by
@gerry-sabar
.
üåê Add Korean translation for
docs/ko/docs/tutorial/sql-databases.md
. PR
## 13093
by
@GeumBinLee
.
üåê Update Chinese translation for
docs/zh/docs/async.md
. PR
## 13095
by
@Zhongheng-Cheng
.
üåê Add Chinese translation for
docs/zh/docs/advanced/openapi-webhooks.md
. PR
## 13091
by
@Zhongheng-Cheng
.
üåê Add Chinese translation for
docs/zh/docs/advanced/async-tests.md
. PR
## 13074
by
@Zhongheng-Cheng
.
üåê Add Ukrainian translation for
docs/uk/docs/fastapi-cli.md
. PR
## 13020
by
@ykertytsky
.
üåê Add Chinese translation for
docs/zh/docs/advanced/events.md
. PR
## 12512
by
@ZhibangYue
.
üåê Add Russian translation for
/docs/ru/docs/tutorial/sql-databases.md
. PR
## 13079
by
@alv2017
.
üåê Update Chinese translation for
docs/zh/docs/advanced/testing-dependencies.md
. PR
## 13066
by
@Zhongheng-Cheng
.
üåê Update Traditional Chinese translation for
docs/zh-hant/docs/tutorial/index.md
. PR
## 13075
by
@codingjenny
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/sql-databases.md
. PR
## 13051
by
@Zhongheng-Cheng
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/query-params-str-validations.md
. PR
## 12928
by
@Vincy1230
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/header-param-models.md
. PR
## 13040
by
@Zhongheng-Cheng
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/path-params.md
. PR
## 12926
by
@Vincy1230
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/first-steps.md
. PR
## 12923
by
@Vincy1230
.
üåê Update Russian translation for
docs/ru/docs/deployment/docker.md
. PR
## 13048
by
@anklav24
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/generate-clients.md
. PR
## 13030
by
@vitumenezes
.
üåê Add Indonesian translation for
docs/id/docs/tutorial/first-steps.md
. PR
## 13042
by
@gerry-sabar
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/cookie-param-models.md
. PR
## 13038
by
@Zhongheng-Cheng
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/request-form-models.md
. PR
## 13045
by
@Zhongheng-Cheng
.
üåê Add Russian translation for
docs/ru/docs/virtual-environments.md
. PR
## 13026
by
@alv2017
.
üåê Add Korean translation for
docs/ko/docs/tutorial/testing.md
. PR
## 12968
by
@jts8257
.
üåê Add Korean translation for
docs/ko/docs/advanced/async-test.md
. PR
## 12918
by
@icehongssii
.
üåê Add Russian translation for
docs/ru/docs/tutorial/security/oauth2-jwt.md
. PR
## 10601
by
@AlertRED
.
üåê Add Russian translation for
docs/ru/docs/tutorial/security/simple-oauth2.md
. PR
## 10599
by
@AlertRED
.
üåê Add Russian translation for
docs/ru/docs/tutorial/security/get-current-user.md
. PR
## 10594
by
@AlertRED
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/features.md
. PR
## 12441
by
@codingjenny
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/virtual-environments.md
. PR
## 12791
by
@Vincy1230
.
üåê Add Korean translation for
docs/ko/docs/advanced/templates.md
. PR
## 12726
by
@Heumhub
.
üåê Add Russian translation for
docs/ru/docs/fastapi-cli.md
. PR
## 13041
by
@alv2017
.
üåê Add Korean translation for
docs/ko/docs/tutorial/cookie-param-models.md
. PR
## 13000
by
@hard-coders
.
üåê Add Korean translation for
docs/ko/docs/tutorial/header-param-models.md
. PR
## 13001
by
@hard-coders
.
üåê Add Korean translation for
docs/ko/docs/tutorial/request-form-models.md
. PR
## 13002
by
@hard-coders
.
üåê Add Korean translation for
docs/ko/docs/tutorial/request-forms.md
. PR
## 13003
by
@hard-coders
.
üåê Add Korean translation for
docs/ko/docs/resources/index.md
. PR
## 13004
by
@hard-coders
.
üåê Add Korean translation for
docs/ko/docs/how-to/configure-swagger-ui.md
. PR
## 12898
by
@nahyunkeem
.
üåê Add Korean translation to
docs/ko/docs/advanced/additional-status-codes.md
. PR
## 12715
by
@nahyunkeem
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/tutorial/first-steps.md
. PR
## 12467
by
@codingjenny
.
Internal
üîß Add Pydantic 2 trove classifier. PR
## 13199
by
@johnthagen
.
üë• Update FastAPI People - Sponsors. PR
## 13231
by
@tiangolo
.
üë∑ Refactor FastAPI People Sponsors to use 2 tokens. PR
## 13228
by
@tiangolo
.
üë∑ Update token for FastAPI People - Sponsors. PR
## 13225
by
@tiangolo
.
üë∑ Add independent CI automation for FastAPI People - Sponsors. PR
## 13221
by
@tiangolo
.
üë∑ Add retries to Smokeshow. PR
## 13151
by
@tiangolo
.
üîß Update Speakeasy sponsor graphic. PR
## 13147
by
@chailandau
.
üë• Update FastAPI GitHub topic repositories. PR
## 13146
by
@tiangolo
.
üë∑‚Äç‚ôÄÔ∏è Add script for GitHub Topic Repositories and update External Links. PR
## 13135
by
@alejsdev
.
üë• Update FastAPI People - Contributors and Translators. PR
## 13145
by
@tiangolo
.
‚¨Ü Bump markdown-include-variants from 0.0.3 to 0.0.4. PR
## 13129
by
@dependabot[bot]
.
‚¨Ü Bump inline-snapshot from 0.14.0 to 0.18.1. PR
## 13132
by
@dependabot[bot]
.
‚¨Ü Bump mkdocs-macros-plugin from 1.0.5 to 1.3.7. PR
## 13133
by
@dependabot[bot]
.
üî® Add internal scripts to generate language translations with PydanticAI, include Spanish prompt. PR
## 13123
by
@tiangolo
.
‚¨Ü Bump astral-sh/setup-uv from 4 to 5. PR
## 13096
by
@dependabot[bot]
.
üîß Update sponsors: rename CryptAPI to BlockBee. PR
## 13078
by
@tiangolo
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.12.2 to 1.12.3. PR
## 13055
by
@dependabot[bot]
.
‚¨Ü Bump types-ujson from 5.7.0.1 to 5.10.0.20240515. PR
## 13018
by
@dependabot[bot]
.
‚¨Ü Bump black from 24.3.0 to 24.10.0. PR
## 13014
by
@dependabot[bot]
.
‚¨Ü Bump inline-snapshot from 0.13.0 to 0.14.0. PR
## 13017
by
@dependabot[bot]
.
‚¨Ü Bump dirty-equals from 0.6.0 to 0.8.0. PR
## 13015
by
@dependabot[bot]
.
‚¨Ü Bump cloudflare/wrangler-action from 3.12 to 3.13. PR
## 12996
by
@dependabot[bot]
.
‚¨Ü Bump astral-sh/setup-uv from 3 to 4. PR
## 12982
by
@dependabot[bot]
.
üîß Remove duplicate actions/checkout in
notify-translations.yml
. PR
## 12915
by
@tinyboxvk
.
üîß Update team members. PR
## 13033
by
@tiangolo
.
üìù Update sponsors: remove Codacy. PR
## 13032
by
@tiangolo
.
0.115.6
Fixes
üêõ Preserve traceback when an exception is raised in sync dependency with
yield
. PR
## 5823
by
@sombek
.
Refactors
‚ôªÔ∏è Update tests and internals for compatibility with Pydantic >=2.10. PR
## 12971
by
@tamird
.
Docs
üìù Update includes format in docs with an automated script. PR
## 12950
by
@tiangolo
.
üìù Update includes for
docs/de/docs/advanced/using-request-directly.md
. PR
## 12685
by
@alissadb
.
üìù Update includes for
docs/de/docs/how-to/conditional-openapi.md
. PR
## 12689
by
@alissadb
.
Translations
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/async.md
. PR
## 12990
by
@ILoveSorasakiHina
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/tutorial/query-param-models.md
. PR
## 12932
by
@Vincy1230
.
üåê Add Korean translation for
docs/ko/docs/advanced/testing-dependencies.md
. PR
## 12992
by
@Limsunoh
.
üåê Add Korean translation for
docs/ko/docs/advanced/websockets.md
. PR
## 12991
by
@kwang1215
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/response-model.md
. PR
## 12933
by
@AndreBBM
.
üåê Add Korean translation for
docs/ko/docs/advanced/middlewares.md
. PR
## 12753
by
@nahyunkeem
.
üåê Add Korean translation for
docs/ko/docs/advanced/openapi-webhooks.md
. PR
## 12752
by
@saeye
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/query-param-models.md
. PR
## 12931
by
@Vincy1230
.
üåê Add Russian translation for
docs/ru/docs/tutorial/query-param-models.md
. PR
## 12445
by
@gitgernit
.
üåê Add Korean translation for
docs/ko/docs/tutorial/query-param-models.md
. PR
## 12940
by
@jts8257
.
üî• Remove obsolete tutorial translation to Chinese for
docs/zh/docs/tutorial/sql-databases.md
, it references files that are no longer on the repo. PR
## 12949
by
@tiangolo
.
Internal
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12954
by
@pre-commit-ci[bot]
.
0.115.5
Refactors
‚ôªÔ∏è Update internal checks to support Pydantic 2.10. PR
## 12914
by
@tiangolo
.
Docs
üìù Update includes for
docs/en/docs/tutorial/body.md
. PR
## 12757
by
@gsheni
.
üìù Update includes in
docs/en/docs/advanced/testing-dependencies.md
. PR
## 12647
by
@AyushSinghal1794
.
üìù Update includes for
docs/en/docs/tutorial/metadata.md
. PR
## 12773
by
@Nimitha-jagadeesha
.
üìù Update
docs/en/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 12045
by
@xuvjso
.
üìù Update includes for
docs/en/docs/tutorial/dependencies/global-dependencies.md
. PR
## 12653
by
@vishnuvskvkl
.
üìù Update includes for
docs/en/docs/tutorial/body-updates.md
. PR
## 12712
by
@davioc
.
üìù Remove mention of Celery in the project generators. PR
## 12742
by
@david-caro
.
üìù Update includes in
docs/en/docs/tutorial/header-param-models.md
. PR
## 12814
by
@zhaohan-dong
.
üìù Update
contributing.md
docs, include note to not translate this page. PR
## 12841
by
@tiangolo
.
üìù Update includes in
docs/en/docs/tutorial/request-forms.md
. PR
## 12648
by
@vishnuvskvkl
.
üìù Update includes in
docs/en/docs/tutorial/request-form-models.md
. PR
## 12649
by
@vishnuvskvkl
.
üìù Update includes in
docs/en/docs/tutorial/security/oauth2-jwt.md
. PR
## 12650
by
@OCE1960
.
üìù Update includes in
docs/vi/docs/tutorial/first-steps.md
. PR
## 12754
by
@MxPy
.
üìù Update includes for
docs/pt/docs/advanced/wsgi.md
. PR
## 12769
by
@Nimitha-jagadeesha
.
üìù Update includes for
docs/en/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 12815
by
@handabaldeep
.
üìù Update includes for
docs/en/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 12813
by
@handabaldeep
.
‚úèÔ∏è Fix error in
docs/en/docs/tutorial/middleware.md
. PR
## 12819
by
@alejsdev
.
üìù Update includes for
docs/en/docs/tutorial/security/get-current-user.md
. PR
## 12645
by
@OCE1960
.
üìù Update includes for
docs/en/docs/tutorial/security/first-steps.md
. PR
## 12643
by
@OCE1960
.
üìù Update includes in
docs/de/docs/advanced/additional-responses.md
. PR
## 12821
by
@zhaohan-dong
.
üìù Update includes in
docs/en/docs/advanced/generate-clients.md
. PR
## 12642
by
@AyushSinghal1794
.
üìù Fix admonition double quotes with new syntax. PR
## 12835
by
@tiangolo
.
üìù Update includes in
docs/zh/docs/advanced/additional-responses.md
. PR
## 12828
by
@zhaohan-dong
.
üìù Update includes in
docs/en/docs/tutorial/path-params-numeric-validations.md
. PR
## 12825
by
@zhaohan-dong
.
üìù Update includes for
docs/en/docs/advanced/testing-websockets.md
. PR
## 12761
by
@hamidrasti
.
üìù Update includes for
docs/en/docs/advanced/using-request-directly.md
. PR
## 12760
by
@hamidrasti
.
üìù Update includes for
docs/advanced/wsgi.md
. PR
## 12758
by
@hamidrasti
.
üìù Update includes in
docs/de/docs/tutorial/middleware.md
. PR
## 12729
by
@paintdog
.
üìù Update includes for
docs/en/docs/tutorial/schema-extra-example.md
. PR
## 12822
by
@tiangolo
.
üìù Update includes in
docs/fr/docs/advanced/additional-responses.md
. PR
## 12634
by
@fegmorte
.
üìù Update includes in
docs/fr/docs/advanced/path-operation-advanced-configuration.md
. PR
## 12633
by
@kantandane
.
üìù Update includes in
docs/fr/docs/advanced/response-directly.md
. PR
## 12632
by
@kantandane
.
üìù Update includes for
docs/en/docs/tutorial/header-params.md
. PR
## 12640
by
@vishnuvskvkl
.
üìù Update includes in
docs/en/docs/tutorial/cookie-param-models.md
. PR
## 12639
by
@vishnuvskvkl
.
üìù Update includes for
docs/en/docs/tutorial/extra-models.md
. PR
## 12638
by
@vishnuvskvkl
.
üìù Update includes for
docs/en/docs/tutorial/cors.md
. PR
## 12637
by
@vishnuvskvkl
.
üìù Update includes for
docs/en/docs/tutorial/dependencies/sub-dependencies.md
. PR
## 12810
by
@handabaldeep
.
üìù Update includes in
docs/en/docs/tutorial/body-nested-models.md
. PR
## 12812
by
@zhaohan-dong
.
üìù Update includes in
docs/en/docs/tutorial/path-operation-configuration.md
. PR
## 12809
by
@AlexWendland
.
üìù Update includes in
docs/en/docs/tutorial/request-files.md
. PR
## 12818
by
@zhaohan-dong
.
üìù Update includes for
docs/en/docs/tutorial/query-param-models.md
. PR
## 12817
by
@handabaldeep
.
üìù Update includes in
docs/en/docs/tutorial/path-params.md
. PR
## 12811
by
@AlexWendland
.
üìù Update includes in
docs/en/docs/tutorial/response-model.md
. PR
## 12621
by
@kantandane
.
üìù Update includes in
docs/en/docs/advanced/websockets.md
. PR
## 12606
by
@vishnuvskvkl
.
üìù Updates include for
docs/en/docs/tutorial/cookie-params.md
. PR
## 12808
by
@handabaldeep
.
üìù Update includes in
docs/en/docs/tutorial/middleware.md
. PR
## 12807
by
@AlexWendland
.
üìù Update includes in
docs/en/docs/advanced/sub-applications.md
. PR
## 12806
by
@zhaohan-dong
.
üìù Update includes in
docs/en/docs/advanced/response-headers.md
. PR
## 12805
by
@zhaohan-dong
.
üìù Update includes in
docs/fr/docs/tutorial/first-steps.md
. PR
## 12594
by
@kantandane
.
üìù Update includes in
docs/en/docs/advanced/response-cookies.md
. PR
## 12804
by
@zhaohan-dong
.
üìù Update includes in
docs/en/docs/advanced/path-operation-advanced-configuration.md
. PR
## 12802
by
@zhaohan-dong
.
üìù Update includes for
docs/en/docs/advanced/response-directly.md
. PR
## 12803
by
@handabaldeep
.
üìù Update includes in
docs/zh/docs/tutorial/background-tasks.md
. PR
## 12798
by
@zhaohan-dong
.
üìù Update includes for
docs/de/docs/tutorial/body-multiple-params.md
. PR
## 12699
by
@alissadb
.
üìù Update includes in
docs/em/docs/tutorial/body-updates.md
. PR
## 12799
by
@AlexWendland
.
üìù Update includes
docs/en/docs/advanced/response-change-status-code.md
. PR
## 12801
by
@handabaldeep
.
üìù Update includes
docs/en/docs/advanced/openapi-callbacks.md
. PR
## 12800
by
@handabaldeep
.
üìù Update includes in
docs/fr/docs/tutorial/body-multiple-params.md
. PR
## 12598
by
@kantandane
.
üìù Update includes in
docs/en/docs/tutorial/body-multiple-params.md
. PR
## 12593
by
@Tashanam-Shahbaz
.
üìù Update includes in
docs/pt/docs/tutorial/background-tasks.md
. PR
## 12736
by
@bhunao
.
üìù Update includes for
docs/en/docs/advanced/custom-response.md
. PR
## 12797
by
@handabaldeep
.
üìù Update includes for
docs/pt/docs/python-types.md
. PR
## 12671
by
@ceb10n
.
üìù Update includes for
docs/de/docs/python-types.md
. PR
## 12660
by
@alissadb
.
üìù Update includes for
docs/de/docs/advanced/dataclasses.md
. PR
## 12658
by
@alissadb
.
üìù Update includes in
docs/fr/docs/tutorial/path-params.md
. PR
## 12592
by
@kantandane
.
üìù Update includes for
docs/de/docs/how-to/configure-swagger-ui.md
. PR
## 12690
by
@alissadb
.
üìù Update includes in
docs/en/docs/advanced/security/oauth2-scopes.md
. PR
## 12572
by
@krishnamadhavan
.
üìù Update includes for
docs/en/docs/how-to/conditional-openapi.md
. PR
## 12624
by
@rabinlamadong
.
üìù Update includes in
docs/en/docs/tutorial/dependencies/index.md
. PR
## 12615
by
@bharara
.
üìù Update includes in
docs/en/docs/tutorial/response-status-code.md
. PR
## 12620
by
@kantandane
.
üìù Update includes in
docs/en/docs/how-to/custom-docs-ui-assets.md
. PR
## 12623
by
@rabinlamadong
.
üìù Update includes in
docs/en/docs/advanced/openapi-webhooks.md
. PR
## 12605
by
@salmantec
.
üìù Update includes in
docs/en/docs/advanced/events.md
. PR
## 12604
by
@salmantec
.
üìù Update includes in
docs/en/docs/advanced/dataclasses.md
. PR
## 12603
by
@salmantec
.
üìù Update includes in
docs/es/docs/tutorial/cookie-params.md
. PR
## 12602
by
@antonyare93
.
üìù Update includes in
docs/fr/docs/tutorial/path-params-numeric-validations.md
. PR
## 12601
by
@kantandane
.
üìù Update includes in
docs/fr/docs/tutorial/background-tasks.md
. PR
## 12600
by
@kantandane
.
üìù Update includes in
docs/en/docs/tutorial/encoder.md
. PR
## 12597
by
@tonyjly
.
üìù Update includes in
docs/en/docs/how-to/custom-docs-ui-assets.md
. PR
## 12557
by
@philipokiokio
.
üé® Adjust spacing. PR
## 12635
by
@alejsdev
.
üìù Update includes in
docs/en/docs/how-to/custom-request-and-route.md
. PR
## 12560
by
@philipokiokio
.
Translations
üåê Add Korean translation for
docs/ko/docs/advanced/testing-websockets.md
. PR
## 12739
by
@Limsunoh
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/environment-variables.md
. PR
## 12785
by
@Vincy1230
.
üåê Add Chinese translation for
docs/zh/docs/environment-variables.md
. PR
## 12784
by
@Vincy1230
.
üåê Add Korean translation for
ko/docs/advanced/response-headers.md
. PR
## 12740
by
@kwang1215
.
üåê Add Chinese translation for
docs/zh/docs/virtual-environments.md
. PR
## 12790
by
@Vincy1230
.
üåê Add Korean translation for
/docs/ko/docs/environment-variables.md
. PR
## 12526
by
@Tolerblanc
.
üåê Add Korean translation for
docs/ko/docs/history-design-future.md
. PR
## 12646
by
@saeye
.
üåê Add Korean translation for
docs/ko/docs/advanced/advanced-dependencies.md
. PR
## 12675
by
@kim-sangah
.
üåê Add Korean translation for
docs/ko/docs/how-to/conditional-openapi.md
. PR
## 12731
by
@sptcnl
.
üåê Add Korean translation for
docs/ko/docs/advanced/using_request_directly.md
. PR
## 12738
by
@kwang1215
.
üåê Add Korean translation for
docs/ko/docs/advanced/testing-events.md
. PR
## 12741
by
@9zimin9
.
üåê Add Korean translation for
docs/ko/docs/security/index.md
. PR
## 12743
by
@kim-sangah
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/path-operation-advanced-configuration.md
. PR
## 12762
by
@Joao-Pedro-P-Holanda
.
üåê Add Korean translation for
docs/ko/docs/advanced/wsgi.md
. PR
## 12659
by
@Limsunoh
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/websockets.md
. PR
## 12703
by
@devfernandoa
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/security/simple-oauth2.md
. PR
## 12520
by
@LidiaDomingos
.
üåê Add Korean translation for
docs/ko/docs/advanced/response-directly.md
. PR
## 12674
by
@9zimin9
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/middleware.md
. PR
## 12704
by
@devluisrodrigues
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/openapi-callbacks.md
. PR
## 12705
by
@devfernandoa
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/request-files.md
. PR
## 12706
by
@devluisrodrigues
.
üåê Add Portuguese Translation for
docs/pt/docs/advanced/custom-response.md
. PR
## 12631
by
@Joao-Pedro-P-Holanda
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/metadata.md
. PR
## 12538
by
@LinkolnR
.
üåê Add Korean translation for
docs/ko/docs/tutorial/metadata.md
. PR
## 12541
by
@kwang1215
.
üåê Add Korean Translation for
docs/ko/docs/advanced/response-cookies.md
. PR
## 12546
by
@kim-sangah
.
üåê Add Korean translation for
docs/ko/docs/fastapi-cli.md
. PR
## 12515
by
@dhdld
.
üåê Add Korean Translation for
docs/ko/docs/advanced/response-change-status-code.md
. PR
## 12547
by
@9zimin9
.
Internal
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12907
by
@pre-commit-ci[bot]
.
üî® Update docs preview script to show previous version and English version. PR
## 12856
by
@tiangolo
.
‚¨Ü Bump tiangolo/latest-changes from 0.3.1 to 0.3.2. PR
## 12794
by
@dependabot[bot]
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.12.0 to 1.12.2. PR
## 12788
by
@dependabot[bot]
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.11.0 to 1.12.0. PR
## 12781
by
@dependabot[bot]
.
‚¨Ü Bump cloudflare/wrangler-action from 3.11 to 3.12. PR
## 12777
by
@dependabot[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12766
by
@pre-commit-ci[bot]
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.10.3 to 1.11.0. PR
## 12721
by
@dependabot[bot]
.
‚¨Ü Update pre-commit requirement from <4.0.0,>=2.17.0 to >=2.17.0,<5.0.0. PR
## 12749
by
@dependabot[bot]
.
‚¨Ü Bump typer from 0.12.3 to 0.12.5. PR
## 12748
by
@dependabot[bot]
.
‚¨Ü Update flask requirement from <3.0.0,>=1.1.2 to >=1.1.2,<4.0.0. PR
## 12747
by
@dependabot[bot]
.
‚¨Ü Bump pillow from 10.4.0 to 11.0.0. PR
## 12746
by
@dependabot[bot]
.
‚¨Ü Update pytest requirement from <8.0.0,>=7.1.3 to >=7.1.3,<9.0.0. PR
## 12745
by
@dependabot[bot]
.
üîß Update sponsors: add Render. PR
## 12733
by
@tiangolo
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12707
by
@pre-commit-ci[bot]
.
0.115.4
Refactors
‚ôªÔ∏è Update logic to import and check
python-multipart
for compatibility with newer version. PR
## 12627
by
@tiangolo
.
Docs
üìù Update includes in
docs/fr/docs/tutorial/body.md
. PR
## 12596
by
@kantandane
.
üìù Update includes in
docs/fr/docs/tutorial/debugging.md
. PR
## 12595
by
@kantandane
.
üìù Update includes in
docs/fr/docs/tutorial/query-params-str-validations.md
. PR
## 12591
by
@kantandane
.
üìù Update includes in
docs/fr/docs/tutorial/query-params.md
. PR
## 12589
by
@kantandane
.
üìù Update includes in
docs/en/tutorial/body-fields.md
. PR
## 12588
by
@lucaromagnoli
.
üìù Update includes in
docs/de/docs/tutorial/response-status-code.md
. PR
## 12585
by
@abejaranoh
.
üìù Update includes in
docs/en/docs/tutorial/body.md
. PR
## 12586
by
@lucaromagnoli
.
üìù Update includes in
docs/en/docs/advanced/behind-a-proxy.md
. PR
## 12583
by
@imjuanleonard
.
üìù Update includes syntax for
docs/pl/docs/tutorial/first-steps.md
. PR
## 12584
by
@sebkozlo
.
üìù Update includes in
docs/en/docs/advanced/middleware.md
. PR
## 12582
by
@montanarograziano
.
üìù Update includes in
docs/en/docs/advanced/additional-status-codes.md
. PR
## 12577
by
@krishnamadhavan
.
üìù Update includes in
docs/en/docs/advanced/advanced-dependencies.md
. PR
## 12578
by
@krishnamadhavan
.
üìù Update includes in
docs/en/docs/advanced/additional-responses.md
. PR
## 12576
by
@krishnamadhavan
.
üìù Update includes in
docs/en/docs/tutorial/static-files.md
. PR
## 12575
by
@lucaromagnoli
.
üìù Update includes in
docs/en/docs/advanced/async-tests.md
. PR
## 12568
by
@krishnamadhavan
.
üìù Update includes in
docs/pt/docs/advanced/behind-a-proxy.md
. PR
## 12563
by
@asmioglou
.
üìù Update includes in
docs/de/docs/advanced/security/http-basic-auth.md
. PR
## 12561
by
@Nimitha-jagadeesha
.
üìù Update includes in
docs/en/docs/tutorial/background-tasks.md
. PR
## 12559
by
@FarhanAliRaza
.
üìù Update includes in
docs/fr/docs/python-types.md
. PR
## 12558
by
@Ismailtlem
.
üìù Update includes in
docs/en/docs/how-to/graphql.md
. PR
## 12564
by
@philipokiokio
.
üìù Update includes in
docs/en/docs/how-to/extending-openapi.md
. PR
## 12562
by
@philipokiokio
.
üìù Update includes for
docs/en/docs/how-to/configure-swagger-ui.md
. PR
## 12556
by
@tiangolo
.
üìù Update includes for
docs/en/docs/how-to/separate-openapi-schemas.md
. PR
## 12555
by
@tiangolo
.
üìù Update includes for
docs/en/docs/advanced/security/http-basic-auth.md
. PR
## 12553
by
@tiangolo
.
üìù Update includes in
docs/en/docs/tutorial/first-steps.md
. PR
## 12552
by
@tiangolo
.
üìù Update includes in
docs/en/docs/python-types.md
. PR
## 12551
by
@tiangolo
.
üìù Fix link in OAuth2 docs. PR
## 12550
by
@tiangolo
.
üìù Add External Link: FastAPI do Zero. PR
## 12533
by
@rennerocha
.
üìù Fix minor typos. PR
## 12516
by
@kkirsche
.
üåê Fix rendering issue in translations. PR
## 12509
by
@alejsdev
.
Translations
üìù Update includes in
docs/de/docs/advanced/async-tests.md
. PR
## 12567
by
@imjuanleonard
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/sql-databases.md
. PR
## 12530
by
@ilacftemp
.
üåê Add Korean translation for
docs/ko/docs/benchmarks.md
. PR
## 12540
by
@Limsunoh
.
üåê Add Portuguese translation for
docs/pt/docs/how-to/separate-openapi-schemas.md
. PR
## 12518
by
@ilacftemp
.
üåê Update Traditional Chinese translation for
docs/zh-hant/docs/deployment/index.md
. PR
## 12521
by
@codingjenny
.
üåê Update Traditional Chinese translation for
docs/zh-hant/docs/deployment/cloud.md
. PR
## 12522
by
@codingjenny
.
üåê Update Traditional Chinese translation for
docs/zh-hant/docs/how-to/index.md
. PR
## 12523
by
@codingjenny
.
üåê Update Traditional Chinese translation for
docs/zh-hant/docs/tutorial/index.md
. PR
## 12524
by
@codingjenny
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/how-to/index.md
. PR
## 12468
by
@codingjenny
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/tutorial/index.md
. PR
## 12466
by
@codingjenny
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/header-param-models.md
. PR
## 12437
by
@Joao-Pedro-P-Holanda
.
üåê Add Portuguese translation for
docs/pt/docs/how-to/extending-openapi.md
. PR
## 12470
by
@ilacftemp
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/dataclasses.md
. PR
## 12475
by
@leoscarlato
.
üåê Add Portuguese translation for
docs/pt/docs/how-to/custom-request-and-route.md
. PR
## 12483
by
@devfernandoa
.
Internal
‚¨Ü Bump cloudflare/wrangler-action from 3.9 to 3.11. PR
## 12544
by
@dependabot[bot]
.
üë∑ Update GitHub Action to deploy docs previews to handle missing deploy comments. PR
## 12527
by
@tiangolo
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12505
by
@pre-commit-ci[bot]
.
0.115.3
Upgrades
‚¨ÜÔ∏è Upgrade Starlette to
>=0.40.0,<0.42.0
. PR
## 12469
by
@defnull
.
Docs
üìù Fix broken link in docs. PR
## 12495
by
@eltonjncorreia
.
Translations
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/fastapi-cli.md
. PR
## 12444
by
@codingjenny
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/deployment/index.md
. PR
## 12439
by
@codingjenny
.
üåê Add Portuguese translation for
docs/pt/docs/how-to/testing-database.md
. PR
## 12472
by
@GuilhermeRameh
.
üåê Add Portuguese translation for
docs/pt/docs/how-to/custom-docs-ui-assets.md
. PR
## 12473
by
@devluisrodrigues
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/response-headers.md
. PR
## 12458
by
@leonardopaloschi
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/deployment/cloud.md
. PR
## 12440
by
@codingjenny
.
üåê Update Portuguese translation for
docs/pt/docs/python-types.md
. PR
## 12428
by
@ceb10n
.
üåê Add Russian translation for
docs/ru/docs/environment-variables.md
. PR
## 12436
by
@wisderfin
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/resources/index.md
. PR
## 12443
by
@codingjenny
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/about/index.md
. PR
## 12438
by
@codingjenny
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/query-param-models.md
. PR
## 12414
by
@ceb10n
.
üåê Remove Portuguese translation for
docs/pt/docs/deployment.md
. PR
## 12427
by
@ceb10n
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/body-updates.md
. PR
## 12381
by
@andersonrocha0
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/response-cookies.md
. PR
## 12417
by
@Paulofalcao2002
.
Internal
üë∑ Update issue manager workflow . PR
## 12457
by
@alejsdev
.
üîß Update team, include YuriiMotov üöÄ. PR
## 12453
by
@tiangolo
.
üë∑ Refactor label-approved, make it an internal script instead of an external GitHub Action. PR
## 12280
by
@tiangolo
.
üë∑ Fix smokeshow, checkout files on CI. PR
## 12434
by
@tiangolo
.
üë∑ Use uv in CI. PR
## 12281
by
@tiangolo
.
‚¨Ü Update httpx requirement from <0.25.0,>=0.23.0 to >=0.23.0,<0.28.0. PR
## 11509
by
@dependabot[bot]
.
0.115.2
Upgrades
‚¨ÜÔ∏è Upgrade Starlette to
>=0.37.2,<0.41.0
. PR
## 12431
by
@tiangolo
.
0.115.1
Fixes
üêõ Fix openapi generation with responses kwarg. PR
## 10895
by
@flxdot
.
üêõ Remove
Required
shadowing from fastapi using Pydantic v2. PR
## 12197
by
@pachewise
.
Refactors
‚ôªÔ∏è Update type annotations for improved
python-multipart
. PR
## 12407
by
@tiangolo
.
Docs
‚ú® Add new tutorial for SQL databases with SQLModel. PR
## 12285
by
@tiangolo
.
üìù Add External Link: How to profile a FastAPI asynchronous request. PR
## 12389
by
@brouberol
.
üîß Remove
base_path
for
mdx_include
Markdown extension in MkDocs. PR
## 12391
by
@tiangolo
.
üìù Update link to Swagger UI configuration docs. PR
## 12264
by
@makisukurisu
.
üìù Adding links for Playwright and Vite in
docs/project-generation.md
. PR
## 12274
by
@kayqueGovetri
.
üìù Fix small typos in the documentation. PR
## 12213
by
@svlandeg
.
Translations
üåê Add Portuguese translation for
docs/pt/docs/tutorial/cookie-param-models.md
. PR
## 12298
by
@ceb10n
.
üåê Add Portuguese translation for
docs/pt/docs/how-to/graphql.md
. PR
## 12215
by
@AnandaCampelo
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/security/oauth2-scopes.md
. PR
## 12263
by
@ceb10n
.
üåê Add Portuguese translation for
docs/pt/docs/deployment/concepts.md
. PR
## 12219
by
@marcelomarkus
.
üåê Add Portuguese translation for
docs/pt/docs/how-to/conditional-openapi.md
. PR
## 12221
by
@marcelomarkus
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/response-directly.md
. PR
## 12266
by
@Joao-Pedro-P-Holanda
.
üåê Update Portuguese translation for
docs/pt/docs/tutorial/cookie-params.md
. PR
## 12297
by
@ceb10n
.
üåê Fix Korean translation for
docs/ko/docs/tutorial/index.md
. PR
## 12278
by
@kkotipy
.
üåê Update Portuguese translation for
docs/pt/docs/advanced/security/http-basic-auth.md
. PR
## 12275
by
@andersonrocha0
.
üåê Add Portuguese translation for
docs/pt/docs/deployment/cloud.md
. PR
## 12217
by
@marcelomarkus
.
‚úèÔ∏è Fix typo in
docs/es/docs/python-types.md
. PR
## 12235
by
@JavierSanchezCastro
.
üåê Add Dutch translation for
docs/nl/docs/environment-variables.md
. PR
## 12200
by
@maxscheijen
.
üåê Add Portuguese translation for
docs/pt/docs/deployment/manually.md
. PR
## 12210
by
@JoaoGustavoRogel
.
üåê Add Portuguese translation for
docs/pt/docs/deployment/server-workers.md
. PR
## 12220
by
@marcelomarkus
.
üåê Add Portuguese translation for
docs/pt/docs/how-to/configure-swagger-ui.md
. PR
## 12222
by
@marcelomarkus
.
Internal
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12396
by
@pre-commit-ci[bot]
.
üî® Add script to generate variants of files. PR
## 12405
by
@tiangolo
.
üîß Add speakeasy-api to
sponsors_badge.yml
. PR
## 12404
by
@tiangolo
.
‚ûï Add docs dependency: markdown-include-variants. PR
## 12399
by
@tiangolo
.
üìù Fix extra mdx-base-path paths. PR
## 12397
by
@tiangolo
.
üë∑ Tweak labeler to not override custom labels. PR
## 12398
by
@tiangolo
.
üë∑ Update worfkow deploy-docs-notify URL. PR
## 12392
by
@tiangolo
.
üë∑ Update Cloudflare GitHub Action. PR
## 12387
by
@tiangolo
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.10.1 to 1.10.3. PR
## 12386
by
@dependabot[bot]
.
‚¨Ü Bump mkdocstrings[python] from 0.25.1 to 0.26.1. PR
## 12371
by
@dependabot[bot]
.
‚¨Ü Bump griffe-typingdoc from 0.2.6 to 0.2.7. PR
## 12370
by
@dependabot[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12331
by
@pre-commit-ci[bot]
.
üîß Update sponsors, remove Fine.dev. PR
## 12271
by
@tiangolo
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12253
by
@pre-commit-ci[bot]
.
‚úèÔ∏è Fix docstring typos in http security. PR
## 12223
by
@albertvillanova
.
0.115.0
Highlights
Now you can declare
Query
,
Header
, and
Cookie
parameters with Pydantic models. üéâ
Query
Parameter Models
Use Pydantic models for
Query
parameters:
from
typing
import
Annotated
,
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
Read the new docs:
Query Parameter Models
.
Header
Parameter Models
Use Pydantic models for
Header
parameters:
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
Read the new docs:
Header Parameter Models
.
Cookie
Parameter Models
Use Pydantic models for
Cookie
parameters:
from
typing
import
Annotated
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
str
|
None
=
None
googall_tracker
:
str
|
None
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
Read the new docs:
Cookie Parameter Models
.
Forbid Extra Query (Cookie, Header) Parameters
Use Pydantic models to restrict extra values for
Query
parameters (also applies to
Header
and
Cookie
parameters).
To achieve it, use Pydantic's
model_config = {"extra": "forbid"}
:
from
typing
import
Annotated
,
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
This applies to
Query
,
Header
, and
Cookie
parameters, read the new docs:
Forbid Extra Query Parameters
Forbid Extra Headers
Forbid Extra Cookies
Features
‚ú® Add support for Pydantic models for parameters using
Query
,
Cookie
,
Header
. PR
## 12199
by
@tiangolo
.
Translations
üåê Add Portuguese translation for
docs/pt/docs/advanced/security/http-basic-auth.md
. PR
## 12195
by
@ceb10n
.
Internal
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12204
by
@pre-commit-ci[bot]
.
0.114.2
Fixes
üêõ Fix form field regression with
alias
. PR
## 12194
by
@Wurstnase
.
Translations
üåê Add Portuguese translation for
docs/pt/docs/tutorial/request-form-models.md
. PR
## 12175
by
@ceb10n
.
üåê Add Chinese translation for
docs/zh/docs/project-generation.md
. PR
## 12170
by
@waketzheng
.
üåê Add Dutch translation for
docs/nl/docs/python-types.md
. PR
## 12158
by
@maxscheijen
.
Internal
üí° Add comments with instructions for Playwright screenshot scripts. PR
## 12193
by
@tiangolo
.
‚ûï Add inline-snapshot for tests. PR
## 12189
by
@tiangolo
.
0.114.1
Refactors
‚ö°Ô∏è Improve performance in request body parsing with a cache for internal model fields. PR
## 12184
by
@tiangolo
.
Docs
üìù Remove duplicate line in docs for
docs/en/docs/environment-variables.md
. PR
## 12169
by
@prometek
.
Translations
üåê Add Portuguese translation for
docs/pt/docs/virtual-environments.md
. PR
## 12163
by
@marcelomarkus
.
üåê Add Portuguese translation for
docs/pt/docs/environment-variables.md
. PR
## 12162
by
@marcelomarkus
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/testing.md
. PR
## 12164
by
@marcelomarkus
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/debugging.md
. PR
## 12165
by
@marcelomarkus
.
üåê Add Korean translation for
docs/ko/docs/project-generation.md
. PR
## 12157
by
@BORA040126
.
Internal
‚¨Ü Bump tiangolo/issue-manager from 0.5.0 to 0.5.1. PR
## 12173
by
@dependabot[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12176
by
@pre-commit-ci[bot]
.
üë∑ Update
issue-manager.yml
. PR
## 12159
by
@tiangolo
.
‚úèÔ∏è Fix typo in
fastapi/params.py
. PR
## 12143
by
@surreal30
.
0.114.0
You can restrict form fields to only include those declared in a Pydantic model and forbid any extra field sent in the request using Pydantic's
model_config = {"extra": "forbid"}
:
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
model_config
=
{
"extra"
:
"forbid"
}
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
Read the new docs:
Form Models - Forbid Extra Form Fields
.
Features
‚ú® Add support for forbidding extra form fields with Pydantic models. PR
## 12134
by
@tiangolo
.
Docs
üìù Update docs, Form Models section title, to match config name. PR
## 12152
by
@tiangolo
.
Internal
‚úÖ Update internal tests for latest Pydantic, including CI tweaks to install the latest Pydantic. PR
## 12147
by
@tiangolo
.
0.113.0
Now you can declare form fields with Pydantic models:
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
Read the new docs:
Form Models
.
Features
‚ú® Add support for Pydantic models in
Form
parameters. PR
## 12129
by
@tiangolo
.
Internal
üîß Update sponsors: Coherence link. PR
## 12130
by
@tiangolo
.
0.112.4
This release is mainly a big internal refactor to enable adding support for Pydantic models for
Form
fields, but that feature comes in the next release.
This release shouldn't affect apps using FastAPI in any way. You don't even have to upgrade to this version yet. It's just a checkpoint. ü§ì
Refactors
‚ôªÔ∏è Refactor deciding if
embed
body fields, do not overwrite fields, compute once per router, refactor internals in preparation for Pydantic models in
Form
,
Query
and others. PR
## 12117
by
@tiangolo
.
Internal
‚è™Ô∏è Temporarily revert "‚ú® Add support for Pydantic models in
Form
parameters" to make a checkpoint release. PR
## 12128
by
@tiangolo
. Restored by PR
## 12129
.
‚ú® Add support for Pydantic models in
Form
parameters. PR
## 12127
by
@tiangolo
. Reverted by PR
## 12128
to make a checkpoint release with only refactors. Restored by PR
## 12129
.
0.112.3
This release is mainly internal refactors, it shouldn't affect apps using FastAPI in any way. You don't even have to upgrade to this version yet. There are a few bigger releases coming right after. üöÄ
Refactors
‚ôªÔ∏è Refactor internal
check_file_field()
, rename to
ensure_multipart_is_installed()
to clarify its purpose. PR
## 12106
by
@tiangolo
.
‚ôªÔ∏è Rename internal
create_response_field()
to
create_model_field()
as it's used for more than response models. PR
## 12103
by
@tiangolo
.
‚ôªÔ∏è Refactor and simplify internal data from
solve_dependencies()
using dataclasses. PR
## 12100
by
@tiangolo
.
‚ôªÔ∏è Refactor and simplify internal
analyze_param()
to structure data with dataclasses instead of tuple. PR
## 12099
by
@tiangolo
.
‚ôªÔ∏è Refactor and simplify dependencies data structures with dataclasses. PR
## 12098
by
@tiangolo
.
Docs
üìù Add External Link: Techniques and applications of SQLAlchemy global filters in FastAPI. PR
## 12109
by
@TheShubhendra
.
üìù Add note about
time.perf_counter()
in middlewares. PR
## 12095
by
@tiangolo
.
üìù Tweak middleware code sample
time.time()
to
time.perf_counter()
. PR
## 11957
by
@domdent
.
üîß Update sponsors: Coherence. PR
## 12093
by
@tiangolo
.
üìù Fix async test example not to trigger DeprecationWarning. PR
## 12084
by
@marcinsulikowski
.
üìù Update
docs_src/path_params_numeric_validations/tutorial006.py
. PR
## 11478
by
@MuhammadAshiqAmeer
.
üìù Update comma in
docs/en/docs/async.md
. PR
## 12062
by
@Alec-Gillis
.
üìù Update docs about serving FastAPI: ASGI servers, Docker containers, etc.. PR
## 12069
by
@tiangolo
.
üìù Clarify
response_class
parameter, validations, and returning a response directly. PR
## 12067
by
@tiangolo
.
üìù Fix minor typos and issues in the documentation. PR
## 12063
by
@svlandeg
.
üìù Add note in Docker docs about ensuring graceful shutdowns and lifespan events with
CMD
exec form. PR
## 11960
by
@GPla
.
Translations
üåê Add Dutch translation for
docs/nl/docs/features.md
. PR
## 12101
by
@maxscheijen
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/testing-events.md
. PR
## 12108
by
@ceb10n
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/security/index.md
. PR
## 12114
by
@ceb10n
.
üåê Add Dutch translation for
docs/nl/docs/index.md
. PR
## 12042
by
@svlandeg
.
üåê Update Chinese translation for
docs/zh/docs/how-to/index.md
. PR
## 12070
by
@synthpop123
.
Internal
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12115
by
@pre-commit-ci[bot]
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.10.0 to 1.10.1. PR
## 12120
by
@dependabot[bot]
.
‚¨Ü Bump pillow from 10.3.0 to 10.4.0. PR
## 12105
by
@dependabot[bot]
.
üíö Set
include-hidden-files
to
True
when using the
upload-artifact
GH action. PR
## 12118
by
@svlandeg
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.9.0 to 1.10.0. PR
## 12112
by
@dependabot[bot]
.
üîß Update sponsors link: Coherence. PR
## 12097
by
@tiangolo
.
üîß Update labeler config to handle sponsorships data. PR
## 12096
by
@tiangolo
.
üîß Update sponsors, remove Kong. PR
## 12085
by
@tiangolo
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12076
by
@pre-commit-ci[bot]
.
üë∑ Update
latest-changes
GitHub Action. PR
## 12073
by
@tiangolo
.
0.112.2
Fixes
üêõ Fix
allow_inf_nan
option for Param and Body classes. PR
## 11867
by
@giunio-prc
.
üêõ Ensure that
app.include_router
merges nested lifespans. PR
## 9630
by
@Lancetnik
.
Refactors
üé® Fix typing annotation for semi-internal
FastAPI.add_api_route()
. PR
## 10240
by
@ordinary-jamie
.
‚¨ÜÔ∏è Upgrade version of Ruff and reformat. PR
## 12032
by
@tiangolo
.
Docs
üìù Fix a typo in
docs/en/docs/virtual-environments.md
. PR
## 12064
by
@aymenkrifa
.
üìù Add docs about Environment Variables and Virtual Environments. PR
## 12054
by
@tiangolo
.
üìù Add Asyncer mention in async docs. PR
## 12037
by
@tiangolo
.
üìù Move the Features docs to the top level to improve the main page menu. PR
## 12036
by
@tiangolo
.
‚úèÔ∏è Fix import typo in reference example for
Security
. PR
## 11168
by
@0shah0
.
üìù Highlight correct line in tutorial
docs/en/docs/tutorial/body-multiple-params.md
. PR
## 11978
by
@svlandeg
.
üî• Remove Sentry link from Advanced Middleware docs. PR
## 12031
by
@alejsdev
.
üìù Clarify management tasks for translations, multiples files in one PR. PR
## 12030
by
@tiangolo
.
üìù Edit the link to the OpenAPI "Responses Object" and "Response Object" sections in the "Additional Responses in OpenAPI" section. PR
## 11996
by
@VaitoSoi
.
üî® Specify
email-validator
dependency with dash. PR
## 11515
by
@jirikuncar
.
üåê Add Spanish translation for
docs/es/docs/project-generation.md
. PR
## 11947
by
@alejsdev
.
üìù Fix minor typo. PR
## 12026
by
@MicaelJarniac
.
üìù Several docs improvements, tweaks, and clarifications. PR
## 11390
by
@nilslindemann
.
üìù Add missing
compresslevel
parameter on docs for
GZipMiddleware
. PR
## 11350
by
@junah201
.
üìù Fix inconsistent response code when item already exists in docs for testing. PR
## 11818
by
@lokomilo
.
üìù Update
docs/en/docs/tutorial/body.md
with Python 3.10 union type example. PR
## 11415
by
@rangzen
.
Translations
üåê Add Portuguese translation for
docs/pt/docs/tutorial/request_file.md
. PR
## 12018
by
@Joao-Pedro-P-Holanda
.
üåê Add Japanese translation for
docs/ja/docs/learn/index.md
. PR
## 11592
by
@ukwhatn
.
üìù Update Spanish translation docs for consistency. PR
## 12044
by
@alejsdev
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 12028
by
@xuvjso
.
üìù Update FastAPI People, do not translate to have the most recent info. PR
## 12034
by
@tiangolo
.
üåê Update Urdu translation for
docs/ur/docs/benchmarks.md
. PR
## 10046
by
@AhsanSheraz
.
Internal
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 12046
by
@pre-commit-ci[bot]
.
üîß Update coverage config files. PR
## 12035
by
@tiangolo
.
üî® Standardize shebang across shell scripts. PR
## 11942
by
@gitworkflows
.
‚¨Ü Update sqlalchemy requirement from <1.4.43,>=1.3.18 to >=1.3.18,<2.0.33. PR
## 11979
by
@dependabot[bot]
.
üîä Remove old ignore warnings. PR
## 11950
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade griffe-typingdoc for the docs. PR
## 12029
by
@tiangolo
.
üôà Add .coverage* to
.gitignore
. PR
## 11940
by
@gitworkflows
.
‚öôÔ∏è Record and show test coverage contexts (what test covers which line). PR
## 11518
by
@slafs
.
0.112.1
Upgrades
‚¨ÜÔ∏è Allow Starlette 0.38.x, update the pin to
>=0.37.2,<0.39.0
. PR
## 11876
by
@musicinmybrain
.
Docs
üìù Update docs section about "Don't Translate these Pages". PR
## 12022
by
@tiangolo
.
üìù Add documentation for non-translated pages and scripts to verify them. PR
## 12020
by
@tiangolo
.
üìù Update docs about discussions questions. PR
## 11985
by
@tiangolo
.
Translations
üåê Add Portuguese translation for
docs/pt/docs/tutorial/bigger-applications.md
. PR
## 11971
by
@marcelomarkus
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/testing-websockets.md
. PR
## 11994
by
@ceb10n
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/testing-dependencies.md
. PR
## 11995
by
@ceb10n
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/using-request-directly.md
. PR
## 11956
by
@ceb10n
.
üåê Add French translation for
docs/fr/docs/tutorial/body-multiple-params.md
. PR
## 11796
by
@pe-brian
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/query-params.md
. PR
## 11557
by
@caomingpei
.
üåê Update typo in Chinese translation for
docs/zh/docs/advanced/testing-dependencies.md
. PR
## 11944
by
@bestony
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/sub-applications.md
and
docs/pt/docs/advanced/behind-a-proxy.md
. PR
## 11856
by
@marcelomarkus
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/cors.md
and
docs/pt/docs/tutorial/middleware.md
. PR
## 11916
by
@wesinalves
.
üåê Add French translation for
docs/fr/docs/tutorial/path-params-numeric-validations.md
. PR
## 11788
by
@pe-brian
.
Internal
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.8.14 to 1.9.0. PR
## 11727
by
@dependabot[bot]
.
üîß Add changelog URL to
pyproject.toml
, shows in PyPI. PR
## 11152
by
@Pierre-VF
.
üë∑ Do not sync labels as it overrides manually added labels. PR
## 12024
by
@tiangolo
.
üë∑üèª Update Labeler GitHub Actions. PR
## 12019
by
@tiangolo
.
üîß Update configs for MkDocs for languages and social cards. PR
## 12016
by
@tiangolo
.
üë∑ Update permissions and config for labeler GitHub Action. PR
## 12008
by
@tiangolo
.
üë∑üèª Add GitHub Action label-checker. PR
## 12005
by
@tiangolo
.
üë∑ Add label checker GitHub Action. PR
## 12004
by
@tiangolo
.
üë∑ Update GitHub Action add-to-project. PR
## 12002
by
@tiangolo
.
üîß Update labeler GitHub Action. PR
## 12001
by
@tiangolo
.
üë∑ Add GitHub Action labeler. PR
## 12000
by
@tiangolo
.
üë∑ Add GitHub Action add-to-project. PR
## 11999
by
@tiangolo
.
üìù Update admonitions in docs missing. PR
## 11998
by
@tiangolo
.
üî® Update docs.py script to enable dirty reload conditionally. PR
## 11986
by
@tiangolo
.
üîß Update MkDocs instant previews. PR
## 11982
by
@tiangolo
.
üêõ Fix deploy docs previews script to handle mkdocs.yml files. PR
## 11984
by
@tiangolo
.
üí° Add comment about custom Termynal line-height. PR
## 11976
by
@tiangolo
.
üë∑ Add alls-green for test-redistribute. PR
## 11974
by
@tiangolo
.
üë∑ Update docs-previews to handle no docs changes. PR
## 11975
by
@tiangolo
.
üî® Refactor script
deploy_docs_status.py
to account for deploy URLs with or without trailing slash. PR
## 11965
by
@tiangolo
.
üîíÔ∏è Update permissions for deploy-docs action. PR
## 11964
by
@tiangolo
.
üë∑üèª Add deploy docs status and preview links to PRs. PR
## 11961
by
@tiangolo
.
üîß Update docs setup with latest configs and plugins. PR
## 11953
by
@tiangolo
.
üîá Ignore warning from attrs in Trio. PR
## 11949
by
@tiangolo
.
0.112.0
Breaking Changes
‚ôªÔ∏è Add support for
pip install "fastapi[standard]"
with standard dependencies and
python -m fastapi
. PR
## 11935
by
@tiangolo
.
Summary
Install with:
pip
install
"fastapi[standard]"
Other Changes
This adds support for calling the CLI as:
python
-m
fastapi
And it upgrades
fastapi-cli[standard] >=0.0.5
.
Technical Details
Before this,
fastapi
would include the standard dependencies, with Uvicorn and the
fastapi-cli
, etc.
And
fastapi-slim
would not include those standard dependencies.
Now
fastapi
doesn't include those standard dependencies unless you install with
pip install "fastapi[standard]"
.
Before, you would install
pip install fastapi
, now you should include the
standard
optional dependencies (unless you want to exclude one of those):
pip install "fastapi[standard]"
.
This change is because having the standard optional dependencies installed by default was being inconvenient to several users, and having to install instead
fastapi-slim
was not being a feasible solution.
Discussed here:
## 11522
and here:
## 11525
Docs
‚úèÔ∏è Fix typos in docs. PR
## 11926
by
@jianghuyiyuan
.
üìù Tweak management docs. PR
## 11918
by
@tiangolo
.
üöö Rename GitHub links from tiangolo/fastapi to fastapi/fastapi. PR
## 11913
by
@tiangolo
.
üìù Add docs about FastAPI team and project management. PR
## 11908
by
@tiangolo
.
üìù Re-structure docs main menu. PR
## 11904
by
@tiangolo
.
üìù Update Speakeasy URL. PR
## 11871
by
@ndimares
.
Translations
üåê Update Portuguese translation for
docs/pt/docs/alternatives.md
. PR
## 11931
by
@ceb10n
.
üåê Add Russian translation for
docs/ru/docs/tutorial/dependencies/sub-dependencies.md
. PR
## 10515
by
@AlertRED
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/response-change-status-code.md
. PR
## 11863
by
@ceb10n
.
üåê Add Portuguese translation for
docs/pt/docs/reference/background.md
. PR
## 11849
by
@lucasbalieiro
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 11848
by
@Joao-Pedro-P-Holanda
.
üåê Add Portuguese translation for
docs/pt/docs/reference/apirouter.md
. PR
## 11843
by
@lucasbalieiro
.
Internal
üîß Update sponsors: add liblab. PR
## 11934
by
@tiangolo
.
üë∑ Update GitHub Action label-approved permissions. PR
## 11933
by
@tiangolo
.
üë∑ Refactor GitHub Action to comment docs deployment URLs and update token. PR
## 11925
by
@tiangolo
.
üë∑ Update tokens for GitHub Actions. PR
## 11924
by
@tiangolo
.
üë∑ Update token permissions to comment deployment URL in docs. PR
## 11917
by
@tiangolo
.
üë∑ Update token permissions for GitHub Actions. PR
## 11915
by
@tiangolo
.
üë∑ Update GitHub Actions token usage. PR
## 11914
by
@tiangolo
.
üë∑ Update GitHub Action to notify translations with label
approved-1
. PR
## 11907
by
@tiangolo
.
üîß Update sponsors, remove Reflex. PR
## 11875
by
@tiangolo
.
üîß Update sponsors: remove TalkPython. PR
## 11861
by
@tiangolo
.
üî® Update docs Termynal scripts to not include line nums for local dev. PR
## 11854
by
@tiangolo
.
0.111.1
Upgrades
‚ûñ Remove
orjson
and
ujson
from default dependencies. PR
## 11842
by
@tiangolo
.
These dependencies are still installed when you install with
pip install "fastapi[all]"
. But they are not included in
pip install fastapi
.
üìù Restored Swagger-UI links to use the latest version possible. PR
## 11459
by
@UltimateLobster
.
Docs
‚úèÔ∏è Rewording in
docs/en/docs/fastapi-cli.md
. PR
## 11716
by
@alejsdev
.
üìù Update Hypercorn links in all the docs. PR
## 11744
by
@kittydoor
.
üìù Update docs with Ariadne reference from Starlette to FastAPI. PR
## 11797
by
@DamianCzajkowski
.
üìù Update fastapi instrumentation external link. PR
## 11317
by
@softwarebloat
.
‚úèÔ∏è Fix links to alembic example repo in docs. PR
## 11628
by
@augiwan
.
‚úèÔ∏è Update
docs/en/docs/fastapi-cli.md
. PR
## 11715
by
@alejsdev
.
üìù Update External Links . PR
## 11500
by
@devon2018
.
üìù Add External Link: Tutorial de FastAPI, ¬øel mejor framework de Python?. PR
## 11618
by
@EduardoZepeda
.
üìù Fix typo in
docs/en/docs/tutorial/body-multiple-params.md
. PR
## 11698
by
@mwb-u
.
üìù Add External Link: Deploy a Serverless FastAPI App with Neon Postgres and AWS App Runner at any scale. PR
## 11633
by
@ananis25
.
üìù Update
security/first-steps.md
. PR
## 11674
by
@alejsdev
.
üìù Update
security/first-steps.md
. PR
## 11673
by
@alejsdev
.
üìù Update note in
path-params-numeric-validations.md
. PR
## 11672
by
@alejsdev
.
üìù Tweak intro docs about
Annotated
and
Query()
params. PR
## 11664
by
@tiangolo
.
üìù Update JWT auth documentation to use PyJWT instead of pyhon-jose. PR
## 11589
by
@estebanx64
.
üìù Update docs. PR
## 11603
by
@alejsdev
.
‚úèÔ∏è Fix typo: convert every 're-use' to 'reuse'.. PR
## 11598
by
@hasansezertasan
.
‚úèÔ∏è Fix typo in
fastapi/applications.py
. PR
## 11593
by
@petarmaric
.
‚úèÔ∏è Fix link in
fastapi-cli.md
. PR
## 11524
by
@svlandeg
.
Translations
üåê Add Spanish translation for
docs/es/docs/how-to/graphql.md
. PR
## 11697
by
@camigomezdev
.
üåê Add Portuguese translation for
docs/pt/docs/reference/index.md
. PR
## 11840
by
@lucasbalieiro
.
üåê Fix link in German translation. PR
## 11836
by
@anitahammer
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/sub-dependencies.md
. PR
## 11792
by
@Joao-Pedro-P-Holanda
.
üåê Add Turkish translation for
docs/tr/docs/tutorial/request-forms.md
. PR
## 11553
by
@hasansezertasan
.
üåê Add Portuguese translation for
docs/pt/docs/reference/exceptions.md
. PR
## 11834
by
@lucasbalieiro
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/global-dependencies.md
. PR
## 11826
by
@Joao-Pedro-P-Holanda
.
üåê Add Portuguese translation for
docs/pt/docs/how-to/general.md
. PR
## 11825
by
@lucasbalieiro
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/async-tests.md
. PR
## 11808
by
@ceb10n
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/first-steps.md
. PR
## 11809
by
@vkhoroshchak
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/dependencies-in-path-operation-operators.md
. PR
## 11804
by
@Joao-Pedro-P-Holanda
.
üåê Add Chinese translation for
docs/zh/docs/fastapi-cli.md
. PR
## 11786
by
@logan2d5
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/openapi-webhooks.md
. PR
## 11791
by
@ceb10n
.
üåê Update Chinese translation for
docs/tutorial/security/oauth2-jwt.md
. PR
## 11781
by
@logan2d5
.
üìù Fix image missing in French translation for
docs/fr/docs/async.md
. PR
## 11787
by
@pe-brian
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/advanced-dependencies.md
. PR
## 11775
by
@ceb10n
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 11768
by
@Joao-Pedro-P-Holanda
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/additional-status-codes.md
. PR
## 11753
by
@ceb10n
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/dependencies/index.md
. PR
## 11757
by
@Joao-Pedro-P-Holanda
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/settings.md
. PR
## 11739
by
@Joao-Pedro-P-Holanda
.
üåê Add French translation for
docs/fr/docs/learn/index.md
. PR
## 11712
by
@benjaminvandammeholberton
.
üåê Add Portuguese translation for
docs/pt/docs/how-to/index.md
. PR
## 11731
by
@vhsenna
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/additional-responses.md
. PR
## 11736
by
@ceb10n
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/benchmarks.md
. PR
## 11713
by
@ceb10n
.
üåê Fix Korean translation for
docs/ko/docs/tutorial/response-status-code.md
. PR
## 11718
by
@nayeonkinn
.
üåê Add Korean translation for
docs/ko/docs/tutorial/extra-data-types.md
. PR
## 11711
by
@nayeonkinn
.
üåê Fix Korean translation for
docs/ko/docs/tutorial/body-nested-models.md
. PR
## 11710
by
@nayeonkinn
.
üåê Add Portuguese translation for
docs/pt/docs/advanced/fastapi-cli.md
. PR
## 11641
by
@ayr-ton
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/fastapi-people.md
. PR
## 11639
by
@hsuanchi
.
üåê Add Turkish translation for
docs/tr/docs/advanced/index.md
. PR
## 11606
by
@hasansezertasan
.
üåê Add Turkish translation for
docs/tr/docs/deployment/cloud.md
. PR
## 11610
by
@hasansezertasan
.
üåê Add Turkish translation for
docs/tr/docs/advanced/security/index.md
. PR
## 11609
by
@hasansezertasan
.
üåê Add Turkish translation for
docs/tr/docs/advanced/testing-websockets.md
. PR
## 11608
by
@hasansezertasan
.
üåê Add Turkish translation for
docs/tr/docs/how-to/general.md
. PR
## 11607
by
@hasansezertasan
.
üåê Update Chinese translation for
docs/zh/docs/advanced/templates.md
. PR
## 11620
by
@chaoless
.
üåê Add Turkish translation for
docs/tr/docs/deployment/index.md
. PR
## 11605
by
@hasansezertasan
.
üåê Add Turkish translation for
docs/tr/docs/tutorial/static-files.md
. PR
## 11599
by
@hasansezertasan
.
üåê Polish translation for
docs/pl/docs/fastapi-people.md
. PR
## 10196
by
@isulim
.
üåê Add Turkish translation for
docs/tr/docs/advanced/wsgi.md
. PR
## 11575
by
@hasansezertasan
.
üåê Add Turkish translation for
docs/tr/docs/tutorial/cookie-params.md
. PR
## 11561
by
@hasansezertasan
.
üåê Add Russian translation for
docs/ru/docs/about/index.md
. PR
## 10961
by
@s111d
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/sql-databases.md
. PR
## 11539
by
@chaoless
.
üåê Add Chinese translation for
docs/zh/docs/how-to/configure-swagger-ui.md
. PR
## 11501
by
@Lucas-lyh
.
üåê Update Chinese translation for
/docs/advanced/security/http-basic-auth.md
. PR
## 11512
by
@nick-cjyx9
.
Internal
‚ôªÔ∏è Simplify internal docs script. PR
## 11777
by
@gitworkflows
.
üîß Update sponsors: add Fine. PR
## 11784
by
@tiangolo
.
üîß Tweak sponsors: Kong URL. PR
## 11765
by
@tiangolo
.
üîß Tweak sponsors: Kong URL. PR
## 11764
by
@tiangolo
.
üîß Update sponsors, add Stainless. PR
## 11763
by
@tiangolo
.
üîß Update sponsors, add Zuplo. PR
## 11729
by
@tiangolo
.
üîß Update Sponsor link: Coherence. PR
## 11730
by
@tiangolo
.
üë• Update FastAPI People. PR
## 11669
by
@tiangolo
.
üîß Add sponsor Kong. PR
## 11662
by
@tiangolo
.
üë∑ Update Smokeshow, fix sync download artifact and smokeshow configs. PR
## 11563
by
@tiangolo
.
üë∑ Update Smokeshow download artifact GitHub Action. PR
## 11562
by
@tiangolo
.
üë∑ Update GitHub actions to download and upload artifacts to v4, for docs and coverage. PR
## 11550
by
@tamird
.
üë∑ Tweak CI for test-redistribute, add needed env vars for slim. PR
## 11549
by
@tiangolo
.
üë• Update FastAPI People. PR
## 11511
by
@tiangolo
.
0.111.0
Features
‚ú® Add FastAPI CLI, the new
fastapi
command. PR
## 11522
by
@tiangolo
.
New docs:
FastAPI CLI
.
Try it out with:
$
pip
install
--upgrade
fastapi
$
fastapi
dev
main.py
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FastAPI CLI - Development mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ ‚îÇ
‚îÇ Serving at: http://127.0.0.1:8000 ‚îÇ
‚îÇ ‚îÇ
‚îÇ API docs: http://127.0.0.1:8000/docs ‚îÇ
‚îÇ ‚îÇ
‚îÇ Running in development mode, for production use: ‚îÇ
‚îÇ ‚îÇ
‚îÇ fastapi run ‚îÇ
‚îÇ ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
Refactors
üîß Add configs and setup for
fastapi-slim
including optional extras
fastapi-slim[standard]
, and
fastapi
including by default the same
standard
extras. PR
## 11503
by
@tiangolo
.
0.110.3
Docs
üìù Update references to Python version, FastAPI supports all the current versions, no need to make the version explicit. PR
## 11496
by
@tiangolo
.
‚úèÔ∏è Fix typo in
fastapi/security/api_key.py
. PR
## 11481
by
@ch33zer
.
‚úèÔ∏è Fix typo in
security/http.py
. PR
## 11455
by
@omarmoo5
.
Translations
üåê Add Traditional Chinese translation for
docs/zh-hant/benchmarks.md
. PR
## 11484
by
@KNChiu
.
üåê Update Chinese translation for
docs/zh/docs/fastapi-people.md
. PR
## 11476
by
@billzhong
.
üåê Add Chinese translation for
docs/zh/docs/how-to/index.md
and
docs/zh/docs/how-to/general.md
. PR
## 11443
by
@billzhong
.
üåê Add Spanish translation for cookie-params
docs/es/docs/tutorial/cookie-params.md
. PR
## 11410
by
@fabianfalon
.
Internal
‚¨Ü Bump mkdocstrings[python] from 0.23.0 to 0.24.3. PR
## 11469
by
@dependabot[bot]
.
üî® Update internal scripts and remove unused ones. PR
## 11499
by
@tiangolo
.
üîß Migrate from Hatch to PDM for the internal build. PR
## 11498
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade MkDocs Material and re-enable cards. PR
## 11466
by
@tiangolo
.
‚¨Ü Bump pillow from 10.2.0 to 10.3.0. PR
## 11403
by
@dependabot[bot]
.
üîß Ungroup dependabot updates. PR
## 11465
by
@tiangolo
.
0.110.2
Fixes
üêõ Fix support for query parameters with list types, handle JSON encoding Pydantic
UndefinedType
. PR
## 9929
by
@arjwilliams
.
Refactors
‚ôªÔ∏è Simplify Pydantic configs in OpenAPI models in
fastapi/openapi/models.py
. PR
## 10886
by
@JoeTanto2
.
‚ú® Add support for Pydantic's 2.7 new deprecated Field parameter, remove URL from validation errors response. PR
## 11461
by
@tiangolo
.
Docs
üìù Fix types in examples under
docs_src/extra_data_types
. PR
## 10535
by
@nilslindemann
.
üìù Update references to UJSON. PR
## 11464
by
@tiangolo
.
üìù Tweak docs and translations links, typos, format. PR
## 11389
by
@nilslindemann
.
üìù Fix typo in
docs/es/docs/async.md
. PR
## 11400
by
@fabianfalon
.
üìù Update OpenAPI client generation docs to use
@hey-api/openapi-ts
. PR
## 11339
by
@jordanshatford
.
Translations
üåê Update Chinese translation for
docs/zh/docs/index.html
. PR
## 11430
by
@waketzheng
.
üåê Add Russian translation for
docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 11411
by
@anton2yakovlev
.
üåê Add Portuguese translations for
learn/index.md
resources/index.md
help/index.md
about/index.md
. PR
## 10807
by
@nazarepiedady
.
üåê Update Russian translations for deployments docs. PR
## 11271
by
@Lufa1u
.
üåê Add Bengali translations for
docs/bn/docs/python-types.md
. PR
## 11376
by
@imtiaz101325
.
üåê Add Korean translation for
docs/ko/docs/tutorial/security/simple-oauth2.md
. PR
## 5744
by
@KdHyeon0661
.
üåê Add Korean translation for
docs/ko/docs/help-fastapi.md
. PR
## 4139
by
@kty4119
.
üåê Add Korean translation for
docs/ko/docs/advanced/events.md
. PR
## 5087
by
@pers0n4
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/path-operation-configuration.md
. PR
## 1954
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/request-forms-and-files.md
. PR
## 1946
by
@SwftAlpc
.
üåê Add Russian translation for
docs/ru/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 10532
by
@AlertRED
.
üåê Add Korean translation for
docs/ko/docs/tutorial/debugging.md
. PR
## 5695
by
@JungWooGeon
.
Internal
‚¨ÜÔ∏è Upgrade version of typer for docs. PR
## 11393
by
@tiangolo
.
0.110.1
Fixes
üêõ Fix parameterless
Depends()
with generics. PR
## 9479
by
@nzig
.
Refactors
‚ôªÔ∏è Update mypy. PR
## 11049
by
@k0t3n
.
‚ôªÔ∏è Simplify string format with f-strings in
fastapi/applications.py
. PR
## 11335
by
@igeni
.
Upgrades
‚¨ÜÔ∏è Upgrade Starlette to >=0.37.2,<0.38.0, remove Starlette filterwarning for internal tests. PR
## 11266
by
@nothielf
.
Docs
üìù Tweak docs and translations links and remove old docs translations. PR
## 11381
by
@tiangolo
.
‚úèÔ∏è Fix typo in
fastapi/security/oauth2.py
. PR
## 11368
by
@shandongbinzhou
.
üìù Update links to Pydantic docs to point to new website. PR
## 11328
by
@alejsdev
.
‚úèÔ∏è Fix typo in
docs/en/docs/tutorial/extra-models.md
. PR
## 11329
by
@alejsdev
.
üìù Update
project-generation.md
. PR
## 11326
by
@alejsdev
.
üìù Update External Links. PR
## 11327
by
@alejsdev
.
üî• Remove link to Pydantic's benchmark, on other i18n pages.. PR
## 11224
by
@hirotoKirimaru
.
‚úèÔ∏è Fix typos in docstrings. PR
## 11295
by
@davidhuser
.
üõ†Ô∏è Improve Node.js script in docs to generate TypeScript clients. PR
## 11293
by
@alejsdev
.
üìù Update examples for tests to replace "inexistent" for "nonexistent". PR
## 11220
by
@Homesteady
.
üìù Update
python-multipart
GitHub link in all docs from
https://andrew-d.github.io/python-multipart/
to
https://github.com/Kludex/python-multipart
. PR
## 11239
by
@joshjhans
.
Translations
üåê Add German translation for
docs/de/docs/tutorial/response-status-code.md
. PR
## 10357
by
@nilslindemann
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/query-params.md
. PR
## 3480
by
@jaystone776
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/body.md
. PR
## 3481
by
@jaystone776
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/path-params.md
. PR
## 3479
by
@jaystone776
.
üåê Update Chinese translation for
docs/tutorial/body-fields.md
. PR
## 3496
by
@jaystone776
.
üåê Update Chinese translation for
docs/tutorial/extra-models.md
. PR
## 3497
by
@jaystone776
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/metadata.md
. PR
## 2667
by
@tokusumi
.
üåê Add German translation for
docs/de/docs/contributing.md
. PR
## 10487
by
@nilslindemann
.
üåê Update Japanese translation of
docs/ja/docs/tutorial/query-params.md
. PR
## 10808
by
@urushio
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/security/get-current-user.md
. PR
## 3842
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/openapi-callbacks.md
. PR
## 3825
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/extending-openapi.md
. PR
## 3823
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/testing-dependencies.md
. PR
## 3819
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/custom-request-and-route.md
. PR
## 3816
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/external-links.md
. PR
## 3833
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/templates.md
. PR
## 3812
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/sub-applications.md
. PR
## 3811
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/async-sql-databases.md
. PR
## 3805
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/middleware.md
. PR
## 3804
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/dataclasses.md
. PR
## 3803
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/using-request-directly.md
. PR
## 3802
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/security/http-basic-auth.md
. PR
## 3801
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/security/oauth2-scopes.md
. PR
## 3800
by
@jaystone776
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/cookie-params.md
. PR
## 3486
by
@jaystone776
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/header-params.md
. PR
## 3487
by
@jaystone776
.
üåê Update Chinese translation for
docs/tutorial/response-status-code.md
. PR
## 3498
by
@jaystone776
.
üåê Add German translation for
docs/de/docs/tutorial/security/first-steps.md
. PR
## 10432
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/events.md
. PR
## 10693
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/deployment/cloud.md
. PR
## 10746
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/behind-a-proxy.md
. PR
## 10675
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/help-fastapi.md
. PR
## 10455
by
@nilslindemann
.
üåê Update German translation for
docs/de/docs/python-types.md
. PR
## 10287
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/path-params.md
. PR
## 10290
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/handling-errors.md
. PR
## 10379
by
@nilslindemann
.
üåê Update German translation for
docs/de/docs/index.md
. PR
## 10283
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/security/http-basic-auth.md
. PR
## 10651
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/bigger-applications.md
. PR
## 10554
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/path-operation-advanced-configuration.md
. PR
## 10612
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/static-files.md
. PR
## 10584
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/security/oauth2-jwt.md
. PR
## 10522
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/response-model.md
. PR
## 10345
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/extra-models.md
. PR
## 10351
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/body-updates.md
. PR
## 10396
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/alternatives.md
. PR
## 10855
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/templates.md
. PR
## 10678
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/security/oauth2-scopes.md
. PR
## 10643
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/async-tests.md
. PR
## 10708
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/metadata.md
. PR
## 10581
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/testing.md
. PR
## 10586
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/schema-extra-example.md
. PR
## 10597
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/index.md
. PR
## 10611
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/response-directly.md
. PR
## 10618
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/additional-responses.md
. PR
## 10626
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/response-cookies.md
. PR
## 10627
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/response-headers.md
. PR
## 10628
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/response-change-status-code.md
. PR
## 10632
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/advanced-dependencies.md
. PR
## 10633
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/security/index.md
. PR
## 10635
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/using-request-directly.md
. PR
## 10653
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/dataclasses.md
. PR
## 10667
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/middleware.md
. PR
## 10668
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/sub-applications.md
. PR
## 10671
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/websockets.md
. PR
## 10687
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/testing-websockets.md
. PR
## 10703
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/testing-events.md
. PR
## 10704
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/testing-dependencies.md
. PR
## 10706
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/openapi-callbacks.md
. PR
## 10710
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/settings.md
. PR
## 10709
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/wsgi.md
. PR
## 10713
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/deployment/index.md
. PR
## 10733
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/deployment/https.md
. PR
## 10737
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/deployment/manually.md
. PR
## 10738
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/deployment/concepts.md
. PR
## 10744
by
@nilslindemann
.
üåê Update German translation for
docs/de/docs/features.md
. PR
## 10284
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/deployment/server-workers.md
. PR
## 10747
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/deployment/docker.md
. PR
## 10759
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/how-to/index.md
. PR
## 10769
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/how-to/general.md
. PR
## 10770
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/how-to/graphql.md
. PR
## 10788
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/how-to/custom-request-and-route.md
. PR
## 10789
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/how-to/conditional-openapi.md
. PR
## 10790
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/how-to/separate-openapi-schemas.md
. PR
## 10796
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/how-to/configure-swagger-ui.md
. PR
## 10804
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/how-to/custom-docs-ui-assets.md
. PR
## 10803
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/parameters.md
. PR
## 10814
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/status.md
. PR
## 10815
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/uploadfile.md
. PR
## 10816
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/exceptions.md
. PR
## 10817
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/dependencies.md
. PR
## 10818
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/apirouter.md
. PR
## 10819
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/websockets.md
. PR
## 10822
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/httpconnection.md
. PR
## 10823
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/response.md
. PR
## 10824
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/middleware.md
. PR
## 10837
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/openapi/*.md
. PR
## 10838
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/security/index.md
. PR
## 10839
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/staticfiles.md
. PR
## 10841
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/testclient.md
. PR
## 10843
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/project-generation.md
. PR
## 10851
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/history-design-future.md
. PR
## 10865
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 10422
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/dependencies/global-dependencies.md
. PR
## 10420
by
@nilslindemann
.
üåê Update German translation for
docs/de/docs/fastapi-people.md
. PR
## 10285
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/dependencies/sub-dependencies.md
. PR
## 10409
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/security/index.md
. PR
## 10429
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 10411
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/extra-data-types.md
. PR
## 10534
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/security/simple-oauth2.md
. PR
## 10504
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/security/get-current-user.md
. PR
## 10439
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/request-forms-and-files.md
. PR
## 10368
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/encoder.md
. PR
## 10385
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/request-forms.md
. PR
## 10361
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/deployment/versions.md
. PR
## 10491
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/async.md
. PR
## 10449
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/cookie-params.md
. PR
## 10323
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 10407
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/dependencies/index.md
. PR
## 10399
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/header-params.md
. PR
## 10326
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/path-params-numeric-validations.md
. PR
## 10307
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/query-params-str-validations.md
. PR
## 10304
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/request-files.md
. PR
## 10364
by
@nilslindemann
.
:globe_with_meridians: Add Portuguese translation for
docs/pt/docs/advanced/templates.md
. PR
## 11338
by
@SamuelBFavarin
.
üåê Add Bengali translations for
docs/bn/docs/learn/index.md
. PR
## 11337
by
@imtiaz101325
.
üåê Fix Korean translation for
docs/ko/docs/index.md
. PR
## 11296
by
@choi-haram
.
üåê Add Korean translation for
docs/ko/docs/about/index.md
. PR
## 11299
by
@choi-haram
.
üåê Add Korean translation for
docs/ko/docs/advanced/index.md
. PR
## 9613
by
@ElliottLarsen
.
üåê Add German translation for
docs/de/docs/how-to/extending-openapi.md
. PR
## 10794
by
@nilslindemann
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/metadata.md
. PR
## 11286
by
@jackleeio
.
üåê Update Chinese translation for
docs/zh/docs/contributing.md
. PR
## 10887
by
@Aruelius
.
üåê Add Azerbaijani translation for
docs/az/docs/fastapi-people.md
. PR
## 11195
by
@vusallyv
.
üåê Add Russian translation for
docs/ru/docs/tutorial/dependencies/index.md
. PR
## 11223
by
@kohiry
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/query-params.md
. PR
## 11242
by
@jackleeio
.
üåê Add Azerbaijani translation for
docs/az/learn/index.md
. PR
## 11192
by
@vusallyv
.
Internal
üë• Update FastAPI People. PR
## 11387
by
@tiangolo
.
‚¨Ü Bump actions/cache from 3 to 4. PR
## 10988
by
@dependabot[bot]
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.8.11 to 1.8.14. PR
## 11318
by
@dependabot[bot]
.
‚¨Ü Bump pillow from 10.1.0 to 10.2.0. PR
## 11011
by
@dependabot[bot]
.
‚¨Ü Bump black from 23.3.0 to 24.3.0. PR
## 11325
by
@dependabot[bot]
.
üë∑ Add cron to run test once a week on monday. PR
## 11377
by
@estebanx64
.
‚ûï Replace mkdocs-markdownextradata-plugin with mkdocs-macros-plugin. PR
## 11383
by
@tiangolo
.
üë∑ Disable MkDocs insiders social plugin while an issue in MkDocs Material is handled. PR
## 11373
by
@tiangolo
.
üë∑ Fix logic for when to install and use MkDocs Insiders. PR
## 11372
by
@tiangolo
.
üë∑ Do not use Python packages cache for publish. PR
## 11366
by
@tiangolo
.
üë∑ Add CI to test sdists for redistribution (e.g. Linux distros). PR
## 11365
by
@tiangolo
.
üë∑ Update build-docs GitHub Action path filter. PR
## 11354
by
@tiangolo
.
üîß Update Ruff config, add extra ignore rule from SQLModel. PR
## 11353
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade configuration for Ruff v0.2.0. PR
## 11075
by
@charliermarsh
.
üîß Update sponsors, add MongoDB. PR
## 11346
by
@tiangolo
.
‚¨Ü Bump dorny/paths-filter from 2 to 3. PR
## 11028
by
@dependabot[bot]
.
‚¨Ü Bump dawidd6/action-download-artifact from 3.0.0 to 3.1.4. PR
## 11310
by
@dependabot[bot]
.
‚ôªÔ∏è Refactor computing FastAPI People, include 3 months, 6 months, 1 year, based on comment date, not discussion date. PR
## 11304
by
@tiangolo
.
üë• Update FastAPI People. PR
## 11228
by
@tiangolo
.
üî• Remove Jina AI QA Bot from the docs. PR
## 11268
by
@nan-wang
.
üîß Update sponsors, remove Jina, remove Powens, move TestDriven.io. PR
## 11213
by
@tiangolo
.
0.110.0
Breaking Changes
üêõ Fix unhandled growing memory for internal server errors, refactor dependencies with
yield
and
except
to require raising again as in regular Python. PR
## 11191
by
@tiangolo
.
This is a breaking change (and only slightly) if you used dependencies with
yield
, used
except
in those dependencies, and didn't raise again.
This was reported internally by
@rushilsrivastava
as a memory leak when the server had unhandled exceptions that would produce internal server errors, the memory allocated before that point would not be released.
Read the new docs:
Dependencies with
yield
and
except
.
In short, if you had dependencies that looked like:
def
my_dep
():
try
:
yield
except
SomeException
:
pass
Now you need to make sure you raise again after
except
, just as you would in regular Python:
def
my_dep
():
try
:
yield
except
SomeException
:
raise
Docs
‚úèÔ∏è Fix minor typos in
docs/ko/docs/
. PR
## 11126
by
@KaniKim
.
‚úèÔ∏è Fix minor typo in
fastapi/applications.py
. PR
## 11099
by
@JacobHayes
.
Translations
üåê Add German translation for
docs/de/docs/reference/background.md
. PR
## 10820
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/templating.md
. PR
## 10842
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/external-links.md
. PR
## 10852
by
@nilslindemann
.
üåê Update Turkish translation for
docs/tr/docs/tutorial/query-params.md
. PR
## 11162
by
@hasansezertasan
.
üåê Add German translation for
docs/de/docs/reference/encoders.md
. PR
## 10840
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/responses.md
. PR
## 10825
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/reference/request.md
. PR
## 10821
by
@nilslindemann
.
üåê Add Turkish translation for
docs/tr/docs/tutorial/query-params.md
. PR
## 11078
by
@emrhnsyts
.
üåê Add German translation for
docs/de/docs/reference/fastapi.md
. PR
## 10813
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/newsletter.md
. PR
## 10853
by
@nilslindemann
.
üåê Add Traditional Chinese translation for
docs/zh-hant/docs/learn/index.md
. PR
## 11142
by
@hsuanchi
.
üåê Add Korean translation for
/docs/ko/docs/tutorial/dependencies/global-dependencies.md
. PR
## 11123
by
@riroan
.
üåê Add Korean translation for
/docs/ko/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 11124
by
@riroan
.
üåê Add Korean translation for
/docs/ko/docs/tutorial/schema-extra-example.md
. PR
## 11121
by
@KaniKim
.
üåê Add Korean translation for
/docs/ko/docs/tutorial/body-fields.md
. PR
## 11112
by
@KaniKim
.
üåê Add Korean translation for
/docs/ko/docs/tutorial/cookie-params.md
. PR
## 11118
by
@riroan
.
üåê Update Korean translation for
/docs/ko/docs/dependencies/index.md
. PR
## 11114
by
@KaniKim
.
üåê Update Korean translation for
/docs/ko/docs/deployment/docker.md
. PR
## 11113
by
@KaniKim
.
üåê Update Turkish translation for
docs/tr/docs/tutorial/first-steps.md
. PR
## 11094
by
@hasansezertasan
.
üåê Add Spanish translation for
docs/es/docs/advanced/security/index.md
. PR
## 2278
by
@Xaraxx
.
üåê Add Spanish translation for
docs/es/docs/advanced/response-headers.md
. PR
## 2276
by
@Xaraxx
.
üåê Add Spanish translation for
docs/es/docs/deployment/index.md
and
~/deployment/versions.md
. PR
## 9669
by
@pabloperezmoya
.
üåê Add Spanish translation for
docs/es/docs/benchmarks.md
. PR
## 10928
by
@pablocm83
.
üåê Add Spanish translation for
docs/es/docs/advanced/response-change-status-code.md
. PR
## 11100
by
@alejsdev
.
0.109.2
Upgrades
‚¨ÜÔ∏è Upgrade version of Starlette to
>= 0.36.3
. PR
## 11086
by
@tiangolo
.
Translations
üåê Update Turkish translation for
docs/tr/docs/fastapi-people.md
. PR
## 10547
by
@alperiox
.
Internal
üç± Add new FastAPI logo. PR
## 11090
by
@tiangolo
.
0.109.1
Security fixes
‚¨ÜÔ∏è Upgrade minimum version of
python-multipart
to
>=0.0.7
to fix a vulnerability when using form data with a ReDos attack. You can also simply upgrade
python-multipart
.
Read more in the
advisory: Content-Type Header ReDoS
.
Features
‚ú® Include HTTP 205 in status codes with no body. PR
## 10969
by
@tiangolo
.
Refactors
‚úÖ Refactor tests for duplicate operation ID generation for compatibility with other tools running the FastAPI test suite. PR
## 10876
by
@emmettbutler
.
‚ôªÔ∏è Simplify string format with f-strings in
fastapi/utils.py
. PR
## 10576
by
@eukub
.
üîß Fix Ruff configuration unintentionally enabling and re-disabling mccabe complexity check. PR
## 10893
by
@jiridanek
.
‚úÖ Re-enable test in
tests/test_tutorial/test_header_params/test_tutorial003.py
after fix in Starlette. PR
## 10904
by
@ooknimm
.
Docs
üìù Tweak wording in
help-fastapi.md
. PR
## 11040
by
@tiangolo
.
üìù Tweak docs for Behind a Proxy. PR
## 11038
by
@tiangolo
.
üìù Add External Link: 10 Tips for adding SQLAlchemy to FastAPI. PR
## 11036
by
@Donnype
.
üìù Add External Link: Tips on migrating from Flask to FastAPI and vice-versa. PR
## 11029
by
@jtemporal
.
üìù Deprecate old tutorials: Peewee, Couchbase, encode/databases. PR
## 10979
by
@tiangolo
.
‚úèÔ∏è Fix typo in
fastapi/security/oauth2.py
. PR
## 10972
by
@RafalSkolasinski
.
üìù Update
HTTPException
details in
docs/en/docs/tutorial/handling-errors.md
. PR
## 5418
by
@papb
.
‚úèÔ∏è A few tweaks in
docs/de/docs/tutorial/first-steps.md
. PR
## 10959
by
@nilslindemann
.
‚úèÔ∏è Fix link in
docs/en/docs/advanced/async-tests.md
. PR
## 10960
by
@nilslindemann
.
‚úèÔ∏è Fix typos for Spanish documentation. PR
## 10957
by
@jlopezlira
.
üìù Add warning about lifespan functions and backwards compatibility with events. PR
## 10734
by
@jacob-indigo
.
‚úèÔ∏è Fix broken link in
docs/tutorial/sql-databases.md
in several languages. PR
## 10716
by
@theoohoho
.
‚úèÔ∏è Remove broken links from
external_links.yml
. PR
## 10943
by
@Torabek
.
üìù Update template docs with more info about
url_for
. PR
## 5937
by
@EzzEddin
.
üìù Update usage of Token model in security docs. PR
## 9313
by
@piotrszacilowski
.
‚úèÔ∏è Update highlighted line in
docs/en/docs/tutorial/bigger-applications.md
. PR
## 5490
by
@papb
.
üìù Add External Link: Explore How to Effectively Use JWT With FastAPI. PR
## 10212
by
@aanchlia
.
üìù Add hyperlink to
docs/en/docs/tutorial/static-files.md
. PR
## 10243
by
@hungtsetse
.
üìù Add External Link: Instrument a FastAPI service adding tracing with OpenTelemetry and send/show traces in Grafana Tempo. PR
## 9440
by
@softwarebloat
.
üìù Review and rewording of
en/docs/contributing.md
. PR
## 10480
by
@nilslindemann
.
üìù Add External Link: ML serving and monitoring with FastAPI and Evidently. PR
## 9701
by
@mnrozhkov
.
üìù Reword in docs, from "have in mind" to "keep in mind". PR
## 10376
by
@malicious
.
üìù Add External Link: Talk by Jeny Sadadia. PR
## 10265
by
@JenySadadia
.
üìù Add location info to
tutorial/bigger-applications.md
. PR
## 10552
by
@nilslindemann
.
‚úèÔ∏è Fix Pydantic method name in
docs/en/docs/advanced/path-operation-advanced-configuration.md
. PR
## 10826
by
@ahmedabdou14
.
Translations
üåê Add Spanish translation for
docs/es/docs/external-links.md
. PR
## 10933
by
@pablocm83
.
üåê Update Korean translation for
docs/ko/docs/tutorial/first-steps.md
,
docs/ko/docs/tutorial/index.md
,
docs/ko/docs/tutorial/path-params.md
, and
docs/ko/docs/tutorial/query-params.md
. PR
## 4218
by
@SnowSuno
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 10870
by
@zhiquanchi
.
üåê Add Chinese translation for
docs/zh/docs/deployment/concepts.md
. PR
## 10282
by
@xzmeng
.
üåê Add Azerbaijani translation for
docs/az/docs/index.md
. PR
## 11047
by
@aykhans
.
üåê Add Korean translation for
docs/ko/docs/tutorial/middleware.md
. PR
## 2829
by
@JeongHyeongKim
.
üåê Add German translation for
docs/de/docs/tutorial/body-nested-models.md
. PR
## 10313
by
@nilslindemann
.
üåê Add Persian translation for
docs/fa/docs/tutorial/middleware.md
. PR
## 9695
by
@mojtabapaso
.
üåê Update Farsi translation for
docs/fa/docs/index.md
. PR
## 10216
by
@theonlykingpin
.
üåê Add German translation for
docs/de/docs/tutorial/body-fields.md
. PR
## 10310
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/body.md
. PR
## 10295
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/body-multiple-params.md
. PR
## 10308
by
@nilslindemann
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/security/get-current-user.md
. PR
## 2681
by
@sh0nk
.
üåê Add Chinese translation for
docs/zh/docs/advanced/advanced-dependencies.md
. PR
## 3798
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/events.md
. PR
## 3815
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/behind-a-proxy.md
. PR
## 3820
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/testing-events.md
. PR
## 3818
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/testing-websockets.md
. PR
## 3817
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/advanced/testing-database.md
. PR
## 3821
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/deployment/deta.md
. PR
## 3837
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/history-design-future.md
. PR
## 3832
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/project-generation.md
. PR
## 3831
by
@jaystone776
.
üåê Add Chinese translation for
docs/zh/docs/deployment/docker.md
. PR
## 10296
by
@xzmeng
.
üåê Update Spanish translation for
docs/es/docs/features.md
. PR
## 10884
by
@pablocm83
.
üåê Add Spanish translation for
docs/es/docs/newsletter.md
. PR
## 10922
by
@pablocm83
.
üåê Add Korean translation for
docs/ko/docs/tutorial/background-tasks.md
. PR
## 5910
by
@junah201
.
:globe_with_meridians: Add Turkish translation for
docs/tr/docs/alternatives.md
. PR
## 10502
by
@alperiox
.
üåê Add Korean translation for
docs/ko/docs/tutorial/dependencies/index.md
. PR
## 10989
by
@KaniKim
.
üåê Add Korean translation for
/docs/ko/docs/tutorial/body.md
. PR
## 11000
by
@KaniKim
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/schema-extra-example.md
. PR
## 4065
by
@luccasmmg
.
üåê Add Turkish translation for
docs/tr/docs/history-design-future.md
. PR
## 11012
by
@hasansezertasan
.
üåê Add Turkish translation for
docs/tr/docs/resources/index.md
. PR
## 11020
by
@hasansezertasan
.
üåê Add Turkish translation for
docs/tr/docs/how-to/index.md
. PR
## 11021
by
@hasansezertasan
.
üåê Add German translation for
docs/de/docs/tutorial/query-params.md
. PR
## 10293
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/benchmarks.md
. PR
## 10866
by
@nilslindemann
.
üåê Add Turkish translation for
docs/tr/docs/learn/index.md
. PR
## 11014
by
@hasansezertasan
.
üåê Add Persian translation for
docs/fa/docs/tutorial/security/index.md
. PR
## 9945
by
@mojtabapaso
.
üåê Add Turkish translation for
docs/tr/docs/help/index.md
. PR
## 11013
by
@hasansezertasan
.
üåê Add Turkish translation for
docs/tr/docs/about/index.md
. PR
## 11006
by
@hasansezertasan
.
üåê Update Turkish translation for
docs/tr/docs/benchmarks.md
. PR
## 11005
by
@hasansezertasan
.
üåê Add Italian translation for
docs/it/docs/index.md
. PR
## 5233
by
@matteospanio
.
üåê Add Korean translation for
docs/ko/docs/help/index.md
. PR
## 10983
by
@KaniKim
.
üåê Add Korean translation for
docs/ko/docs/features.md
. PR
## 10976
by
@KaniKim
.
üåê Add Korean translation for
docs/ko/docs/tutorial/security/get-current-user.md
. PR
## 5737
by
@KdHyeon0661
.
üåê Add Russian translation for
docs/ru/docs/tutorial/security/first-steps.md
. PR
## 10541
by
@AlertRED
.
üåê Add Russian translation for
docs/ru/docs/tutorial/handling-errors.md
. PR
## 10375
by
@AlertRED
.
üåê Add Russian translation for
docs/ru/docs/tutorial/encoder.md
. PR
## 10374
by
@AlertRED
.
üåê Add Russian translation for
docs/ru/docs/tutorial/body-updates.md
. PR
## 10373
by
@AlertRED
.
üåê Russian translation: updated
fastapi-people.md
.. PR
## 10255
by
@NiKuma0
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/security/index.md
. PR
## 5798
by
@3w36zj6
.
üåê Add German translation for
docs/de/docs/advanced/generate-clients.md
. PR
## 10725
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/openapi-webhooks.md
. PR
## 10712
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/custom-response.md
. PR
## 10624
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/advanced/additional-status-codes.md
. PR
## 10617
by
@nilslindemann
.
üåê Add German translation for
docs/de/docs/tutorial/middleware.md
. PR
## 10391
by
@JohannesJungbluth
.
üåê Add German translation for introduction documents. PR
## 10497
by
@nilslindemann
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/encoder.md
. PR
## 1955
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/extra-data-types.md
. PR
## 1932
by
@SwftAlpc
.
üåê Add Turkish translation for
docs/tr/docs/async.md
. PR
## 5191
by
@BilalAlpaslan
.
üåê Add Turkish translation for
docs/tr/docs/project-generation.md
. PR
## 5192
by
@BilalAlpaslan
.
üåê Add Korean translation for
docs/ko/docs/deployment/docker.md
. PR
## 5657
by
@nearnear
.
üåê Add Korean translation for
docs/ko/docs/deployment/server-workers.md
. PR
## 4935
by
@jujumilk3
.
üåê Add Korean translation for
docs/ko/docs/deployment/index.md
. PR
## 4561
by
@jujumilk3
.
üåê Add Korean translation for
docs/ko/docs/tutorial/path-operation-configuration.md
. PR
## 3639
by
@jungsu-kwon
.
üåê Modify the description of
zh
- Traditional Chinese. PR
## 10889
by
@cherinyy
.
üåê Add Korean translation for
docs/ko/docs/tutorial/static-files.md
. PR
## 2957
by
@jeesang7
.
üåê Add Korean translation for
docs/ko/docs/tutorial/response-model.md
. PR
## 2766
by
@hard-coders
.
üåê Add Korean translation for
docs/ko/docs/tutorial/body-multiple-params.md
. PR
## 2461
by
@PandaHun
.
üåê Add Korean translation for
docs/ko/docs/tutorial/query-params-str-validations.md
. PR
## 2415
by
@hard-coders
.
üåê Add Korean translation for
docs/ko/docs/python-types.md
. PR
## 2267
by
@jrim
.
üåê Add Korean translation for
docs/ko/docs/tutorial/body-nested-models.md
. PR
## 2506
by
@hard-coders
.
üåê Add Korean translation for
docs/ko/docs/learn/index.md
. PR
## 10977
by
@KaniKim
.
üåê Initialize translations for Traditional Chinese. PR
## 10505
by
@hsuanchi
.
‚úèÔ∏è Tweak the german translation of
docs/de/docs/tutorial/index.md
. PR
## 10962
by
@nilslindemann
.
‚úèÔ∏è Fix typo error in
docs/ko/docs/tutorial/path-params.md
. PR
## 10758
by
@2chanhaeng
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 1961
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 1960
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/dependencies/sub-dependencies.md
. PR
## 1959
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/background-tasks.md
. PR
## 2668
by
@tokusumi
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/dependencies/index.md
and
docs/ja/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 1958
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/response-model.md
. PR
## 1938
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/body-multiple-params.md
. PR
## 1903
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/path-params-numeric-validations.md
. PR
## 1902
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/python-types.md
. PR
## 1899
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/handling-errors.md
. PR
## 1953
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/response-status-code.md
. PR
## 1942
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/extra-models.md
. PR
## 1941
by
@SwftAlpc
.
üåê Add Japanese tranlsation for
docs/ja/docs/tutorial/schema-extra-example.md
. PR
## 1931
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/body-nested-models.md
. PR
## 1930
by
@SwftAlpc
.
üåê Add Japanese translation for
docs/ja/docs/tutorial/body-fields.md
. PR
## 1923
by
@SwftAlpc
.
üåê Add German translation for
docs/de/docs/tutorial/index.md
. PR
## 9502
by
@fhabers21
.
üåê Add German translation for
docs/de/docs/tutorial/background-tasks.md
. PR
## 10566
by
@nilslindemann
.
‚úèÔ∏è Fix typo in
docs/ru/docs/index.md
. PR
## 10672
by
@Delitel-WEB
.
‚úèÔ∏è Fix typos in
docs/zh/docs/tutorial/extra-data-types.md
. PR
## 10727
by
@HiemalBeryl
.
üåê Add Russian translation for
docs/ru/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 10410
by
@AlertRED
.
Internal
üë• Update FastAPI People. PR
## 11074
by
@tiangolo
.
üîß Update sponsors: add Coherence. PR
## 11066
by
@tiangolo
.
üë∑ Upgrade GitHub Action issue-manager. PR
## 11056
by
@tiangolo
.
üç± Update sponsors: TalkPython badge. PR
## 11052
by
@tiangolo
.
üîß Update sponsors: TalkPython badge image. PR
## 11048
by
@tiangolo
.
üîß Update sponsors, remove Deta. PR
## 11041
by
@tiangolo
.
üíÑ Fix CSS breaking RTL languages (erroneously introduced by a previous RTL PR). PR
## 11039
by
@tiangolo
.
üîß Add Italian to
mkdocs.yml
. PR
## 11016
by
@alejsdev
.
üî® Verify
mkdocs.yml
languages in CI, update
docs.py
. PR
## 11009
by
@tiangolo
.
üîß Update config in
label-approved.yml
to accept translations with 1 reviewer. PR
## 11007
by
@alejsdev
.
üë∑ Add changes-requested handling in GitHub Action issue manager. PR
## 10971
by
@tiangolo
.
üîß Group dependencies on dependabot updates. PR
## 10952
by
@Kludex
.
‚¨Ü Bump actions/setup-python from 4 to 5. PR
## 10764
by
@dependabot[bot]
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.8.10 to 1.8.11. PR
## 10731
by
@dependabot[bot]
.
‚¨Ü Bump dawidd6/action-download-artifact from 2.28.0 to 3.0.0. PR
## 10777
by
@dependabot[bot]
.
üîß Add support for translations to languages with a longer code name, like
zh-hant
. PR
## 10950
by
@tiangolo
.
0.109.0
Features
‚ú® Add support for Python 3.12. PR
## 10666
by
@Jamim
.
Upgrades
‚¨ÜÔ∏è Upgrade Starlette to >=0.35.0,<0.36.0. PR
## 10938
by
@tiangolo
.
Docs
‚úèÔ∏è Fix typo in
docs/en/docs/alternatives.md
. PR
## 10931
by
@s111d
.
üìù Replace
email
with
username
in
docs_src/security/tutorial007
code examples. PR
## 10649
by
@nilslindemann
.
üìù Add VS Code tutorial link. PR
## 10592
by
@nilslindemann
.
üìù Add notes about Pydantic v2's new
.model_dump()
. PR
## 10929
by
@tiangolo
.
üìù Fix broken link in
docs/en/docs/tutorial/sql-databases.md
. PR
## 10765
by
@HurSungYun
.
üìù Add External Link: FastAPI application monitoring made easy. PR
## 10917
by
@tiangolo
.
‚ú® Generate automatic language names for docs translations. PR
## 5354
by
@jakul
.
‚úèÔ∏è Fix typos in
docs/en/docs/alternatives.md
and
docs/en/docs/tutorial/dependencies/index.md
. PR
## 10906
by
@s111d
.
‚úèÔ∏è Fix typos in
docs/en/docs/tutorial/dependencies/dependencies-with-yield.md
. PR
## 10834
by
@Molkree
.
üìù Add article: "Building a RESTful API with FastAPI: Secure Signup and Login Functionality Included". PR
## 9733
by
@dxphilo
.
üìù Add warning about lifecycle events with
AsyncClient
. PR
## 4167
by
@andrew-chang-dewitt
.
‚úèÔ∏è Fix typos in
/docs/reference/exceptions.md
and
/en/docs/reference/status.md
. PR
## 10809
by
@clarencepenz
.
‚úèÔ∏è Fix typo in
openapi-callbacks.md
. PR
## 10673
by
@kayjan
.
‚úèÔ∏è Fix typo in
fastapi/routing.py
. PR
## 10520
by
@sepsh
.
üìù Replace HTTP code returned in case of existing user error in docs for testing. PR
## 4482
by
@TristanMarion
.
üìù Add blog for FastAPI & Supabase. PR
## 6018
by
@theinfosecguy
.
üìù Update example source files for SQL databases with SQLAlchemy. PR
## 9508
by
@s-mustafa
.
üìù Update code examples in docs for body, replace name
create_item
with
update_item
when appropriate. PR
## 5913
by
@OttoAndrey
.
‚úèÔ∏è Fix typo in dependencies with yield source examples. PR
## 10847
by
@tiangolo
.
Translations
üåê Add Bengali translation for
docs/bn/docs/index.md
. PR
## 9177
by
@Fahad-Md-Kamal
.
‚úèÔ∏è Update Python version in
index.md
in several languages. PR
## 10711
by
@tamago3keran
.
üåê Add Russian translation for
docs/ru/docs/tutorial/request-forms-and-files.md
. PR
## 10347
by
@AlertRED
.
üåê Add Ukrainian translation for
docs/uk/docs/index.md
. PR
## 10362
by
@rostik1410
.
‚úèÔ∏è Update Python version in
docs/ko/docs/index.md
. PR
## 10680
by
@Eeap
.
üåê Add Persian translation for
docs/fa/docs/features.md
. PR
## 5887
by
@amirilf
.
üåê Add Chinese translation for
docs/zh/docs/advanced/additional-responses.md
. PR
## 10325
by
@ShuibeiC
.
üåê Fix typos in Russian translations for
docs/ru/docs/tutorial/background-tasks.md
,
docs/ru/docs/tutorial/body-nested-models.md
,
docs/ru/docs/tutorial/debugging.md
,
docs/ru/docs/tutorial/testing.md
. PR
## 10311
by
@AlertRED
.
üåê Add Russian translation for
docs/ru/docs/tutorial/request-files.md
. PR
## 10332
by
@AlertRED
.
üåê Add Chinese translation for
docs/zh/docs/deployment/server-workers.md
. PR
## 10292
by
@xzmeng
.
üåê Add Chinese translation for
docs/zh/docs/deployment/cloud.md
. PR
## 10291
by
@xzmeng
.
üåê Add Chinese translation for
docs/zh/docs/deployment/manually.md
. PR
## 10279
by
@xzmeng
.
üåê Add Chinese translation for
docs/zh/docs/deployment/https.md
. PR
## 10277
by
@xzmeng
.
üåê Add Chinese translation for
docs/zh/docs/deployment/index.md
. PR
## 10275
by
@xzmeng
.
üåê Add German translation for
docs/de/docs/tutorial/first-steps.md
. PR
## 9530
by
@fhabers21
.
üåê Update Turkish translation for
docs/tr/docs/index.md
. PR
## 10444
by
@hasansezertasan
.
üåê Add Chinese translation for
docs/zh/docs/learn/index.md
. PR
## 10479
by
@KAZAMA-DREAM
.
üåê Add Russian translation for
docs/ru/docs/learn/index.md
. PR
## 10539
by
@AlertRED
.
üåê Update SQLAlchemy instruction in Chinese translation
docs/zh/docs/tutorial/sql-databases.md
. PR
## 9712
by
@Royc30ne
.
üåê Add Turkish translation for
docs/tr/docs/external-links.md
. PR
## 10549
by
@hasansezertasan
.
üåê Add Spanish translation for
docs/es/docs/learn/index.md
. PR
## 10885
by
@pablocm83
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/body-fields.md
. PR
## 10670
by
@ArtemKhymenko
.
üåê Add Hungarian translation for
/docs/hu/docs/index.md
. PR
## 10812
by
@takacs
.
üåê Add Turkish translation for
docs/tr/docs/newsletter.md
. PR
## 10550
by
@hasansezertasan
.
üåê Add Spanish translation for
docs/es/docs/help/index.md
. PR
## 10907
by
@pablocm83
.
üåê Add Spanish translation for
docs/es/docs/about/index.md
. PR
## 10908
by
@pablocm83
.
üåê Add Spanish translation for
docs/es/docs/resources/index.md
. PR
## 10909
by
@pablocm83
.
Internal
üë• Update FastAPI People. PR
## 10871
by
@tiangolo
.
üë∑ Upgrade custom GitHub Action comment-docs-preview-in-pr. PR
## 10916
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade GitHub Action latest-changes. PR
## 10915
by
@tiangolo
.
üë∑ Upgrade GitHub Action label-approved. PR
## 10913
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade GitHub Action label-approved. PR
## 10905
by
@tiangolo
.
0.108.0
Upgrades
‚¨ÜÔ∏è Upgrade Starlette to
>=0.29.0,<0.33.0
, update docs and usage of templates with new Starlette arguments. Remove pin of AnyIO
>=3.7.1,<4.0.0
, add support for AnyIO 4.x.x. PR
## 10846
by
@tiangolo
.
0.107.0
Upgrades
‚¨ÜÔ∏è Upgrade Starlette to 0.28.0. PR
## 9636
by
@adriangb
.
Docs
üìù Add docs: Node.js script alternative to update OpenAPI for generated clients. PR
## 10845
by
@alejsdev
.
üìù Restructure Docs section in Contributing page. PR
## 10844
by
@alejsdev
.
0.106.0
Breaking Changes
Using resources from dependencies with
yield
in background tasks is no longer supported.
This change is what supports the new features, read below. ü§ì
Dependencies with
yield
,
HTTPException
and Background Tasks
Dependencies with
yield
now can raise
HTTPException
and other exceptions after
yield
. üéâ
Read the new docs here:
Dependencies with
yield
and
HTTPException
.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
data
=
{
"plumbus"
:
{
"description"
:
"Freshly pickled plumbus"
,
"owner"
:
"Morty"
},
"portal-gun"
:
{
"description"
:
"Gun to create portals"
,
"owner"
:
"Rick"
},
}
class
OwnerError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
OwnerError
as
e
:
raise
HTTPException
(
status_code
=
400
,
detail
=
f
"Owner error:
{
e
}
"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
not
in
data
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
item
=
data
[
item_id
]
if
item
[
"owner"
]
!=
username
:
raise
OwnerError
(
username
)
return
item
Before FastAPI 0.106.0, raising exceptions after
yield
was not possible, the exit code in dependencies with
yield
was executed
after
the response was sent, so
Exception Handlers
would have already run.
This was designed this way mainly to allow using the same objects "yielded" by dependencies inside of background tasks, because the exit code would be executed after the background tasks were finished.
Nevertheless, as this would mean waiting for the response to travel through the network while unnecessarily holding a resource in a dependency with yield (for example a database connection), this was changed in FastAPI 0.106.0.
Additionally, a background task is normally an independent set of logic that should be handled separately, with its own resources (e.g. its own database connection).
If you used to rely on this behavior, now you should create the resources for background tasks inside the background task itself, and use internally only data that doesn't depend on the resources of dependencies with
yield
.
For example, instead of using the same database session, you would create a new database session inside of the background task, and you would obtain the objects from the database using this new session. And then instead of passing the object from the database as a parameter to the background task function, you would pass the ID of that object and then obtain the object again inside the background task function.
The sequence of execution before FastAPI 0.106.0 was like this diagram:
Time flows from top to bottom. And each column is one of the parts interacting or executing code.
The new execution flow can be found in the docs:
Execution of dependencies with
yield
.
Features
‚ú® Add support for raising exceptions (including
HTTPException
) in dependencies with
yield
in the exit code, do not support them in background tasks. PR
## 10831
by
@tiangolo
.
Internal
üë• Update FastAPI People. PR
## 10567
by
@tiangolo
.
0.105.0
Features
‚ú® Add support for multiple Annotated annotations, e.g.
Annotated[str, Field(), Query()]
. PR
## 10773
by
@tiangolo
.
Refactors
üî• Remove unused NoneType. PR
## 10774
by
@tiangolo
.
Docs
üìù Tweak default suggested configs for generating clients. PR
## 10736
by
@tiangolo
.
Internal
üîß Update sponsors, add Scalar. PR
## 10728
by
@tiangolo
.
üîß Update sponsors, add PropelAuth. PR
## 10760
by
@tiangolo
.
üë∑ Update build docs, verify README on CI. PR
## 10750
by
@tiangolo
.
üîß Update sponsors, remove Fern. PR
## 10729
by
@tiangolo
.
üîß Update sponsors, add Codacy. PR
## 10677
by
@tiangolo
.
üîß Update sponsors, add Reflex. PR
## 10676
by
@tiangolo
.
üìù Update release notes, move and check latest-changes. PR
## 10588
by
@tiangolo
.
üë∑ Upgrade latest-changes GitHub Action. PR
## 10587
by
@tiangolo
.
0.104.1
Fixes
üìå Pin Swagger UI version to 5.9.0 temporarily to handle a bug crashing it in 5.9.1. PR
## 10529
by
@alejandraklachquin
.
This is not really a bug in FastAPI but in Swagger UI, nevertheless pinning the version will work while a solution is found on the
Swagger UI side
.
Docs
üìù Update data structure and render for external-links. PR
## 10495
by
@tiangolo
.
‚úèÔ∏è Fix link to SPDX license identifier in
docs/en/docs/tutorial/metadata.md
. PR
## 10433
by
@worldworm
.
üìù Update example validation error from Pydantic v1 to match Pydantic v2 in
docs/en/docs/tutorial/path-params.md
. PR
## 10043
by
@giuliowaitforitdavide
.
‚úèÔ∏è Fix typos in emoji docs and in some source examples. PR
## 10438
by
@afuetterer
.
‚úèÔ∏è Fix typo in
docs/en/docs/reference/dependencies.md
. PR
## 10465
by
@suravshresth
.
‚úèÔ∏è Fix typos and rewordings in
docs/en/docs/tutorial/body-nested-models.md
. PR
## 10468
by
@yogabonito
.
üìù Update docs, remove references to removed
pydantic.Required
in
docs/en/docs/tutorial/query-params-str-validations.md
. PR
## 10469
by
@yogabonito
.
‚úèÔ∏è Fix typo in
docs/en/docs/reference/index.md
. PR
## 10467
by
@tarsil
.
üî• Remove unnecessary duplicated docstrings. PR
## 10484
by
@tiangolo
.
Internal
‚úèÔ∏è Update Pydantic links to dotenv support. PR
## 10511
by
@White-Mask
.
‚úèÔ∏è Update links in
docs/en/docs/async.md
and
docs/zh/docs/async.md
to make them relative. PR
## 10498
by
@hasnatsajid
.
‚úèÔ∏è Fix links in
docs/em/docs/async.md
. PR
## 10507
by
@hasnatsajid
.
‚úèÔ∏è Fix typo in
docs/em/docs/index.md
, Python 3.8. PR
## 10521
by
@kerriop
.
‚¨Ü Bump pillow from 9.5.0 to 10.1.0. PR
## 10446
by
@dependabot[bot]
.
‚¨Ü Update mkdocs-material requirement from <9.0.0,>=8.1.4 to >=8.1.4,<10.0.0. PR
## 5862
by
@dependabot[bot]
.
‚¨Ü Bump mkdocs-material from 9.1.21 to 9.4.7. PR
## 10545
by
@dependabot[bot]
.
üë∑ Install MkDocs Material Insiders only when secrets are available, for Dependabot. PR
## 10544
by
@tiangolo
.
üîß Update sponsors badges, Databento. PR
## 10519
by
@tiangolo
.
üë∑ Adopt Ruff format. PR
## 10517
by
@tiangolo
.
üîß Add
CITATION.cff
file for academic citations. PR
## 10496
by
@tiangolo
.
üêõ Fix overriding MKDocs theme lang in hook. PR
## 10490
by
@tiangolo
.
üî• Drop/close Gitter chat. Questions should go to GitHub Discussions, free conversations to Discord.. PR
## 10485
by
@tiangolo
.
0.104.0
Features
‚ú® Add reference (code API) docs with PEP 727, add subclass with custom docstrings for
BackgroundTasks
, refactor docs structure. PR
## 10392
by
@tiangolo
. New docs at
FastAPI Reference - Code API
.
Upgrades
‚¨ÜÔ∏è Drop support for Python 3.7, require Python 3.8 or above. PR
## 10442
by
@tiangolo
.
Internal
‚¨Ü Bump dawidd6/action-download-artifact from 2.27.0 to 2.28.0. PR
## 10268
by
@dependabot[bot]
.
‚¨Ü Bump actions/checkout from 3 to 4. PR
## 10208
by
@dependabot[bot]
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.8.6 to 1.8.10. PR
## 10061
by
@dependabot[bot]
.
üîß Update sponsors, Bump.sh images. PR
## 10381
by
@tiangolo
.
üë• Update FastAPI People. PR
## 10363
by
@tiangolo
.
0.103.2
Refactors
‚¨ÜÔ∏è Upgrade compatibility with Pydantic v2.4, new renamed functions and JSON Schema input/output models with default values. PR
## 10344
by
@tiangolo
.
Translations
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/extra-data-types.md
. PR
## 10132
by
@ArtemKhymenko
.
üåê Fix typos in French translations for
docs/fr/docs/advanced/path-operation-advanced-configuration.md
,
docs/fr/docs/alternatives.md
,
docs/fr/docs/async.md
,
docs/fr/docs/features.md
,
docs/fr/docs/help-fastapi.md
,
docs/fr/docs/index.md
,
docs/fr/docs/python-types.md
,
docs/fr/docs/tutorial/body.md
,
docs/fr/docs/tutorial/first-steps.md
,
docs/fr/docs/tutorial/query-params.md
. PR
## 10154
by
@s-rigaud
.
üåê Add Chinese translation for
docs/zh/docs/async.md
. PR
## 5591
by
@mkdir700
.
üåê Update Chinese translation for
docs/tutorial/security/simple-oauth2.md
. PR
## 3844
by
@jaystone776
.
üåê Add Korean translation for
docs/ko/docs/deployment/cloud.md
. PR
## 10191
by
@Sion99
.
üåê Add Japanese translation for
docs/ja/docs/deployment/https.md
. PR
## 10298
by
@tamtam-fitness
.
üåê Fix typo in Russian translation for
docs/ru/docs/tutorial/body-fields.md
. PR
## 10224
by
@AlertRED
.
üåê Add Polish translation for
docs/pl/docs/help-fastapi.md
. PR
## 10121
by
@romabozhanovgithub
.
üåê Add Russian translation for
docs/ru/docs/tutorial/header-params.md
. PR
## 10226
by
@AlertRED
.
üåê Add Chinese translation for
docs/zh/docs/deployment/versions.md
. PR
## 10276
by
@xzmeng
.
Internal
üîß Update sponsors, remove Flint. PR
## 10349
by
@tiangolo
.
üîß Rename label "awaiting review" to "awaiting-review" to simplify search queries. PR
## 10343
by
@tiangolo
.
üîß Update sponsors, enable Svix (revert #10228). PR
## 10253
by
@tiangolo
.
üîß Update sponsors, remove Svix. PR
## 10228
by
@tiangolo
.
üîß Update sponsors, add Bump.sh. PR
## 10227
by
@tiangolo
.
0.103.1
Fixes
üìå Pin AnyIO to < 4.0.0 to handle an incompatibility while upgrading to Starlette 0.31.1. PR
## 10194
by
@tiangolo
.
Docs
‚úèÔ∏è Fix validation parameter name in docs, from
regex
to
pattern
. PR
## 10085
by
@pablodorrio
.
‚úèÔ∏è Fix indent format in
docs/en/docs/deployment/server-workers.md
. PR
## 10066
by
@tamtam-fitness
.
‚úèÔ∏è Fix Pydantic examples in tutorial for Python types. PR
## 9961
by
@rahulsalgare
.
‚úèÔ∏è Fix link to Pydantic docs in
docs/en/docs/tutorial/extra-data-types.md
. PR
## 10155
by
@hasnatsajid
.
‚úèÔ∏è Fix typo in
docs/en/docs/tutorial/handling-errors.md
. PR
## 10170
by
@poupapaa
.
‚úèÔ∏è Fix typo in
docs/en/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 10172
by
@ragul-kachiappan
.
Translations
üåê Remove duplicate line in translation for
docs/pt/docs/tutorial/path-params.md
. PR
## 10126
by
@LecoOliveira
.
üåê Add Yoruba translation for
docs/yo/docs/index.md
. PR
## 10033
by
@AfolabiOlaoluwa
.
üåê Add Ukrainian translation for
docs/uk/docs/python-types.md
. PR
## 10080
by
@rostik1410
.
üåê Add Vietnamese translations for
docs/vi/docs/tutorial/first-steps.md
and
docs/vi/docs/tutorial/index.md
. PR
## 10088
by
@magiskboy
.
üåê Add Ukrainian translation for
docs/uk/docs/alternatives.md
. PR
## 10060
by
@whysage
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/index.md
. PR
## 10079
by
@rostik1410
.
‚úèÔ∏è Fix typos in
docs/en/docs/how-to/separate-openapi-schemas.md
and
docs/en/docs/tutorial/schema-extra-example.md
. PR
## 10189
by
@xzmeng
.
üåê Add Chinese translation for
docs/zh/docs/advanced/generate-clients.md
. PR
## 9883
by
@funny-cat-happy
.
Refactors
‚úèÔ∏è Fix typos in comment in
fastapi/applications.py
. PR
## 10045
by
@AhsanSheraz
.
‚úÖ Add missing test for OpenAPI examples, it was missing in coverage. PR
## 10188
by
@tiangolo
.
Internal
üë• Update FastAPI People. PR
## 10186
by
@tiangolo
.
0.103.0
Features
‚ú® Add support for
openapi_examples
in all FastAPI parameters. PR
## 10152
by
@tiangolo
.
New docs:
OpenAPI-specific examples
.
Docs
üìù Add note to docs about Separate Input and Output Schemas with FastAPI version. PR
## 10150
by
@tiangolo
.
0.102.0
Features
‚ú® Add support for disabling the separation of input and output JSON Schemas in OpenAPI with Pydantic v2 with
separate_input_output_schemas=False
. PR
## 10145
by
@tiangolo
.
New docs
Separate OpenAPI Schemas for Input and Output or Not
.
This PR also includes a new setup (internal tools) for generating screenshots for the docs.
Refactors
‚ôªÔ∏è Refactor tests for new Pydantic 2.2.1. PR
## 10115
by
@tiangolo
.
Docs
üìù Add new docs section, How To - Recipes, move docs that don't have to be read by everyone to How To. PR
## 10114
by
@tiangolo
.
üìù Update Advanced docs, add links to sponsor courses. PR
## 10113
by
@tiangolo
.
üìù Update docs for generating clients. PR
## 10112
by
@tiangolo
.
üìù Tweak MkDocs and add redirects. PR
## 10111
by
@tiangolo
.
üìù Restructure docs for cloud providers, include links to sponsors. PR
## 10110
by
@tiangolo
.
Internal
üîß Update sponsors, add Speakeasy. PR
## 10098
by
@tiangolo
.
0.101.1
Fixes
‚ú® Add
ResponseValidationError
printable details, to show up in server error logs. PR
## 10078
by
@tiangolo
.
Refactors
‚úèÔ∏è Fix typo in deprecation warnings in
fastapi/params.py
. PR
## 9854
by
@russbiggs
.
‚úèÔ∏è Fix typos in comments on internal code in
fastapi/concurrency.py
and
fastapi/routing.py
. PR
## 9590
by
@ElliottLarsen
.
Docs
‚úèÔ∏è Fix typo in release notes. PR
## 9835
by
@francisbergin
.
üìù Add external article: Build an SMS Spam Classifier Serverless Database with FaunaDB and FastAPI. PR
## 9847
by
@adejumoridwan
.
üìù Fix typo in
docs/en/docs/contributing.md
. PR
## 9878
by
@VicenteMerino
.
üìù Fix code highlighting in
docs/en/docs/tutorial/bigger-applications.md
. PR
## 9806
by
@theonlykingpin
.
Translations
üåê Add Japanese translation for
docs/ja/docs/deployment/concepts.md
. PR
## 10062
by
@tamtam-fitness
.
üåê Add Japanese translation for
docs/ja/docs/deployment/server-workers.md
. PR
## 10064
by
@tamtam-fitness
.
üåê Update Japanese translation for
docs/ja/docs/deployment/docker.md
. PR
## 10073
by
@tamtam-fitness
.
üåê Add Ukrainian translation for
docs/uk/docs/fastapi-people.md
. PR
## 10059
by
@rostik1410
.
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/cookie-params.md
. PR
## 10032
by
@rostik1410
.
üåê Add Russian translation for
docs/ru/docs/deployment/docker.md
. PR
## 9971
by
@Xewus
.
üåê Add Vietnamese translation for
docs/vi/docs/python-types.md
. PR
## 10047
by
@magiskboy
.
üåê Add Russian translation for
docs/ru/docs/tutorial/dependencies/global-dependencies.md
. PR
## 9970
by
@dudyaosuplayer
.
üåê Add Urdu translation for
docs/ur/docs/benchmarks.md
. PR
## 9974
by
@AhsanSheraz
.
Internal
üîß Add sponsor Porter. PR
## 10051
by
@tiangolo
.
üîß Update sponsors, add Jina back as bronze sponsor. PR
## 10050
by
@tiangolo
.
‚¨Ü Bump mypy from 1.4.0 to 1.4.1. PR
## 9756
by
@dependabot[bot]
.
‚¨Ü Bump mkdocs-material from 9.1.17 to 9.1.21. PR
## 9960
by
@dependabot[bot]
.
0.101.0
Features
‚ú® Enable Pydantic's serialization mode for responses, add support for Pydantic's
computed_field
, better OpenAPI for response models, proper required attributes, better generated clients. PR
## 10011
by
@tiangolo
.
Refactors
‚úÖ Fix tests for compatibility with pydantic 2.1.1. PR
## 9943
by
@dmontagu
.
‚úÖ Fix test error in Windows for
jsonable_encoder
. PR
## 9840
by
@iudeen
.
Upgrades
üìå Do not allow Pydantic 2.1.0 that breaks (require 2.1.1). PR
## 10012
by
@tiangolo
.
Translations
üåê Add Russian translation for
docs/ru/docs/tutorial/security/index.md
. PR
## 9963
by
@eVery1337
.
üåê Remove Vietnamese note about missing translation. PR
## 9957
by
@tiangolo
.
Internal
üë∑ Add GitHub Actions step dump context to debug external failures. PR
## 10008
by
@tiangolo
.
üîß Restore MkDocs Material pin after the fix. PR
## 10001
by
@tiangolo
.
üîß Update the Question template to ask for the Pydantic version. PR
## 10000
by
@tiangolo
.
üìç Update MkDocs Material dependencies. PR
## 9986
by
@tiangolo
.
üë• Update FastAPI People. PR
## 9999
by
@tiangolo
.
üê≥ Update Dockerfile with compatibility versions, to upgrade later. PR
## 9998
by
@tiangolo
.
‚ûï Add pydantic-settings to FastAPI People dependencies. PR
## 9988
by
@tiangolo
.
‚ôªÔ∏è Update FastAPI People logic with new Pydantic. PR
## 9985
by
@tiangolo
.
üç± Update sponsors, Fern badge. PR
## 9982
by
@tiangolo
.
üë∑ Deploy docs to Cloudflare Pages. PR
## 9978
by
@tiangolo
.
üîß Update sponsor Fern. PR
## 9979
by
@tiangolo
.
üë∑ Update CI debug mode with Tmate. PR
## 9977
by
@tiangolo
.
0.100.1
Fixes
üêõ Replace
MultHostUrl
to
AnyUrl
for compatibility with older versions of Pydantic v1. PR
## 9852
by
@Kludex
.
Docs
üìù Update links for self-hosted Swagger UI, point to v5, for OpenAPI 31.0. PR
## 9834
by
@tiangolo
.
Translations
üåê Add Ukrainian translation for
docs/uk/docs/tutorial/body.md
. PR
## 4574
by
@ss-o-furda
.
üåê Add Vietnamese translation for
docs/vi/docs/features.md
and
docs/vi/docs/index.md
. PR
## 3006
by
@magiskboy
.
üåê Add Korean translation for
docs/ko/docs/async.md
. PR
## 4179
by
@NinaHwang
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/background-tasks.md
. PR
## 9812
by
@wdh99
.
üåê Add French translation for
docs/fr/docs/tutorial/query-params-str-validations.md
. PR
## 4075
by
@Smlep
.
üåê Add French translation for
docs/fr/docs/tutorial/index.md
. PR
## 2234
by
@JulianMaurin
.
üåê Add French translation for
docs/fr/docs/contributing.md
. PR
## 2132
by
@JulianMaurin
.
üåê Add French translation for
docs/fr/docs/benchmarks.md
. PR
## 2155
by
@clemsau
.
üåê Update Chinese translations with new source files. PR
## 9738
by
@mahone3297
.
üåê Add Russian translation for
docs/ru/docs/tutorial/request-forms.md
. PR
## 9841
by
@dedkot01
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/handling-errors.md
. PR
## 9485
by
@Creat55
.
Internal
üîß Update sponsors, add Fern. PR
## 9956
by
@tiangolo
.
üë∑ Update FastAPI People token. PR
## 9844
by
@tiangolo
.
üë• Update FastAPI People. PR
## 9775
by
@tiangolo
.
üë∑ Update MkDocs Material token. PR
## 9843
by
@tiangolo
.
üë∑ Update token for latest changes. PR
## 9842
by
@tiangolo
.
0.100.0
‚ú® Support for
Pydantic v2
‚ú®
Pydantic version 2 has the
core
re-written in
Rust
and includes a lot of improvements and features, for example:
Improved
correctness
in corner cases.
Safer
types.
Better
performance
and
less energy
consumption.
Better
extensibility
.
etc.
...all this while keeping the
same Python API
. In most of the cases, for simple models, you can simply upgrade the Pydantic version and get all the benefits. üöÄ
In some cases, for pure data validation and processing, you can get performance improvements of
20x
or more. This means 2,000% or more. ü§Ø
When you use
FastAPI
, there's a lot more going on, processing the request and response, handling dependencies, executing
your own code
, and particularly,
waiting for the network
. But you will probably still get some nice performance improvements just from the upgrade.
The focus of this release is
compatibility
with Pydantic v1 and v2, to make sure your current apps keep working. Later there will be more focus on refactors, correctness, code improvements, and then
performance
improvements. Some third-party early beta testers that ran benchmarks on the beta releases of FastAPI reported improvements of
2x - 3x
. Which is not bad for just doing
pip install --upgrade fastapi pydantic
. This was not an official benchmark and I didn't check it myself, but it's a good sign.
Migration
Check out the
Pydantic migration guide
.
For the things that need changes in your Pydantic models, the Pydantic team built
bump-pydantic
.
A command line tool that will
process your code
and update most of the things
automatically
for you. Make sure you have your code in git first, and review each of the changes to make sure everything is correct before committing the changes.
Pydantic v1
This version of FastAPI still supports Pydantic v1
. And although Pydantic v1 will be deprecated at some point, it will still be supported for a while.
This means that you can install the new Pydantic v2, and if something fails, you can install Pydantic v1 while you fix any problems you might have, but having the latest FastAPI.
There are
tests for both Pydantic v1 and v2
, and test
coverage
is kept at
100%
.
Changes
There are
new parameter
fields supported by Pydantic
Field()
for:
Path()
Query()
Header()
Cookie()
Body()
Form()
File()
The new parameter fields are:
default_factory
alias_priority
validation_alias
serialization_alias
discriminator
strict
multiple_of
allow_inf_nan
max_digits
decimal_places
json_schema_extra
...you can read about them in the Pydantic docs.
The parameter
regex
has been deprecated and replaced by
pattern
.
You can read more about it in the docs for
Query Parameters and String Validations: Add regular expressions
.
New Pydantic models use an improved and simplified attribute
model_config
that takes a simple dict instead of an internal class
Config
for their configuration.
You can read more about it in the docs for
Declare Request Example Data
.
The attribute
schema_extra
for the internal class
Config
has been replaced by the key
json_schema_extra
in the new
model_config
dict.
You can read more about it in the docs for
Declare Request Example Data
.
When you install
"fastapi[all]"
it now also includes:
pydantic-settings
- for settings management.
pydantic-extra-types
- for extra types to be used with Pydantic.
Now Pydantic Settings is an additional optional package (included in
"fastapi[all]"
). To use settings you should now import
from pydantic_settings import BaseSettings
instead of importing from
pydantic
directly.
You can read more about it in the docs for
Settings and Environment Variables
.
PR
## 9816
by
@tiangolo
, included all the work done (in multiple PRs) on the beta branch (
main-pv2
).
0.99.1
Fixes
üêõ Fix JSON Schema accepting bools as valid JSON Schemas, e.g.
additionalProperties: false
. PR
## 9781
by
@tiangolo
.
Docs
üìù Update source examples to use new JSON Schema examples field. PR
## 9776
by
@tiangolo
.
0.99.0
Features
‚ú® Add support for OpenAPI 3.1.0. PR
## 9770
by
@tiangolo
.
New support for documenting
webhooks
, read the new docs here:
Advanced User Guide: OpenAPI Webhooks
.
Upgrade OpenAPI 3.1.0, this uses JSON Schema 2020-12.
Upgrade Swagger UI to version 5.x.x, that supports OpenAPI 3.1.0.
Updated
examples
field in
Query()
,
Cookie()
,
Body()
, etc. based on the latest JSON Schema and OpenAPI. Now it takes a list of examples and they are included directly in the JSON Schema, not outside. Read more about it (including the historical technical details) in the updated docs:
Tutorial: Declare Request Example Data
.
‚ú® Add support for
deque
objects and children in
jsonable_encoder
. PR
## 9433
by
@cranium
.
Docs
üìù Fix form for the FastAPI and friends newsletter. PR
## 9749
by
@tiangolo
.
Translations
üåê Add Persian translation for
docs/fa/docs/advanced/sub-applications.md
. PR
## 9692
by
@mojtabapaso
.
üåê Add Russian translation for
docs/ru/docs/tutorial/response-model.md
. PR
## 9675
by
@glsglsgls
.
Internal
üî® Enable linenums in MkDocs Material during local live development to simplify highlighting code. PR
## 9769
by
@tiangolo
.
‚¨Ü Update httpx requirement from <0.24.0,>=0.23.0 to >=0.23.0,<0.25.0. PR
## 9724
by
@dependabot[bot]
.
‚¨Ü Bump mkdocs-material from 9.1.16 to 9.1.17. PR
## 9746
by
@dependabot[bot]
.
üî• Remove missing translation dummy pages, no longer necessary. PR
## 9751
by
@tiangolo
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 9259
by
@pre-commit-ci[bot]
.
‚ú® Add Material for MkDocs Insiders features and cards. PR
## 9748
by
@tiangolo
.
üî• Remove languages without translations. PR
## 9743
by
@tiangolo
.
‚ú® Refactor docs for building scripts, use MkDocs hooks, simplify (remove) configs for languages. PR
## 9742
by
@tiangolo
.
üî® Add MkDocs hook that renames sections based on the first index file. PR
## 9737
by
@tiangolo
.
üë∑ Make cron jobs run only on main repo, not on forks, to avoid error notifications from missing tokens. PR
## 9735
by
@tiangolo
.
üîß Update MkDocs for other languages. PR
## 9734
by
@tiangolo
.
üë∑ Refactor Docs CI, run in multiple workers with a dynamic matrix to optimize speed. PR
## 9732
by
@tiangolo
.
üî• Remove old internal GitHub Action watch-previews that is no longer needed. PR
## 9730
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade MkDocs and MkDocs Material. PR
## 9729
by
@tiangolo
.
üë∑ Build and deploy docs only on docs changes. PR
## 9728
by
@tiangolo
.
0.98.0
Features
‚ú® Allow disabling
redirect_slashes
at the FastAPI app level. PR
## 3432
by
@cyberlis
.
Docs
üìù Update docs on Pydantic using ujson internally. PR
## 5804
by
@mvasilkov
.
‚úè Rewording in
docs/en/docs/tutorial/debugging.md
. PR
## 9581
by
@ivan-abc
.
üìù Add german blog post (Domain-driven Design mit Python und FastAPI). PR
## 9261
by
@msander
.
‚úèÔ∏è Tweak wording in
docs/en/docs/tutorial/security/index.md
. PR
## 9561
by
@jyothish-mohan
.
üìù Update
Annotated
notes in
docs/en/docs/tutorial/schema-extra-example.md
. PR
## 9620
by
@Alexandrhub
.
‚úèÔ∏è Fix typo
Annotation
->
Annotated
in
docs/en/docs/tutorial/query-params-str-validations.md
. PR
## 9625
by
@mccricardo
.
üìù Use in memory database for testing SQL in docs. PR
## 1223
by
@HarshaLaxman
.
Translations
üåê Add Russian translation for
docs/ru/docs/tutorial/metadata.md
. PR
## 9681
by
@TabarakoAkula
.
üåê Fix typo in Spanish translation for
docs/es/docs/tutorial/first-steps.md
. PR
## 9571
by
@lilidl-nft
.
üåê Add Russian translation for
docs/tutorial/path-operation-configuration.md
. PR
## 9696
by
@TabarakoAkula
.
üåê Add Chinese translation for
docs/zh/docs/advanced/security/index.md
. PR
## 9666
by
@lordqyxz
.
üåê Add Chinese translations for
docs/zh/docs/advanced/settings.md
. PR
## 9652
by
@ChoyeonChern
.
üåê Add Chinese translations for
docs/zh/docs/advanced/websockets.md
. PR
## 9651
by
@ChoyeonChern
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/testing.md
. PR
## 9641
by
@wdh99
.
üåê Add Russian translation for
docs/tutorial/extra-models.md
. PR
## 9619
by
@ivan-abc
.
üåê Add Russian translation for
docs/tutorial/cors.md
. PR
## 9608
by
@ivan-abc
.
üåê Add Polish translation for
docs/pl/docs/features.md
. PR
## 5348
by
@mbroton
.
üåê Add Russian translation for
docs/ru/docs/tutorial/body-nested-models.md
. PR
## 9605
by
@Alexandrhub
.
Internal
‚¨Ü Bump ruff from 0.0.272 to 0.0.275. PR
## 9721
by
@dependabot[bot]
.
‚¨Ü Update uvicorn[standard] requirement from <0.21.0,>=0.12.0 to >=0.12.0,<0.23.0. PR
## 9463
by
@dependabot[bot]
.
‚¨Ü Bump mypy from 1.3.0 to 1.4.0. PR
## 9719
by
@dependabot[bot]
.
‚¨Ü Update pre-commit requirement from <3.0.0,>=2.17.0 to >=2.17.0,<4.0.0. PR
## 9251
by
@dependabot[bot]
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.8.5 to 1.8.6. PR
## 9482
by
@dependabot[bot]
.
‚úèÔ∏è Fix tooltips for light/dark theme toggler in docs. PR
## 9588
by
@pankaj1707k
.
üîß Set minimal hatchling version needed to build the package. PR
## 9240
by
@mgorny
.
üìù Add repo link to PyPI. PR
## 9559
by
@JacobCoffee
.
‚úèÔ∏è Fix typos in data for tests. PR
## 4958
by
@ryanrussell
.
üîß Update sponsors, add Flint. PR
## 9699
by
@tiangolo
.
üë∑ Lint in CI only once, only with one version of Python, run tests with all of them. PR
## 9686
by
@tiangolo
.
0.97.0
Features
‚ú® Add support for
dependencies
in WebSocket routes. PR
## 4534
by
@paulo-raca
.
‚ú® Add exception handler for
WebSocketRequestValidationError
(which also allows to override it). PR
## 6030
by
@kristjanvalur
.
Refactors
‚¨ÜÔ∏è Upgrade and fully migrate to Ruff, remove isort, includes a couple of tweaks suggested by the new version of Ruff. PR
## 9660
by
@tiangolo
.
‚ôªÔ∏è Update internal type annotations and upgrade mypy. PR
## 9658
by
@tiangolo
.
‚ôªÔ∏è Simplify
AsyncExitStackMiddleware
as without Python 3.6
AsyncExitStack
is always available. PR
## 9657
by
@tiangolo
.
Upgrades
‚¨ÜÔ∏è Upgrade Black. PR
## 9661
by
@tiangolo
.
Internal
üíö Update CI cache to fix installs when dependencies change. PR
## 9659
by
@tiangolo
.
‚¨áÔ∏è Separate requirements for development into their own requirements.txt files, they shouldn't be extras. PR
## 9655
by
@tiangolo
.
0.96.1
Fixes
üêõ Fix
HTTPException
header type annotations. PR
## 9648
by
@tiangolo
.
üêõ Fix OpenAPI model fields int validations,
gte
to
ge
. PR
## 9635
by
@tiangolo
.
Upgrades
üìå Update minimum version of Pydantic to >=1.7.4. This fixes an issue when trying to use an old version of Pydantic. PR
## 9567
by
@Kludex
.
Refactors
‚ôª Remove
media_type
from
ORJSONResponse
as it's inherited from the parent class. PR
## 5805
by
@Kludex
.
‚ôª Instantiate
HTTPException
only when needed, optimization refactor. PR
## 5356
by
@pawamoy
.
Docs
üî• Remove link to Pydantic's benchmark, as it was removed there. PR
## 5811
by
@Kludex
.
Translations
üåê Fix spelling in Indonesian translation of
docs/id/docs/tutorial/index.md
. PR
## 5635
by
@purwowd
.
üåê Add Russian translation for
docs/ru/docs/tutorial/index.md
. PR
## 5896
by
@Wilidon
.
üåê Add Chinese translations for
docs/zh/docs/advanced/response-change-status-code.md
and
docs/zh/docs/advanced/response-headers.md
. PR
## 9544
by
@ChoyeonChern
.
üåê Add Russian translation for
docs/ru/docs/tutorial/schema-extra-example.md
. PR
## 9621
by
@Alexandrhub
.
Internal
üîß Add sponsor Platform.sh. PR
## 9650
by
@tiangolo
.
üë∑ Add custom token to Smokeshow and Preview Docs for download-artifact, to prevent API rate limits. PR
## 9646
by
@tiangolo
.
üë∑ Add custom tokens for GitHub Actions to avoid rate limits. PR
## 9647
by
@tiangolo
.
0.96.0
Features
‚ö° Update
create_cloned_field
to use a global cache and improve startup performance. PR
## 4645
by
@madkinsz
and previous original PR by
@huonw
.
Docs
üìù Update Deta deployment tutorial for compatibility with Deta Space. PR
## 6004
by
@mikBighne98
.
‚úèÔ∏è Fix typo in Deta deployment tutorial. PR
## 9501
by
@lemonyte
.
Translations
üåê Add Russian translation for
docs/tutorial/body.md
. PR
## 3885
by
@solomein-sv
.
üåê Add Russian translation for
docs/ru/docs/tutorial/static-files.md
. PR
## 9580
by
@Alexandrhub
.
üåê Add Russian translation for
docs/ru/docs/tutorial/query-params.md
. PR
## 9584
by
@Alexandrhub
.
üåê Add Russian translation for
docs/ru/docs/tutorial/first-steps.md
. PR
## 9471
by
@AGolicyn
.
üåê Add Russian translation for
docs/ru/docs/tutorial/debugging.md
. PR
## 9579
by
@Alexandrhub
.
üåê Add Russian translation for
docs/ru/docs/tutorial/path-params.md
. PR
## 9519
by
@AGolicyn
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/static-files.md
. PR
## 9436
by
@wdh99
.
üåê Update Spanish translation including new illustrations in
docs/es/docs/async.md
. PR
## 9483
by
@andresbermeoq
.
üåê Add Russian translation for
docs/ru/docs/tutorial/path-params-numeric-validations.md
. PR
## 9563
by
@ivan-abc
.
üåê Add Russian translation for
docs/ru/docs/deployment/concepts.md
. PR
## 9577
by
@Xewus
.
üåê Add Russian translation for
docs/ru/docs/tutorial/body-multiple-params.md
. PR
## 9586
by
@Alexandrhub
.
Internal
üë• Update FastAPI People. PR
## 9602
by
@github-actions[bot]
.
üîß Update sponsors, remove InvestSuite. PR
## 9612
by
@tiangolo
.
0.95.2
‚¨ÜÔ∏è Upgrade Starlette version to
>=0.27.0
for a security release. PR
## 9541
by
@tiangolo
. Details on
Starlette's security advisory
.
Translations
üåê Add Portuguese translation for
docs/pt/docs/advanced/events.md
. PR
## 9326
by
@oandersonmagalhaes
.
üåê Add Russian translation for
docs/ru/docs/deployment/manually.md
. PR
## 9417
by
@Xewus
.
üåê Add setup for translations to Lao. PR
## 9396
by
@TheBrown
.
üåê Add Russian translation for
docs/ru/docs/tutorial/testing.md
. PR
## 9403
by
@Xewus
.
üåê Add Russian translation for
docs/ru/docs/deployment/https.md
. PR
## 9428
by
@Xewus
.
‚úè Fix command to install requirements in Windows. PR
## 9445
by
@MariiaRomanuik
.
üåê Add French translation for
docs/fr/docs/advanced/response-directly.md
. PR
## 9415
by
@axel584
.
üåê Initiate Czech translation setup. PR
## 9288
by
@3p1463k
.
‚úè Fix typo in Portuguese docs for
docs/pt/docs/index.md
. PR
## 9337
by
@lucasbalieiro
.
üåê Add Russian translation for
docs/ru/docs/tutorial/response-status-code.md
. PR
## 9370
by
@nadia3373
.
Internal
üêõ Fix
flask.escape
warning for internal tests. PR
## 9468
by
@samuelcolvin
.
‚úÖ Refactor 2 tests, for consistency and simplification. PR
## 9504
by
@tiangolo
.
‚úÖ Refactor OpenAPI tests, prepare for Pydantic v2. PR
## 9503
by
@tiangolo
.
‚¨Ü Bump dawidd6/action-download-artifact from 2.26.0 to 2.27.0. PR
## 9394
by
@dependabot[bot]
.
üíö Disable setup-python pip cache in CI. PR
## 9438
by
@tiangolo
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.6.4 to 1.8.5. PR
## 9346
by
@dependabot[bot]
.
0.95.1
Fixes
üêõ Fix using
Annotated
in routers or path operations decorated multiple times. PR
## 9315
by
@sharonyogev
.
Docs
üåê üî† üìÑ üê¢ Translate docs to Emoji ü•≥ üéâ üí• ü§Ø ü§Ø. PR
## 5385
by
@LeeeeT
.
üìù Add notification message warning about old versions of FastAPI not supporting
Annotated
. PR
## 9298
by
@grdworkin
.
üìù Fix typo in
docs/en/docs/advanced/behind-a-proxy.md
. PR
## 5681
by
@Leommjr
.
‚úè Fix wrong import from typing module in Persian translations for
docs/fa/docs/index.md
. PR
## 6083
by
@Kimiaattaei
.
‚úèÔ∏è Fix format, remove unnecessary asterisks in
docs/en/docs/help-fastapi.md
. PR
## 9249
by
@armgabrielyan
.
‚úè Fix typo in
docs/en/docs/tutorial/query-params-str-validations.md
. PR
## 9272
by
@nicornk
.
‚úè Fix typo/bug in inline code example in
docs/en/docs/tutorial/query-params-str-validations.md
. PR
## 9273
by
@tim-habitat
.
‚úè Fix typo in
docs/en/docs/tutorial/path-params-numeric-validations.md
. PR
## 9282
by
@aadarsh977
.
‚úè Fix typo: 'wll' to 'will' in
docs/en/docs/tutorial/query-params-str-validations.md
. PR
## 9380
by
@dasstyxx
.
Translations
üåê Add French translation for
docs/fr/docs/advanced/index.md
. PR
## 5673
by
@axel584
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/body-nested-models.md
. PR
## 4053
by
@luccasmmg
.
üåê Add Russian translation for
docs/ru/docs/alternatives.md
. PR
## 5994
by
@Xewus
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/extra-models.md
. PR
## 5912
by
@LorhanSohaky
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/path-operation-configuration.md
. PR
## 5936
by
@LorhanSohaky
.
üåê Add Russian translation for
docs/ru/docs/contributing.md
. PR
## 6002
by
@stigsanek
.
üåê Add Korean translation for
docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 9176
by
@sehwan505
.
üåê Add Russian translation for
docs/ru/docs/project-generation.md
. PR
## 9243
by
@Xewus
.
üåê Add French translation for
docs/fr/docs/index.md
. PR
## 9265
by
@frabc
.
üåê Add Russian translation for
docs/ru/docs/tutorial/query-params-str-validations.md
. PR
## 9267
by
@dedkot01
.
üåê Add Russian translation for
docs/ru/docs/benchmarks.md
. PR
## 9271
by
@Xewus
.
Internal
üîß Update sponsors: remove Jina. PR
## 9388
by
@tiangolo
.
üîß Update sponsors, add databento, remove Ines's course and StriveWorks. PR
## 9351
by
@tiangolo
.
0.95.0
Highlights
This release adds support for dependencies and parameters using
Annotated
and recommends its usage. ‚ú®
This has
several benefits
, one of the main ones is that now the parameters of your functions with
Annotated
would
not be affected
at all.
If you call those functions in
other places in your code
, the actual
default values
will be kept, your editor will help you notice missing
required arguments
, Python will require you to pass required arguments at
runtime
, you will be able to
use the same functions
for different things and with different libraries (e.g.
Typer
will soon support
Annotated
too, then you could use the same function for an API and a CLI), etc.
Because
Annotated
is
standard Python
, you still get all the
benefits
from editors and tools, like
autocompletion
,
inline errors
, etc.
One of the
biggest benefits
is that now you can create
Annotated
dependencies that are then shared by multiple
path operation functions
, this will allow you to
reduce
a lot of
code duplication
in your codebase, while keeping all the support from editors and tools.
For example, you could have code like this:
def
get_current_user
(
token
:
str
):
## authenticate user
return
User
()
@app
.
get
(
"/items/"
)
def
read_items
(
user
:
User
=
Depends
(
get_current_user
)):
...
@app
.
post
(
"/items/"
)
def
create_item
(
*
,
user
:
User
=
Depends
(
get_current_user
),
item
:
Item
):
...
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
*
,
user
:
User
=
Depends
(
get_current_user
),
item_id
:
int
):
...
@app
.
delete
(
"/items/
{item_id}
"
)
def
delete_item
(
*
,
user
:
User
=
Depends
(
get_current_user
),
item_id
:
int
):
...
There's a bit of code duplication for the dependency:
user
:
User
=
Depends
(
get_current_user
)
...the bigger the codebase, the more noticeable it is.
Now you can create an annotated dependency once, like this:
CurrentUser
=
Annotated
[
User
,
Depends
(
get_current_user
)]
And then you can reuse this
Annotated
dependency:
CurrentUser
=
Annotated
[
User
,
Depends
(
get_current_user
)]
@app
.
get
(
"/items/"
)
def
read_items
(
user
:
CurrentUser
):
...
@app
.
post
(
"/items/"
)
def
create_item
(
user
:
CurrentUser
,
item
:
Item
):
...
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
user
:
CurrentUser
,
item_id
:
int
):
...
@app
.
delete
(
"/items/
{item_id}
"
)
def
delete_item
(
user
:
CurrentUser
,
item_id
:
int
):
...
...and
CurrentUser
has all the typing information as
User
, so your editor will work as expected (autocompletion and everything), and
FastAPI
will be able to understand the dependency defined in
Annotated
. üòé
Roughly
all the docs
have been rewritten to use
Annotated
as the main way to declare
parameters
and
dependencies
. All the
examples
in the docs now include a version with
Annotated
and a version without it, for each of the specific Python versions (when there are small differences/improvements in more recent versions). There were around 23K new lines added between docs, examples, and tests. üöÄ
The key updated docs are:
Python Types Intro:
Type Hints with Metadata Annotations
.
Tutorial:
Query Parameters and String Validations - Additional validation
Advantages of
Annotated
Path Parameters and Numeric Validations - Order the parameters as you need, tricks
Better with
Annotated
Dependencies - First Steps - Share
Annotated
dependencies
Special thanks to
@nzig
for the core implementation and to
@adriangb
for the inspiration and idea with
Xpresso
! üöÄ
Features
‚ú®Add support for PEP-593
Annotated
for specifying dependencies and parameters. PR
## 4871
by
@nzig
.
Docs
üìù Tweak tip recommending
Annotated
in docs. PR
## 9270
by
@tiangolo
.
üìù Update order of examples, latest Python version first, and simplify version tab names. PR
## 9269
by
@tiangolo
.
üìù Update all docs to use
Annotated
as the main recommendation, with new examples and tests. PR
## 9268
by
@tiangolo
.
0.94.1
Fixes
üé® Fix types for lifespan, upgrade Starlette to 0.26.1. PR
## 9245
by
@tiangolo
.
0.94.0
Upgrades
‚¨Ü Upgrade python-multipart to support 0.0.6. PR
## 9212
by
@musicinmybrain
.
‚¨ÜÔ∏è Upgrade Starlette version, support new
lifespan
with state. PR
## 9239
by
@tiangolo
.
Docs
üìù Update Sentry link in docs. PR
## 9218
by
@smeubank
.
Translations
üåê Add Russian translation for
docs/ru/docs/history-design-future.md
. PR
## 5986
by
@Xewus
.
Internal
‚ûï Add
pydantic
to PyPI classifiers. PR
## 5914
by
@yezz123
.
‚¨Ü Bump black from 22.10.0 to 23.1.0. PR
## 5953
by
@dependabot[bot]
.
‚¨Ü Bump types-ujson from 5.6.0.0 to 5.7.0.1. PR
## 6027
by
@dependabot[bot]
.
‚¨Ü Bump dawidd6/action-download-artifact from 2.24.3 to 2.26.0. PR
## 6034
by
@dependabot[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 5709
by
@pre-commit-ci[bot]
.
0.93.0
Features
‚ú® Add support for
lifespan
async context managers (superseding
startup
and
shutdown
events). Initial PR
## 2944
by
@uSpike
.
Now, instead of using independent
startup
and
shutdown
events, you can define that logic in a single function with
yield
decorated with
@asynccontextmanager
(an async context manager).
For example:
from
contextlib
import
asynccontextmanager
from
fastapi
import
FastAPI
def
fake_answer_to_everything_ml_model
(
x
:
float
):
return
x
*
42
ml_models
=
{}
@asynccontextmanager
async
def
lifespan
(
app
:
FastAPI
):
## Load the ML model
ml_models
[
"answer_to_everything"
]
=
fake_answer_to_everything_ml_model
yield
## Clean up the ML models and release the resources
ml_models
.
clear
()
app
=
FastAPI
(
lifespan
=
lifespan
)
@app
.
get
(
"/predict"
)
async
def
predict
(
x
:
float
):
result
=
ml_models
[
"answer_to_everything"
](
x
)
return
{
"result"
:
result
}
Note
: This is the recommended way going forward, instead of using
startup
and
shutdown
events.
Read more about it in the new docs:
Advanced User Guide: Lifespan Events
.
Docs
‚úè Fix formatting in
docs/en/docs/tutorial/metadata.md
for
ReDoc
. PR
## 6005
by
@eykamp
.
Translations
üåê Tamil translations - initial setup. PR
## 5564
by
@gusty1g
.
üåê Add French translation for
docs/fr/docs/advanced/path-operation-advanced-configuration.md
. PR
## 9221
by
@axel584
.
üåê Add French translation for
docs/tutorial/debugging.md
. PR
## 9175
by
@frabc
.
üåê Initiate Armenian translation setup. PR
## 5844
by
@har8
.
üåê Add French translation for
deployment/manually.md
. PR
## 3693
by
@rjNemo
.
Internal
üë∑ Update translation bot messages. PR
## 9206
by
@tiangolo
.
üë∑ Update translations bot to use Discussions, and notify when a PR is done. PR
## 9183
by
@tiangolo
.
üîß Update sponsors-badges. PR
## 9182
by
@tiangolo
.
üë• Update FastAPI People. PR
## 9181
by
@github-actions[bot]
.
üîä Log GraphQL errors in FastAPI People, because it returns 200, with a payload with an error. PR
## 9171
by
@tiangolo
.
üíö Fix/workaround GitHub Actions in Docker with git for FastAPI People. PR
## 9169
by
@tiangolo
.
‚ôªÔ∏è Refactor FastAPI Experts to use only discussions now that questions are migrated. PR
## 9165
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade analytics. PR
## 6025
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade and re-enable installing Typer-CLI. PR
## 6008
by
@tiangolo
.
0.92.0
üö® This is a security fix. Please upgrade as soon as possible.
Upgrades
‚¨ÜÔ∏è Upgrade Starlette to 0.25.0. PR
## 5996
by
@tiangolo
.
This solves a vulnerability that could allow denial of service attacks by using many small multipart fields/files (parts), consuming high CPU and memory.
Only applications using forms (e.g. file uploads) could be affected.
For most cases, upgrading won't have any breaking changes.
0.91.0
Upgrades
‚¨ÜÔ∏è Upgrade Starlette version to
0.24.0
and refactor internals for compatibility. PR
## 5985
by
@tiangolo
.
This can solve nuanced errors when using middlewares. Before Starlette
0.24.0
, a new instance of each middleware class would be created when a new middleware was added. That normally was not a problem, unless the middleware class expected to be created only once, with only one instance, that happened in some cases. This upgrade would solve those cases (thanks
@adriangb
! Starlette PR
## 2017
). Now the middleware class instances are created once, right before the first request (the first time the app is called).
If you depended on that previous behavior, you might need to update your code. As always, make sure your tests pass before merging the upgrade.
0.90.1
Upgrades
‚¨ÜÔ∏è Upgrade Starlette range to allow 0.23.1. PR
## 5980
by
@tiangolo
.
Docs
‚úè Tweak wording to clarify
docs/en/docs/project-generation.md
. PR
## 5930
by
@chandra-deb
.
‚úè Update Pydantic GitHub URLs. PR
## 5952
by
@yezz123
.
üìù Add opinion from Cisco. PR
## 5981
by
@tiangolo
.
Translations
üåê Add Russian translation for
docs/ru/docs/tutorial/cookie-params.md
. PR
## 5890
by
@bnzone
.
Internal
‚úè Update
zip-docs.sh
internal script, remove extra space. PR
## 5931
by
@JuanPerdomo00
.
0.90.0
Upgrades
‚¨ÜÔ∏è Bump Starlette from 0.22.0 to 0.23.0. Initial PR
## 5739
by
@Kludex
.
Docs
üìù Add article "Tortoise ORM / FastAPI Êï¥ÂêàÂø´ÈÄüÁ≠ÜË®ò" to External Links. PR
## 5496
by
@Leon0824
.
üë• Update FastAPI People. PR
## 5954
by
@github-actions[bot]
.
üìù Micro-tweak help docs. PR
## 5960
by
@tiangolo
.
üîß Update new issue chooser to direct to GitHub Discussions. PR
## 5948
by
@tiangolo
.
üìù Recommend GitHub Discussions for questions. PR
## 5944
by
@tiangolo
.
Translations
üåê Add Russian translation for
docs/ru/docs/tutorial/body-fields.md
. PR
## 5898
by
@simatheone
.
üåê Add Russian translation for
docs/ru/docs/help-fastapi.md
. PR
## 5970
by
@tiangolo
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/static-files.md
. PR
## 5858
by
@batlopes
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/encoder.md
. PR
## 5525
by
@felipebpl
.
üåê Add Russian translation for
docs/ru/docs/contributing.md
. PR
## 5870
by
@Xewus
.
Internal
‚¨ÜÔ∏è Upgrade Ubuntu version for docs workflow. PR
## 5971
by
@tiangolo
.
üîß Update sponsors badges. PR
## 5943
by
@tiangolo
.
‚ú® Compute FastAPI Experts including GitHub Discussions. PR
## 5941
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade isort and update pre-commit. PR
## 5940
by
@tiangolo
.
üîß Add template for questions in Discussions. PR
## 5920
by
@tiangolo
.
üîß Update Sponsor Budget Insight to Powens. PR
## 5916
by
@tiangolo
.
üîß Update GitHub Sponsors badge data. PR
## 5915
by
@tiangolo
.
0.89.1
Fixes
üêõ Ignore Response classes on return annotation. PR
## 5855
by
@Kludex
. See the new docs in the PR below.
Docs
üìù Update docs and examples for Response Model with Return Type Annotations, and update runtime error. PR
## 5873
by
@tiangolo
. New docs at
Response Model - Return Type: Other Return Type Annotations
.
üìù Add External Link: FastAPI lambda container: serverless simplified. PR
## 5784
by
@rafrasenberg
.
Translations
üåê Add Turkish translation for
docs/tr/docs/tutorial/first_steps.md
. PR
## 5691
by
@Kadermiyanyedi
.
0.89.0
Features
‚ú® Add support for function return type annotations to declare the
response_model
. Initial PR
## 1436
by
@uriyyo
.
Now you can declare the return type /
response_model
in the function return type annotation:
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
@app
.
get
(
"/items/"
)
async
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
price
=
42.0
),
Item
(
name
=
"Plumbus"
,
price
=
32.0
),
]
FastAPI will use the return type annotation to perform:
Data validation
Automatic documentation
It could power automatic client generators
Data filtering
Before this version it was only supported via the
response_model
parameter.
Read more about it in the new docs:
Response Model - Return Type
.
Docs
üìù Add External Link: Authorization on FastAPI with Casbin. PR
## 5712
by
@Xhy-5000
.
‚úè Fix typo in
docs/en/docs/async.md
. PR
## 5785
by
@Kingdageek
.
‚úè Fix typo in
docs/en/docs/deployment/concepts.md
. PR
## 5824
by
@kelbyfaessler
.
Translations
üåê Add Russian translation for
docs/ru/docs/fastapi-people.md
. PR
## 5577
by
@Xewus
.
üåê Fix typo in Chinese translation for
docs/zh/docs/benchmarks.md
. PR
## 4269
by
@15027668g
.
üåê Add Korean translation for
docs/tutorial/cors.md
. PR
## 3764
by
@NinaHwang
.
Internal
‚¨Ü Update coverage[toml] requirement from <7.0,>=6.5.0 to >=6.5.0,<8.0. PR
## 5801
by
@dependabot[bot]
.
‚¨Ü Update uvicorn[standard] requirement from <0.19.0,>=0.12.0 to >=0.12.0,<0.21.0 for development. PR
## 5795
by
@dependabot[bot]
.
‚¨Ü Bump dawidd6/action-download-artifact from 2.24.2 to 2.24.3. PR
## 5842
by
@dependabot[bot]
.
üë• Update FastAPI People. PR
## 5825
by
@github-actions[bot]
.
‚¨Ü Bump types-ujson from 5.5.0 to 5.6.0.0. PR
## 5735
by
@dependabot[bot]
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.5.2 to 1.6.4. PR
## 5750
by
@dependabot[bot]
.
üë∑ Add GitHub Action gate/check. PR
## 5492
by
@webknjaz
.
üîß Update sponsors, add Svix. PR
## 5848
by
@tiangolo
.
üîß Remove Doist sponsor. PR
## 5847
by
@tiangolo
.
‚¨Ü Update sqlalchemy requirement from <=1.4.41,>=1.3.18 to >=1.3.18,<1.4.43. PR
## 5540
by
@dependabot[bot]
.
‚¨Ü Bump nwtgck/actions-netlify from 1.2.4 to 2.0.0. PR
## 5757
by
@dependabot[bot]
.
üë∑ Refactor CI artifact upload/download for docs previews. PR
## 5793
by
@tiangolo
.
‚¨Ü Bump pypa/gh-action-pypi-publish from 1.5.1 to 1.5.2. PR
## 5714
by
@dependabot[bot]
.
üë• Update FastAPI People. PR
## 5722
by
@github-actions[bot]
.
üîß Update sponsors, disable course bundle. PR
## 5713
by
@tiangolo
.
‚¨Ü Update typer[all] requirement from <0.7.0,>=0.6.1 to >=0.6.1,<0.8.0. PR
## 5639
by
@dependabot[bot]
.
0.88.0
Upgrades
‚¨Ü Bump Starlette to version
0.22.0
to fix bad encoding for query parameters in new
TestClient
. PR
## 5659
by
@azogue
.
Docs
‚úèÔ∏è Fix typo in docs for
docs/en/docs/advanced/middleware.md
. PR
## 5376
by
@rifatrakib
.
Translations
üåê Add Portuguese translation for
docs/pt/docs/deployment/docker.md
. PR
## 5663
by
@ayr-ton
.
Internal
üë∑ Tweak build-docs to improve CI performance. PR
## 5699
by
@tiangolo
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 5566
by
@pre-commit-ci[bot]
.
‚¨ÜÔ∏è Upgrade Ruff. PR
## 5698
by
@tiangolo
.
üë∑ Remove pip cache for Smokeshow as it depends on a requirements.txt. PR
## 5700
by
@tiangolo
.
üíö Fix pip cache for Smokeshow. PR
## 5697
by
@tiangolo
.
üë∑ Fix and tweak CI cache handling. PR
## 5696
by
@tiangolo
.
üë∑ Update
setup-python
action in tests to use new caching feature. PR
## 5680
by
@madkinsz
.
‚¨Ü Bump black from 22.8.0 to 22.10.0. PR
## 5569
by
@dependabot[bot]
.
0.87.0
Highlights of this release:
Upgraded Starlette
Now the
TestClient
is based on HTTPX instead of Requests. üöÄ
There are some possible
breaking changes
in the
TestClient
usage, but
@Kludex
built
bump-testclient
to help you automatize migrating your tests. Make sure you are using Git and that you can undo any unnecessary changes (false positive changes, etc) before using
bump-testclient
.
New
WebSocketException (and docs)
, re-exported from Starlette.
Upgraded and relaxed dependencies for package extras
all
(including new Uvicorn version), when you install
"fastapi[all]"
.
New docs about how to
Help Maintain FastAPI
.
Features
‚¨ÜÔ∏è Upgrade and relax dependencies for extras "all". PR
## 5634
by
@tiangolo
.
‚ú® Re-export Starlette's
WebSocketException
and add it to docs. PR
## 5629
by
@tiangolo
.
üìù Update references to Requests for tests to HTTPX, and add HTTPX to extras. PR
## 5628
by
@tiangolo
.
‚¨Ü Upgrade Starlette to
0.21.0
, including the new
TestClient
based on HTTPX
. PR
## 5471
by
@pawelrubin
.
Docs
‚úèÔ∏è Tweak Help FastAPI from PR review after merging. PR
## 5633
by
@tiangolo
.
‚úèÔ∏è Clarify docs on CORS. PR
## 5627
by
@paxcodes
.
üìù Update Help FastAPI: Help Maintain FastAPI. PR
## 5632
by
@tiangolo
.
Translations
üåê Fix highlight lines for Japanese translation for
docs/tutorial/query-params.md
. PR
## 2969
by
@ftnext
.
üåê Add French translation for
docs/fr/docs/advanced/additional-status-code.md
. PR
## 5477
by
@axel584
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/request-forms-and-files.md
. PR
## 5579
by
@batlopes
.
üåê Add Japanese translation for
docs/ja/docs/advanced/websockets.md
. PR
## 4983
by
@xryuseix
.
Internal
‚ú® Use Ruff for linting. PR
## 5630
by
@tiangolo
.
üõ† Add Arabic issue number to Notify Translations GitHub Action. PR
## 5610
by
@tiangolo
.
‚¨Ü Bump dawidd6/action-download-artifact from 2.24.1 to 2.24.2. PR
## 5609
by
@dependabot[bot]
.
‚¨Ü Bump dawidd6/action-download-artifact from 2.24.0 to 2.24.1. PR
## 5603
by
@dependabot[bot]
.
üìù Update coverage badge to use Samuel Colvin's Smokeshow. PR
## 5585
by
@tiangolo
.
0.86.0
Features
‚¨Ü Add Python 3.11 to the officially supported versions. PR
## 5587
by
@tiangolo
.
‚úÖ Enable tests for Python 3.11. PR
## 4881
by
@tiangolo
.
Fixes
üêõ Close FormData (uploaded files) after the request is done. PR
## 5465
by
@adriangb
.
Docs
‚úè Fix typo in
docs/en/docs/tutorial/security/oauth2-jwt.md
. PR
## 5584
by
@vivekashok1221
.
Translations
üåê Update wording in Chinese translation for
docs/zh/docs/python-types.md
. PR
## 5416
by
@supercaizehua
.
üåê Add Russian translation for
docs/ru/docs/deployment/index.md
. PR
## 5336
by
@Xewus
.
üåê Update Chinese translation for
docs/tutorial/security/oauth2-jwt.md
. PR
## 3846
by
@jaystone776
.
Internal
üë∑ Update FastAPI People to exclude bots: pre-commit-ci, dependabot. PR
## 5586
by
@tiangolo
.
üé® Format OpenAPI JSON in
test_starlette_exception.py
. PR
## 5379
by
@iudeen
.
üë∑ Switch from Codecov to Smokeshow plus pytest-cov to pure coverage for internal tests. PR
## 5583
by
@tiangolo
.
üë• Update FastAPI People. PR
## 5571
by
@github-actions[bot]
.
0.85.2
Docs
‚úè Fix grammar and add helpful links to dependencies in
docs/en/docs/async.md
. PR
## 5432
by
@pamelafox
.
‚úè Fix broken link in
alternatives.md
. PR
## 5455
by
@su-shubham
.
‚úè Fix typo in docs about contributing, for compatibility with
pip
in Zsh. PR
## 5523
by
@zhangbo2012
.
üìù Fix typo in docs with examples for Python 3.10 instead of 3.9. PR
## 5545
by
@feliciss
.
Translations
üåê Add Portuguese translation for
docs/pt/docs/tutorial/request-forms.md
. PR
## 4934
by
@batlopes
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/dependencies/classes-as-dependencies.md
. PR
## 4971
by
@Zssaer
.
üåê Add French translation for
deployment/deta.md
. PR
## 3692
by
@rjNemo
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/query-params-str-validations.md
. PR
## 5255
by
@hjlarry
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/sql-databases.md
. PR
## 4999
by
@Zssaer
.
üåê Add Chinese translation for
docs/zh/docs/advanced/wsgi.md
. PR
## 4505
by
@ASpathfinder
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/body-multiple-params.md
. PR
## 4111
by
@lbmendes
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/path-params-numeric-validations.md
. PR
## 4099
by
@lbmendes
.
üåê Add French translation for
deployment/versions.md
. PR
## 3690
by
@rjNemo
.
üåê Add French translation for
docs/fr/docs/help-fastapi.md
. PR
## 2233
by
@JulianMaurin
.
üåê Fix typo in Chinese translation for
docs/zh/docs/tutorial/security/first-steps.md
. PR
## 5530
by
@yuki1sntSnow
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/response-status-code.md
. PR
## 4922
by
@batlopes
.
üîß Add config for Tamil translations. PR
## 5563
by
@tiangolo
.
Internal
‚¨Ü Bump internal dependency mypy from 0.971 to 0.982. PR
## 5541
by
@dependabot[bot]
.
‚¨Ü Bump nwtgck/actions-netlify from 1.2.3 to 1.2.4. PR
## 5507
by
@dependabot[bot]
.
‚¨Ü Bump internal dependency types-ujson from 5.4.0 to 5.5.0. PR
## 5537
by
@dependabot[bot]
.
‚¨Ü Bump dawidd6/action-download-artifact from 2.23.0 to 2.24.0. PR
## 5508
by
@dependabot[bot]
.
‚¨Ü Update internal dependency pytest-cov requirement from <4.0.0,>=2.12.0 to >=2.12.0,<5.0.0. PR
## 5539
by
@dependabot[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 5536
by
@pre-commit-ci[bot]
.
üêõ Fix internal Trio test warnings. PR
## 5547
by
@samuelcolvin
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 5408
by
@pre-commit-ci[bot]
.
‚¨ÜÔ∏è Upgrade Typer to include Rich in scripts for docs. PR
## 5502
by
@tiangolo
.
üêõ Fix calling
mkdocs
for languages as a subprocess to fix/enable MkDocs Material search plugin. PR
## 5501
by
@tiangolo
.
0.85.1
Fixes
üêõ Fix support for strings in OpenAPI status codes:
default
,
1XX
,
2XX
,
3XX
,
4XX
,
5XX
. PR
## 5187
by
@JarroVGIT
.
Docs
üìù Add WayScript x FastAPI Tutorial to External Links section. PR
## 5407
by
@moneeka
.
Internal
üë• Update FastAPI People. PR
## 5447
by
@github-actions[bot]
.
üîß Disable Material for MkDocs search plugin. PR
## 5495
by
@tiangolo
.
üîá Ignore Trio warning in tests for CI. PR
## 5483
by
@samuelcolvin
.
0.85.0
Features
‚¨Ü Upgrade version required of Starlette from
0.19.1
to
0.20.4
. Initial PR
## 4820
by
@Kludex
.
This includes several bug fixes in Starlette.
‚¨ÜÔ∏è Upgrade Uvicorn max version in public extras: all. From
>=0.12.0,<0.18.0
to
>=0.12.0,<0.19.0
. PR
## 5401
by
@tiangolo
.
Internal
‚¨ÜÔ∏è Upgrade dependencies for doc and dev internal extras: Typer, Uvicorn. PR
## 5400
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade test dependencies: Black, HTTPX, databases, types-ujson. PR
## 5399
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade mypy and tweak internal type annotations. PR
## 5398
by
@tiangolo
.
üîß Update test dependencies, upgrade Pytest, move dependencies from dev to test. PR
## 5396
by
@tiangolo
.
0.84.0
Breaking Changes
This version of FastAPI drops support for Python 3.6. üî• Please upgrade to a supported version of Python (3.7 or above), Python 3.6 reached the end-of-life a long time ago. üòÖ‚ò†
üîß Update package metadata, drop support for Python 3.6, move build internals from Flit to Hatch. PR
## 5240
by
@ofek
.
0.83.0
üö® This is probably the last release (or one of the last releases) to support Python 3.6. üî•
Python 3.6 reached the
end-of-life and is no longer supported by Python
since around a year ago.
You hopefully updated to a supported version of Python a while ago. If you haven't, you really should.
Features
‚ú® Add support in
jsonable_encoder
for include and exclude with dataclasses. PR
## 4923
by
@DCsunset
.
Fixes
üêõ Fix
RuntimeError
raised when
HTTPException
has a status code with no content. PR
## 5365
by
@iudeen
.
üêõ Fix empty reponse body when default
status_code
is empty but the a
Response
parameter with
response.status_code
is set. PR
## 5360
by
@tmeckel
.
Docs
üìù Update
SECURITY.md
. PR
## 5377
by
@Kludex
.
Internal
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 5352
by
@pre-commit-ci[bot]
.
0.82.0
üö® This is probably the last release (or one of the last releases) to support Python 3.6. üî•
Python 3.6 reached the
end-of-life and is no longer supported by Python
since around a year ago.
You hopefully updated to a supported version of Python a while ago. If you haven't, you really should.
Features
‚ú® Export
WebSocketState
in
fastapi.websockets
. PR
## 4376
by
@matiuszka
.
‚ú® Support Python internal description on Pydantic model's docstring. PR
## 3032
by
@Kludex
.
‚ú® Update
ORJSONResponse
to support non
str
keys and serializing Numpy arrays. PR
## 3892
by
@baby5
.
Fixes
üêõ Allow exit code for dependencies with
yield
to always execute, by removing capacity limiter for them, to e.g. allow closing DB connections without deadlocks. PR
## 5122
by
@adriangb
.
üêõ Fix FastAPI People GitHub Action: set HTTPX timeout for GraphQL query request. PR
## 5222
by
@iudeen
.
üêõ Make sure a parameter defined as required is kept required in OpenAPI even if defined as optional in another dependency. PR
## 4319
by
@cd17822
.
üêõ Fix support for path parameters in WebSockets. PR
## 3879
by
@davidbrochart
.
Docs
‚úè Update Hypercorn link, now pointing to GitHub. PR
## 5346
by
@baconfield
.
‚úè Tweak wording in
docs/en/docs/advanced/dataclasses.md
. PR
## 3698
by
@pfackeldey
.
üìù Add note about Python 3.10
X | Y
operator in explanation about Response Models. PR
## 5307
by
@MendyLanda
.
üìù Add link to New Relic article: "How to monitor FastAPI application performance using Python agent". PR
## 5260
by
@sjyothi54
.
üìù Update docs for
ORJSONResponse
with details about improving performance. PR
## 2615
by
@falkben
.
üìù Add docs for creating a custom Response class. PR
## 5331
by
@tiangolo
.
üìù Add tip about using alias for form data fields. PR
## 5329
by
@tiangolo
.
Translations
üåê Add Russian translation for
docs/ru/docs/features.md
. PR
## 5315
by
@Xewus
.
üåê Update Chinese translation for
docs/zh/docs/tutorial/request-files.md
. PR
## 4529
by
@ASpathfinder
.
üåê Add Chinese translation for
docs/zh/docs/tutorial/encoder.md
. PR
## 4969
by
@Zssaer
.
üåê Fix MkDocs file line for Portuguese translation of
background-task.md
. PR
## 5242
by
@ComicShrimp
.
Internal
üë• Update FastAPI People. PR
## 5347
by
@github-actions[bot]
.
‚¨Ü Bump dawidd6/action-download-artifact from 2.22.0 to 2.23.0. PR
## 5321
by
@dependabot[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 5318
by
@pre-commit-ci[bot]
.
‚úè Fix a small code highlight line error. PR
## 5256
by
@hjlarry
.
‚ôª Internal small refactor, move
operation_id
parameter position in delete method for consistency with the code. PR
## 4474
by
@hiel
.
üîß Update sponsors, disable ImgWhale. PR
## 5338
by
@tiangolo
.
0.81.0
Features
‚ú® Add ReDoc
<noscript>
warning when JS is disabled. PR
## 5074
by
@evroon
.
‚ú® Add support for
FrozenSet
in parameters (e.g. query). PR
## 2938
by
@juntatalor
.
‚ú® Allow custom middlewares to raise
HTTPException
s and propagate them. PR
## 2036
by
@ghandic
.
‚ú® Preserve
json.JSONDecodeError
information when handling invalid JSON in request body, to support custom exception handlers that use its information. PR
## 4057
by
@UKnowWhoIm
.
Fixes
üêõ Fix
jsonable_encoder
for dataclasses with pydantic-compatible fields. PR
## 3607
by
@himbeles
.
üêõ Fix support for extending
openapi_extras
with parameter lists. PR
## 4267
by
@orilevari
.
Docs
‚úè Fix a simple typo in
docs/en/docs/python-types.md
. PR
## 5193
by
@GlitchingCore
.
‚úè Fix typos in
tests/test_schema_extra_examples.py
. PR
## 5126
by
@supraaxdd
.
‚úè Fix typos in
docs/en/docs/tutorial/path-params-numeric-validations.md
. PR
## 5142
by
@invisibleroads
.
üìù Add step about upgrading pip in the venv to avoid errors when installing dependencies
docs/en/docs/contributing.md
. PR
## 5181
by
@edisnake
.
‚úè Reword and clarify text in tutorial
docs/en/docs/tutorial/body-nested-models.md
. PR
## 5169
by
@papb
.
‚úè Fix minor typo in
docs/en/docs/features.md
. PR
## 5206
by
@OtherBarry
.
‚úè Fix minor typos in
docs/en/docs/async.md
. PR
## 5125
by
@Ksenofanex
.
üìù Add external link to docs: "Fastapi, Docker(Docker compose) and Postgres". PR
## 5033
by
@krishnardt
.
üìù Simplify example for docs for Additional Responses, remove unnecessary
else
. PR
## 4693
by
@adriangb
.
üìù Update docs, compare enums with identity instead of equality. PR
## 4905
by
@MicaelJarniac
.
‚úè Fix typo in
docs/en/docs/python-types.md
. PR
## 4886
by
@MicaelJarniac
.
üé® Fix syntax highlighting in docs for OpenAPI Callbacks. PR
## 4368
by
@xncbf
.
‚úè Reword confusing sentence in docs file
typo-fix-path-params-numeric-validations.md
. PR
## 3219
by
@ccrenfroe
.
üìù Update docs for handling HTTP Basic Auth with
secrets.compare_digest()
to account for non-ASCII characters. PR
## 3536
by
@lewoudar
.
üìù Update docs for testing, fix examples with relative imports. PR
## 5302
by
@tiangolo
.
Translations
üåê Add Russian translation for
docs/ru/docs/index.md
. PR
## 5289
by
@impocode
.
üåê Add Russian translation for
docs/ru/docs/deployment/versions.md
. PR
## 4985
by
@emp7yhead
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/header-params.md
. PR
## 4921
by
@batlopes
.
üåê Update
ko/mkdocs.yml
for a missing link. PR
## 5020
by
@dalinaum
.
Internal
‚¨Ü Bump dawidd6/action-download-artifact from 2.21.1 to 2.22.0. PR
## 5258
by
@dependabot[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 5196
by
@pre-commit-ci[bot]
.
üî• Delete duplicated tests in
tests/test_tutorial/test_sql_databases/test_sql_databases.py
. PR
## 5040
by
@raccoonyy
.
‚ôª Simplify internal RegEx in
fastapi/utils.py
. PR
## 5057
by
@pylounge
.
üîß Fix Type hint of
auto_error
which does not need to be
Optional[bool]
. PR
## 4933
by
@DavidKimDY
.
üîß Update mypy config, use
strict = true
instead of manual configs. PR
## 4605
by
@michaeloliverx
.
‚ôª Change a
dict()
for
{}
in
fastapi/utils.py
. PR
## 3138
by
@ShahriyarR
.
‚ôª Move internal variable for errors in
jsonable_encoder
to put related code closer. PR
## 4560
by
@GuilleQP
.
‚ôª Simplify conditional assignment in
fastapi/dependencies/utils.py
. PR
## 4597
by
@cikay
.
‚¨Ü Upgrade version pin accepted for Flake8, for internal code, to
flake8 >=3.8.3,<6.0.0
. PR
## 4097
by
@jamescurtin
.
üç± Update Jina banner, fix typo. PR
## 5301
by
@tiangolo
.
0.80.0
Breaking Changes - Fixes
üêõ Fix
response_model
not invalidating
None
. PR
## 2725
by
@hukkin
.
If you are using
response_model
with some type that doesn't include
None
but the function is returning
None
, it will now raise an internal server error, because you are returning invalid data that violates the contract in
response_model
. Before this release it would allow breaking that contract returning
None
.
For example, if you have an app like this:
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
price
:
Optional
[
float
]
=
None
owner_ids
:
Optional
[
List
[
int
]]
=
None
app
=
FastAPI
()
@app
.
get
(
"/items/invalidnone"
,
response_model
=
Item
)
def
get_invalid_none
():
return
None
...calling the path
/items/invalidnone
will raise an error, because
None
is not a valid type for the
response_model
declared with
Item
.
You could also be implicitly returning
None
without realizing, for example:
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
price
:
Optional
[
float
]
=
None
owner_ids
:
Optional
[
List
[
int
]]
=
None
app
=
FastAPI
()
@app
.
get
(
"/items/invalidnone"
,
response_model
=
Item
)
def
get_invalid_none
():
if
flag
:
return
{
"name"
:
"foo"
}
## if flag is False, at this point the function will implicitly return None
If you have
path operations
using
response_model
that need to be allowed to return
None
, make it explicit in
response_model
using
Union[Something, None]
:
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
price
:
Optional
[
float
]
=
None
owner_ids
:
Optional
[
List
[
int
]]
=
None
app
=
FastAPI
()
@app
.
get
(
"/items/invalidnone"
,
response_model
=
Union
[
Item
,
None
])
def
get_invalid_none
():
return
None
This way the data will be correctly validated, you won't have an internal server error, and the documentation will also reflect that this
path operation
could return
None
(or
null
in JSON).
Fixes
‚¨Ü Upgrade Swagger UI copy of
oauth2-redirect.html
to include fixes for flavors of authorization code flows in Swagger UI. PR
## 3439
initial PR by
@koonpeng
.
‚ôª Strip empty whitespace from description extracted from docstrings. PR
## 2821
by
@and-semakin
.
üêõ Fix cached dependencies when using a dependency in
Security()
and other places (e.g.
Depends()
) with different OAuth2 scopes. PR
## 2945
by
@laggardkernel
.
üé® Update type annotations for
response_model
, allow things like
Union[str, None]
. PR
## 5294
by
@tiangolo
.
Translations
üåê Fix typos in German translation for
docs/de/docs/features.md
. PR
## 4533
by
@0xflotus
.
üåê Add missing navigator for
encoder.md
in Korean translation. PR
## 5238
by
@joonas-yoon
.
(Empty PR merge by accident)
## 4913
.
0.79.1
Fixes
üêõ Fix
jsonable_encoder
using
include
and
exclude
parameters for non-Pydantic objects. PR
## 2606
by
@xaviml
.
üêõ Fix edge case with repeated aliases names not shown in OpenAPI. PR
## 2351
by
@klaa97
.
üìù Add misc dependency installs to tutorial docs. PR
## 2126
by
@TeoZosa
.
Docs
üìù Add note giving credit for illustrations to
Ketrina Thompson
. PR
## 5284
by
@tiangolo
.
‚úè Fix typo in
python-types.md
. PR
## 5116
by
@Kludex
.
‚úè Fix typo in
docs/en/docs/python-types.md
. PR
## 5007
by
@atiabbz
.
üìù Remove unneeded Django/Flask references from async topic intro. PR
## 5280
by
@carltongibson
.
‚ú® Add illustrations for Concurrent burgers and Parallel burgers. PR
## 5277
by
@tiangolo
. Updated docs at:
Concurrency and Burgers
.
Translations
üåê Add Portuguese translation for
docs/pt/docs/tutorial/query-params.md
. PR
## 4775
by
@batlopes
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/security/first-steps.md
. PR
## 4954
by
@FLAIR7
.
üåê Add translation for
docs/zh/docs/advanced/response-cookies.md
. PR
## 4638
by
@zhangbo2012
.
üåê Add French translation for
docs/fr/docs/deployment/index.md
. PR
## 3689
by
@rjNemo
.
üåê Add Portuguese translation for
tutorial/handling-errors.md
. PR
## 4769
by
@frnsimoes
.
üåê Add French translation for
docs/fr/docs/history-design-future.md
. PR
## 3451
by
@rjNemo
.
üåê Add Russian translation for
docs/ru/docs/tutorial/background-tasks.md
. PR
## 4854
by
@AdmiralDesu
.
üåê Add Chinese translation for
docs/tutorial/security/first-steps.md
. PR
## 3841
by
@jaystone776
.
üåê Add Japanese translation for
docs/ja/docs/advanced/nosql-databases.md
. PR
## 4205
by
@sUeharaE4
.
üåê Add Indonesian translation for
docs/id/docs/tutorial/index.md
. PR
## 4705
by
@bas-baskara
.
üåê Add Persian translation for
docs/fa/docs/index.md
and tweak right-to-left CSS. PR
## 2395
by
@mohsen-mahmoodi
.
Internal
üîß Update Jina sponsorship. PR
## 5283
by
@tiangolo
.
üîß Update Jina sponsorship. PR
## 5272
by
@tiangolo
.
üîß Update sponsors, Striveworks badge. PR
## 5179
by
@tiangolo
.
0.79.0
Fixes - Breaking Changes
üêõ Fix removing body from status codes that do not support it. PR
## 5145
by
@tiangolo
.
Setting
status_code
to
204
,
304
, or any code below
200
(1xx) will remove the body from the response.
This fixes an error in Uvicorn that otherwise would be thrown:
RuntimeError: Response content longer than Content-Length
.
This removes
fastapi.openapi.constants.STATUS_CODES_WITH_NO_BODY
, it is replaced by a function in utils.
Translations
üåê Start of Hebrew translation. PR
## 5050
by
@itay-raveh
.
üîß Add config for Swedish translations notification. PR
## 5147
by
@tiangolo
.
üåê Start of Swedish translation. PR
## 5062
by
@MrRawbin
.
üåê Add Japanese translation for
docs/ja/docs/advanced/index.md
. PR
## 5043
by
@wakabame
.
üåêüáµüá± Add Polish translation for
docs/pl/docs/tutorial/first-steps.md
. PR
## 5024
by
@Valaraucoo
.
Internal
üîß Update translations notification for Hebrew. PR
## 5158
by
@tiangolo
.
üîß Update Dependabot commit message. PR
## 5156
by
@tiangolo
.
‚¨Ü Bump actions/upload-artifact from 2 to 3. PR
## 5148
by
@dependabot[bot]
.
‚¨Ü Bump actions/cache from 2 to 3. PR
## 5149
by
@dependabot[bot]
.
üîß Update sponsors badge configs. PR
## 5155
by
@tiangolo
.
üë• Update FastAPI People. PR
## 5154
by
@tiangolo
.
üîß Update Jina sponsor badges. PR
## 5151
by
@tiangolo
.
‚¨Ü Bump actions/checkout from 2 to 3. PR
## 5133
by
@dependabot[bot]
.
‚¨Ü [pre-commit.ci] pre-commit autoupdate. PR
## 5030
by
@pre-commit-ci[bot]
.
‚¨Ü Bump nwtgck/actions-netlify from 1.1.5 to 1.2.3. PR
## 5132
by
@dependabot[bot]
.
‚¨Ü Bump codecov/codecov-action from 2 to 3. PR
## 5131
by
@dependabot[bot]
.
‚¨Ü Bump dawidd6/action-download-artifact from 2.9.0 to 2.21.1. PR
## 5130
by
@dependabot[bot]
.
‚¨Ü Bump actions/setup-python from 2 to 4. PR
## 5129
by
@dependabot[bot]
.
üë∑ Add Dependabot. PR
## 5128
by
@tiangolo
.
‚ôªÔ∏è Move from
Optional[X]
to
Union[X, None]
for internal utils. PR
## 5124
by
@tiangolo
.
üîß Update sponsors, remove Dropbase, add Doist. PR
## 5096
by
@tiangolo
.
üîß Update sponsors, remove Classiq, add ImgWhale. PR
## 5079
by
@tiangolo
.
0.78.0
Features
‚ú® Add support for omitting
...
as default value when declaring required parameters with:
Path()
Query()
Header()
Cookie()
Body()
Form()
File()
New docs at
Tutorial - Query Parameters and String Validations - Make it required
. PR
## 4906
by
@tiangolo
.
Up to now, declaring a required parameter while adding additional validation or metadata needed using
...
(Ellipsis).
For example:
from
fastapi
import
Cookie
,
FastAPI
,
Header
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
def
main
(
item_id
:
int
=
Path
(
default
=...
,
gt
=
0
),
query
:
str
=
Query
(
default
=...
,
max_length
=
10
),
session
:
str
=
Cookie
(
default
=...
,
min_length
=
3
),
x_trace
:
str
=
Header
(
default
=...
,
title
=
"Tracing header"
),
):
return
{
"message"
:
"Hello World"
}
...all these parameters are required because the default value is
...
(Ellipsis).
But now it's possible and supported to just omit the default value, as would be done with Pydantic fields, and the parameters would still be required.
‚ú® For example, this is now supported:
from
fastapi
import
Cookie
,
FastAPI
,
Header
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
def
main
(
item_id
:
int
=
Path
(
gt
=
0
),
query
:
str
=
Query
(
max_length
=
10
),
session
:
str
=
Cookie
(
min_length
=
3
),
x_trace
:
str
=
Header
(
title
=
"Tracing header"
),
):
return
{
"message"
:
"Hello World"
}
To declare parameters as optional (not required), you can set a default value as always, for example using
None
:
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
,
Header
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
def
main
(
item_id
:
int
=
Path
(
gt
=
0
),
query
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
max_length
=
10
),
session
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
,
min_length
=
3
),
x_trace
:
Union
[
str
,
None
]
=
Header
(
default
=
None
,
title
=
"Tracing header"
),
):
return
{
"message"
:
"Hello World"
}
Docs
üìù Add docs recommending
Union
over
Optional
and migrate source examples. New docs at
Python Types Intro - Using
Union
or
Optional
. PR
## 4908
by
@tiangolo
.
üé® Fix default value as set in tutorial for Path Operations Advanced Configurations. PR
## 4899
by
@tiangolo
.
üìù Add documentation for redefined path operations. PR
## 4864
by
@madkinsz
.
üìù Updates links for Celery documentation. PR
## 4736
by
@sammyzord
.
‚úè Fix example code with sets in tutorial for body nested models. PR
## 3030
by
@hitrust
.
‚úè Fix links to Pydantic docs. PR
## 4670
by
@kinuax
.
üìù Update docs about Swagger UI self-hosting with newer source links. PR
## 4813
by
@Kastakin
.
üìù Add link to external article: Building the Poll App From Django Tutorial With FastAPI And React. PR
## 4778
by
@jbrocher
.
üìù Add OpenAPI warning to "Body - Fields" docs with extra schema extensions. PR
## 4846
by
@ml-evs
.
Translations
üåê Fix code examples in Japanese translation for
docs/ja/docs/tutorial/testing.md
. PR
## 4623
by
@hirotoKirimaru
.
Internal
‚ôª Refactor dict value extraction to minimize key lookups
fastapi/utils.py
. PR
## 3139
by
@ShahriyarR
.
‚úÖ Add tests for required nonable parameters and body fields. PR
## 4907
by
@tiangolo
.
üë∑ Fix installing Material for MkDocs Insiders in CI. PR
## 4897
by
@tiangolo
.
üë∑ Add pre-commit CI instead of custom GitHub Action. PR
## 4896
by
@tiangolo
.
üë∑ Add pre-commit GitHub Action workflow. PR
## 4895
by
@tiangolo
.
üìù Add dark mode auto switch to docs based on OS preference. PR
## 4869
by
@ComicShrimp
.
üî• Remove un-used old pending tests, already covered in other places. PR
## 4891
by
@tiangolo
.
üîß Add Python formatting hooks to pre-commit. PR
## 4890
by
@tiangolo
.
üîß Add pre-commit with first config and first formatting pass. PR
## 4888
by
@tiangolo
.
üë∑ Disable CI installing Material for MkDocs in forks. PR
## 4410
by
@dolfinus
.
0.77.1
Upgrades
‚¨Ü Upgrade Starlette from 0.19.0 to 0.19.1. PR
## 4819
by
@Kludex
.
Docs
üìù Add link to german article: REST-API Programmieren mittels Python und dem FastAPI Modul. PR
## 4624
by
@fschuermeyer
.
üìù Add external link: PyCharm Guide to FastAPI. PR
## 4512
by
@mukulmantosh
.
üìù Add external link to article: Building an API with FastAPI and Supabase and Deploying on Deta. PR
## 4440
by
@aUnicornDev
.
‚úè Fix small typo in
docs/en/docs/tutorial/security/first-steps.md
. PR
## 4515
by
@KikoIlievski
.
Translations
üåê Add Polish translation for
docs/pl/docs/tutorial/index.md
. PR
## 4516
by
@MKaczkow
.
‚úè Fix typo in deployment. PR
## 4629
by
@raisulislam541
.
üåê Add Portuguese translation for
docs/pt/docs/help-fastapi.md
. PR
## 4583
by
@mateusjs
.
Internal
üîß Add notifications in issue for Uzbek translations. PR
## 4884
by
@tiangolo
.
0.77.0
Upgrades
‚¨Ü Upgrade Starlette from 0.18.0 to 0.19.0. PR
## 4488
by
@Kludex
.
When creating an explicit
JSONResponse
the
content
argument is now required.
Docs
üìù Add external link to article: Seamless FastAPI Configuration with ConfZ. PR
## 4414
by
@silvanmelchior
.
üìù Add external link to article: 5 Advanced Features of FastAPI You Should Try. PR
## 4436
by
@kaustubhgupta
.
‚úè Reword to improve legibility of docs about
TestClient
. PR
## 4389
by
@rgilton
.
üìù Add external link to blog post about Kafka, FastAPI, and Ably. PR
## 4044
by
@Ugbot
.
‚úè Fix typo in
docs/en/docs/tutorial/sql-databases.md
. PR
## 4875
by
@wpyoga
.
‚úè Fix typo in
docs/en/docs/async.md
. PR
## 4726
by
@Prezu
.
Translations
üåê Update source example highlights for
docs/zh/docs/tutorial/query-params-str-validations.md
. PR
## 4237
by
@caimaoy
.
üåê Remove translation docs references to aiofiles as it's no longer needed since AnyIO. PR
## 3594
by
@alonme
.
‚úè üåê Fix typo in Portuguese translation for
docs/pt/docs/tutorial/path-params.md
. PR
## 4722
by
@CleoMenezesJr
.
üåê Fix live docs server for translations for some languages. PR
## 4729
by
@wakabame
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/cookie-params.md
. PR
## 4112
by
@lbmendes
.
üåê Fix French translation for
docs/tutorial/body.md
. PR
## 4332
by
@Smlep
.
üåê Add Japanese translation for
docs/ja/docs/advanced/conditional-openapi.md
. PR
## 2631
by
@sh0nk
.
üåê Fix Japanese translation of
docs/ja/docs/tutorial/body.md
. PR
## 3062
by
@a-takahashi223
.
üåê Add Portuguese translation for
docs/pt/docs/tutorial/background-tasks.md
. PR
## 2170
by
@izaguerreiro
.
üåê Add Portuguese translation for
docs/deployment/deta.md
. PR
## 4442
by
@lsglucas
.
üåê Add Russian translation for
docs/async.md
. PR
## 4036
by
@Winand
.
üåê Add Portuguese translation for
docs/tutorial/body.md
. PR
## 3960
by
@leandrodesouzadev
.
üåê Add Portuguese translation of
tutorial/extra-data-types.md
. PR
## 4077
by
@luccasmmg
.
üåê Update German translation for
docs/features.md
. PR
## 3905
by
@jomue
.
0.76.0
Upgrades
‚¨Ü Upgrade Starlette from 0.17.1 to 0.18.0. PR
## 4483
by
@Kludex
.
Internal
üë• Update FastAPI People. PR
## 4847
by
@github-actions[bot]
.
üîß Add Budget Insight sponsor. PR
## 4824
by
@tiangolo
.
üç± Update sponsor, ExoFlare badge. PR
## 4822
by
@tiangolo
.
üîß Update sponsors, enable Dropbase again, update TalkPython link. PR
## 4821
by
@tiangolo
.
0.75.2
This release includes upgrades to third-party packages that handle security issues. Although there's a chance these issues don't affect you in particular, please upgrade as soon as possible.
Fixes
‚úÖ Fix new/recent tests with new fixed
ValidationError
JSON Schema. PR
## 4806
by
@tiangolo
.
üêõ Fix JSON Schema for
ValidationError
at field
loc
. PR
## 3810
by
@dconathan
.
üêõ Fix support for prefix on APIRouter WebSockets. PR
## 2640
by
@Kludex
.
Upgrades
‚¨ÜÔ∏è Update ujson ranges for CVE-2021-45958. PR
## 4804
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade dependencies upper range for extras "all". PR
## 4803
by
@tiangolo
.
‚¨Ü Upgrade Swagger UI - swagger-ui-dist@4. This handles a security issue in Swagger UI itself where it could be possible to inject HTML into Swagger UI. Please upgrade as soon as you can, in particular if you expose your Swagger UI (
/docs
) publicly to non-expert users. PR
## 4347
by
@RAlanWright
.
Internal
üîß Update sponsors, add: ExoFlare, Ines Course; remove: Dropbase, Vim.so, Calmcode; update: Striveworks, TalkPython and TestDriven.io. PR
## 4805
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade Codecov GitHub Action. PR
## 4801
by
@tiangolo
.
0.75.1
Translations
üåê Start Dutch translations. PR
## 4703
by
@tiangolo
.
üåê Start Persian/Farsi translations. PR
## 4243
by
@aminalaee
.
‚úè Reword sentence about handling errors. PR
## 1993
by
@khuhroproeza
.
Internal
üë• Update FastAPI People. PR
## 4752
by
@github-actions[bot]
.
‚ûñ Temporarily remove typer-cli from dependencies and upgrade Black to unblock Pydantic CI. PR
## 4754
by
@tiangolo
.
üîß Add configuration to notify Dutch translations. PR
## 4702
by
@tiangolo
.
üë• Update FastAPI People. PR
## 4699
by
@github-actions[bot]
.
üêõ Fix FastAPI People generation to include missing file in commit. PR
## 4695
by
@tiangolo
.
üîß Update Classiq sponsor links. PR
## 4688
by
@tiangolo
.
üîß Add Classiq sponsor. PR
## 4671
by
@tiangolo
.
üìù Add Jina's QA Bot to the docs to help people that want to ask quick questions. PR
## 4655
by
@tiangolo
based on original PR
## 4626
by
@hanxiao
.
0.75.0
Features
‚ú® Add support for custom
generate_unique_id_function
and docs for generating clients. New docs:
Advanced - Generate Clients
. PR
## 4650
by
@tiangolo
.
0.74.1
Features
‚ú® Include route in scope to allow middleware and other tools to extract its information. PR
## 4603
by
@tiangolo
.
0.74.0
Breaking Changes
‚ú® Update internal
AsyncExitStack
to fix context for dependencies with
yield
. PR
## 4575
by
@tiangolo
.
Dependencies with
yield
can now catch
HTTPException
and custom exceptions. For example:
async
def
get_database
():
with
Session
()
as
session
:
try
:
yield
session
except
HTTPException
:
session
.
rollback
()
raise
finally
:
session
.
close
()
After the dependency with
yield
handles the exception (or not) the exception is raised again. So that any exception handlers can catch it, or ultimately the default internal
ServerErrorMiddleware
.
If you depended on exceptions not being received by dependencies with
yield
, and receiving an exception breaks the code after
yield
, you can use a block with
try
and
finally
:
async
def
do_something
():
try
:
yield
something
finally
:
some_cleanup
()
...that way the
finally
block is run regardless of any exception that might happen.
Features
The same PR
## 4575
from above also fixes the
contextvars
context for the code before and after
yield
. This was the main objective of that PR.
This means that now, if you set a value in a context variable before
yield
, the value would still be available after
yield
(as you would intuitively expect). And it also means that you can reset the context variable with a token afterwards.
For example, this works correctly now:
from
contextvars
import
ContextVar
from
typing
import
Any
,
Dict
,
Optional
legacy_request_state_context_var
:
ContextVar
[
Optional
[
Dict
[
str
,
Any
]]]
=
ContextVar
(
"legacy_request_state_context_var"
,
default
=
None
)
async
def
set_up_request_state_dependency
():
request_state
=
{
"user"
:
"deadpond"
}
contextvar_token
=
legacy_request_state_context_var
.
set
(
request_state
)
yield
request_state
legacy_request_state_context_var
.
reset
(
contextvar_token
)
...before this change it would raise an error when resetting the context variable, because the
contextvars
context was different, because of the way it was implemented.
Note
: You probably don't need
contextvars
, and you should probably avoid using them. But they are powerful and useful in some advanced scenarios, for example, migrating from code that used Flask's
g
semi-global variable.
Technical Details
: If you want to know more of the technical details you can check out the PR description
## 4575
.
Internal
üîß Add Striveworks sponsor. PR
## 4596
by
@tiangolo
.
üíö Only build docs on push when on master to avoid duplicate runs from PRs. PR
## 4564
by
@tiangolo
.
üë• Update FastAPI People. PR
## 4502
by
@github-actions[bot]
.
0.73.0
Features
‚ú® Add support for declaring
UploadFile
parameters without explicit
File()
. PR
## 4469
by
@tiangolo
. New docs:
Request Files - File Parameters with UploadFile
.
‚ú® Add support for tags with Enums. PR
## 4468
by
@tiangolo
. New docs:
Path Operation Configuration - Tags with Enums
.
‚ú® Allow hiding from OpenAPI (and Swagger UI)
Query
,
Cookie
,
Header
, and
Path
parameters. PR
## 3144
by
@astraldawn
. New docs:
Query Parameters and String Validations - Exclude from OpenAPI
.
Docs
üìù Tweak and improve docs for Request Files. PR
## 4470
by
@tiangolo
.
Fixes
üêõ Fix bug preventing to use OpenAPI when using tuples. PR
## 3874
by
@victorbenichoux
.
üêõ Prefer custom encoder over defaults if specified in
jsonable_encoder
. PR
## 2061
by
@viveksunder
.
üíö Duplicate PR to trigger CI. PR
## 4467
by
@tiangolo
.
Internal
üêõ Fix docs dependencies cache, to get the latest Material for MkDocs. PR
## 4466
by
@tiangolo
.
üîß Add sponsor Dropbase. PR
## 4465
by
@tiangolo
.
0.72.0
Features
‚ú® Enable configuring Swagger UI parameters. Original PR
## 2568
by
@jmriebold
. Here are the new docs:
Configuring Swagger UI
.
Docs
üìù Update Python Types docs, add missing 3.6 / 3.9 example. PR
## 4434
by
@tiangolo
.
Translations
üåê Update Chinese translation for
docs/help-fastapi.md
. PR
## 3847
by
@jaystone776
.
üåê Fix Korean translation for
docs/ko/docs/index.md
. PR
## 4195
by
@kty4119
.
üåê Add Polish translation for
docs/pl/docs/index.md
. PR
## 4245
by
@MicroPanda123
.
üåê Add Chinese translation for
docs\tutorial\path-operation-configuration.md
. PR
## 3312
by
@jaystone776
.
Internal
üîß Enable MkDocs Material Insiders'
content.tabs.link
. PR
## 4399
by
@tiangolo
.
0.71.0
Features
‚ú® Add docs and tests for Python 3.9 and Python 3.10. PR
## 3712
by
@tiangolo
.
You can start with
Python Types Intro
, it explains what changes between different Python versions, in Python 3.9 and in Python 3.10.
All the FastAPI docs are updated. Each code example in the docs that could use different syntax in Python 3.9 or Python 3.10 now has all the alternatives in tabs.
‚¨ÜÔ∏è Upgrade Starlette to 0.17.1. PR
## 4145
by
@simondale00
.
Internal
üë• Update FastAPI People. PR
## 4354
by
@github-actions[bot]
.
üîß Add FastAPI Trove Classifier for PyPI as now there's one ü§∑üòÅ. PR
## 4386
by
@tiangolo
.
‚¨Ü Upgrade MkDocs Material and configs. PR
## 4385
by
@tiangolo
.
0.70.1
There's nothing interesting in this particular FastAPI release. It is mainly to enable/unblock the release of the next version of Pydantic that comes packed with features and improvements. ü§©
Fixes
üêõ Fix JSON Schema for dataclasses, supporting the fixes in Pydantic 1.9. PR
## 4272
by
@PrettyWood
.
Translations
üåê Add Korean translation for
docs/tutorial/request-forms-and-files.md
. PR
## 3744
by
@NinaHwang
.
üåê Add Korean translation for
docs/tutorial/request-files.md
. PR
## 3743
by
@NinaHwang
.
üåê Add portuguese translation for
docs/tutorial/query-params-str-validations.md
. PR
## 3965
by
@leandrodesouzadev
.
üåê Add Korean translation for
docs/tutorial/response-status-code.md
. PR
## 3742
by
@NinaHwang
.
üåê Add Korean translation for Tutorial - JSON Compatible Encoder. PR
## 3152
by
@NEONKID
.
üåê Add Korean translation for Tutorial - Path Parameters and Numeric Validations. PR
## 2432
by
@hard-coders
.
üåê Add Korean translation for
docs/ko/docs/deployment/versions.md
. PR
## 4121
by
@DevDae
.
üåê Fix Korean translation for
docs/ko/docs/tutorial/index.md
. PR
## 4193
by
@kimjaeyoonn
.
üîß Add CryptAPI sponsor. PR
## 4264
by
@tiangolo
.
üìù Update
docs/tutorial/dependencies/classes-as-dependencies
: Add type of query parameters in a description of
Classes as dependencies
. PR
## 4015
by
@0417taehyun
.
üåê Add French translation for Tutorial - First steps. PR
## 3455
by
@Smlep
.
üåê Add French translation for
docs/tutorial/path-params.md
. PR
## 3548
by
@Smlep
.
üåê Add French translation for
docs/tutorial/query-params.md
. PR
## 3556
by
@Smlep
.
üåê Add Turkish translation for
docs/python-types.md
. PR
## 3926
by
@BilalAlpaslan
.
Internal
üë• Update FastAPI People. PR
## 4274
by
@github-actions[bot]
.
0.70.0
This release just upgrades Starlette to the latest version,
0.16.0
, which includes several bug fixes and some small breaking changes.
These last
three consecutive releases
are independent so that you can
migrate gradually
:
First to FastAPI
0.68.2
, with no breaking changes, but upgrading all the sub-dependencies.
Next to FastAPI
0.69.0
, which upgrades Starlette to
0.15.0
, with AnyIO support, and a higher chance of having breaking changes in your code.
Finally to FastAPI
0.70.0
, just upgrading Starlette to the latest version
0.16.0
with additional bug fixes.
This way, in case there was a breaking change for your code in one of the releases, you can still benefit from the previous upgrades. ‚ú®
Breaking Changes - Upgrade
‚¨ÜÔ∏è Upgrade Starlette to 0.16.0. PR
## 4016
by
@tiangolo
.
Also upgrades the ranges of optional dependencies:
"jinja2 >=2.11.2,<4.0.0"
"itsdangerous >=1.1.0,<3.0.0"
0.69.0
Breaking Changes - Upgrade
This release adds support for
Trio
. ‚ú®
It upgrades the version of Starlette to
0.15.0
, now based on
AnyIO
, and the internal async components in
FastAPI
are now based on AnyIO as well, making it compatible with both
asyncio
and
Trio
.
You can read the docs about running
FastAPI with Trio using Hypercorn
.
This release also removes
graphene
as an optional dependency for GraphQL. If you need to work with GraphQL, the recommended library now is
Strawberry
. You can read the new
FastAPI with GraphQL docs
.
Features
‚ú® Add support for Trio via AnyIO, upgrading Starlette to
0.15.0
. PR
## 3372
by
@graingert
.
‚ûñ Remove
graphene
as an optional dependency. PR
## 4007
by
@tiangolo
.
Docs
üìù Add docs for using Trio with Hypercorn. PR
## 4014
by
@tiangolo
.
‚úè Fix typos in Deployment Guide. PR
## 3975
by
@ghandic
.
üìù Update docs with pip install calls when using extras with brackets, use quotes for compatibility with Zsh. PR
## 3131
by
@tomwei7
.
üìù Add external link to article: Deploying ML Models as API Using FastAPI and Heroku. PR
## 3904
by
@kaustubhgupta
.
‚úè Fix typo in file paths in
docs/en/docs/contributing.md
. PR
## 3752
by
@NinaHwang
.
‚úè Fix a typo in
docs/en/docs/advanced/path-operation-advanced-configuration.md
and
docs/en/docs/release-notes.md
. PR
## 3750
by
@saintmalik
.
‚úèÔ∏è Add a missing comma in the security tutorial. PR
## 3564
by
@jalvaradosegura
.
‚úè Fix typo in
docs/en/docs/help-fastapi.md
. PR
## 3760
by
@jaystone776
.
‚úè Fix typo about file path in
docs/en/docs/tutorial/bigger-applications.md
. PR
## 3285
by
@HolyDorus
.
‚úè Re-word to clarify test client in
docs/en/docs/tutorial/testing.md
. PR
## 3382
by
@Bharat123rox
.
üìù Fix incorrect highlighted code. PR
## 3325
by
@paxcodes
.
üìù Add external link to article: How-to deploy FastAPI app to Heroku. PR
## 3241
by
@Jarmos-san
.
‚úè Fix typo (mistranslation) in
docs/en/docs/advanced/templates.md
. PR
## 3211
by
@oerpli
.
üìù Remove note about (now supported) feature from Swagger UI in
docs/en/docs/tutorial/request-files.md
. PR
## 2803
by
@gsganden
.
‚úè Fix typo re-word in
docs/tutorial/handling-errors.md
. PR
## 2700
by
@graue70
.
Translations
üåê Initialize Azerbaijani translations. PR
## 3941
by
@madatbay
.
üåê Add Turkish translation for
docs/fastapi-people.md
. PR
## 3848
by
@BilalAlpaslan
.
Internal
üìù Add supported Python versions badge. PR
## 2794
by
@hramezani
.
‚úè Fix link in Japanese docs for
docs/ja/docs/deployment/docker.md
. PR
## 3245
by
@utamori
.
üîß Correct DeprecationWarning config and comment in pytest settings. PR
## 4008
by
@graingert
.
üîß Swap light/dark theme button icon. PR
## 3246
by
@eddsalkield
.
üîß Lint only in Python 3.7 and above. PR
## 4006
by
@tiangolo
.
üîß Add GitHub Action notify-translations config for Azerbaijani. PR
## 3995
by
@tiangolo
.
0.68.2
This release has
no breaking changes
. üéâ
It upgrades the version ranges of sub-dependencies to allow applications using FastAPI to easily upgrade them.
Soon there will be a new FastAPI release upgrading Starlette to take advantage of recent improvements, but as that has a higher chance of having breaking changes, it will be in a separate release.
Features
‚¨ÜIncrease supported version of aiofiles to suppress warnings. PR
## 2899
by
@SnkSynthesis
.
‚ûñ Do not require backports in Python >= 3.7. PR
## 1880
by
@FFY00
.
‚¨Ü Upgrade required Python version to >= 3.6.1, needed by typing.Deque, used by Pydantic. PR
## 2733
by
@hukkin
.
‚¨ÜÔ∏è Bump Uvicorn max range to 0.15.0. PR
## 3345
by
@Kludex
.
Docs
üìù Update GraphQL docs, recommend Strawberry. PR
## 3981
by
@tiangolo
.
üìù Re-write and extend Deployment guide: Concepts, Uvicorn, Gunicorn, Docker, Containers, Kubernetes. PR
## 3974
by
@tiangolo
.
üìù Upgrade HTTPS guide with more explanations and diagrams. PR
## 3950
by
@tiangolo
.
Translations
üåê Add Turkish translation for
docs/features.md
. PR
## 1950
by
@ycd
.
üåê Add Turkish translation for
docs/benchmarks.md
. PR
## 2729
by
@Telomeraz
.
üåê Add Turkish translation for
docs/index.md
. PR
## 1908
by
@ycd
.
üåê Add French translation for
docs/tutorial/body.md
. PR
## 3671
by
@Smlep
.
üåê Add French translation for
deployment/docker.md
. PR
## 3694
by
@rjNemo
.
üåê Add Portuguese translation for
docs/tutorial/path-params.md
. PR
## 3664
by
@FelipeSilva93
.
üåê Add Portuguese translation for
docs/deployment/https.md
. PR
## 3754
by
@lsglucas
.
üåê Add German translation for
docs/features.md
. PR
## 3699
by
@mawassk
.
Internal
‚ú® Update GitHub Action: notify-translations, to avoid a race conditions. PR
## 3989
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade development
autoflake
, supporting multi-line imports. PR
## 3988
by
@tiangolo
.
‚¨ÜÔ∏è Increase dependency ranges for tests and docs: pytest-cov, pytest-asyncio, black, httpx, sqlalchemy, databases, mkdocs-markdownextradata-plugin. PR
## 3987
by
@tiangolo
.
üë• Update FastAPI People. PR
## 3986
by
@github-actions[bot]
.
üíö Fix badges in README and main page. PR
## 3979
by
@ghandic
.
‚¨Ü Upgrade internal testing dependencies: mypy to version 0.910, add newly needed type packages. PR
## 3350
by
@ArcLightSlavik
.
‚ú® Add Deepset Sponsorship. PR
## 3976
by
@tiangolo
.
üé® Tweak CSS styles for shell animations. PR
## 3888
by
@tiangolo
.
üîß Add new Sponsor Calmcode.io. PR
## 3777
by
@tiangolo
.
0.68.1
‚ú® Add support for
read_with_orm_mode
, to support
SQLModel
relationship attributes. PR
## 3757
by
@tiangolo
.
Translations
üåê Add Portuguese translation of
docs/fastapi-people.md
. PR
## 3461
by
@ComicShrimp
.
üåê Add Chinese translation for
docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
. PR
## 3492
by
@jaystone776
.
üîß Add new Translation tracking issues for German and Indonesian. PR
## 3718
by
@tiangolo
.
üåê Add Chinese translation for
docs/tutorial/dependencies/sub-dependencies.md
. PR
## 3491
by
@jaystone776
.
üåê Add Portuguese translation for
docs/advanced/index.md
. PR
## 3460
by
@ComicShrimp
.
üåê Portuguese translation of
docs/async.md
. PR
## 1330
by
@Serrones
.
üåê Add French translation for
docs/async.md
. PR
## 3416
by
@Smlep
.
Internal
‚ú® Add GitHub Action: Notify Translations. PR
## 3715
by
@tiangolo
.
‚ú® Update computation of FastAPI People and sponsors. PR
## 3714
by
@tiangolo
.
‚ú® Enable recent Material for MkDocs Insiders features. PR
## 3710
by
@tiangolo
.
üî• Remove/clean extra imports from examples in docs for features. PR
## 3709
by
@tiangolo
.
‚ûï Update docs library to include sources in Markdown. PR
## 3648
by
@tiangolo
.
‚¨Ü Enable tests for Python 3.9. PR
## 2298
by
@Kludex
.
üë• Update FastAPI People. PR
## 3642
by
@github-actions[bot]
.
0.68.0
Features
‚ú® Add support for extensions and updates to the OpenAPI schema in each
path operation
. New docs:
FastAPI Path Operation Advanced Configuration - OpenAPI Extra
. Initial PR
## 1922
by
@edouardlp
.
‚ú® Add additional OpenAPI metadata parameters to
FastAPI
class, shown on the automatic API docs UI. New docs:
Metadata and Docs URLs
. Initial PR
## 1812
by
@dkreeft
.
‚ú® Add
description
parameter to all the security scheme classes, e.g.
APIKeyQuery(name="key", description="A very cool API key")
. PR
## 1757
by
@hylkepostma
.
‚ú® Update OpenAPI models, supporting recursive models and extensions. PR
## 3628
by
@tiangolo
.
‚ú® Import and re-export data structures from Starlette, used by Request properties, on
fastapi.datastructures
. Initial PR
## 1872
by
@jamescurtin
.
Docs
üìù Update docs about async and response-model with more gender neutral language. PR
## 1869
by
@Edward-Knight
.
Translations
üåê Add Russian translation for
docs/python-types.md
. PR
## 3039
by
@dukkee
.
üåê Add Chinese translation for
docs/tutorial/dependencies/index.md
. PR
## 3489
by
@jaystone776
.
üåê Add Russian translation for
docs/external-links.md
. PR
## 3036
by
@dukkee
.
üåê Add Chinese translation for
docs/tutorial/dependencies/global-dependencies.md
. PR
## 3493
by
@jaystone776
.
üåê Add Portuguese translation for
docs/deployment/versions.md
. PR
## 3618
by
@lsglucas
.
üåê Add Japanese translation for
docs/tutorial/security/oauth2-jwt.md
. PR
## 3526
by
@sattosan
.
Internal
‚úÖ Add the
docs_src
directory to test coverage and update tests. Initial PR
## 1904
by
@Kludex
.
üîß Add new GitHub templates with forms for new issues. PR
## 3612
by
@tiangolo
.
üìù Add official FastAPI Twitter to docs:
@fastapi
. PR
## 3578
by
@tiangolo
.
0.67.0
Features
‚ú® Add support for
dataclasses
in request bodies and
response_model
. New documentation:
Advanced User Guide - Using Dataclasses
. PR
## 3577
by
@tiangolo
.
‚ú® Support
dataclasses
in responses. PR
## 3576
by
@tiangolo
, continuation from initial PR
## 2722
by
@amitlissack
.
Docs
üìù Add external link: How to Create A Fake Certificate Authority And Generate TLS Certs for FastAPI. PR
## 2839
by
@aitoehigie
.
‚úè Fix code highlighted line in:
body-nested-models.md
. PR
## 3463
by
@jaystone776
.
‚úè Fix typo in
body-nested-models.md
. PR
## 3462
by
@jaystone776
.
‚úè Fix typo "might me" -> "might be" in
docs/en/docs/tutorial/schema-extra-example.md
. PR
## 3362
by
@dbrakman
.
üìù Add external link: Building simple E-Commerce with NuxtJS and FastAPI. PR
## 3271
by
@ShahriyarR
.
üìù Add external link: Serve a machine learning model using Sklearn, FastAPI and Docker. PR
## 2974
by
@rodrigo-arenas
.
‚úèÔ∏è Fix typo on docstring in datastructures file. PR
## 2887
by
@Kludex
.
üìù Add External Link: Deploy FastAPI on Ubuntu and Serve using Caddy 2 Web Server. PR
## 3572
by
@tiangolo
.
üìù Add External Link, replaces #1898. PR
## 3571
by
@tiangolo
.
Internal
üé® Improve style for sponsors, add radius border. PR
## 2388
by
@Kludex
.
üë∑ Update GitHub Action latest-changes. PR
## 3574
by
@tiangolo
.
üë∑ Update GitHub Action latest-changes. PR
## 3573
by
@tiangolo
.
üë∑ Rename and clarify CI workflow job names. PR
## 3570
by
@tiangolo
.
üë∑ Update GitHub Action latest-changes, strike 2 ‚öæ. PR
## 3575
by
@tiangolo
.
üîß Sort external links in docs to have the most recent at the top. PR
## 3568
by
@tiangolo
.
0.66.1
Translations
üåê Add basic setup for German translations. PR
## 3522
by
@0x4Dark
.
üåê Add Portuguese translation for
docs/tutorial/security/index.md
. PR
## 3507
by
@oandersonmagalhaes
.
üåê Add Portuguese translation for
docs/deployment/index.md
. PR
## 3337
by
@lsglucas
.
Internal
üîß Configure strict pytest options and update/refactor tests. Upgrade pytest to
>=6.2.4,<7.0.0
and pytest-cov to
>=2.12.0,<3.0.0
. Initial PR
## 2790
by
@graingert
.
‚¨ÜÔ∏è Upgrade python-jose dependency to
>=3.3.0,<4.0.0
for tests. PR
## 3468
by
@tiangolo
.
0.66.0
Features
‚ú® Allow setting the
response_class
to
RedirectResponse
or
FileResponse
and returning the URL from the function. New and updated docs are in the tutorial section
Custom Response - HTML, Stream, File, others
, in
RedirectResponse
and in
FileResponse
. PR
## 3457
by
@tiangolo
.
Fixes
üêõ Fix include/exclude for dicts in
jsonable_encoder
. PR
## 2016
by
@Rubikoid
.
üêõ Support custom OpenAPI / JSON Schema fields in the generated output OpenAPI. PR
## 1429
by
@jmagnusson
.
Translations
üåê Add Spanish translation for
tutorial/query-params.md
. PR
## 2243
by
@mariacamilagl
.
üåê Add Spanish translation for
advanced/response-directly.md
. PR
## 1253
by
@jfunez
.
üåê Add Spanish translation for
advanced/additional-status-codes.md
. PR
## 1252
by
@jfunez
.
üåê Add Spanish translation for
advanced/path-operation-advanced-configuration.md
. PR
## 1251
by
@jfunez
.
0.65.3
Fixes
‚ôª Assume request bodies contain JSON when no Content-Type header is provided. This fixes a breaking change introduced by
0.65.2 with PR #2118
. It should allow upgrading FastAPI applications with clients that send JSON data without a
Content-Type
header. And there's still protection against CSRFs. PR
## 3456
by
@tiangolo
.
Translations
üåê Initialize Indonesian translations. PR
## 3014
by
@pace-noge
.
üåê Add Spanish translation of Tutorial - Path Parameters. PR
## 2219
by
@mariacamilagl
.
üåê Add Spanish translation of Tutorial - First Steps. PR
## 2208
by
@mariacamilagl
.
üåê Portuguese translation of Tutorial - Body - Fields. PR
## 3420
by
@ComicShrimp
.
üåê Add Chinese translation for Tutorial - Request - Forms - and - Files. PR
## 3249
by
@jaystone776
.
üåê Add Chinese translation for Tutorial - Handling - Errors. PR
## 3299
by
@jaystone776
.
üåê Add Chinese translation for Tutorial - Form - Data. PR
## 3248
by
@jaystone776
.
üåê Add Chinese translation for Tutorial - Body - Updates. PR
## 3237
by
@jaystone776
.
üåê Add Chinese translation for FastAPI People. PR
## 3112
by
@hareru
.
üåê Add French translation for Project Generation. PR
## 3197
by
@Smlep
.
üåê Add French translation for Python Types Intro. PR
## 3185
by
@Smlep
.
üåê Add French translation for External Links. PR
## 3103
by
@Smlep
.
üåê Add French translation for Alternatives, Inspiration and Comparisons. PR
## 3020
by
@rjNemo
.
üåê Fix Chinese translation code snippet mismatch in Tutorial - Python Types Intro. PR
## 2573
by
@BoYanZh
.
üåê Add Portuguese translation for Development Contributing. PR
## 1364
by
@Serrones
.
üåê Add Chinese translation for Tutorial - Request - Files. PR
## 3244
by
@jaystone776
.
Internal
üë• Update FastAPI People. PR
## 3450
by
@github-actions[bot]
.
üë• Update FastAPI People. PR
## 3319
by
@github-actions[bot]
.
‚¨Ü Upgrade docs development dependency on
typer-cli
to >=0.0.12 to fix conflicts. PR
## 3429
by
@tiangolo
.
0.65.2
Security fixes
üîí Check Content-Type request header before assuming JSON. Initial PR
## 2118
by
@patrickkwang
.
This change fixes a
CSRF
security vulnerability when using cookies for authentication in path operations with JSON payloads sent by browsers.
In versions lower than
0.65.2
, FastAPI would try to read the request payload as JSON even if the
content-type
header sent was not set to
application/json
or a compatible JSON media type (e.g.
application/geo+json
).
So, a request with a content type of
text/plain
containing JSON data would be accepted and the JSON data would be extracted.
But requests with content type
text/plain
are exempt from
CORS
preflights, for being considered
Simple requests
. So, the browser would execute them right away including cookies, and the text content could be a JSON string that would be parsed and accepted by the FastAPI application.
See
CVE-2021-32677
for more details.
Thanks to
Dima Boger
for the security report! üôáüîí
Internal
üîß Update sponsors badge, course bundle. PR
## 3340
by
@tiangolo
.
üîß Add new gold sponsor Jina üéâ. PR
## 3291
by
@tiangolo
.
üîß Add new banner sponsor badge for FastAPI courses bundle. PR
## 3288
by
@tiangolo
.
üë∑ Upgrade Issue Manager GitHub Action. PR
## 3236
by
@tiangolo
.
0.65.1
Security fixes
üìå Upgrade pydantic pin, to handle security vulnerability
CVE-2021-29510
. PR
## 3213
by
@tiangolo
.
0.65.0
Breaking Changes - Upgrade
‚¨ÜÔ∏è Upgrade Starlette to
0.14.2
, including internal
UJSONResponse
migrated from Starlette. This includes several bug fixes and features from Starlette. PR
## 2335
by
@hanneskuettner
.
Translations
üåê Initialize new language Polish for translations. PR
## 3170
by
@neternefer
.
Internal
üë∑ Add GitHub Action cache to speed up CI installs. PR
## 3204
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade setup-python GitHub Action to v2. PR
## 3203
by
@tiangolo
.
üêõ Fix docs script to generate a new translation language with
overrides
boilerplate. PR
## 3202
by
@tiangolo
.
‚ú® Add new Deta banner badge with new sponsorship tier üôá. PR
## 3194
by
@tiangolo
.
üë• Update FastAPI People. PR
## 3189
by
@github-actions[bot]
.
üîä Update FastAPI People to allow better debugging. PR
## 3188
by
@tiangolo
.
0.64.0
Features
‚ú® Add support for adding multiple
examples
in request bodies and path, query, cookie, and header params. New docs:
Declare Request Example Data
. Initial PR
## 1267
by
@austinorr
.
Fixes
üìå Pin SQLAlchemy range for tests, as it doesn't use SemVer. PR
## 3001
by
@tiangolo
.
üé® Add newly required type annotations for mypy. PR
## 2882
by
@tiangolo
.
üé® Remove internal "type: ignore", now unnecessary. PR
## 2424
by
@AsakuraMizu
.
Docs
üìù Add link to article in Russian "FastAPI: –∑–Ω–∞–∫–æ–º–∏–º—Å—è —Å —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–æ–º". PR
## 2564
by
@trkohler
.
üìù Add external link to blog post "Authenticate Your FastAPI App with Auth0". PR
## 2172
by
@dompatmore
.
üìù Fix broken link to article: Machine learning model serving in Python using FastAPI and Streamlit. PR
## 2557
by
@davidefiocco
.
üìù Add FastAPI Medium Article: Deploy a dockerized FastAPI application to AWS. PR
## 2515
by
@vjanz
.
‚úè Fix typo in Tutorial - Handling Errors. PR
## 2486
by
@johnthagen
.
‚úè Fix typo in Security OAuth2 scopes. PR
## 2407
by
@jugmac00
.
‚úè Fix typo/clarify docs for SQL (Relational) Databases. PR
## 2393
by
@kangni
.
üìù Add external link to "FastAPI for Flask Users". PR
## 2280
by
@amitness
.
Translations
üåê Fix Chinese translation of Tutorial - Query Parameters, remove obsolete content. PR
## 3051
by
@louis70109
.
üåê Add French translation for Tutorial - Background Tasks. PR
## 3098
by
@Smlep
.
üåê Fix Korean translation for docs/ko/docs/index.md. PR
## 3159
by
@SueNaEunYang
.
üåê Add Korean translation for Tutorial - Query Parameters. PR
## 2390
by
@hard-coders
.
üåê Add French translation for FastAPI People. PR
## 2232
by
@JulianMaurin
.
üåê Add Korean translation for Tutorial - Path Parameters. PR
## 2355
by
@hard-coders
.
üåê Add French translation for Features. PR
## 2157
by
@Jefidev
.
üë• Update FastAPI People. PR
## 3031
by
@github-actions[bot]
.
üåê Add Chinese translation for Tutorial - Debugging. PR
## 2737
by
@blt232018
.
üåê Add Chinese translation for Tutorial - Security - OAuth2 with Password (and hashing), Bearer with JWT tokens. PR
## 2642
by
@waynerv
.
üåê Add Korean translation for Tutorial - Header Parameters. PR
## 2589
by
@mode9
.
üåê Add Chinese translation for Tutorial - Metadata and Docs URLs. PR
## 2559
by
@blt232018
.
üåê Add Korean translation for Tutorial - First Steps. PR
## 2323
by
@hard-coders
.
üåê Add Chinese translation for Tutorial - CORS (Cross-Origin Resource Sharing). PR
## 2540
by
@blt232018
.
üåê Add Chinese translation for Tutorial - Middleware. PR
## 2334
by
@lpdswing
.
üåê Add Korean translation for Tutorial - Intro. PR
## 2317
by
@hard-coders
.
üåê Add Chinese translation for Tutorial - Bigger Applications - Multiple Files. PR
## 2453
by
@waynerv
.
üåê Add Chinese translation for Tutorial - Security - Security Intro. PR
## 2443
by
@waynerv
.
üåê Add Chinese translation for Tutorial - Header Parameters. PR
## 2412
by
@maoyibo
.
üåê Add Chinese translation for Tutorial - Extra Data Types. PR
## 2410
by
@maoyibo
.
üåê Add Japanese translation for Deployment - Docker. PR
## 2312
by
@tokusumi
.
üåê Add Japanese translation for Deployment - Versions. PR
## 2310
by
@tokusumi
.
üåê Add Chinese translation for Tutorial - Cookie Parameters. PR
## 2261
by
@alicrazy1947
.
üåê Add Japanese translation for Tutorial - Static files. PR
## 2260
by
@tokusumi
.
üåê Add Japanese translation for Tutorial - Testing. PR
## 2259
by
@tokusumi
.
üåê Add Japanese translation for Tutorial - Debugging. PR
## 2256
by
@tokusumi
.
üåê Add Japanese translation for Tutorial - Middleware. PR
## 2255
by
@tokusumi
.
üåê Add Japanese translation for Concurrency and async / await. PR
## 2058
by
@tokusumi
.
üåê Add Chinese translation for Tutorial - Security - Simple OAuth2 with Password and Bearer. PR
## 2514
by
@waynerv
.
üåê Add Japanese translation for Deployment - Deta. PR
## 2314
by
@tokusumi
.
üåê Add Chinese translation for Tutorial - Security - Get Current User. PR
## 2474
by
@waynerv
.
üåê Add Japanese translation for Deployment - Manually. PR
## 2313
by
@tokusumi
.
üåê Add Japanese translation for Deployment - Intro. PR
## 2309
by
@tokusumi
.
üåê Add Japanese translation for FastAPI People. PR
## 2254
by
@tokusumi
.
üåê Add Japanese translation for Advanced - Path Operation Advanced Configuration. PR
## 2124
by
@Attsun1031
.
üåê Add Japanese translation for External Links. PR
## 2070
by
@tokusumi
.
üåê Add Japanese translation for Tutorial - Body - Updates. PR
## 1956
by
@SwftAlpc
.
üåê Add Japanese translation for Tutorial - Form Data. PR
## 1943
by
@SwftAlpc
.
üåê Add Japanese translation for Tutorial - Cookie Parameters. PR
## 1933
by
@SwftAlpc
.
Internal
üîß Update top banner, point to newsletter. PR
## 3003
by
@tiangolo
.
üîß Disable sponsor WeTransfer. PR
## 3002
by
@tiangolo
.
üë• Update FastAPI People. PR
## 2880
by
@github-actions[bot]
.
üë• Update FastAPI People. PR
## 2739
by
@github-actions[bot]
.
üîß Add new Gold Sponsor Talk Python üéâ. PR
## 2673
by
@tiangolo
.
üîß Add new Gold Sponsor vim.so üéâ. PR
## 2669
by
@tiangolo
.
üîß Add FastAPI user survey banner. PR
## 2623
by
@tiangolo
.
üîß Add new Bronze Sponsor(s) ü•âüéâ. PR
## 2622
by
@tiangolo
.
üìù Update social links: add Discord, fix GitHub. PR
## 2621
by
@tiangolo
.
üîß Update FastAPI People GitHub Sponsors order. PR
## 2620
by
@tiangolo
.
üîß Update InvestSuite sponsor data. PR
## 2608
by
@tiangolo
.
üë• Update FastAPI People. PR
## 2590
by
@github-actions[bot]
.
0.63.0
Features
‚ú® Improve type annotations, add support for mypy --strict, internally and for external packages. PR
## 2547
by
@tiangolo
.
Breaking changes
‚¨ÜÔ∏è Upgrade Uvicorn when installing
fastapi[all]
to the latest version including
uvloop
, the new range is
uvicorn[standard] >=0.12.0,<0.14.0
. PR
## 2548
by
@tiangolo
.
Fixes
üêõ PR
## 2547
(read above) also fixes some false-positive mypy errors with
callbacks
parameters and when using the
OAuth2
class.
Docs
üìù Update Uvicorn installation instructions to use uvicorn[standard] (includes uvloop). PR
## 2543
by
@tiangolo
.
üìù Update title for Deta tutorial. PR
## 2466
by
@tiangolo
.
üë• Update FastAPI People. PR
## 2454
by
@github-actions[bot]
.
Translations
üåê Add docs lang selector widget. PR
## 2542
by
@tiangolo
.
üåê Add Chinese translation for Tutorial - Response Status Code. PR
## 2442
by
@waynerv
.
üåê Start translation of the documentation for the Albanian language. PR
## 2516
by
@vjanz
.
üåê Add Chinese translation for Tutorial - Extra Models. PR
## 2416
by
@waynerv
.
üåê Add Chinese translation for Tutorial - Response Model. PR
## 2414
by
@waynerv
.
üåê Add Chinese translation for Tutorial - Schema Extra Example. PR
## 2411
by
@maoyibo
.
üåê Add Korean translation for Index. PR
## 2192
by
@hard-coders
.
üåê Add Japanese translation for Advanced User Guide - Additional Status Codes. PR
## 2145
by
@Attsun1031
.
Internal
üêõ Fix docs overrides directory for translations. PR
## 2541
by
@tiangolo
.
‚ûñ Remove Typer as a docs building dependency (covered by typer-cli) to fix pip resolver conflicts. PR
## 2539
by
@tiangolo
.
‚ú® Add newsletter: FastAPI and friends. PR
## 2509
by
@tiangolo
.
‚ú® Add new Gold Sponsor: InvestSuite üéâ. PR
## 2508
by
@tiangolo
.
üîß Add issue template configs. PR
## 2476
by
@tiangolo
.
0.62.0
Features
‚ú® Add support for shared/top-level parameters (dependencies, tags, etc). PR
## 2434
by
@tiangolo
.
Up to now, for several options, the only way to apply them to a group of
path operations
was in
include_router
. That works well, but the call to
app.include_router()
or
router.include_router()
is normally done in another file.
That means that, for example, to apply authentication to all the
path operations
in a router it would end up being done in a different file, instead of keeping related logic together.
Setting options in
include_router
still makes sense in some cases, for example, to override or increase configurations from a third party router included in an app. But in a router that is part of a bigger application, it would probably make more sense to add those settings when creating the
APIRouter
.
In
FastAPI
This allows setting the (mostly new) parameters (additionally to the already existing parameters):
default_response_class
: updated to handle defaults in
APIRouter
and
include_router
.
dependencies
: to include ‚ú® top-level dependencies ‚ú® that apply to the whole application. E.g. to add global authentication.
callbacks
: OpenAPI callbacks that apply to all the
path operations
.
deprecated
: to mark all the
path operations
as deprecated. ü§∑
include_in_schema
: to allow excluding all the
path operations
from the OpenAPI schema.
responses
: OpenAPI responses that apply to all the
path operations
.
For example:
from
fastapi
import
FastAPI
,
Depends
async
def
some_dependency
():
return
app
=
FastAPI
(
dependencies
=
[
Depends
(
some_dependency
)])
In
APIRouter
This allows setting the (mostly new) parameters (additionally to the already existing parameters):
default_response_class
: updated to handle defaults in
APIRouter
and
include_router
. For example, it's not needed to set it explicitly when
creating callbacks
.
dependencies
: to include ‚ú® router-level dependencies ‚ú® that apply to all the
path operations
in a router. Up to now, this was only possible with
include_router
.
callbacks
: OpenAPI callbacks that apply to all the
path operations
in this router.
deprecated
: to mark all the
path operations
in a router as deprecated.
include_in_schema
: to allow excluding all the
path operations
in a router from the OpenAPI schema.
responses
: OpenAPI responses that apply to all the
path operations
in a router.
prefix
: to set the path prefix for a router. Up to now, this was only possible when calling
include_router
.
tags
: OpenAPI tags to apply to all the
path operations
in this router.
For example:
from
fastapi
import
APIRouter
,
Depends
async
def
some_dependency
():
return
router
=
APIRouter
(
prefix
=
"/users"
,
dependencies
=
[
Depends
(
some_dependency
)])
In
include_router
Most of these settings are now supported in
APIRouter
, which normally lives closer to the related code, so it is recommended to use
APIRouter
when possible.
But
include_router
is still useful to, for example, adding options (like
dependencies
,
prefix
, and
tags
) when including a third party router, or a generic router that is shared between several projects.
This PR allows setting the (mostly new) parameters (additionally to the already existing parameters):
default_response_class
: updated to handle defaults in
APIRouter
and
FastAPI
.
deprecated
: to mark all the
path operations
in a router as deprecated in OpenAPI.
include_in_schema
: to allow disabling all the
path operations
from showing in the OpenAPI schema.
callbacks
: OpenAPI callbacks that apply to all the
path operations
in this router.
Note: all the previous parameters are still there, so it's still possible to declare
dependencies
in
include_router
.
Breaking Changes
PR
## 2434
includes several improvements that shouldn't affect normal use cases, but could affect in advanced scenarios:
If you are testing the generated OpenAPI (you shouldn't, FastAPI already tests it extensively for you): the order for
tags
in
include_router
and
path operations
was updated for consistency, but it's a simple order change.
If you have advanced custom logic to access each route's
route.response_class
, or the
router.default_response_class
, or the
app.default_response_class
: the default value for
response_class
in
APIRoute
and for
default_response_class
in
APIRouter
and
FastAPI
is now a
DefaultPlaceholder
used internally to handle and solve default values and overrides. The actual response class inside the
DefaultPlaceholder
is available at
route.response_class.value
.
Docs
PR
## 2434
(above) includes new or updated docs:
Advanced User Guide - OpenAPI Callbacks
.
Tutorial - Bigger Applications
.
Tutorial - Dependencies - Dependencies in path operation decorators
.
Tutorial - Dependencies - Global Dependencies
.
üìù Add FastAPI monitoring blog post to External Links. PR
## 2324
by
@louisguitton
.
‚úèÔ∏è Fix typo in Deta tutorial. PR
## 2320
by
@tiangolo
.
‚ú® Add Discord chat. PR
## 2322
by
@tiangolo
.
üìù Fix image links for sponsors. PR
## 2304
by
@tiangolo
.
Translations
üåê Add Japanese translation for Advanced - Custom Response. PR
## 2193
by
@Attsun1031
.
üåê Add Chinese translation for Benchmarks. PR
## 2119
by
@spaceack
.
üåê Add Chinese translation for Tutorial - Body - Nested Models. PR
## 1609
by
@waynerv
.
üåê Add Chinese translation for Advanced - Custom Response. PR
## 1459
by
@RunningIkkyu
.
üåê Add Chinese translation for Advanced - Return a Response Directly. PR
## 1452
by
@RunningIkkyu
.
üåê Add Chinese translation for Advanced - Additional Status Codes. PR
## 1451
by
@RunningIkkyu
.
üåê Add Chinese translation for Advanced - Path Operation Advanced Configuration. PR
## 1447
by
@RunningIkkyu
.
üåê Add Chinese translation for Advanced User Guide - Intro. PR
## 1445
by
@RunningIkkyu
.
Internal
üîß Update TestDriven link to course in sponsors section. PR
## 2435
by
@tiangolo
.
üç± Update sponsor logos. PR
## 2418
by
@tiangolo
.
üíö Fix disabling install of Material for MkDocs Insiders in forks, strike 1 ‚öæ. PR
## 2340
by
@tiangolo
.
üêõ Fix disabling Material for MkDocs Insiders install in forks. PR
## 2339
by
@tiangolo
.
‚ú® Add silver sponsor WeTransfer. PR
## 2338
by
@tiangolo
.
‚ú® Set up and enable Material for MkDocs Insiders for the docs. PR
## 2325
by
@tiangolo
.
0.61.2
Fixes
üìå Relax Swagger UI version pin. PR
## 2089
by
@jmriebold
.
üêõ Fix bug overriding custom HTTPException and RequestValidationError from exception_handlers. PR
## 1924
by
@uriyyo
.
‚úèÔ∏è Fix typo on dependencies utils and cleanup unused variable. PR
## 1912
by
@Kludex
.
Docs
‚úèÔ∏è Fix typo in Tutorial - Path Parameters. PR
## 2231
by
@mariacamilagl
.
‚úè Fix a stylistic error in docs. PR
## 2206
by
@ddobrinskiy
.
‚úè Fix capitalizaiton typo in docs. PR
## 2204
by
@imba-tjd
.
‚úè Fix typo in docs. PR
## 2179
by
@ammarasmro
.
üìù Update/fix links in docs to use HTTPS. PR
## 2165
by
@imba-tjd
.
‚úè Fix typos and add rewording in docs. PR
## 2159
by
@nukopy
.
üìù Fix code consistency in examples for Tutorial - User Guide - Path Parameters. PR
## 2158
by
@nukopy
.
üìù Fix renamed parameter
content_type
typo. PR
## 2135
by
@TeoZosa
.
‚úè Fix minor typos in docs. PR
## 2122
by
@TeoZosa
.
‚úè Fix typos in docs and source examples. PR
## 2102
by
@AdrianDeAnda
.
‚úè Fix incorrect Celery URLs in docs. PR
## 2100
by
@CircleOnCircles
.
üìù Simplify intro to Python Types, all currently supported Python versions include type hints üéâ. PR
## 2085
by
@ninjaaron
.
üìù Fix example code with sets in Tutorial - Body - Nested Models 3. PR
## 2054
by
@hitrust
.
üìù Fix example code with sets in Tutorial - Body - Nested Models 2. PR
## 2053
by
@hitrust
.
üìù Fix example code with sets in Tutorial - Body - Nested Models. PR
## 2052
by
@hitrust
.
‚úè Fix typo in Benchmarks. PR
## 1995
by
@AlejoAsd
.
üìù Add note in CORS tutorial about allow_origins with ["*"] and allow_credentials. PR
## 1895
by
@dsmurrell
.
üìù Add deployment to Deta, the first gold sponsor üéâ. PR
## 2303
by
@tiangolo
.
üë• Update FastAPI People. PR
## 2282
by
@github-actions[bot]
.
‚úèÔ∏è Fix uppercase in Tutorial - Query parameters. PR
## 2245
by
@mariacamilagl
.
üìù Add articles to External Links. PR
## 2247
by
@tiangolo
.
‚úè Fix typo in Spanish tutorial index. PR
## 2020
by
@aviloncho
.
Translations
üåê Add Japanese translation for Advanced Tutorial - Response Directly. PR
## 2191
by
@Attsun1031
.
üìù Add Japanese translation for Tutorial - Security - First Steps. PR
## 2153
by
@komtaki
.
üåê Add Japanese translation for Tutorial - Query Parameters and String Validations. PR
## 1901
by
@SwftAlpc
.
üåê Add Portuguese translation for External Links. PR
## 1443
by
@Serrones
.
üåê Add Japanese translation for Tutorial - CORS. PR
## 2125
by
@tokusumi
.
üåê Add Japanese translation for Contributing. PR
## 2067
by
@komtaki
.
üåê Add Japanese translation for Project Generation. PR
## 2050
by
@tokusumi
.
üåê Add Japanese translation for Alternatives. PR
## 2043
by
@Attsun1031
.
üåê Add Japanese translation for History Design and Future. PR
## 2002
by
@komtaki
.
üåê Add Japanese translation for Benchmarks. PR
## 1992
by
@komtaki
.
üåê Add Japanese translation for Tutorial - Header Parameters. PR
## 1935
by
@SwftAlpc
.
üåê Add Portuguese translation for Tutorial - First Steps. PR
## 1861
by
@jessicapaz
.
üåê Add Portuguese translation for Python Types. PR
## 1796
by
@izaguerreiro
.
üåê Add Japanese translation for Help FastAPI. PR
## 1692
by
@tokusumi
.
üåê Add Japanese translation for Tutorial - Body. PR
## 1683
by
@tokusumi
.
üåê Add Japanese translation for Tutorial - Query Params. PR
## 1674
by
@tokusumi
.
üåê Add Japanese translation for tutorial/path-params.md. PR
## 1671
by
@tokusumi
.
üåê Add Japanese translation for tutorial/first-steps.md. PR
## 1658
by
@tokusumi
.
üåê Add Japanese translation for tutorial/index.md. PR
## 1656
by
@tokusumi
.
üåê Add translation to Portuguese for Project Generation. PR
## 1602
by
@Serrones
.
üåê Add Japanese translation for Features. PR
## 1625
by
@tokusumi
.
üåê Initialize new language Korean for translations. PR
## 2018
by
@hard-coders
.
üåê Add Portuguese translation of Deployment. PR
## 1374
by
@Serrones
.
Internal
üî• Cleanup after upgrade for Docs Previews GitHub Action. PR
## 2248
by
@tiangolo
.
üêõ Fix CI docs preview, unzip docs. PR
## 2246
by
@tiangolo
.
‚ú® Add instant docs deploy previews for PRs from forks. PR
## 2244
by
@tiangolo
.
‚ö°Ô∏è Build docs for languages in parallel in subprocesses to speed up CI. PR
## 2242
by
@tiangolo
.
üêõ Fix docs order generation for partial translations. PR
## 2238
by
@tiangolo
.
üë• Update FastAPI People. PR
## 2202
by
@github-actions[bot]
.
‚ôªÔ∏è Update FastAPI People GitHub Action to send the PR as github-actions. PR
## 2201
by
@tiangolo
.
üîß Update FastAPI People GitHub Action config, run monthly. PR
## 2199
by
@tiangolo
.
üêõ Fix FastAPI People GitHub Action Docker dependency, strike 1 ‚öæ. PR
## 2198
by
@tiangolo
.
üêõ Fix FastAPI People GitHub Action Docker dependencies. PR
## 2197
by
@tiangolo
.
üêõ Fix FastAPI People GitHub Action when there's nothing to change. PR
## 2196
by
@tiangolo
.
üë• Add new section FastAPI People. PR
## 2195
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade GitHub Action Latest Changes. PR
## 2190
by
@tiangolo
.
‚¨ÜÔ∏è Upgrade GitHub Action Label Approved. PR
## 2189
by
@tiangolo
.
üîß Update GitHub Action Label Approved, run at 12:00. PR
## 2185
by
@tiangolo
.
üë∑ Upgrade GitHub Action Latest Changes. PR
## 2184
by
@tiangolo
.
üë∑ Set GitHub Action Label Approved to run daily, not every minute. PR
## 2163
by
@tiangolo
.
üî• Remove pr-approvals GitHub Action as it's not compatible with forks. Use the new one. PR
## 2162
by
@tiangolo
.
üë∑ Add GitHub Action Latest Changes. PR
## 2160
.
üë∑ Add GitHub Action Label Approved. PR
## 2161
.
0.61.1
Fixes
Fix issues using
jsonable_encoder
with SQLAlchemy models directly. PR
## 1987
.
Docs
Fix typo in NoSQL docs. PR
## 1980
by
@facundojmaero
.
Translations
Add translation for
main page to Japanese
PR
## 1571
by
@ryuckel
.
Initialize French translations. PR
## 1975
by
@JulianMaurin-BM
.
Initialize Turkish translations. PR
## 1905
by
@ycd
.
Internal
Improve docs maintainability by updating
hl_lines
syntax to use ranges. PR
## 1863
by
@la-mar
.
0.61.0
Features
Add support for injecting
HTTPConnection
(as
Request
and
WebSocket
). Useful for sharing app state in dependencies. PR
## 1827
by
@nsidnev
.
Export
WebSocketDisconnect
and add example handling WebSocket disconnections to docs. PR
## 1822
by
@rkbeatss
.
Breaking Changes
Require Pydantic >
1.0.0
.
Remove support for deprecated Pydantic
0.32.2
. This improves maintainability and allows new features.
In
FastAPI
and
APIRouter
:
Remove
path operation decorators
related/deprecated parameter
response_model_skip_defaults
(use
response_model_exclude_unset
instead).
Change
path operation decorators
parameter default for
response_model_exclude
from
set()
to
None
(as is in Pydantic).
In
encoders.jsonable_encoder
:
Remove deprecated
skip_defaults
, use instead
exclude_unset
.
Set default of
exclude
from
set()
to
None
(as is in Pydantic).
PR
## 1862
.
In
encoders.jsonable_encoder
remove parameter
sqlalchemy_safe
.
It was an early hack to allow returning SQLAlchemy models, but it was never documented, and the recommended way is using Pydantic's
orm_mode
as described in the tutorial:
SQL (Relational) Databases
.
PR
## 1864
.
Docs
Add link to the course by TestDriven.io:
Test-Driven Development with FastAPI and Docker
. PR
## 1860
.
Fix empty log message in docs example about handling errors. PR
## 1815
by
@manlix
.
Reword text to reduce ambiguity while not being gender-specific. PR
## 1824
by
@Mause
.
Internal
Add Flake8 linting. Original PR
## 1774
by
@MashhadiNima
.
Disable Gitter bot, as it's currently broken, and Gitter's response doesn't show the problem. PR
## 1853
.
0.60.2
Fix typo in docs for query parameters. PR
## 1832
by
@ycd
.
Add docs about
Async Tests
. PR
## 1619
by
@empicano
.
Raise an exception when using form data (
Form
,
File
) without having
python-multipart
installed.
Up to now the application would run, and raise an exception only when receiving a request with form data, the new behavior, raising early, will prevent from deploying applications with broken dependencies.
It also detects if the correct package
python-multipart
is installed instead of the incorrect
multipart
(both importable as
multipart
).
PR
## 1851
based on original PR
## 1627
by
@chrisngyn
,
@YKo20010
,
@kx-chen
.
Re-enable Gitter releases bot. PR
## 1831
.
Add link to async SQL databases tutorial from main SQL tutorial. PR
## 1813
by
@short2strings
.
Fix typo in tutorial about behind a proxy. PR
## 1807
by
@toidi
.
Fix typo in Portuguese docs. PR
## 1795
by
@izaguerreiro
.
Add translations setup for Ukrainian. PR
## 1830
.
Add external link
Build And Host Fast Data Science Applications Using FastAPI
. PR
## 1786
by
@Kludex
.
Fix encoding of Pydantic models that inherit from others models with custom
json_encoders
. PR
## 1769
by
@henrybetts
.
Simplify and improve
jsonable_encoder
. PR
## 1754
by
@MashhadiNima
.
Simplify internal code syntax in several points. PR
## 1753
by
@uriyyo
.
Improve internal typing, declare
Optional
parameters. PR
## 1731
by
@MashhadiNima
.
Add external link
Deploy FastAPI on Azure App Service
to docs. PR
## 1726
by
@windson
.
Add link to Starlette docs about WebSocket testing. PR
## 1717
by
@hellocoldworld
.
Refactor generating dependant, merge for loops. PR
## 1714
by
@Bloodielie
.
Update example for templates with Jinja to include HTML media type. PR
## 1690
by
@frafra
.
Fix typos in docs for security. PR
## 1678
by
@nilslindemann
.
Fix typos in docs for dependencies. PR
## 1675
by
@nilslindemann
.
Fix type annotation for
**extra
parameters in
FastAPI
. PR
## 1659
by
@bharel
.
Bump MkDocs Material to fix docs in browsers with dark mode. PR
## 1789
by
@adriencaccia
.
Remove docs preview comment from each commit. PR
## 1826
.
Update GitHub context extraction for Gitter notification bot. PR
## 1766
.
0.60.1
Add debugging logs for GitHub actions to introspect GitHub hidden context. PR
## 1764
.
Use OS preference theme for online docs. PR
## 1760
by
@adriencaccia
.
Upgrade Starlette to version
0.13.6
to handle a vulnerability when using static files in Windows. PR
## 1759
by
@jamesag26
.
Pin Swagger UI temporarily, waiting for a fix for
swagger-api/swagger-ui#6249
. PR
## 1763
.
Update GitHub Actions, use commit from PR for docs preview, not commit from pre-merge. PR
## 1761
.
Update GitHub Actions, refactor Gitter bot. PR
## 1746
.
0.60.0
Add GitHub Action to watch for missing preview docs and trigger a preview deploy. PR
## 1740
.
Add custom GitHub Action to get artifact with docs preview. PR
## 1739
.
Add new GitHub Actions to preview docs from PRs. PR
## 1738
.
Add XML test coverage to support GitHub Actions. PR
## 1737
.
Update badges and remove Travis now that GitHub Actions is the main CI. PR
## 1736
.
Add GitHub Actions for CI, move from Travis. PR
## 1735
.
Add support for adding OpenAPI schema for GET requests with a body. PR
## 1626
by
@victorphoenix3
.
0.59.0
Fix typo in docstring for OAuth2 utils. PR
## 1621
by
@tomarv2
.
Update JWT docs to use Python-jose instead of PyJWT. Initial PR
## 1610
by
@asheux
.
Fix/re-enable search bar in docs. PR
## 1703
.
Auto-generate a "server" in OpenAPI
servers
when there's a
root_path
instead of prefixing all the
paths
:
Add a new parameter for
FastAPI
classes:
root_path_in_servers
to disable the auto-generation of
servers
.
New docs about
root_path
and
servers
in
Additional Servers
.
Update OAuth2 examples to use a relative URL for
tokenUrl="token"
to make sure those examples keep working as-is even when behind a reverse proxy.
Initial PR
## 1596
by
@rkbeatss
.
Fix typo/link in External Links. PR
## 1702
.
Update handling of
External Links
to use a data file and allow translating the headers without becoming obsolete quickly when new links are added. PR
## https://github.com/tiangolo/fastapi/pull/1701
.
Add external link
Machine learning model serving in Python using FastAPI and Streamlit
to docs. PR
## 1669
by
@davidefiocco
.
Add note in docs on order in Pydantic Unions. PR
## 1591
by
@kbanc
.
Improve support for tests in editor. PR
## 1699
.
Pin dependencies. PR
## 1697
.
Update isort to version 5.x.x. PR
## 1670
by
@asheux
.
0.58.1
Add link in docs to Pydantic data types. PR
## 1612
by
@tayoogunbiyi
.
Fix link in warning logs for
openapi_prefix
. PR
## 1611
by
@bavaria95
.
Fix bad link in docs. PR
## 1603
by
@molto0504
.
Add Vim temporary files to
.gitignore
for contributors using Vim. PR
## 1590
by
@asheux
.
Fix typo in docs for sub-applications. PR
## 1578
by
@schlpbch
.
Use
Optional
in all the examples in the docs. Original PR
## 1574
by
@chrisngyn
,
@kx-chen
,
@YKo20010
. Updated and merged PR
## 1644
.
Update tests and handling of
response_model_by_alias
. PR
## 1642
.
Add translation to Chinese for
Body - Fields - ËØ∑Ê±Ç‰Ωì - Â≠óÊÆµ
. PR
## 1569
by
@waynerv
.
Update Chinese translation of main page. PR
## 1564
by
@waynerv
.
Add translation to Chinese for
Body - Multiple Parameters - ËØ∑Ê±Ç‰Ωì - Â§ö‰∏™ÂèÇÊï∞
. PR
## 1532
by
@waynerv
.
Add translation to Chinese for
Path Parameters and Numeric Validations - Ë∑ØÂæÑÂèÇÊï∞ÂíåÊï∞ÂÄºÊ†°È™å
. PR
## 1506
by
@waynerv
.
Add GitHub action to auto-label approved PRs (mainly for translations). PR
## 1638
.
0.58.0
Deep merge OpenAPI responses to preserve all the additional metadata. PR
## 1577
.
Mention in docs that only main app events are run (not sub-apps). PR
## 1554
by
@amacfie
.
Fix body validation error response, do not include body variable when it is not embedded. PR
## 1553
by
@amacfie
.
Fix testing OAuth2 security scopes when using dependency overrides. PR
## 1549
by
@amacfie
.
Fix Model for JSON Schema keyword
not
as a JSON Schema instead of a list. PR
## 1548
by
@v-do
.
Add support for OpenAPI
servers
. PR
## 1547
by
@mikaello
.
0.57.0
Remove broken link from "External Links". PR
## 1565
by
@victorphoenix3
.
Update/fix docs for
WebSockets with dependencies
. Original PR
## 1540
by
@ChihSeanHsu
.
Add support for Python's
http.HTTPStatus
in
status_code
parameters. PR
## 1534
by
@retnikt
.
When using Pydantic models with
__root__
, use the internal value in
jsonable_encoder
. PR
## 1524
by
@patrickkwang
.
Update docs for path parameters. PR
## 1521
by
@yankeexe
.
Update docs for first steps, links and rewording. PR
## 1518
by
@yankeexe
.
Enable
showCommonExtensions
in Swagger UI to show additional validations like
maxLength
, etc. PR
## 1466
by
@TiewKH
.
Make
OAuth2PasswordRequestFormStrict
importable directly from
fastapi.security
. PR
## 1462
by
@RichardHoekstra
.
Add docs about
Default response class
. PR
## 1455
by
@TezRomacH
.
Add note in docs about additional parameters
response_model_exclude_defaults
and
response_model_exclude_none
in
Response Model
. PR
## 1427
by
@wshayes
.
Add note about
PyCharm Pydantic plugin
to docs. PR
## 1420
by
@koxudaxi
.
Update and clarify testing function name. PR
## 1395
by
@chenl
.
Fix duplicated headers created by indirect dependencies that use the request directly. PR
## 1386
by
@obataku
from tests by
@scottsmith2gmail
.
Upgrade Starlette version to
0.13.4
. PR
## 1361
by
@rushton
.
Improve error handling and feedback for requests with invalid JSON. PR
## 1354
by
@aviramha
.
Add support for declaring metadata for tags in OpenAPI. New docs at
Tutorial - Metadata and Docs URLs - Metadata for tags
. PR
## 1348
by
@thomas-maschler
.
Add basic setup for Russian translations. PR
## 1566
.
Remove obsolete Chinese articles after adding official community translations. PR
## 1510
by
@waynerv
.
Add
__repr__
for
path operation function
parameter helpers (like
Query
,
Depends
, etc) to simplify debugging. PR
## 1560
by
@rkbeatss
and
@victorphoenix3
.
0.56.1
Add link to advanced docs from tutorial. PR
## 1512
by
@kx-chen
.
Remove internal unnecessary f-strings. PR
## 1526
by
@kotamatsuoka
.
Add translation to Chinese for
Query Parameters and String Validations - Êü•ËØ¢ÂèÇÊï∞ÂíåÂ≠óÁ¨¶‰∏≤Ê†°È™å
. PR
## 1500
by
@waynerv
.
Add translation to Chinese for
Request Body - ËØ∑Ê±Ç‰Ωì
. PR
## 1492
by
@waynerv
.
Add translation to Chinese for
Help FastAPI - Get Help - Â∏ÆÂä© FastAPI - Ëé∑ÂèñÂ∏ÆÂä©
. PR
## 1465
by
@waynerv
.
Add translation to Chinese for
Query Parameters - Êü•ËØ¢ÂèÇÊï∞
. PR
## 1454
by
@waynerv
.
Add translation to Chinese for
Contributing - ÂºÄÂèë - Ë¥°ÁåÆ
. PR
## 1460
by
@waynerv
.
Add translation to Chinese for
Path Parameters - Ë∑ØÂæÑÂèÇÊï∞
. PR
## 1453
by
@waynerv
.
Add official Microsoft project generator for
serving spaCy with FastAPI and Azure Cognitive Skills
to
Project Generators
. PR
## 1390
by
@kabirkhan
.
Update docs in
Python Types Intro
to include info about
Optional
. Original PR
## 1377
by
@yaegassy
.
Fix support for callable class dependencies with
yield
. PR
## 1365
by
@mrosales
.
Fix/remove incorrect error logging when a client sends invalid payloads. PR
## 1351
by
@dbanty
.
Add translation to Chinese for
First Steps - Á¨¨‰∏ÄÊ≠•
. PR
## 1323
by
@waynerv
.
Fix generating OpenAPI for apps using callbacks with routers including Pydantic models. PR
## 1322
by
@nsidnev
.
Optimize internal regex performance in
get_path_param_names()
. PR
## 1243
by
@heckad
.
Remove
*,
from functions in docs where it's not needed. PR
## 1239
by
@pankaj-giri
.
Start translations for Italian. PR
## 1557
by
@csr
.
0.56.0
Add support for ASGI
root_path
:
Use
root_path
internally for mounted applications, so that OpenAPI and the docs UI works automatically without extra configurations and parameters.
Add new
root_path
parameter for
FastAPI
applications to provide it in cases where it can be set with the command line (e.g. for Uvicorn and Hypercorn, with the parameter
--root-path
).
Deprecate
openapi_prefix
parameter in favor of the new
root_path
parameter.
Add new/updated docs for
Sub Applications - Mounts
, without
openapi_prefix
(as it is now handled automatically).
Add new/updated docs for
Behind a Proxy
, including how to setup a local testing proxy with Traefik and using
root_path
.
Update docs for
Extending OpenAPI
with the new
openapi_prefix
parameter passed (internally generated from
root_path
).
Original PR
## 1199
by
@iksteen
.
Update new issue templates and docs:
Help FastAPI - Get Help
. PR
## 1531
.
Update GitHub action issue-manager. PR
## 1520
.
Add new links:
English articles
:
Real-time Notifications with Python and Postgres
by
Guillermo Cruz
.
Microservice in Python using FastAPI
by
Paurakh Sharma Humagain
.
Build simple API service with Python FastAPI ‚Äî Part 1
by
cuongld2
.
FastAPI + Zeit.co = üöÄ
by
Paul Sec
.
Build a web API from scratch with FastAPI - the workshop
by
Sebasti√°n Ram√≠rez (tiangolo)
.
Build a Secure Twilio Webhook with Python and FastAPI
by
Twilio
.
Using FastAPI with Django
by
Stavros Korokithakis
.
Introducing Dispatch
by
Netflix
.
Podcasts
:
Build The Next Generation Of Python Web Applications With FastAPI - Episode 259 - interview to Sebast√≠an Ram√≠rez (tiangolo)
by
Podcast.
__init__
.
Talks
:
PyConBY 2020: Serve ML models easily with FastAPI
by
Sebasti√°n Ram√≠rez (tiangolo)
.
[VIRTUAL] Py.Amsterdam's flying Software Circus: Intro to FastAPI
by
Sebasti√°n Ram√≠rez (tiangolo)
.
PR
## 1467
.
Add translation to Chinese for
Python Types Intro - Python Á±ªÂûãÊèêÁ§∫ÁÆÄ‰ªã
. PR
## 1197
by
@waynerv
.
0.55.1
Fix handling of enums with their own schema in path parameters. To support
pydantic/pydantic#1432
in FastAPI. PR
## 1463
.
0.55.0
Allow enums to allow them to have their own schemas in OpenAPI. To support
pydantic/pydantic#1432
in FastAPI. PR
## 1461
.
Add links for funding through
GitHub sponsors
. PR
## 1425
.
Update issue template for for questions. PR
## 1344
by
@retnikt
.
Update warning about storing passwords in docs. PR
## 1336
by
@skorokithakis
.
Fix typo. PR
## 1326
by
@chenl
.
Add translation to Portuguese for
Alternatives, Inspiration and Comparisons - Alternativas, Inspira√ß√£o e Compara√ß√µes
. PR
## 1325
by
@Serrones
.
Fix 2 typos in docs. PR
## 1324
by
@waynerv
.
Update CORS docs, fix correct default of
max_age=600
. PR
## 1301
by
@derekbekoe
.
Add translation of
main page to Portuguese
. PR
## 1300
by
@Serrones
.
Re-word and clarify docs for extra info in fields. PR
## 1299
by
@chris-allnutt
.
Make sure the
*
in short features in the docs is consistent (after
.
) in all languages. PR
## 1424
.
Update order of execution for
get_db
in SQLAlchemy tutorial. PR
## 1293
by
@bcb
.
Fix typos in Async docs. PR
## 1423
.
0.54.2
Add translation to Spanish for
Concurrency and async / await - Concurrencia y async / await
. PR
## 1290
by
@alvaropernas
.
Remove obsolete vote link. PR
## 1289
by
@donhui
.
Allow disabling docs UIs by just disabling OpenAPI with
openapi_url=None
. New example in docs:
Advanced: Conditional OpenAPI
. PR
## 1421
.
Add translation to Portuguese for
Benchmarks - Compara√ß√µes
. PR
## 1274
by
@Serrones
.
Add translation to Portuguese for
Tutorial - User Guide - Intro - Tutorial - Guia de Usu√°rio - Introdu√ß√£o
. PR
## 1259
by
@marcosmmb
.
Allow using Unicode in MkDocs for translations. PR
## 1419
.
Add translation to Spanish for
Advanced User Guide - Intro - Gu√≠a de Usuario Avanzada - Introducci√≥n
. PR
## 1250
by
@jfunez
.
Add translation to Portuguese for
History, Design and Future - Hist√≥ria, Design e Futuro
. PR
## 1249
by
@marcosmmb
.
Add translation to Portuguese for
Features - Recursos
. PR
## 1248
by
@marcosmmb
.
Add translation to Spanish for
Tutorial - User Guide - Intro - Tutorial - Gu√≠a de Usuario - Introducci√≥n
. PR
## 1244
by
@MartinEliasQ
.
Add translation to Chinese for
Deployment - ÈÉ®ÁΩ≤
. PR
## 1203
by
@RunningIkkyu
.
Add translation to Chinese for
Tutorial - User Guide - Intro - ÊïôÁ®ã - Áî®Êà∑ÊåáÂçó - ÁÆÄ‰ªã
. PR
## 1202
by
@waynerv
.
Add translation to Chinese for
Features - ÁâπÊÄß
. PR
## 1192
by
@Dustyposa
.
Add translation for
main page to Chinese
PR
## 1191
by
@waynerv
.
Update docs for project generation. PR
## 1287
.
Add Spanish translation for
Introducci√≥n a los Tipos de Python (Python Types Intro)
. PR
## 1237
by
@mariacamilagl
.
Add Spanish translation for
Caracter√≠sticas (Features)
. PR
## 1220
by
@mariacamilagl
.
0.54.1
Update database test setup. PR
## 1226
.
Improve test debugging by showing response text in failing tests. PR
## 1222
by
@samuelcolvin
.
0.54.0
Fix grammatical mistakes in async docs. PR
## 1188
by
@mickeypash
.
Add support for
response_model_exclude_defaults
and
response_model_exclude_none
:
Deprecate the parameter
include_none
in
jsonable_encoder
and add the inverted
exclude_none
, to keep in sync with Pydantic.
PR
## 1166
by
@voegtlel
.
Add example about
Testing a Database
. Initial PR
## 1144
by
@duganchen
.
Update docs for
Development - Contributing: Translations
including note about reviewing translation PRs.
## 1215
.
Update log style in README.md for GitHub Markdown compatibility. PR
## 1200
by
## geekgao
.
Add Python venv
env
to
.gitignore
. PR
## 1212
by
@cassiobotaro
.
Start Portuguese translations. PR
## 1210
by
@cassiobotaro
.
Update docs for Pydantic's
Settings
using a dependency with
@lru_cache()
. PR
## 1214
.
Add first translation to Spanish
FastAPI
. PR
## 1201
by
@mariacamilagl
.
Add docs about
Settings and Environment Variables
. Initial PR
1118
by
@alexmitelman
.
0.53.2
Fix automatic embedding of body fields for dependencies and sub-dependencies. Original PR
## 1079
by
@Toad2186
.
Fix dependency overrides in WebSocket testing. PR
## 1122
by
@amitlissack
.
Fix docs script to ensure languages are always sorted. PR
## 1189
.
Start translations for Chinese. PR
## 1187
by
@RunningIkkyu
.
Add docs for
Schema Extra - Example
. PR
## 1185
.
0.53.1
Fix included example after translations refactor. PR
## 1182
.
Add docs example for
example
in
Field
. Docs at
Body - Fields: JSON Schema extras
. PR
## 1106
by
@JohnPaton
.
Fix using recursive models in
response_model
. PR
## 1164
by
@voegtlel
.
Add docs for
Pycharm Debugging
. PR
## 1096
by
@youngquan
.
Fix typo in docs. PR
## 1148
by
@PLNech
.
Update Windows development environment instructions. PR
## 1179
.
0.53.0
Update test coverage badge. PR
## 1175
.
Add
orjson
to
pip install fastapi[all]
. PR
## 1161
by
@michael0liver
.
Fix included example for
GZipMiddleware
. PR
## 1138
by
@arimbr
.
Fix class name in docstring for
OAuth2PasswordRequestFormStrict
. PR
## 1126
by
@adg-mh
.
Clarify function name in example in docs. PR
## 1121
by
@tmsick
.
Add external link
Apache Kafka producer and consumer with FastAPI and aiokafka
to docs. PR
## 1112
by
@iwpnd
.
Fix serialization when using
by_alias
or
exclude_unset
and returning data with Pydantic models. PR
## 1074
by
@juhovh-aiven
.
Add Gitter chat to docs. PR
## 1061
by
@aakashnand
.
Update and simplify translations docs. PR
## 1171
.
Update development of FastAPI docs, set address to
127.0.0.1
to improve Windows support. PR
## 1169
by
@mariacamilagl
.
Add support for docs translations. New docs:
Development - Contributing: Docs: Translations
. PR
## 1168
.
Update terminal styles in docs and add note about
Typer
, the FastAPI of CLIs
. PR
## 1139
.
0.52.0
Add new high-performance JSON response class using
orjson
. New docs:
Custom Response - HTML, Stream, File, others:
ORJSONResponse
. PR
## 1065
.
0.51.0
Re-export utils from Starlette:
This allows using things like
from fastapi.responses import JSONResponse
instead of
from starlette.responses import JSONResponse
.
It's mainly syntax sugar, a convenience for developer experience.
Now
Request
,
Response
,
WebSocket
,
status
can be imported directly from
fastapi
as in
from fastapi import Response
. This is because those are frequently used, to use the request directly, to set headers and cookies, to get status codes, etc.
Documentation changes in many places, but new docs and noticeable improvements:
Custom Response - HTML, Stream, File, others
.
Advanced Middleware
.
Including WSGI - Flask, Django, others
.
PR
## 1064
.
0.50.0
Add link to Release Notes from docs about pinning versions for deployment. PR
## 1058
.
Upgrade code to use the latest version of Starlette, including:
Several bug fixes.
Optional redirects of slashes, with or without ending in
/
.
Events for routers,
"startup"
, and
"shutdown"
.
PR
## 1057
.
Add docs about pinning FastAPI versions for deployment:
Deployment: FastAPI versions
. PR
## 1056
.
0.49.2
Fix links in release notes. PR
## 1052
by
@sattosan
.
Fix typo in release notes. PR
## 1051
by
@sattosan
.
Refactor/clarify
serialize_response
parameter name to avoid confusion. PR
## 1031
by
@patrickmckenna
.
Refactor calling each a path operation's handler function in an isolated function, to simplify profiling. PR
## 1027
by
@sm-Fifteen
.
Add missing dependencies for testing. PR
## 1026
by
@sm-Fifteen
.
Fix accepting valid types for response models, including Python types like
List[int]
. PR
## 1017
by
@patrickmckenna
.
Fix format in SQL tutorial. PR
## 1015
by
@vegarsti
.
0.49.1
Fix path operation duplicated parameters when used in dependencies and the path operation function. PR
## 994
by
@merowinger92
.
Update Netlify previews deployment GitHub action as the fix is already merged and there's a new release. PR
## 1047
.
Move mypy configurations to config file. PR
## 987
by
@hukkinj1
.
Temporary fix to Netlify previews not deployable from PRs from forks. PR
## 1046
by
@mariacamilagl
.
0.49.0
Fix encoding of
pathlib
paths in
jsonable_encoder
. PR
## 978
by
@patrickmckenna
.
Add articles to
External Links
:
Python„ÅÆWeb framework„ÅÆ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊØîËºÉ (Django, Flask, responder, FastAPI, japronto)
and
[FastAPI] PythonË£Ω„ÅÆASGI Web „Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ FastAPI„Å´ÂÖ•ÈñÄ„Åô„Çã
. PR
## 974
by
@tokusumi
.
Fix broken links in docs. PR
## 949
by
@tsotnikov
.
Fix small typos. PR
## 941
by
@NikitaKolesov
.
Update and clarify docs for dependencies with
yield
. PR
## 986
.
Add Mermaid JS support for diagrams in docs. Add first diagrams to
Dependencies: First Steps
and
Dependencies with
yield
and
HTTPException
. PR
## 985
.
Update CI to run docs deployment in GitHub actions. PR
## 983
.
Allow
callable
s in
path operation functions
, like functions modified with
functools.partial
. PR
## 977
.
0.48.0
Run linters first in tests to error out faster. PR
## 948
.
Log warning about
email-validator
only when used. PR
## 946
.
Simplify
Peewee docs
with double dependency with
yield
. PR
## 947
.
Add article
External Links
:
Create and Deploy FastAPI app to Heroku
. PR
## 942
by
@windson
.
Update description of Sanic, as it is now ASGI too. PR
## 932
by
@raphaelauv
.
Fix typo in main page. PR
## 920
by
@mMarzeta
.
Fix parsing of possibly invalid bodies. PR
## 918
by
@dmontagu
.
Fix typo
## 916
by
@adursun
.
Allow
Any
type for enums in OpenAPI. PR
## 906
by
@songzhi
.
Add article to
External Links
:
How to continuously deploy a FastAPI to AWS Lambda with AWS SAM
. PR
## 901
by
@iwpnd
.
Add note about using Body parameters without Pydantic. PR
## 900
by
@pawamoy
.
Fix Pydantic field clone logic. PR
## 899
by
@deuce2367
.
Fix link in middleware docs. PR
## 893
by
@linchiwei123
.
Rename default API title from "Fast API" to "FastAPI" for consistency. PR
## 890
.
0.47.1
Fix model filtering in
response_model
, cloning sub-models. PR
## 889
.
Fix FastAPI serialization of Pydantic models using ORM mode blocking the event loop. PR
## 888
.
0.47.0
Refactor documentation to make a simpler and shorter
Tutorial - User Guide
and an additional
Advanced User Guide
with all the additional docs. PR
## 887
.
Tweak external links, Markdown format, typos. PR
## 881
.
Fix bug in tutorial handling HTTP Basic Auth
username
and
password
. PR
## 865
by
@isaevpd
.
Fix handling form
path operation
parameters declared with pure classes like
list
,
tuple
, etc. PR
## 856
by
@nsidnev
.
Add request
body
to
RequestValidationError
, new docs:
Use the
RequestValidationError
body
. Initial PR
## 853
by
@aviramha
.
Update
External Links
with new links and dynamic GitHub projects with
fastapi
topic. PR
## 850
.
Fix Peewee
contextvars
handling in docs:
SQL (Relational) Databases with Peewee
. PR
## 879
.
Setup development environment with Python's Venv and Flit, instead of requiring the extra Pipenv duplicating dependencies. Updated docs:
Development - Contributing
. PR
## 877
.
Update docs for
HTTP Basic Auth
to improve security against timing attacks. Initial PR
## 807
by
@zwass
.
0.46.0
Fix typos and tweak configs. PR
## 837
.
Add link to Chinese article in
External Links
. PR
810
by
@wxq0309
.
Implement
OAuth2AuthorizationCodeBearer
class. PR
## 797
by
@kuwv
.
Update example upgrade in docs main page. PR
## 795
by
@cdeil
.
Fix callback handling for sub-routers. PR
## 792
by
@jekirl
.
Fix typos. PR
## 784
by
@kkinder
.
Add 4 Japanese articles to
External Links
. PR
## 783
by
@HymanZHAN
.
Add support for subtypes of main types in
jsonable_encoder
, e.g. asyncpg's UUIDs. PR
## 756
by
@RmStorm
.
Fix usage of Pydantic's
HttpUrl
in docs. PR
## 832
by
@Dustyposa
.
Fix Twitter links in docs. PR
## 813
by
@justindujardin
.
Add docs for correctly
using FastAPI with Peewee ORM
. Including how to overwrite parts of Peewee to correctly handle async threads. PR
## 789
.
0.45.0
Add support for OpenAPI Callbacks:
New docs:
OpenAPI Callbacks
.
Refactor generation of
operationId
s to be valid Python names (also valid variables in most languages).
Add
default_response_class
parameter to
APIRouter
.
Original PR
## 722
by
@booooh
.
Refactor logging to use the same logger everywhere, update log strings and levels. PR
## 781
.
Add article to
External Links
:
–ü–æ—á–µ–º—É –í—ã –¥–æ–ª–∂–Ω—ã –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å FastAPI?
. PR
## 766
by
@prostomarkeloff
.
Remove gender bias in docs for handling errors. PR
## 780
. Original idea in PR
## 761
by
@classywhetten
.
Rename docs and references to
body-schema
to
body-fields
to keep in line with Pydantic. PR
## 746
by
@prostomarkeloff
.
0.44.1
Add GitHub social preview images to git. PR
## 752
.
Update PyPI "trove classifiers". PR
## 751
.
Add full support for Python 3.8. Enable Python 3.8 in full in Travis. PR
749
.
Update "new issue" templates. PR
## 749
.
Fix serialization of errors for exotic Pydantic types. PR
## 748
by
@dmontagu
.
0.44.0
Add GitHub action
Issue Manager
. PR
## 742
.
Fix typos in docs. PR
734
by
@bundabrg
.
Fix usage of
custom_encoder
in
jsonable_encoder
. PR
## 715
by
@matrixise
.
Fix invalid XML example. PR
710
by
@OcasoProtal
.
Fix typos and update wording in deployment docs. PR
## 700
by
@marier-nico
.
Add note about dependencies in
APIRouter
docs. PR
## 698
by
@marier-nico
.
Add support for async class methods as dependencies
## 681
by
@frankie567
.
Add FastAPI with Swagger UI cheatsheet to external links. PR
## 671
by
@euri10
.
Fix typo in HTTP protocol in CORS example. PR
## 647
by
@forestmonster
.
Add support for Pydantic versions
1.0.0
and above, with temporary (deprecated) backwards compatibility for Pydantic
0.32.2
. PR
## 646
by
@dmontagu
.
0.43.0
Update docs to reduce gender bias. PR
## 645
by
@ticosax
.
Add docs about
overriding the
operationId
for all the
path operations
based on their function name. PR
## 642
by
@SKalt
.
Fix validators in models generating an incorrect key order. PR
## 637
by
@jaddison
.
Generate correct OpenAPI docs for responses with no content. PR
## 621
by
@brotskydotcom
.
Remove
$
from Bash code blocks in docs for consistency. PR
## 613
by
@nstapelbroek
.
Add docs for
self-serving docs' (Swagger UI) static assets
, e.g. to use the docs offline, or without Internet. Initial PR
## 557
by
@svalouch
.
Fix
black
linting after upgrade. PR
## 682
by
@frankie567
.
0.42.0
Add dependencies with
yield
, a.k.a. exit steps, context managers, cleanup, teardown, ...
This allows adding extra code after a dependency is done. It can be used, for example, to close database connections.
Dependencies with
yield
can be normal or
async
,
FastAPI
will run normal dependencies in a threadpool.
They can be combined with normal dependencies.
It's possible to have arbitrary trees/levels of dependencies with
yield
and exit steps are handled in the correct order automatically.
It works by default in Python 3.7 or above. For Python 3.6, it requires the extra backport dependencies:
async-exit-stack
async-generator
New docs at
Dependencies with
yield
.
Updated database docs
SQL (Relational) Databases: Main
FastAPI
app
.
PR
## 595
.
Fix
sitemap.xml
in website. PR
## 598
by
@samuelcolvin
.
0.41.0
Upgrade required Starlette to
0.12.9
, the new range is
>=0.12.9,<=0.12.9
.
Add
State
to FastAPI apps at
app.state
.
PR
## 593
.
Improve handling of custom classes for
Request
s and
APIRoute
s.
This helps to more easily solve use cases like:
Reading a body before and/or after a request (equivalent to a middleware).
Run middleware-like code only for a subset of
path operations
.
Process a request before passing it to a
path operation function
. E.g. decompressing, deserializing, etc.
Processing a response after being generated by
path operation functions
but before returning it. E.g. adding custom headers, logging, adding extra metadata.
New docs section:
Custom Request and APIRoute class
.
PR
## 589
by
@dmontagu
.
Fix preserving custom route class in routers when including other sub-routers. PR
## 538
by
@dmontagu
.
0.40.0
Add notes to docs about installing
python-multipart
when using forms. PR
## 574
by
@sliptonic
.
Generate OpenAPI schemas in alphabetical order. PR
## 554
by
@dmontagu
.
Add support for truncating docstrings from
path operation functions
.
New docs at
Advanced description from docstring
.
PR
## 556
by
@svalouch
.
Fix
DOCTYPE
in HTML files generated for Swagger UI and ReDoc. PR
## 537
by
@Trim21
.
Fix handling
4XX
responses overriding default
422
validation error responses. PR
## 517
by
@tsouvarev
.
Fix typo in documentation for
Simple HTTP Basic Auth
. PR
## 514
by
@prostomarkeloff
.
Fix incorrect documentation example in
first steps
. PR
## 511
by
@IgnatovFedor
.
Add support for Swagger UI
initOauth
settings with the parameter
swagger_ui_init_oauth
. PR
## 499
by
@zamiramir
.
0.39.0
Allow path parameters to have default values (e.g.
None
) and discard them instead of raising an error.
This allows declaring a parameter like
user_id: str = None
that can be taken from a query parameter, but the same
path operation
can be included in a router with a path
/users/{user_id}
, in which case will be taken from the path and will be required.
PR
## 464
by
@jonathanunderwood
.
Add support for setting a
default_response_class
in the
FastAPI
instance or in
include_router
. Initial PR
## 467
by
@toppk
.
Add support for type annotations using strings and
from __future__ import annotations
. PR
## 451
by
@dmontagu
.
0.38.1
Fix incorrect
Request
class import. PR
## 493
by
@kamalgill
.
0.38.0
Add recent articles to
External Links
and recent opinions. PR
## 490
.
Upgrade support range for Starlette to include
0.12.8
. The new range is
>=0.11.1,<=0.12.8"
. PR
## 477
by
@dmontagu
.
Upgrade support to Pydantic version 0.32.2 and update internal code to use it (breaking change). PR
## 463
by
@dmontagu
.
0.37.0
Add support for custom route classes for advanced use cases. PR
## 468
by
@dmontagu
.
Allow disabling Google fonts in ReDoc. PR
## 481
by
@b1-luettje
.
Fix security issue: when returning a sub-class of a response model and using
skip_defaults
it could leak information. PR
## 485
by
@dmontagu
.
Enable tests for Python 3.8-dev. PR
## 465
by
@Jamim
.
Add support and tests for Pydantic dataclasses in
response_model
. PR
## 454
by
@dconathan
.
Fix typo in OAuth2 JWT tutorial. PR
## 447
by
@pablogamboa
.
Use the
media_type
parameter in
Body()
params to set the media type in OpenAPI for
requestBody
. PR
## 439
by
@divums
.
Add article
Deploying a scikit-learn model with ONNX and FastAPI
by
Nico Axtmann
. PR
## 438
by
@naxty
.
Allow setting custom
422
(validation error) response/schema in OpenAPI.
And use media type from response class instead of fixed
application/json
(the default).
PR
## 437
by
@divums
.
Fix using
"default"
extra response with status codes at the same time. PR
## 489
.
Allow additional responses to use status code ranges (like
5XX
and
4XX
) and
"default"
. PR
## 435
by
@divums
.
0.36.0
Fix implementation for
skip_defaults
when returning a Pydantic model. PR
## 422
by
@dmontagu
.
Fix OpenAPI generation when using the same dependency in multiple places for the same
path operation
. PR
## 417
by
@dmontagu
.
Allow having empty paths in
path operations
used with
include_router
and a
prefix
.
This allows having a router for
/cats
and all its
path operations
, while having one of them for
/cats
.
Now it doesn't have to be only
/cats/
(with a trailing slash).
To use it, declare the path in the
path operation
as the empty string (
""
).
PR
## 415
by
@vitalik
.
Fix mypy error after merging PR #415. PR
## 462
.
0.35.0
Fix typo in routing
assert
. PR
## 419
by
@pablogamboa
.
Fix typo in docs. PR
## 411
by
@bronsen
.
Fix parsing a body type declared with
Union
. PR
## 400
by
@koxudaxi
.
0.34.0
Upgrade Starlette supported range to include the latest
0.12.7
. The new range is
0.11.1,<=0.12.7
. PR
## 367
by
@dedsm
.
Add test for OpenAPI schema with duplicate models from PR
## 333
by
@dmontagu
. PR
## 385
.
0.33.0
Upgrade Pydantic version to
0.30.0
. PR
## 384
by
@jekirl
.
0.32.0
Fix typo in docs for features. PR
## 380
by
@MartinoMensio
.
Fix source code
limit
for example in
Query Parameters
. PR
## 366
by
@Smashman
.
Update wording in docs about
OAuth2 scopes
. PR
## 371
by
@cjw296
.
Update docs for
Enum
s to inherit from
str
and improve Swagger UI rendering. PR
## 351
.
Fix regression, add Swagger UI deep linking again. PR
## 350
.
Add test for having path templates in
prefix
of
.include_router
. PR
## 349
.
Add note to docs:
Include the same router multiple times with different
prefix
. PR
## 348
.
Fix OpenAPI/JSON Schema generation for two functions with the same name (in different modules) with the same composite bodies.
Composite bodies' IDs are now based on path, not only on route name, as the auto-generated name uses the function names, that can be duplicated in different modules.
The same new ID generation applies to response models.
This also changes the generated title for those models.
Only composite bodies and response models are affected because those are generated dynamically, they don't have a module (a Python file).
This also adds the possibility of using
.include_router()
with the same
APIRouter
multiple
times, with different prefixes, e.g.
/api/v2
and
/api/latest
, and it will now work correctly.
PR
## 347
.
0.31.0
Upgrade Pydantic supported version to
0.29.0
.
New supported version range is
"pydantic >=0.28,<=0.29.0"
.
This adds support for Pydantic
Generic Models
, kudos to
@dmontagu
.
PR
## 344
.
0.30.1
Add section in docs about
External Links and Articles
. PR
## 341
.
Remove
Pipfile.lock
from the repository as it is only used by FastAPI contributors (developers of FastAPI itself). See the PR for more details. PR
## 340
.
Update section about
Help FastAPI - Get Help
. PR
## 339
.
Refine internal type declarations to improve/remove Mypy errors in users' code. PR
## 338
.
Update and clarify
SQL tutorial with SQLAlchemy
. PR
## 331
by
@mariacamilagl
.
Add SQLite
online viewers to the docs
. PR
## 330
by
@cyrilbois
.
0.30.0
Add support for Pydantic's ORM mode:
Updated documentation about SQL with SQLAlchemy, using Pydantic models with ORM mode, SQLAlchemy models with relations, separation of files, simplification of code and other changes. New docs:
SQL (Relational) Databases
.
The new support for ORM mode fixes issues/adds features related to ORMs with lazy-loading, hybrid properties, dynamic/getters (using
@property
decorators) and several other use cases.
This applies to ORMs like SQLAlchemy, Peewee, Tortoise ORM, GINO ORM and virtually any other.
If your
path operations
return an arbitrary object with attributes (e.g.
my_item.name
instead of
my_item["name"]
) AND you use a
response_model
, make sure to update the Pydantic models with
orm_mode = True
as described in the docs (link above).
New documentation about receiving plain
dict
s as request bodies:
Bodies of arbitrary
dict
s
.
New documentation about returning arbitrary
dict
s in responses:
Response with arbitrary
dict
.
Technical Details
:
When declaring a
response_model
it is used directly to generate the response content, from whatever was returned from the
path operation function
.
Before this, the return content was first passed through
jsonable_encoder
to ensure it was a "jsonable" object, like a
dict
, instead of an arbitrary object with attributes (like an ORM model). That's why you should make sure to update your Pydantic models for objects with attributes to use
orm_mode = True
.
If you don't have a
response_model
, the return object will still be passed through
jsonable_encoder
first.
When a
response_model
is declared, the same
response_model
type declaration won't be used as is, it will be "cloned" to create an new one (a cloned Pydantic
Field
with all the submodels cloned as well).
This avoids/fixes a potential security issue: as the returned object is passed directly to Pydantic, if the returned object was a subclass of the
response_model
(e.g. you return a
UserInDB
that inherits from
User
but contains extra fields, like
hashed_password
, and
User
is used in the
response_model
), it would still pass the validation (because
UserInDB
is a subclass of
User
) and the object would be returned as-is, including the
hashed_password
. To fix this, the declared
response_model
is cloned, if it is a Pydantic model class (or contains Pydantic model classes in it, e.g. in a
List[Item]
), the Pydantic model class(es) will be a different one (the "cloned" one). So, an object that is a subclass won't simply pass the validation and returned as-is, because it is no longer a sub-class of the cloned
response_model
. Instead, a new Pydantic model object will be created with the contents of the returned object. So, it will be a new object (made with the data from the returned one), and will be filtered by the cloned
response_model
, containing only the declared fields as normally.
PR
## 322
.
Remove/clean unused RegEx code in routing. PR
## 314
by
@dmontagu
.
Use default response status code descriptions for additional responses. PR
## 313
by
@duxiaoyao
.
Upgrade Pydantic support to
0.28
. PR
## 320
by
@jekirl
.
0.29.1
Fix handling an empty-body request with a required body param. PR
## 311
.
Fix broken link in docs:
Return a Response directly
. PR
## 306
by
@dmontagu
.
Fix docs discrepancy in docs for
Response Model
. PR
## 288
by
@awiddersheim
.
0.29.0
Add support for declaring a
Response
parameter:
This allows declaring:
Response Cookies
.
Response Headers
.
An HTTP Status Code different than the default:
Response - Change Status Code
.
All of this while still being able to return arbitrary objects (
dict
, DB model, etc).
Update attribution to Hug, for inspiring the
response
parameter pattern.
PR
## 294
.
0.28.0
Implement dependency cache per request.
This avoids calling each dependency multiple times for the same request.
This is useful while calling external services, performing costly computation, etc.
This also means that if a dependency was declared as a
path operation decorator
dependency, possibly at the router level (with
.include_router()
) and then it is declared again in a specific
path operation
, the dependency will be called only once.
The cache can be disabled per dependency declaration, using
use_cache=False
as in
Depends(your_dependency, use_cache=False)
.
Updated docs at:
Using the same dependency multiple times
.
PR
## 292
.
Implement dependency overrides for testing.
This allows using overrides/mocks of dependencies during tests.
New docs:
Testing Dependencies with Overrides
.
PR
## 291
.
0.27.2
Fix path and query parameters receiving
dict
as a valid type. It should be mapped to a body payload. PR
## 287
. Updated docs at:
Query parameter list / multiple values with defaults: Using
list
.
0.27.1
Fix
auto_error=False
handling in
HTTPBearer
security scheme. Do not
raise
when there's an incorrect
Authorization
header if
auto_error=False
. PR
## 282
.
Fix type declaration of
HTTPException
. PR
## 279
.
0.27.0
Fix broken link in docs about OAuth 2.0 with scopes. PR
## 275
by
@dmontagu
.
Refactor param extraction using Pydantic
Field
:
Large refactor, improvement, and simplification of param extraction from
path operations
.
Fix/add support for list
query parameters
with list defaults. New documentation:
Query parameter list / multiple values with defaults
.
Add support for enumerations in
path operation
parameters. New documentation:
Path Parameters: Predefined values
.
Add support for type annotations using
Optional
as in
param: Optional[str] = None
. New documentation:
Optional type declarations
.
PR
## 278
.
0.26.0
Separate error handling for validation errors.
This will allow developers to customize the exception handlers.
Document better how to handle exceptions and use error handlers.
Include
RequestValidationError
and
WebSocketRequestValidationError
(this last one will be useful once
encode/starlette#527
or equivalent is merged).
New documentation about exceptions handlers:
Install custom exception handlers
.
Override the default exception handlers
.
Reuse
FastAPI's
exception handlers
.
PR
## 273
.
Fix support for
paths
in
path parameters
without needing explicit
Path(...)
.
PR
## 256
.
Documented in PR
## 272
by
@wshayes
.
New documentation at:
Path Parameters containing paths
.
Update docs for testing FastAPI. Include using
POST
, sending JSON, testing headers, etc. New documentation:
Testing
. PR
## 271
.
Fix type declaration of
response_model
to allow generic Python types as
List[Model]
. Mainly to fix
mypy
for users. PR
## 266
.
0.25.0
Add support for Pydantic's
include
,
exclude
,
by_alias
.
Update documentation:
Response Model
.
Add docs for:
Body - updates
, using Pydantic's
skip_defaults
.
Add method consistency tests.
PR
## 264
.
Add
CONTRIBUTING.md
file to GitHub, to help new contributors. PR
## 255
by
@wshayes
.
Add support for Pydantic's
skip_defaults
:
There's a new
path operation decorator
parameter
response_model_skip_defaults
.
The name of the parameter will most probably change in a future version to
response_skip_defaults
,
model_skip_defaults
or something similar.
New
documentation section about using
response_model_skip_defaults
.
PR
## 248
by
@wshayes
.
0.24.0
Add support for WebSockets with dependencies and parameters.
Support included for:
Depends
Security
Cookie
Header
Path
Query
...as these are compatible with the WebSockets protocol (e.g.
Body
is not).
Updated documentation for WebSockets
.
PR
## 178
by
@jekirl
.
Upgrade the compatible version of Pydantic to
0.26.0
.
This includes JSON Schema support for IP address and network objects, bug fixes, and other features.
PR
## 247
by
@euri10
.
0.23.0
Upgrade the compatible version of Starlette to
0.12.0
.
This includes support for ASGI 3 (the latest version of the standard).
It's now possible to use
Starlette's
StreamingResponse
with iterators, like
file-like
objects (as those returned by
open()
).
It's now possible to use the low level utility
iterate_in_threadpool
from
starlette.concurrency
(for advanced scenarios).
PR
## 243
.
Add OAuth2 redirect page for Swagger UI. This allows having delegated authentication in the Swagger UI docs. For this to work, you need to add
{your_origin}/docs/oauth2-redirect
to the allowed callbacks in your OAuth2 provider (in Auth0, Facebook, Google, etc).
For example, during development, it could be
http://localhost:8000/docs/oauth2-redirect
.
Keep in mind that this callback URL is independent of whichever one is used by your frontend. You might also have another callback at
https://yourdomain.com/login/callback
.
This is only to allow delegated authentication in the API docs with Swagger UI.
PR
## 198
by
@steinitzu
.
Make Swagger UI and ReDoc route handlers (
path operations
) be
async
functions instead of lambdas to improve performance. PR
## 241
by
@Trim21
.
Make Swagger UI and ReDoc URLs parameterizable, allowing to host and serve local versions of them and have offline docs. PR
## 112
by
@euri10
.
0.22.0
Add support for
dependencies
parameter:
A parameter in
path operation decorators
, for dependencies that should be executed but the return value is not important or not used in the
path operation function
.
A parameter in the
.include_router()
method of FastAPI applications and routers, to include dependencies that should be executed in each
path operation
in a router.
This is useful, for example, to require authentication or permissions in specific group of
path operations
.
Different
dependencies
can be applied to different routers.
These
dependencies
are run before the normal parameter dependencies. And normal dependencies are run too. They can be combined.
Dependencies declared in a router are executed first, then the ones defined in
path operation decorators
, and then the ones declared in normal parameters. They are all combined and executed.
All this also supports using
Security
with
scopes
in those
dependencies
parameters, for more advanced OAuth 2.0 security scenarios with scopes.
New documentation about
dependencies in
path operation decorators
.
New documentation about
dependencies in the
include_router()
method
.
PR
## 235
.
Fix OpenAPI documentation of Starlette URL convertors. Specially useful when using
path
convertors, to take a whole path as a parameter, like
/some/url/{p:path}
. PR
## 234
by
@euri10
.
Make default parameter utilities exported from
fastapi
be functions instead of classes (the new functions return instances of those classes). To be able to override the return types and fix
mypy
errors in FastAPI's users' code. Applies to
Path
,
Query
,
Header
,
Cookie
,
Body
,
Form
,
File
,
Depends
, and
Security
. PR
## 226
and PR
## 231
.
Separate development scripts
test.sh
,
lint.sh
, and
format.sh
. PR
## 232
.
Re-enable
black
formatting checks for Python 3.7. PR
## 229
by
@zamiramir
.
0.21.0
On body parsing errors, raise
from
previous exception, to allow better introspection in logging code. PR
## 192
by
@ricardomomm
.
Use Python logger named "
fastapi
" instead of root logger. PR
## 222
by
@euri10
.
Upgrade Pydantic to version 0.25. PR
## 225
by
@euri10
.
Fix typo in routing. PR
## 221
by
@djlambert
.
0.20.1
Add typing information to package including file
py.typed
. PR
## 209
by
@meadsteve
.
Add FastAPI bot for Gitter. To automatically announce new releases. PR
## 189
.
0.20.0
Upgrade OAuth2:
Upgrade Password flow using Bearer tokens to use the correct HTTP status code 401
UNAUTHORIZED
, with
WWW-Authenticate
headers.
Update, simplify, and improve all the
security docs
.
Add new
scope_str
to
SecurityScopes
and update docs:
OAuth2 scopes
.
Update docs, images, tests.
PR
## 188
.
Include
Hypercorn
as an alternative ASGI server in the docs. PR
## 187
.
Add docs for
Static Files
and
Templates
. PR
## 186
.
Add docs for handling
Response Cookies
and
Response Headers
. PR
## 185
.
Fix typos in docs. PR
## 176
by
@chdsbd
.
0.19.0
Rename
path operation decorator
parameter
content_type
to
response_class
. PR
## 183
.
Add docs:
How to use the
jsonable_encoder
in
JSON compatible encoder
.
How to
Return a Response directly
.
Update how to use a
Custom Response Class
.
PR
## 184
.
0.18.0
Add docs for
HTTP Basic Auth
. PR
## 177
.
Upgrade HTTP Basic Auth handling with automatic headers (automatic browser login prompt). PR
## 175
.
Update dependencies for security. PR
## 174
.
Add docs for
Middleware
. PR
## 173
.
0.17.0
Make Flit publish from CI. PR
## 170
.
Add documentation about handling
CORS (Cross-Origin Resource Sharing)
. PR
## 169
.
By default, encode by alias. This allows using Pydantic
alias
parameters working by default. PR
## 168
.
0.16.0
Upgrade
path operation
docstring
parsing to support proper Markdown descriptions. New documentation at
Path Operation Configuration
. PR
## 163
.
Refactor internal usage of Pydantic to use correct data types. PR
## 164
.
Upgrade Pydantic to version
0.23
. PR
## 160
by
@euri10
.
Fix typo in Tutorial about Extra Models. PR
## 159
by
@danielmichaels
.
Fix
Query Parameters
URL examples in docs. PR
## 157
by
@hayata-yamamoto
.
0.15.0
Add support for multiple file uploads (as a single form field). New docs at:
Multiple file uploads
. PR
## 158
.
Add docs for:
Additional Status Codes
. PR
## 156
.
0.14.0
Improve automatically generated names of
path operations
in OpenAPI (in API docs). A function
read_items
instead of having a generated name "Read Items Get" will have "Read Items". PR
## 155
.
Add docs for:
Testing
FastAPI
. PR
## 151
.
Update
/docs
Swagger UI to enable deep linking. This allows sharing the URL pointing directly to the
path operation
documentation in the docs. PR
## 148
by
@wshayes
.
Update development dependencies,
Pipfile.lock
. PR
## 150
.
Include Falcon and Hug in:
Alternatives, Inspiration and Comparisons
.
0.13.0
Improve/upgrade OAuth2 scopes support with
SecurityScopes
:
SecurityScopes
can be declared as a parameter like
Request
, to get the scopes of all super-dependencies/dependants.
Improve
Security
handling, merging scopes when declaring
SecurityScopes
.
Allow using
SecurityBase
(like
OAuth2
) classes with
Depends
and still document them.
Security
now is needed only to declare
scopes
.
Updated docs about:
OAuth2 with Password (and hashing), Bearer with JWT tokens
.
New docs about:
OAuth2 scopes
.
PR
## 141
.
0.12.1
Fix bug: handling additional
responses
in
APIRouter.include_router()
. PR
## 140
.
Fix typo in SQL tutorial. PR
## 138
by
@mostaphaRoudsari
.
Fix typos in section about nested models and OAuth2 with JWT. PR
## 127
by
@mmcloud
.
0.12.0
Add additional
responses
parameter to
path operation decorators
to extend responses in OpenAPI (and API docs).
It also allows extending existing responses generated from
response_model
, declare other media types (like images), etc.
The new documentation is here:
Additional Responses
.
responses
can also be added to
.include_router()
, the updated docs are here:
Bigger Applications
.
PR
## 97
originally initiated by
@barsi
.
Update
scripts/test-cov-html.sh
to allow passing extra parameters like
-vv
, for development.
0.11.0
Add
auto_error
parameter to security utility functions. Allowing them to be optional. Also allowing to have multiple alternative security schemes that are then checked in a single dependency instead of each one verifying and returning the error to the client automatically when not satisfied. PR
## 134
.
Update
SQL Tutorial
to close database sessions even when there are exceptions. PR
## 89
by
@alexiri
.
Fix duplicate dependency in
pyproject.toml
. PR
## 128
by
@zxalif
.
0.10.3
Add Gitter chat, badge, links, etc.
https://gitter.im/tiangolo/fastapi
. PR
## 117
.
Add docs about
Extending OpenAPI
. PR
## 126
.
Make Travis run Ubuntu Xenial (newer version) and Python 3.7 instead of Python 3.7-dev. PR
## 92
by
@blueyed
.
Fix duplicated param variable creation. PR
## 123
by
@yihuang
.
Add note in
Response Model docs
about why using a function parameter instead of a function return type annotation. PR
## 109
by
@JHSaunders
.
Fix event docs (startup/shutdown) function name. PR
## 105
by
@stratosgear
.
0.10.2
Fix OpenAPI (JSON Schema) for declarations of Python
Union
(JSON Schema
additionalProperties
). PR
## 121
.
Update
Background Tasks
with a note on Celery.
Document response models using unions and lists, updated at:
Extra Models
. PR
## 108
.
0.10.1
Add docs and tests for
encode/databases
. New docs at:
Async SQL (Relational) Databases
. PR
## 107
.
0.10.0
Add support for Background Tasks in
path operation functions
and dependencies. New documentation about
Background Tasks is here
. PR
## 103
.
Add support for
.websocket_route()
in
APIRouter
. PR
## 100
by
@euri10
.
New docs section about
Events: startup - shutdown
. PR
## 99
.
0.9.1
Document receiving
Multiple values with the same query parameter
and
Duplicate headers
. PR
## 95
.
0.9.0
Upgrade compatible Pydantic version to
0.21.0
. PR
## 90
.
Add documentation for:
Application Configuration
.
Fix typo in docs. PR
## 76
by
@matthewhegarty
.
Fix link in "Deployment" to "Bigger Applications".
0.8.0
Make development scripts executable. PR
## 76
by
@euri10
.
Add support for adding
tags
in
app.include_router()
. PR
## 55
by
@euri10
. Documentation updated in the section:
Bigger Applications
.
Update docs related to Uvicorn to use new
--reload
option from version
0.5.x
. PR
## 74
.
Update
isort
imports and scripts to be compatible with newer versions. PR
## 75
.
0.7.1
Update
technical details about
async def
handling
with respect to previous frameworks. PR
## 64
by
@haizaar
.
Add
deployment documentation for Docker in Raspberry Pi
and other architectures.
Trigger Docker images build on Travis CI automatically. PR
## 65
.
0.7.0
Add support for
UploadFile
in
File
parameter annotations.
This includes a file-like interface.
Here's the updated documentation for declaring
File
parameters with
UploadFile
.
And here's the updated documentation for using
Form
parameters mixed with
File
parameters, supporting
bytes
and
UploadFile
at the same time.
PR
## 63
.
0.6.4
Add
technical details about
async def
handling to docs
. PR
## 61
.
Add docs for
Debugging FastAPI applications in editors
.
Clarify
Bigger Applications deployed with Docker
.
Fix typos in docs.
Add section about
History, Design and Future
.
Add docs for using
WebSockets with
FastAPI
. PR
## 62
.
0.6.3
Add Favicons to docs. PR
## 53
.
0.6.2
Introduce new project generator based on FastAPI and PostgreSQL:
https://github.com/tiangolo/full-stack-fastapi-postgresql
. PR
## 52
.
Update
SQL tutorial with SQLAlchemy, using
Depends
to improve editor support and reduce code repetition
. PR
## 52
.
Improve middleware naming in tutorial for SQL with SQLAlchemy
https://fastapi.tiangolo.com/tutorial/sql-databases/
.
0.6.1
Add docs for GraphQL:
https://fastapi.tiangolo.com/advanced/graphql/
. PR
## 48
.
0.6.0
Update SQL with SQLAlchemy tutorial at
https://fastapi.tiangolo.com/tutorial/sql-databases/
using the new official
request.state
. PR
## 45
.
Upgrade Starlette to version
0.11.1
and add required compatibility changes. PR
## 44
.
0.5.1
Add section about
helping and getting help with
FastAPI
.
Add note about
path operations order in docs
.
Update
section about error handling
with more information and make relation with Starlette error handling utilities more explicit. PR
## 41
.
Add
Development - Contributing section to the docs
. PR
## 42
.
0.5.0
Add new
HTTPException
with support for custom headers. With new documentation for handling errors at:
https://fastapi.tiangolo.com/tutorial/handling-errors/
. PR
## 35
.
Add
documentation to use Starlette
Request
object
directly. Check
## 25
by
@euri10
.
Add issue templates to simplify reporting bugs, getting help, etc:
## 34
.
Update example for the SQLAlchemy tutorial at
https://fastapi.tiangolo.com/tutorial/sql-databases/
using middleware and database session attached to request.
0.4.0
Add
openapi_prefix
, support for reverse proxy and mounting sub-applications. See the docs at
https://fastapi.tiangolo.com/advanced/sub-applications-proxy/
:
## 26
by
@kabirkhan
.
Update
docs/tutorial for SQLAlchemy
including note about
DB Browser for SQLite
.
0.3.0
Fix/add SQLAlchemy support, including ORM, and update
docs for SQLAlchemy
:
## 30
.
0.2.1
Fix
jsonable_encoder
for Pydantic models with
Config
but without
json_encoders
:
## 29
.
0.2.0
Fix typos in Security section:
## 24
by
@kkinder
.
Add support for Pydantic custom JSON encoders:
## 21
by
@euri10
.
0.1.19
Upgrade Starlette version to the current latest
0.10.1
:
## 17
by
@euri10
.

## 106_RU
FastAPI¬∂
---

FastAPI
–ì–æ—Ç–æ–≤—ã–π –∫ –≤–Ω–µ–¥—Ä–µ–Ω–∏—é –≤—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–π —Ñ—Ä–µ–π–º–≤–æ—Ä–∫, –ø—Ä–æ—Å—Ç–æ–π –≤ –∏–∑—É—á–µ–Ω–∏–∏ –∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.
–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
:
https://fastapi.tiangolo.com
–ò—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥
:
https://github.com/fastapi/fastapi
FastAPI ‚Äî —ç—Ç–æ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π, –±—ã—Å—Ç—Ä—ã–π (–≤—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–π) –≤–µ–±-—Ñ—Ä–µ–π–º–≤–æ—Ä–∫ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è API –∏—Å–ø–æ–ª—å–∑—É—è Python, –≤ –æ—Å–Ω–æ–≤–µ –∫–æ—Ç–æ—Ä–æ–≥–æ –ª–µ–∂–∏—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –∞–Ω–Ω–æ—Ç–∞—Ü–∏—è —Ç–∏–ø–æ–≤ Python.
–ö–ª—é—á–µ–≤—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
–°–∫–æ—Ä–æ—Å—Ç—å
: –û—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, –Ω–∞ —É—Ä–æ–≤–Ω–µ
NodeJS
–∏
Go
(–±–ª–∞–≥–æ–¥–∞—Ä—è Starlette –∏ Pydantic).
–û–¥–∏–Ω –∏–∑ —Å–∞–º—ã—Ö –±—ã—Å—Ç—Ä—ã—Ö —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–æ–≤ Python
.
–ë—ã—Å—Ç—Ä–æ—Ç–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
: –£–≤–µ–ª–∏—á—å—Ç–µ —Å–∫–æ—Ä–æ—Å—Ç—å —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–∏–º–µ—Ä–Ω–æ –Ω–∞ 200‚Äì300%. *
–ú–µ–Ω—å—à–µ –æ—à–∏–±–æ–∫
: –°–æ–∫—Ä–∞—Ç–∏—Ç–µ –ø—Ä–∏–º–µ—Ä–Ω–æ –Ω–∞ 40% –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—à–∏–±–æ–∫, –≤—ã–∑–≤–∞–Ω–Ω—ã—Ö —á–µ–ª–æ–≤–µ–∫–æ–º (—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–º). *
–ò–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ –ø–æ–Ω—è—Ç–Ω—ã–π
: –û—Ç–ª–∏—á–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞.
–ê–≤—Ç–æ–∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
–≤–µ–∑–¥–µ. –ú–µ–Ω—å—à–µ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ –æ—Ç–ª–∞–¥–∫—É.
–õ—ë–≥–∫–æ—Å—Ç—å
: –†–∞–∑—Ä–∞–±–æ—Ç–∞–Ω —Ç–∞–∫, —á—Ç–æ–±—ã –µ–≥–æ –±—ã–ª–æ –ª–µ–≥–∫–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –æ—Å–≤–∞–∏–≤–∞—Ç—å. –ú–µ–Ω—å—à–µ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —á—Ç–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏.
–ö—Ä–∞—Ç–∫–æ—Å—Ç—å
: –°–≤–µ–¥–∏—Ç–µ –∫ –º–∏–Ω–∏–º—É–º—É –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞. –ö–∞–∂–¥—ã–π –æ–±—ä—è–≤–ª–µ–Ω–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä - –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ—É–Ω–∫—Ü–∏–π. –ú–µ–Ω—å—à–µ –æ—à–∏–±–æ–∫.
–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å
: –ü–æ–ª—É—á–∏—Ç–µ –≥–æ—Ç–æ–≤—ã–π –∫ —Ä–∞–±–æ—Ç–µ –∫–æ–¥. –° –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π.
–ù–∞ –æ—Å–Ω–æ–≤–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–æ–≤
: –û—Å–Ω–æ–≤–∞–Ω –Ω–∞ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞—Ö API –∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–≤–º–µ—Å—Ç–∏–º —Å –Ω–∏–º–∏:
OpenAPI
(—Ä–∞–Ω–µ–µ –∏–∑–≤–µ—Å—Ç–Ω–æ–º –∫–∞–∫ Swagger) –∏
JSON Schema
.
* –æ—Ü–µ–Ω–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ—Å—Ç–æ–≤ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –∫–æ–º–∞–Ω–¥—ã —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤, —Å–æ–∑–¥–∞—é—â–∏—Ö –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.
–°–ø–æ–Ω—Å–æ—Ä—ã
–î—Ä—É–≥–∏–µ —Å–ø–æ–Ω—Å–æ—Ä—ã
–û—Ç–∑—ã–≤—ã
"
–í –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è —è –º–Ω–æ–≥–æ –≥–¥–µ –∏—Å–ø–æ–ª—å–∑—É—é
FastAPI
. [...] –ù–∞ —Å–∞–º–æ–º –¥–µ–ª–µ —è –ø–ª–∞–Ω–∏—Ä—É—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –¥–ª—è –≤—Å–µ—Ö
—Å–µ—Ä–≤–∏—Å–æ–≤ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è –º–æ–µ–π –∫–æ–º–∞–Ω–¥—ã –≤ Microsoft
. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∏—Ö –∏–Ω—Ç–µ–≥—Ä–∏—Ä—É—é—Ç—Å—è –≤ –æ—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ–¥—É–∫—Ç
Windows
, –∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ ‚Äî –≤ –ø—Ä–æ–¥—É–∫—Ç—ã
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
–ú—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫—É
FastAPI
–¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ—Ä–≤–µ—Ä–∞
REST
, –∫ –∫–æ—Ç–æ—Ä–æ–º—É –º–æ–∂–Ω–æ –¥–µ–ª–∞—Ç—å –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è
–ø—Ä–æ–≥–Ω–æ–∑–æ–≤
. [–¥–ª—è Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
—Ä–∞–¥–∞ –æ–±—ä—è–≤–∏—Ç—å –æ –≤—ã–ø—É—Å–∫–µ –æ–ø–µ–Ω—Å–æ—Ä—Å–Ω–æ–≥–æ —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–∞ –¥–ª—è –æ—Ä–∫–µ—Å—Ç—Ä–æ–≤–∫–∏
–∞–Ω—Ç–∏–∫—Ä–∏–∑–∏—Å–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
:
Dispatch
! [—Å–æ–∑–¥–∞–Ω–∞ —Å –ø–æ–º–æ—â—å—é
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
–Ø –≤ –ø–æ–ª–Ω–æ–º –≤–æ—Å—Ç–æ—Ä–≥–µ –æ—Ç
FastAPI
. –≠—Ç–æ —Ç–∞–∫ –≤–µ—Å–µ–ª–æ!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
–ß–µ—Å—Ç–Ω–æ –≥–æ–≤–æ—Ä—è, —Ç–æ, —á—Ç–æ –≤—ã —Å–æ–∑–¥–∞–ª–∏, –≤—ã–≥–ª—è–¥–∏—Ç –æ—á–µ–Ω—å —Å–æ–ª–∏–¥–Ω–æ –∏ –æ—Ç–ø–æ–ª–∏—Ä–æ–≤–∞–Ω–æ. –í–æ –º–Ω–æ–≥–∏—Ö —Å–º—ã—Å–ª–∞—Ö —è —Ö–æ—Ç–µ–ª, —á—Ç–æ–±—ã
Hug
–±—ã–ª –∏–º–µ–Ω–Ω–æ —Ç–∞–∫–∏–º ‚Äî —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –≤–¥–æ—Ö–Ω–æ–≤–ª—è–µ—Ç, –∫–æ–≥–¥–∞ –∫—Ç–æ-—Ç–æ —Å–æ–∑–¥–∞—ë—Ç —Ç–∞–∫–æ–µ.
"
Timothy Crosley -
Hug
creator
(ref)
"
–ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∏–∑—É—á–∏—Ç—å –∫–∞–∫–æ–π-–Ω–∏–±—É–¥—å
—Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ—Ä–µ–π–º–≤–æ—Ä–∫
–¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è REST API, –æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å
FastAPI
[...] –û–Ω –±—ã—Å—Ç—Ä—ã–π, –ª—ë–≥–∫–∏–π –∏ –ø—Ä–æ—Å—Ç–æ–π –≤ –∏–∑—É—á–µ–Ω–∏–∏ [...]
"
"
–ú—ã –ø–µ—Ä–µ—à–ª–∏ –Ω–∞
FastAPI
–¥–ª—è –Ω–∞—à–∏—Ö
API
[...] –Ø –¥—É–º–∞—é, –≤–∞–º —Ç–æ–∂–µ –ø–æ–Ω—Ä–∞–≤–∏—Ç—Å—è [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ –¥–ª—è FastAPI
–ï—Å–ª–∏ –≤—ã —Å–æ–∑–¥–∞–µ—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
CLI
–¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ –≤–º–µ—Å—Ç–æ –≤–µ–±-API, –æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å
Typer
.
Typer
‚Äî –º–ª–∞–¥—à–∏–π –±—Ä–∞—Ç FastAPI. –ò –æ–Ω –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ
–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ –¥–ª—è FastAPI
. ‚å®Ô∏è üöÄ
–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
FastAPI —Å—Ç–æ–∏—Ç –Ω–∞ –ø–ª–µ—á–∞—Ö –≥–∏–≥–∞–Ω—Ç–æ–≤:
Starlette
–¥–ª—è —á–∞—Å—Ç–∏ —Å–≤—è–∑–∞–Ω–Ω–æ–π —Å –≤–µ–±–æ–º.
Pydantic
–¥–ª—è —á–∞—Å—Ç–∏ —Å–≤—è–∑–∞–Ω–Ω–æ–π —Å –¥–∞–Ω–Ω—ã–º–∏.
–£—Å—Ç–∞–Ω–æ–≤–∫–∞
fast ‚Üí
pip install fastapi
restart ‚Üª
–í–∞–º —Ç–∞–∫–∂–µ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è —Å–µ—Ä–≤–µ—Ä ASGI –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞, —Ç–∞–∫–æ–π –∫–∞–∫
Uvicorn
–∏–ª–∏
Hypercorn
.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
–ü—Ä–∏–º–µ—Ä
–°–æ–∑–¥–∞–Ω–∏–µ
–°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª
main.py
—Å–æ —Å–ª–µ–¥—É—é—â–∏–º —Å–æ–¥–µ—Ä–∂–∏–º—ã–º:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
–ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ
async def
...
–ï—Å–ª–∏ –≤–∞—à –∫–æ–¥ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç
async
/
await
, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ
:
–ï—Å–ª–∏ –≤—ã –Ω–µ –∑–Ω–∞–µ—Ç–µ, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–∑–¥–µ–ª
"–¢–æ—Ä–æ–ø–∏—Ç–µ—Å—å?"
–≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –æ–±
async
–∏
await
.
–ó–∞–ø—É—Å–∫
–ó–∞–ø—É—Å—Ç–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä —Å –ø–æ–º–æ—â—å—é:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
–û –∫–æ–º–∞–Ω–¥–µ
uvicorn main:app --reload
...
–ö–æ–º–∞–Ω–¥–∞
uvicorn main:app
–æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫:
main
: —Ñ–∞–π–ª
main.py
(–º–æ–¥—É–ª—å Python).
app
: –æ–±—ä–µ–∫—Ç, —Å–æ–∑–¥–∞–Ω–Ω—ã–π –≤–Ω—É—Ç—Ä–∏
main.py
—Å –ø–æ–º–æ—â—å—é —Å—Ç—Ä–æ–∫–∏
app = FastAPI()
.
--reload
: –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ –ø–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–æ–¥–∞. –î–µ–ª–∞–π—Ç–µ —ç—Ç–æ —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏.
–ü—Ä–æ–≤–µ—Ä–∫–∞
–û—Ç–∫—Ä–æ–π—Ç–µ –±—Ä–∞—É–∑–µ—Ä –Ω–∞
http://127.0.0.1:8000/items/5?q=somequery
.
–í—ã —É–≤–∏–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â–∏–π JSON –æ—Ç–≤–µ—Ç:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
–í—ã —É–∂–µ —Å–æ–∑–¥–∞–ª–∏ API, –∫–æ—Ç–æ—Ä—ã–π:
–ü–æ–ª—É—á–∞–µ—Ç HTTP-–∑–∞–ø—Ä–æ—Å—ã –ø–æ
–ø—É—Ç—è–º
/
–∏
/items/{item_id}
.
–ò –ø–µ—Ä–≤—ã–π –∏ –≤—Ç–æ—Ä–æ–π
–ø—É—Ç—å
–∏—Å–ø–æ–ª—å–∑—É—é—Ç
GET
–æ–ø–µ—Ä–∞—Ü–∏–∏
(—Ç–∞–∫–∂–µ –∏–∑–≤–µ—Å—Ç–Ω—ã–µ –∫–∞–∫ HTTP
–º–µ—Ç–æ–¥—ã
).
–ø—É—Ç—å
/items/{item_id}
–∏–º–µ–µ—Ç
–ø–∞—Ä–∞–º–µ—Ç—Ä –ø—É—Ç–∏
item_id
, –∫–æ—Ç–æ—Ä—ã–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å
int
.
–ø—É—Ç—å
/items/{item_id}
–∏–º–µ–µ—Ç –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π
str
–ø–∞—Ä–∞–º–µ—Ç—Ä –∑–∞–ø—Ä–æ—Å–∞
q
.
–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –ø–æ API
–ü–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞
http://127.0.0.1:8000/docs
.
–í—ã —É–≤–∏–¥–∏—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—É—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é API (–ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—É—é
Swagger UI
):
–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –ø–æ API
–ê —Ç–µ–ø–µ—Ä—å –ø–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞
http://127.0.0.1:8000/redoc
.
–í—ã —É–≤–∏–¥–∏—Ç–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—É—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é (–ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—É—é
ReDoc
):
–ü—Ä–∏–º–µ—Ä –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
–¢–µ–ø–µ—Ä—å –∏–∑–º–µ–Ω–∏—Ç–µ —Ñ–∞–π–ª
main.py
, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–ª–æ –æ—Ç–≤–µ—Ç–∞ –∏–∑
PUT
–∑–∞–ø—Ä–æ—Å–∞.
–û–±—ä—è–≤–∏—Ç–µ —Ç–µ–ª–æ, –∏—Å–ø–æ–ª—å–∑—É—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é —Ç–∏–ø–∏–∑–∞—Ü–∏—é Python, —Å–ø–∞—Å–∏–±–æ Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
–°–µ—Ä–≤–µ—Ä –¥–æ–ª–∂–µ–Ω –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ (–ø–æ—Ç–æ–º—É —á—Ç–æ –≤—ã –¥–æ–±–∞–≤–∏–ª–∏
--reload
–∫ –∫–æ–º–∞–Ω–¥–µ
uvicorn
–≤—ã—à–µ).
–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ API
–ü–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞
http://127.0.0.1:8000/docs
.
–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è API –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è, –≤–∫–ª—é—á–∞—è –Ω–æ–≤–æ–µ —Ç–µ–ª–æ:
–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É "Try it out", —ç—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –≤–∞–º –∑–∞–ø–æ–ª–Ω–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –Ω–∞–ø—Ä—è–º—É—é –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å —Å API:
–ó–∞—Ç–µ–º –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É "Execute", –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞—à–∏–º API, –æ—Ç–ø—Ä–∞–≤–∏—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –ø–æ–ª—É—á–∏—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏ –æ—Ç–æ–±—Ä–∞–∑–∏—Ç –∏—Ö –Ω–∞ —ç–∫—Ä–∞–Ω–µ:
–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ API
–ê —Ç–µ–ø–µ—Ä—å –ø–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞
http://127.0.0.1:8000/redoc
.
–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è —Ç–∞–∫–∂–µ –±—É–¥–µ—Ç –æ—Ç—Ä–∞–∂–∞—Ç—å –Ω–æ–≤—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –∏ —Ç–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞:
–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏
–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –≤—ã –æ–±—ä—è–≤–ª—è–µ—Ç–µ
–æ–¥–∏–Ω —Ä–∞–∑
—Ç–∏–ø—ã –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, —Ç–µ–ª–æ –∏ —Ç. –¥. –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏.
–í—ã –¥–µ–ª–∞–µ—Ç–µ —ç—Ç–æ –∏—Å–ø–æ–ª—å–∑—É—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—É—é —Ç–∏–ø–∏–∑–∞—Ü–∏—é Python.
–í–∞–º –Ω–µ –Ω—É–∂–Ω–æ –∏–∑—É—á–∞—Ç—å –Ω–æ–≤—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å, –º–µ—Ç–æ–¥—ã –∏–ª–∏ –∫–ª–∞—Å—Å—ã –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏ —Ç. –¥.
–¢–æ–ª—å–∫–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π
Python
.
–ù–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è
int
:
item_id
:
int
–∏–ª–∏ –¥–ª—è –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–æ–π –º–æ–¥–µ–ª–∏
Item
:
item
:
Item
... –∏ —Å —ç—Ç–∏–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ–º –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ:
–ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞, –≤ —Ç–æ–º —á–∏—Å–ª–µ:
–ê–≤—Ç–æ–∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ.
–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤.
–í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö:
–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –∏ —á–µ—Ç–∫–∏–µ –æ—à–∏–±–∫–∏, –∫–æ–≥–¥–∞ –¥–∞–Ω–Ω—ã–µ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã.
–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–∂–µ –¥–ª—è –≥–ª—É–±–æ–∫–æ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ JSON.
–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
–≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö: –ø–æ—Å—Ç—É–ø–∞—é—â–∏–µ –∏–∑ —Å–µ—Ç–∏ –≤ –æ–±—ä–µ–∫—Ç—ã Python —Å —Å–æ–±–ª—é–¥–µ–Ω–∏–µ–º —Ç–∏–ø–æ–≤. –ß—Ç–µ–Ω–∏–µ –∏–∑:
JSON.
–ü–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø—É—Ç–∏.
–ü–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∑–∞–ø—Ä–æ—Å–∞.
Cookies.
–ó–∞–≥–æ–ª–æ–≤–∫–æ–≤.
–§–æ—Ä–º.
–§–∞–π–ª–æ–≤.
–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
–≤—ã—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö: –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ Python –≤ –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã–µ –ø–æ —Å–µ—Ç–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç (—Ç–∞–∫–∏–µ –∫–∞–∫ JSON):
–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ç–∏–ø–æ–≤ Python (
str
,
int
,
float
,
bool
,
list
, –∏ —Ç.–¥.).
–û–±—ä–µ–∫—Ç—ã
datetime
.
–û–±—ä–µ–∫—Ç—ã
UUID
.
–ú–æ–¥–µ–ª–∏ –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö.
...–∏ –º–Ω–æ–≥–æ–µ –¥—Ä—É–≥–æ–µ.
–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –ø–æ API, –≤–∫–ª—é—á–∞—è 2 –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞:
Swagger UI.
ReDoc.
–í–æ–∑–≤—Ä–∞—â–∞—è—Å—å –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É –ø—Ä–∏–º–µ—Ä—É –∫–æ–¥–∞,
FastAPI
–±—É–¥–µ—Ç:
–ü—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–∞–ª–∏—á–∏–µ
item_id
–≤ –ø—É—Ç–∏ –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤
GET
–∏
PUT
.
–ü—Ä–æ–≤–µ—Ä—è—Ç—å, —á—Ç–æ
item_id
–∏–º–µ–µ—Ç —Ç–∏–ø
int
–¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤
GET
–∏
PUT
.
–ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —Ç–∞–∫, –∫–ª–∏–µ–Ω—Ç —É–≤–∏–¥–∏—Ç –ø–æ–ª–µ–∑–Ω—É—é —á—ë—Ç–∫—É—é –æ—à–∏–±–∫—É.
–ü—Ä–æ–≤–µ—Ä—è—Ç—å, –µ—Å—Ç—å –ª–∏ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –∑–∞–ø—Ä–æ—Å–∞ —Å –∏–º–µ–Ω–µ–º
q
(–Ω–∞–ø—Ä–∏–º–µ—Ä,
http://127.0.0.1:8000/items/foo?q=somequery
) –¥–ª—è
GET
–∑–∞–ø—Ä–æ—Å–æ–≤.
–ü–æ—Å–∫–æ–ª—å–∫—É –ø–∞—Ä–∞–º–µ—Ç—Ä
q
–æ–±—ä—è–≤–ª–µ–Ω —Å
= None
, –æ–Ω —è–≤–ª—è–µ—Ç—Å—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º.
–ë–µ–∑
None
–æ–Ω –±—ã–ª –±—ã –Ω–µ–æ–±—Ö–æ–¥–∏–º (–∫–∞–∫ —Ç–µ–ª–æ –≤ —Å–ª—É—á–∞–µ —Å
PUT
).
–î–ª—è
PUT
–∑–∞–ø—Ä–æ—Å–æ–≤ –∫
/items/{item_id}
—á–∏—Ç–∞—Ç—å —Ç–µ–ª–æ –∫–∞–∫ JSON:
–ü—Ä–æ–≤–µ—Ä—è—Ç—å, —á—Ç–æ —É –Ω–µ–≥–æ –µ—Å—Ç—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –∞—Ç—Ä–∏–±—É—Ç
name
, –∫–æ—Ç–æ—Ä—ã–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å
str
.
–ü—Ä–æ–≤–µ—Ä—è—Ç—å, —á—Ç–æ —É –Ω–µ–≥–æ –µ—Å—Ç—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –∞—Ç—Ä–∏–±—É—Ç
price
, –∫–æ—Ç–æ—Ä—ã–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å
float
.
–ü—Ä–æ–≤–µ—Ä—è—Ç—å, —á—Ç–æ —É –Ω–µ–≥–æ –µ—Å—Ç—å –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –∞—Ç—Ä–∏–±—É—Ç
is_offer
, –∫–æ—Ç–æ—Ä—ã–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å
bool
, –µ—Å–ª–∏ –æ–Ω –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç.
–í—Å–µ —ç—Ç–æ —Ç–∞–∫–∂–µ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –¥–ª—è –≥–ª—É–±–æ–∫–æ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ JSON.
–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞—Ç—å –∏–∑ –∏ –≤ JSON –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.
–î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —Å –ø–æ–º–æ—â—å—é OpenAPI –≤—Å–µ, —á—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ:
–°–∏—Å—Ç–µ–º—ã –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏.
–°–∏—Å—Ç–µ–º—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–≥–æ –∫–æ–¥–∞ –¥–ª—è –º–Ω–æ–≥–∏—Ö —è–∑—ã–∫–æ–≤.
–û–±–µ—Å–ø–µ—á–∏—Ç 2 –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã—Ö –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –Ω–∞–ø—Ä—è–º—É—é.
–ú—ã —Ç–æ–ª—å–∫–æ –Ω–µ–º–Ω–æ–≥–æ –∫–æ–ø–Ω—É–ª–∏ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å, –Ω–æ –≤—ã —É–∂–µ –ø–æ–Ω—è–ª–∏, –∫–∞–∫ –≤—Å–µ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç.
–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å —Å—Ç—Ä–æ–∫—É —Å –ø–æ–º–æ—â—å—é:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...–∏–∑:
...
"item_name"
:
item
.
name
...
...–≤:
...
"item_price"
:
item
.
price
...
... –∏ –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ, –∫–∞–∫ –≤–∞—à —Ä–µ–¥–∞–∫—Ç–æ—Ä –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–ø–æ–ª–Ω—è—Ç—å –∞—Ç—Ä–∏–±—É—Ç—ã –∏ —É–∑–Ω–∞–≤–∞—Ç—å –∏—Ö —Ç–∏–ø—ã:
–ë–æ–ª–µ–µ –ø–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ —Ñ—É–Ω–∫—Ü–∏—è–º–∏ —Å–º. –≤
–£—á–µ–±–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ - –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
.
–û—Å—Ç–æ—Ä–æ–∂–Ω–æ, —Å–ø–æ–π–ª–µ—Ä
: —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è:
–û–±—ä—è–≤–ª–µ–Ω–∏–µ
–ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
–∏–∑ –¥—Ä—É–≥–∏—Ö –º–µ—Å—Ç, —Ç–∞–∫–∏—Ö –∫–∞–∫:
–∑–∞–≥–æ–ª–æ–≤–∫–∏
,
cookies
,
–ø–æ–ª—è —Ñ–æ—Ä–º—ã
–∏
—Ñ–∞–π–ª—ã
.
–ö–∞–∫ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å
–æ–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
—Ç–∞–∫–∏–µ –∫–∞–∫
maximum_length
–∏–ª–∏
regex
.
–û—á–µ–Ω—å –º–æ—â–Ω–∞—è –∏ –ø—Ä–æ—Å—Ç–∞—è –≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ —Å–∏—Å—Ç–µ–º–∞
–≤–Ω–µ–¥—Ä–µ–Ω–∏—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
.
–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è, –≤–∫–ª—é—á–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫—É
OAuth2
—Å
—Ç–æ–∫–µ–Ω–∞–º–∏ JWT
–∏
HTTP Basic
–∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é.
–ë–æ–ª–µ–µ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ (–Ω–æ —Å—Ç–æ–ª—å –∂–µ –ø—Ä–æ—Å—Ç—ã–µ) –º–µ—Ç–æ–¥—ã –æ–±—ä—è–≤–ª–µ–Ω–∏—è
–≥–ª—É–±–æ–∫–æ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π JSON
(—Å–ø–∞—Å–∏–±–æ Pydantic).
GraphQL
–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å
Strawberry
–∏ –¥—Ä—É–≥–∏–º–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞–º–∏.
–ú–Ω–æ–∂–µ—Å—Ç–≤–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π (–±–ª–∞–≥–æ–¥–∞—Ä—è Starlette), —Ç–∞–∫–∏—Ö –∫–∞–∫:
–í–µ–±-—Å–æ–∫–µ—Ç—ã
–æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç—ã–µ —Ç–µ—Å—Ç—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ HTTPX –∏
pytest
CORS
Cookie —Å–µ–∞–Ω—Å—ã(—Å–µ—Å—Å–∏–∏)
...–∏ –º–Ω–æ–≥–æ–µ –¥—Ä—É–≥–æ–µ.
–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
–ù–µ–∑–∞–≤–∏—Å–∏–º—ã–µ —Ç–µ—Å—Ç—ã TechEmpower –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
FastAPI
, —Ä–∞–±–æ—Ç–∞—é—â–∏–µ –ø–æ–¥ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º Uvicorn, –∫–∞–∫
–æ–¥–∏–Ω –∏–∑ —Å–∞–º—ã—Ö –±—ã—Å—Ç—Ä—ã—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–æ–≤ Python
, —É—Å—Ç—É–ø–∞—é—â–∏–π —Ç–æ–ª—å–∫–æ —Å–∞–º–∏–º Starlette –∏ Uvicorn (–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –≤–Ω—É—Ç—Ä–∏ FastAPI). (*)
–ß—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –±–æ–ª—å—à–µ –æ–± —ç—Ç–æ–º, —Å–º. —Ä–∞–∑–¥–µ–ª
–¢–µ—Å—Ç—ã –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
.
–ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è Pydantic:
email-validator
- –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–π –ø–æ—á—Ç—ã.
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è Starlette:
HTTPX
- –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
TestClient
.
jinja2
- –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —à–∞–±–ª–æ–Ω–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.
python-multipart
- –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å —Ñ–æ—Ä–º—É
"–ø–∞—Ä—Å–∏–Ω–≥–∞"
—Å –ø–æ–º–æ—â—å—é
request.form()
.
itsdangerous
- –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏
SessionMiddleware
.
pyyaml
- –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏
SchemaGenerator
Starlette (–≤–æ–∑–º–æ–∂–Ω–æ, –≤–∞–º —ç—Ç–æ –Ω–µ –Ω—É–∂–Ω–æ —Å FastAPI).
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è FastAPI / Starlette:
uvicorn
- —Å–µ—Ä–≤–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–≥—Ä—É–∂–∞–µ—Ç –∏ –æ–±—Å–ª—É–∂–∏–≤–∞–µ—Ç –≤–∞—à–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.
orjson
- –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
ORJSONResponse
.
ujson
- –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
UJSONResponse
.
–í—ã –º–æ–∂–µ—Ç–µ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å–µ —ç—Ç–æ —Å –ø–æ–º–æ—â—å—é
pip install "fastapi[all]"
.
–õ–∏—Ü–µ–Ω–∑–∏—è
–≠—Ç–æ—Ç –ø—Ä–æ–µ–∫—Ç —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è–µ—Ç—Å—è –Ω–∞ —É—Å–ª–æ–≤–∏—è—Ö –ª–∏—Ü–µ–Ω–∑–∏–∏ MIT.

## 107_TR
FastAPI¬∂
---

FastAPI
FastAPI framework, y√ºksek performanslƒ±, √∂ƒürenmesi olduk√ßa kolay, kodlamasƒ± hƒ±zlƒ±, kullanƒ±ma hazƒ±r
Dok√ºmantasyon
:
https://fastapi.tiangolo.com
Kaynak Kod
:
https://github.com/fastapi/fastapi
FastAPI, Python 'nin standart
tip belirte√ßleri
ne dayalƒ±, modern ve hƒ±zlƒ± (y√ºksek performanslƒ±) API'lar olu≈üturmak i√ßin kullanƒ±labilecek web framework't√ºr.
Temel √∂zellikleri ≈üunlardƒ±r:
Hƒ±zlƒ±
: √áok y√ºksek performanslƒ±,
NodeJS
ve
Go
ile e≈üit d√ºzeyde (Starlette ve Pydantic sayesinde).
En hƒ±zlƒ± Python framework'lerinden bir tanesidir
.
Kodlamasƒ± Hƒ±zlƒ±
: Geli≈ütirme hƒ±zƒ±nƒ± yakla≈üƒ±k %200 ile %300 aralƒ±ƒüƒ±nda arttƒ±rƒ±r. *
Daha az hata
: ƒ∞nsan (geli≈ütirici) kaynaklƒ± hatalarƒ± yakla≈üƒ±k %40 azaltƒ±r. *
Sezgisel
: Muhte≈üem bir edit√∂r desteƒüi. Her yerde
otomatik tamamlama
. Hata ayƒ±klama ile daha az zaman harcayacaksƒ±nƒ±z.
Kolay
: √ñƒürenmesi ve kullanmasƒ± kolay olacak ≈üekilde tasarlandƒ±. Dok√ºman okuma ile daha az zaman harcayacaksƒ±nƒ±z.
Kƒ±sa
: Kod tekrarƒ± minimize edildi. Her parametre tanƒ±mlamasƒ±nda birden fazla √∂zellik ve daha az hatayla kar≈üƒ±la≈üacaksƒ±nƒ±z.
G√º√ßl√º
: Otomatik ve etkile≈üimli dok√ºmantasyon ile birlikte, kullanƒ±ma hazƒ±r kod elde edebilirsiniz.
Standard √∂ncelikli
: API'lar i√ßin a√ßƒ±k standartlara dayalƒ± (ve tamamen uyumlu);
OpenAPI
(eski adƒ±yla Swagger) ve
JSON Schema
.
* ilgili kanƒ±lar, dahili geli≈ütirme ekibinin geli≈ütirdikleri √ºr√ºnlere yaptƒ±klarƒ± testlere dayanmaktadƒ±r.
Sponsorlar
Diƒüer Sponsorlar
G√∂r√º≈üler
"
[...] Bug√ºnlerde
FastAPI
'ƒ± √ßok fazla kullanƒ±yorum. [...] Aslƒ±nda bunu ekibimin
Microsoft'taki Machine Learning servislerinin
tamamƒ±nda kullanmayƒ± planlƒ±yorum. Bunlardan bazƒ±larƒ±
Windows
'un ana √ºr√ºnlerine ve
Office
√ºr√ºnlerine entegre ediliyor.
"
Kabir Khan -
Microsoft
(ref)
"
FastAPI
'ƒ±
tahminlerimiz
'i sorgulanabilir hale getirecek bir
REST
sunucu olu≈üturmak i√ßin benimsedik/kullanmaya ba≈üladƒ±k.
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
,
kriz y√∂netiminde
orkestrasyon yapabilmek i√ßin geli≈ütirdiƒüi yeni framework'√º
Dispatch
'in, a√ßƒ±k kaynak s√ºr√ºm√ºn√º payla≈ümaktan gurur duyuyor. [
FastAPI
ile yapƒ±ldƒ±.]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
FastAPI
i√ßin ayƒ±n √ºzerindeymi≈ücesine heyecanlƒ±yƒ±m. √áok eƒülenceli!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
D√ºr√ºst olmak gerekirse, in≈üa ettiƒüiniz ≈üey ger√ßekten saƒülam ve profesyonel g√∂r√ºn√ºyor. Bir√ßok a√ßƒ±dan
Hug
'ƒ±n olmasƒ±nƒ± istediƒüim ≈üey tam da bu - b√∂yle bir ≈üeyi in≈üa eden birini g√∂rmek ger√ßekten ilham verici.
"
Timothy Crosley -
Hug
'ƒ±n Yaratƒ±cƒ±sƒ±
(ref)
"
Eƒüer REST API geli≈ütirmek i√ßin
modern bir framework
√∂ƒürenme arayƒ±≈üƒ±nda isen,
FastAPI
'a bir g√∂z at [...] Hƒ±zlƒ±, kullanƒ±mƒ± ve √∂ƒürenmesi kolay. [...]
"
"
API
servislerimizi
FastAPI
'a ta≈üƒ±dƒ±k [...] Sizin de beƒüeneceƒüinizi d√º≈ü√ºn√ºyoruz. [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
kurucularƒ± -
spaCy
yaratƒ±cƒ±larƒ±
(ref)
-
(ref)
"
Python ile kullanƒ±ma hazƒ±r bir API olu≈üturmak isteyen herhangi biri i√ßin,
FastAPI
'ƒ± ≈üiddetle tavsiye ederim.
Harika tasarlanmƒ±≈ü
,
kullanƒ±mƒ± kolay
ve
y√ºksek √∂l√ßeklenebilir
, API odaklƒ± geli≈ütirme stratejimizin
ana bile≈üeni
haline geldi ve Virtual TAC Engineer gibi bir√ßok otomasyon ve servisi y√∂netiyor.
"
Deon Pillsbury -
Cisco
(ref)
Komut Satƒ±rƒ± Uygulamalarƒ±nƒ±n FastAPI'ƒ±:
Typer
Eƒüer API yerine, terminalde kullanƒ±lmak √ºzere bir
komut satƒ±rƒ± uygulamasƒ±
geli≈ütiriyorsanƒ±z
Typer
'a g√∂z atabilirsiniz.
Typer
kƒ±saca FastAPI'ƒ±n k√º√ß√ºk karde≈üi. Ve hedefi komut satƒ±rƒ± uygulamalarƒ±nƒ±n
FastAPI'ƒ±
olmak. ‚å®Ô∏è üöÄ
Gereksinimler
FastAPI iki devin omuzlarƒ± √ºst√ºnde duruyor:
Web tarafƒ± i√ßin
Starlette
.
Data tarafƒ± i√ßin
Pydantic
.
Kurulum
fast ‚Üí
pip install fastapi
restart ‚Üª
Uygulamamƒ±zƒ± kullanƒ±labilir hale getirmek i√ßin
Uvicorn
ya da
Hypercorn
gibi bir ASGI sunucusuna ihtiyacƒ±mƒ±z olacak.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
√ñrnek
Kodu Olu≈üturalƒ±m
main.py
adƒ±nda bir dosya olu≈üturup i√ßine ≈üu kodu yapƒ±≈ütƒ±ralƒ±m:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Ya da
async def
...
Eƒüer kodunuzda
async
/
await
varsa,
async def
kullanalƒ±m:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Not
:
Eƒüer bu konu hakkƒ±nda bilginiz yoksa
async
ve
await
dok√ºmantasyonundaki
"Aceleniz mi var?"
kƒ±smƒ±nƒ± kontrol edebilirsiniz.
Kodu √áalƒ±≈ütƒ±ralƒ±m
Sunucuyu a≈üaƒüƒ±daki komutla √ßalƒ±≈ütƒ±ralƒ±m:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
uvicorn main:app --reload
komutuyla ilgili...
uvicorn main:app
komutunu ≈üu ≈üekilde a√ßƒ±klayabiliriz:
main
: dosya olan
main.py
(yani Python "mod√ºl√º").
app
: ise
main.py
dosyasƒ±nƒ±n i√ßerisinde
app = FastAPI()
satƒ±rƒ±nda olu≈üturduƒüumuz
FastAPI
nesnesi.
--reload
: kod deƒüi≈üikliklerinin ardƒ±ndan sunucuyu otomatik olarak yeniden ba≈ülatƒ±r. Bu parameteyi sadece geli≈ütirme a≈üamasƒ±nda kullanmalƒ±yƒ±z.
≈ûimdi de Kontrol Edelim
Tarayƒ±cƒ±mƒ±zda ≈üu baƒülantƒ±yƒ± a√ßalƒ±m
http://127.0.0.1:8000/items/5?q=somequery
.
A≈üaƒüƒ±daki gibi bir JSON yanƒ±tƒ±yla kar≈üƒ±la≈üacaƒüƒ±z:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
Az √∂nce olu≈üturduƒüumuz API:
/
ve
/items/{item_id}
yollarƒ±na
HTTP isteƒüi alabilir.
ƒ∞ki
yolda
GET
operasyonlarƒ±nƒ±
(HTTP
metodlarƒ±
olarak da bilinen) kabul ediyor.
/items/{item_id}
yolu
item_id
adƒ±nda bir
yol parametresine
sahip ve bu parametre
int
deƒüer almak zorundadƒ±r.
/items/{item_id}
yolu
q
adƒ±nda bir
yol parametresine
sahip ve bu parametre opsiyonel olmakla birlikte,
str
deƒüer almak zorundadƒ±r.
Etkile≈üimli API Dok√ºmantasyonu
≈ûimdi
http://127.0.0.1:8000/docs
baƒülantƒ±sƒ±nƒ± a√ßalƒ±m.
Swagger UI
tarafƒ±ndan saƒülanan otomatik etkile≈üimli bir API dok√ºmantasyonu g√∂receƒüiz:
Alternatif API Dok√ºmantasyonu
≈ûimdi
http://127.0.0.1:8000/redoc
baƒülantƒ±sƒ±nƒ± a√ßalƒ±m.
ReDoc
tarafƒ±ndan saƒülanan otomatik dok√ºmantasyonu g√∂receƒüiz:
√ñrneƒüi G√ºncelleyelim
≈ûimdi
main.py
dosyasƒ±nƒ±,
PUT
isteƒüiyle birlikte bir g√∂vde alacak ≈üekilde deƒüi≈ütirelim.
G√∂vde
yi Pydantic sayesinde standart python tiplerini kullanarak tanƒ±mlayalƒ±m.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Sunucu otomatik olarak yeniden ba≈ülamƒ±≈ü olmalƒ± (√ß√ºnk√º yukarƒ±da
uvicorn
komutuyla birlikte
--reload
parametresini kullandƒ±k).
Etkile≈üimli API Dok√ºmantasyonundaki Deƒüi≈üimi G√∂relim
≈ûimdi
http://127.0.0.1:8000/docs
baƒülantƒ±sƒ±na tekrar gidelim.
Etkile≈üimli API dok√ºmantasyonu, yeni g√∂vdede dahil olmak √ºzere otomatik olarak g√ºncellenmi≈ü olacak:
"Try it out" butonuna tƒ±klayalƒ±m, bu i≈ülem API parametleri √ºzerinde deƒüi≈üiklik yapmamƒ±za ve doƒürudan API ile etkile≈üime ge√ßmemize imkan saƒülayacak:
≈ûimdi "Execute" butonuna tƒ±klayalƒ±m, kullanƒ±cƒ± aray√ºz√º API'ƒ±mƒ±z ile baƒülantƒ± kurup parametreleri g√∂nderecek ve sonucu ekranƒ±mƒ±za getirecek:
Alternatif API Dok√ºmantasyonundaki Deƒüi≈üimi G√∂relim
≈ûimdi ise
http://127.0.0.1:8000/redoc
baƒülantƒ±sƒ±na tekrar gidelim.
Alternatif dok√ºmantasyonda yaptƒ±ƒüƒ±mƒ±z deƒüi≈üiklikler ile birlikte yeni sorgu parametresi ve g√∂vde bilgisi ile g√ºncelemi≈ü olacak:
√ñzet
√ñzetlemek gerekirse, parametrelerin, g√∂vdenin, vb. veri tiplerini fonksiyon parametreleri olarak
bir kere
tanƒ±mlƒ±yoruz.
Bu i≈ülemi standart modern Python tipleriyle yapƒ±yoruz.
Yeni bir s√∂zdizimi yapƒ±sƒ±nƒ±, bir k√ºt√ºphane √∂zel metod veya sƒ±nƒ±flarƒ± √∂ƒürenmeye gerek yoktur.
Hepsi sadece
Python
standartlarƒ±na dayalƒ±dƒ±r.
√ñrnek olarak,
int
tanƒ±mlamak i√ßin:
item_id
:
int
ya da daha kompleks herhangi bir python modelini tanƒ±mlayabiliriz, √∂rneƒüin
Item
modeli i√ßin:
item
:
Item
...ve sadece kƒ±sa bir parametre tipi belirterek elde ettiklerimiz:
Edit√∂r desteƒüiyle birlikte:
Otomatik tamamlama.
Tip kontrol√º.
Veri Doƒürulama:
Veri ge√ßerli deƒüilse, otomatik olarak a√ßƒ±klayƒ±cƒ± hatalar g√∂sterir.
√áok
derin
JSON nesnelerinde bile doƒürulama yapar.
Gelen verinin
d√∂n√º≈ü√ºm√ºn√º
a≈üaƒüƒ±daki veri tiplerini kullanarak ger√ßekle≈ütirir:
JSON.
Yol parametreleri.
Sorgu parametreleri.
√áerezler.
Headers.
Formlar.
Dosyalar.
Giden verinin
d√∂n√º≈ü√ºm√ºn√º
a≈üaƒüƒ±daki veri tiplerini kullanarak ger√ßekle≈ütirir (JSON olarak):
Python tiplerinin (
str
,
int
,
float
,
bool
,
list
, vb) d√∂n√º≈ü√ºm√º.
datetime
nesnesi.
UUID
nesnesi.
Veritabanƒ± modelleri.
ve √ßok daha fazlasƒ±...
2 alternatif kullanƒ±cƒ± aray√ºz√º dahil olmak √ºzere, otomatik etkile≈üimli API dok√ºmantasyonu saƒülar:
Swagger UI.
ReDoc.
Az √∂nceki √∂rneƒüe geri d√∂nelim,
FastAPI
'ƒ±n yapacaklarƒ±na bir bakƒ±≈ü atalƒ±m:
item_id
'nin
GET
ve
PUT
istekleri i√ßin, yolda olup olmadƒ±ƒüƒ±nƒ±n kontol edecek.
item_id
'nin
GET
ve
PUT
istekleri i√ßin, tipinin
int
olduƒüunu doƒürulayacak.
Eƒüer deƒüilse, sebebini belirten bir hata mesajƒ± g√∂sterecek.
Opsiyonel bir
q
parametresinin
GET
isteƒüi i√ßinde (
http://127.0.0.1:8000/items/foo?q=somequery
gibi) olup olmadƒ±ƒüƒ±nƒ± kontrol edecek
q
parametresini
= None
ile olu≈üturduƒüumuz i√ßin, opsiyonel bir parametre olacak.
Eƒüer
None
olmasa zorunlu bir parametre olacaktƒ± (
PUT
metodunun g√∂vdesinde olduƒüu gibi).
PUT
isteƒüi i√ßin
/items/{item_id}
'nin g√∂vdesini, JSON olarak doƒürulayƒ±p okuyacak:
name
adƒ±nda zorunlu bir parametre olup olmadƒ±ƒüƒ±nƒ± ve varsa tipinin
str
olup olmadƒ±ƒüƒ±nƒ± kontol edecek.
price
adƒ±nda zorunlu bir parametre olup olmadƒ±ƒüƒ±nƒ± ve varsa tipinin
float
olup olmadƒ±ƒüƒ±nƒ± kontol edecek.
is_offer
adƒ±nda opsiyonel bir parametre olup olmadƒ±ƒüƒ±nƒ± ve varsa tipinin
float
olup olmadƒ±ƒüƒ±nƒ± kontol edecek.
Bunlarƒ±n hepsi en derin JSON nesnelerinde bile √ßalƒ±≈üacak.
Verilerin JSON'a ve JSON'ƒ±n python nesnesine d√∂n√º≈ü√ºm√º otomatik olarak yapƒ±lacak.
Her ≈üeyi OpenAPI ile uyumlu bir ≈üekilde otomatik olarak dok√ºmanlayacak ve bunlarda a≈üaƒüƒ±daki gibi kullanƒ±labilecek:
Etkile≈üimli dok√ºmantasyon sistemleri.
Bir √ßok programlama dili i√ßin otomatik istemci kodu √ºretim sistemleri.
ƒ∞ki ayrƒ± etkile≈üimli dok√ºmantasyon aray√ºz√ºn√º doƒürudan saƒülayacak.
Daha yeni ba≈üladƒ±k ama √ßalƒ±≈üma mantƒ±ƒüƒ±nƒ± √ßoktan anlamƒ±≈ü oldunuz.
≈ûimdi a≈üaƒüƒ±daki satƒ±rƒ± deƒüi≈ütirmeyi deneyin:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...bundan:
...
"item_name"
:
item
.
name
...
...buna:
...
"item_price"
:
item
.
price
...
...ve edit√∂r√ºn√ºn veri tiplerini bildiƒüini ve otomatik tamamladƒ±ƒüƒ±nƒ± g√∂receksiniz:
Daha fazal √∂zellik i√ßeren, daha eksiksiz bir √∂rnek i√ßin
√ñƒüretici - Kullanƒ±cƒ± Rehberi
sayfasƒ±nƒ± ziyaret edebilirsin.
Spoiler
: √ñƒüretici - Kullanƒ±cƒ± rehberi ≈üunlarƒ± i√ßerir:
Parameterlerin
,
headers
,
√ßerezler
,
form alanlarƒ±
ve
dosyalar
olarak tanƒ±mlanmasƒ±.
maximum_length
ya da
regex
gibi
doƒürulama kƒ±sƒ±tlamalarƒ±nƒ±n
nasƒ±l yapƒ±labileceƒüi.
√áok g√º√ßl√º ve kullanƒ±mƒ± kolay
Baƒüƒ±mlƒ±lƒ±k Enjeksiyonu
sistemi olu≈üturmayƒ±.
G√ºvenlik ve kimlik doƒürulama,
JWT tokenleri
ile
OAuth2
desteƒüi, ve
HTTP Basic
doƒürulamasƒ±.
ƒ∞leri seviye fakat bir o kadarda basit olan
√ßok derin JSON modelleri
(Pydantic sayesinde).
GraphQL
entegrasyonu:
Strawberry
ve diƒüer k√ºt√ºphaneleri kullanarak.
Diƒüer ekstra √∂zellikler (Starlette sayesinde):
WebSocketler
HTTPX ve
pytest
sayesinde a≈üƒ±rƒ± kolay testler.
CORS
Cookie Sessions
...ve daha fazlasƒ±.
Performans
Baƒüƒ±msƒ±z TechEmpower kƒ±yaslamalarƒ± g√∂steriyor ki, Uvicorn ile √ßalƒ±≈ütƒ±rƒ±lan
FastAPI
uygulamalarƒ±
en hƒ±zlƒ± Python framework'lerinden birisi
, sadece Starlette ve Uvicorn'dan yava≈ü, ki FastAPI bunlarƒ±n √ºzerine kurulu bir k√ºt√ºphanedir.
Daha fazla bilgi i√ßin, bu b√∂l√ºme bir g√∂z at
Kƒ±yaslamalar
.
Opsiyonel Gereksinimler
Pydantic tarafƒ±nda kullanƒ±lan:
email-validator
- email doƒürulamasƒ± i√ßin.
pydantic-settings
- ayar y√∂netimi i√ßin.
pydantic-extra-types
- Pydantic ile birlikte kullanƒ±labilecek ek tipler i√ßin.
Starlette tarafƒ±nda kullanƒ±lan:
httpx
- Eƒüer
TestClient
yapƒ±sƒ±nƒ± kullanacaksanƒ±z gereklidir.
jinja2
- Eƒüer varsayƒ±lan template konfig√ºrasyonunu kullanacaksanƒ±z gereklidir.
python-multipart
- Eƒüer
request.form()
ile form
d√∂n√º≈ü√ºm√º
desteƒüini kullanacaksanƒ±z gereklidir.
itsdangerous
-
SessionMiddleware
desteƒüi i√ßin gerekli.
pyyaml
-
SchemaGenerator
desteƒüi i√ßin gerekli (Muhtemelen FastAPI kullanƒ±rken ihtiyacƒ±nƒ±z olmaz).
Hem FastAPI hem de Starlette tarafƒ±ndan kullanƒ±lan:
uvicorn
- olu≈üturduƒüumuz uygulamayƒ± servis edecek web sunucusu g√∂revini √ºstlenir.
orjson
-
ORJSONResponse
kullanacaksanƒ±z gereklidir.
ujson
-
UJSONResponse
kullanacaksanƒ±z gerekli.
Bunlarƒ±n hepsini
pip install fastapi[all]
ile y√ºkleyebilirsin.
Lisans
Bu proje, MIT lisansƒ± ≈üartlarƒ± altƒ±nda lisanslanmƒ±≈ütƒ±r.

## 108_TUTORIAL
Tutorial - User Guide¬∂
---

Tutorial - User Guide
This tutorial shows you how to use
FastAPI
with most of its features, step by step.
Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific API needs.
It is also built to work as a future reference so you can come back and see exactly what you need.
Run the code
All the code blocks can be copied and used directly (they are actually tested Python files).
To run any of the examples, copy the code to a file
main.py
, and start
fastapi dev
with:
fast ‚Üí
fastapi dev main.py
FastAPI
Starting development server üöÄ
Searching for package file structure from directories
with
__init__.py
files
Importing from
/home/user/code/
awesomeapp
module
üêç main.py
code
Importing the FastAPI app object from the module with
the following code:
from
main
import
app
app
Using import string:
main:app
server
Server started at
http://127.0.0.1:8000
server
Documentation at
http://127.0.0.1:8000/docs
tip
Running in development mode, for production use:
fastapi run
Logs:
INFO
Will watch for changes in these directories:
[
'/home/user/code/awesomeapp'
]
INFO
Uvicorn running on
http://127.0.0.1:8000
(
Press CTRL+C
to quit
)
INFO
Started reloader process
[
383138
]
using WatchFiles
INFO
Started server process
[
383153
]
INFO
Waiting for application startup.
INFO
Application startup complete.
It is
HIGHLY encouraged
that you write or copy the code, edit it and run it locally.
Using it in your editor is what really shows you the benefits of FastAPI, seeing how little code you have to write, all the type checks, autocompletion, etc.
Install FastAPI
The first step is to install FastAPI.
Make sure you create a
virtual environment
, activate it, and then
install FastAPI
:
fast ‚Üí
pip install "fastapi[standard]"
restart ‚Üª
Note
When you install with
pip install "fastapi[standard]"
it comes with some default optional standard dependencies.
If you don't want to have those optional dependencies, you can instead install
pip install fastapi
.
Advanced User Guide
There is also an
Advanced User Guide
that you can read later after this
Tutorial - User guide
.
The
Advanced User Guide
builds on this one, uses the same concepts, and teaches you some extra features.
But you should first read the
Tutorial - User Guide
(what you are reading right now).
It's designed so that you can build a complete application with just the
Tutorial - User Guide
, and then extend it in different ways, depending on your needs, using some of the additional ideas from the
Advanced User Guide
.

## 109_TUTORIAL_BACKGROUND_TASKS
Background Tasks¬∂
---

Background Tasks
You can define background tasks to be run
after
returning a response.
This is useful for operations that need to happen after a request, but that the client doesn't really have to be waiting for the operation to complete before receiving the response.
This includes, for example:
Email notifications sent after performing an action:
As connecting to an email server and sending an email tends to be "slow" (several seconds), you can return the response right away and send the email notification in the background.
Processing data:
For example, let's say you receive a file that must go through a slow process, you can return a response of "Accepted" (HTTP 202) and process the file in the background.
Using
BackgroundTasks
First, import
BackgroundTasks
and define a parameter in your
path operation function
with a type declaration of
BackgroundTasks
:
Python 3.8+
from
fastapi
import
BackgroundTasks
,
FastAPI
app
=
FastAPI
()
def
write_notification
(
email
:
str
,
message
=
""
):
with
open
(
"log.txt"
,
mode
=
"w"
)
as
email_file
:
content
=
f
"notification for
{
email
}
:
{
message
}
"
email_file
.
write
(
content
)
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
):
background_tasks
.
add_task
(
write_notification
,
email
,
message
=
"some notification"
)
return
{
"message"
:
"Notification sent in the background"
}
FastAPI
will create the object of type
BackgroundTasks
for you and pass it as that parameter.
Create a task function
Create a function to be run as the background task.
It is just a standard function that can receive parameters.
It can be an
async def
or normal
def
function,
FastAPI
will know how to handle it correctly.
In this case, the task function will write to a file (simulating sending an email).
And as the write operation doesn't use
async
and
await
, we define the function with normal
def
:
Python 3.8+
from
fastapi
import
BackgroundTasks
,
FastAPI
app
=
FastAPI
()
def
write_notification
(
email
:
str
,
message
=
""
):
with
open
(
"log.txt"
,
mode
=
"w"
)
as
email_file
:
content
=
f
"notification for
{
email
}
:
{
message
}
"
email_file
.
write
(
content
)
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
):
background_tasks
.
add_task
(
write_notification
,
email
,
message
=
"some notification"
)
return
{
"message"
:
"Notification sent in the background"
}
Add the background task
Inside of your
path operation function
, pass your task function to the
background tasks
object with the method
.add_task()
:
Python 3.8+
from
fastapi
import
BackgroundTasks
,
FastAPI
app
=
FastAPI
()
def
write_notification
(
email
:
str
,
message
=
""
):
with
open
(
"log.txt"
,
mode
=
"w"
)
as
email_file
:
content
=
f
"notification for
{
email
}
:
{
message
}
"
email_file
.
write
(
content
)
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
):
background_tasks
.
add_task
(
write_notification
,
email
,
message
=
"some notification"
)
return
{
"message"
:
"Notification sent in the background"
}
.add_task()
receives as arguments:
A task function to be run in the background (
write_notification
).
Any sequence of arguments that should be passed to the task function in order (
email
).
Any keyword arguments that should be passed to the task function (
message="some notification"
).
Dependency Injection
Using
BackgroundTasks
also works with the dependency injection system, you can declare a parameter of type
BackgroundTasks
at multiple levels: in a
path operation function
, in a dependency (dependable), in a sub-dependency, etc.
FastAPI
knows what to do in each case and how to reuse the same object, so that all the background tasks are merged together and are run in the background afterwards:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
BackgroundTasks
,
Depends
,
FastAPI
app
=
FastAPI
()
def
write_log
(
message
:
str
):
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
message
)
def
get_query
(
background_tasks
:
BackgroundTasks
,
q
:
str
|
None
=
None
):
if
q
:
message
=
f
"found query:
{
q
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
q
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
,
q
:
Annotated
[
str
,
Depends
(
get_query
)]
):
message
=
f
"message to
{
email
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
{
"message"
:
"Message sent"
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
BackgroundTasks
,
Depends
,
FastAPI
app
=
FastAPI
()
def
write_log
(
message
:
str
):
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
message
)
def
get_query
(
background_tasks
:
BackgroundTasks
,
q
:
Union
[
str
,
None
]
=
None
):
if
q
:
message
=
f
"found query:
{
q
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
q
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
,
q
:
Annotated
[
str
,
Depends
(
get_query
)]
):
message
=
f
"message to
{
email
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
{
"message"
:
"Message sent"
}
from
typing
import
Union
from
fastapi
import
BackgroundTasks
,
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
def
write_log
(
message
:
str
):
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
message
)
def
get_query
(
background_tasks
:
BackgroundTasks
,
q
:
Union
[
str
,
None
]
=
None
):
if
q
:
message
=
f
"found query:
{
q
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
q
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
,
q
:
Annotated
[
str
,
Depends
(
get_query
)]
):
message
=
f
"message to
{
email
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
{
"message"
:
"Message sent"
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
BackgroundTasks
,
Depends
,
FastAPI
app
=
FastAPI
()
def
write_log
(
message
:
str
):
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
message
)
def
get_query
(
background_tasks
:
BackgroundTasks
,
q
:
str
|
None
=
None
):
if
q
:
message
=
f
"found query:
{
q
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
q
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
,
q
:
str
=
Depends
(
get_query
)
):
message
=
f
"message to
{
email
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
{
"message"
:
"Message sent"
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
BackgroundTasks
,
Depends
,
FastAPI
app
=
FastAPI
()
def
write_log
(
message
:
str
):
with
open
(
"log.txt"
,
mode
=
"a"
)
as
log
:
log
.
write
(
message
)
def
get_query
(
background_tasks
:
BackgroundTasks
,
q
:
Union
[
str
,
None
]
=
None
):
if
q
:
message
=
f
"found query:
{
q
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
q
@app
.
post
(
"/send-notification/
{email}
"
)
async
def
send_notification
(
email
:
str
,
background_tasks
:
BackgroundTasks
,
q
:
str
=
Depends
(
get_query
)
):
message
=
f
"message to
{
email
}
\n
"
background_tasks
.
add_task
(
write_log
,
message
)
return
{
"message"
:
"Message sent"
}
In this example, the messages will be written to the
log.txt
file
after
the response is sent.
If there was a query in the request, it will be written to the log in a background task.
And then another background task generated at the
path operation function
will write a message using the
email
path parameter.
Technical Details
The class
BackgroundTasks
comes directly from
starlette.background
.
It is imported/included directly into FastAPI so that you can import it from
fastapi
and avoid accidentally importing the alternative
BackgroundTask
(without the
s
at the end) from
starlette.background
.
By only using
BackgroundTasks
(and not
BackgroundTask
), it's then possible to use it as a
path operation function
parameter and have
FastAPI
handle the rest for you, just like when using the
Request
object directly.
It's still possible to use
BackgroundTask
alone in FastAPI, but you have to create the object in your code and return a Starlette
Response
including it.
You can see more details in
Starlette's official docs for Background Tasks
.
Caveat
If you need to perform heavy background computation and you don't necessarily need it to be run by the same process (for example, you don't need to share memory, variables, etc), you might benefit from using other bigger tools like
Celery
.
They tend to require more complex configurations, a message/job queue manager, like RabbitMQ or Redis, but they allow you to run background tasks in multiple processes, and especially, in multiple servers.
But if you need to access variables and objects from the same
FastAPI
app, or you need to perform small background tasks (like sending an email notification), you can simply just use
BackgroundTasks
.
Recap
Import and use
BackgroundTasks
with parameters in
path operation functions
and dependencies to add background tasks.

## 110_TUTORIAL_BIGGER_APPLICATIONS
Bigger Applications - Multiple Files¬∂
---

Bigger Applications - Multiple Files
If you are building an application or a web API, it's rarely the case that you can put everything in a single file.
FastAPI
provides a convenience tool to structure your application while keeping all the flexibility.
Info
If you come from Flask, this would be the equivalent of Flask's Blueprints.
An example file structure
Let's say you have a file structure like this:
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dependencies.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ routers
‚îÇ¬†¬† ‚îÇ ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ ‚îú‚îÄ‚îÄ items.py
‚îÇ¬†¬† ‚îÇ ‚îî‚îÄ‚îÄ users.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ internal
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ admin.py
Tip
There are several
__init__.py
files: one in each directory or subdirectory.
This is what allows importing code from one file into another.
For example, in
app/main.py
you could have a line like:
from app.routers import items
The
app
directory contains everything. And it has an empty file
app/__init__.py
, so it is a "Python package" (a collection of "Python modules"):
app
.
It contains an
app/main.py
file. As it is inside a Python package (a directory with a file
__init__.py
), it is a "module" of that package:
app.main
.
There's also an
app/dependencies.py
file, just like
app/main.py
, it is a "module":
app.dependencies
.
There's a subdirectory
app/routers/
with another file
__init__.py
, so it's a "Python subpackage":
app.routers
.
The file
app/routers/items.py
is inside a package,
app/routers/
, so, it's a submodule:
app.routers.items
.
The same with
app/routers/users.py
, it's another submodule:
app.routers.users
.
There's also a subdirectory
app/internal/
with another file
__init__.py
, so it's another "Python subpackage":
app.internal
.
And the file
app/internal/admin.py
is another submodule:
app.internal.admin
.
The same file structure with comments:
.
‚îú‚îÄ‚îÄ app # "app" is a Python package
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py # this file makes "app" a "Python package"
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py # "main" module, e.g. import app.main
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dependencies.py # "dependencies" module, e.g. import app.dependencies
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ routers # "routers" is a "Python subpackage"
‚îÇ¬†¬† ‚îÇ ‚îú‚îÄ‚îÄ __init__.py # makes "routers" a "Python subpackage"
‚îÇ¬†¬† ‚îÇ ‚îú‚îÄ‚îÄ items.py # "items" submodule, e.g. import app.routers.items
‚îÇ¬†¬† ‚îÇ ‚îî‚îÄ‚îÄ users.py # "users" submodule, e.g. import app.routers.users
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ internal # "internal" is a "Python subpackage"
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py # makes "internal" a "Python subpackage"
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ admin.py # "admin" submodule, e.g. import app.internal.admin
APIRouter
Let's say the file dedicated to handling just users is the submodule at
/app/routers/users.py
.
You want to have the
path operations
related to your users separated from the rest of the code, to keep it organized.
But it's still part of the same
FastAPI
application/web API (it's part of the same "Python Package").
You can create the
path operations
for that module using
APIRouter
.
Import
APIRouter
You import it and create an "instance" the same way you would with the class
FastAPI
:
app/routers/users.py
from
fastapi
import
APIRouter
router
=
APIRouter
()
@router
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
@router
.
get
(
"/users/me"
,
tags
=
[
"users"
])
async
def
read_user_me
():
return
{
"username"
:
"fakecurrentuser"
}
@router
.
get
(
"/users/
{username}
"
,
tags
=
[
"users"
])
async
def
read_user
(
username
:
str
):
return
{
"username"
:
username
}
Path operations
with
APIRouter
And then you use it to declare your
path operations
.
Use it the same way you would use the
FastAPI
class:
app/routers/users.py
from
fastapi
import
APIRouter
router
=
APIRouter
()
@router
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
@router
.
get
(
"/users/me"
,
tags
=
[
"users"
])
async
def
read_user_me
():
return
{
"username"
:
"fakecurrentuser"
}
@router
.
get
(
"/users/
{username}
"
,
tags
=
[
"users"
])
async
def
read_user
(
username
:
str
):
return
{
"username"
:
username
}
You can think of
APIRouter
as a "mini
FastAPI
" class.
All the same options are supported.
All the same
parameters
,
responses
,
dependencies
,
tags
, etc.
Tip
In this example, the variable is called
router
, but you can name it however you want.
We are going to include this
APIRouter
in the main
FastAPI
app, but first, let's check the dependencies and another
APIRouter
.
Dependencies
We see that we are going to need some dependencies used in several places of the application.
So we put them in their own
dependencies
module (
app/dependencies.py
).
We will now use a simple dependency to read a custom
X-Token
header:
Python 3.9+
Python 3.8+
Python 3.8+ non-Annotated
app/dependencies.py
from
typing
import
Annotated
from
fastapi
import
Header
,
HTTPException
async
def
get_token_header
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
get_query_token
(
token
:
str
):
if
token
!=
"jessica"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"No Jessica token provided"
)
app/dependencies.py
from
fastapi
import
Header
,
HTTPException
from
typing_extensions
import
Annotated
async
def
get_token_header
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
get_query_token
(
token
:
str
):
if
token
!=
"jessica"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"No Jessica token provided"
)
Tip
Prefer to use the
Annotated
version if possible.
app/dependencies.py
from
fastapi
import
Header
,
HTTPException
async
def
get_token_header
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
get_query_token
(
token
:
str
):
if
token
!=
"jessica"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"No Jessica token provided"
)
Tip
We are using an invented header to simplify this example.
But in real cases you will get better results using the integrated
Security utilities
.
Another module with
APIRouter
Let's say you also have the endpoints dedicated to handling "items" from your application in the module at
app/routers/items.py
.
You have
path operations
for:
/items/
/items/{item_id}
It's all the same structure as with
app/routers/users.py
.
But we want to be smarter and simplify the code a bit.
We know all the
path operations
in this module have the same:
Path
prefix
:
/items
.
tags
: (just one tag:
items
).
Extra
responses
.
dependencies
: they all need that
X-Token
dependency we created.
So, instead of adding all that to each
path operation
, we can add it to the
APIRouter
.
app/routers/items.py
from
fastapi
import
APIRouter
,
Depends
,
HTTPException
from
..dependencies
import
get_token_header
router
=
APIRouter
(
prefix
=
"/items"
,
tags
=
[
"items"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
404
:
{
"description"
:
"Not found"
}},
)
fake_items_db
=
{
"plumbus"
:
{
"name"
:
"Plumbus"
},
"gun"
:
{
"name"
:
"Portal Gun"
}}
@router
.
get
(
"/"
)
async
def
read_items
():
return
fake_items_db
@router
.
get
(
"/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
fake_items_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"name"
:
fake_items_db
[
item_id
][
"name"
],
"item_id"
:
item_id
}
@router
.
put
(
"/
{item_id}
"
,
tags
=
[
"custom"
],
responses
=
{
403
:
{
"description"
:
"Operation forbidden"
}},
)
async
def
update_item
(
item_id
:
str
):
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
403
,
detail
=
"You can only update the item: plumbus"
)
return
{
"item_id"
:
item_id
,
"name"
:
"The great Plumbus"
}
As the path of each
path operation
has to start with
/
, like in:
@router
.
get
(
"/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
...
...the prefix must not include a final
/
.
So, the prefix in this case is
/items
.
We can also add a list of
tags
and extra
responses
that will be applied to all the
path operations
included in this router.
And we can add a list of
dependencies
that will be added to all the
path operations
in the router and will be executed/solved for each request made to them.
Tip
Note that, much like
dependencies in
path operation decorators
, no value will be passed to your
path operation function
.
The end result is that the item paths are now:
/items/
/items/{item_id}
...as we intended.
They will be marked with a list of tags that contain a single string
"items"
.
These "tags" are especially useful for the automatic interactive documentation systems (using OpenAPI).
All of them will include the predefined
responses
.
All these
path operations
will have the list of
dependencies
evaluated/executed before them.
If you also declare dependencies in a specific
path operation
,
they will be executed too
.
The router dependencies are executed first, then the
dependencies
in the decorator
, and then the normal parameter dependencies.
You can also add
Security
dependencies with
scopes
.
Tip
Having
dependencies
in the
APIRouter
can be used, for example, to require authentication for a whole group of
path operations
. Even if the dependencies are not added individually to each one of them.
Check
The
prefix
,
tags
,
responses
, and
dependencies
parameters are (as in many other cases) just a feature from
FastAPI
to help you avoid code duplication.
Import the dependencies
This code lives in the module
app.routers.items
, the file
app/routers/items.py
.
And we need to get the dependency function from the module
app.dependencies
, the file
app/dependencies.py
.
So we use a relative import with
..
for the dependencies:
app/routers/items.py
from
fastapi
import
APIRouter
,
Depends
,
HTTPException
from
..dependencies
import
get_token_header
router
=
APIRouter
(
prefix
=
"/items"
,
tags
=
[
"items"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
404
:
{
"description"
:
"Not found"
}},
)
fake_items_db
=
{
"plumbus"
:
{
"name"
:
"Plumbus"
},
"gun"
:
{
"name"
:
"Portal Gun"
}}
@router
.
get
(
"/"
)
async
def
read_items
():
return
fake_items_db
@router
.
get
(
"/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
fake_items_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"name"
:
fake_items_db
[
item_id
][
"name"
],
"item_id"
:
item_id
}
@router
.
put
(
"/
{item_id}
"
,
tags
=
[
"custom"
],
responses
=
{
403
:
{
"description"
:
"Operation forbidden"
}},
)
async
def
update_item
(
item_id
:
str
):
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
403
,
detail
=
"You can only update the item: plumbus"
)
return
{
"item_id"
:
item_id
,
"name"
:
"The great Plumbus"
}
How relative imports work
Tip
If you know perfectly how imports work, continue to the next section below.
A single dot
.
, like in:
from
.dependencies
import
get_token_header
would mean:
Starting in the same package that this module (the file
app/routers/items.py
) lives in (the directory
app/routers/
)...
find the module
dependencies
(an imaginary file at
app/routers/dependencies.py
)...
and from it, import the function
get_token_header
.
But that file doesn't exist, our dependencies are in a file at
app/dependencies.py
.
Remember how our app/file structure looks like:
The two dots
..
, like in:
from
..dependencies
import
get_token_header
mean:
Starting in the same package that this module (the file
app/routers/items.py
) lives in (the directory
app/routers/
)...
go to the parent package (the directory
app/
)...
and in there, find the module
dependencies
(the file at
app/dependencies.py
)...
and from it, import the function
get_token_header
.
That works correctly! üéâ
The same way, if we had used three dots
...
, like in:
from
...dependencies
import
get_token_header
that would mean:
Starting in the same package that this module (the file
app/routers/items.py
) lives in (the directory
app/routers/
)...
go to the parent package (the directory
app/
)...
then go to the parent of that package (there's no parent package,
app
is the top level üò±)...
and in there, find the module
dependencies
(the file at
app/dependencies.py
)...
and from it, import the function
get_token_header
.
That would refer to some package above
app/
, with its own file
__init__.py
, etc. But we don't have that. So, that would throw an error in our example. üö®
But now you know how it works, so you can use relative imports in your own apps no matter how complex they are. ü§ì
Add some custom
tags
,
responses
, and
dependencies
We are not adding the prefix
/items
nor the
tags=["items"]
to each
path operation
because we added them to the
APIRouter
.
But we can still add
more
tags
that will be applied to a specific
path operation
, and also some extra
responses
specific to that
path operation
:
app/routers/items.py
from
fastapi
import
APIRouter
,
Depends
,
HTTPException
from
..dependencies
import
get_token_header
router
=
APIRouter
(
prefix
=
"/items"
,
tags
=
[
"items"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
404
:
{
"description"
:
"Not found"
}},
)
fake_items_db
=
{
"plumbus"
:
{
"name"
:
"Plumbus"
},
"gun"
:
{
"name"
:
"Portal Gun"
}}
@router
.
get
(
"/"
)
async
def
read_items
():
return
fake_items_db
@router
.
get
(
"/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
fake_items_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"name"
:
fake_items_db
[
item_id
][
"name"
],
"item_id"
:
item_id
}
@router
.
put
(
"/
{item_id}
"
,
tags
=
[
"custom"
],
responses
=
{
403
:
{
"description"
:
"Operation forbidden"
}},
)
async
def
update_item
(
item_id
:
str
):
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
403
,
detail
=
"You can only update the item: plumbus"
)
return
{
"item_id"
:
item_id
,
"name"
:
"The great Plumbus"
}
Tip
This last path operation will have the combination of tags:
["items", "custom"]
.
And it will also have both responses in the documentation, one for
404
and one for
403
.
The main
FastAPI
Now, let's see the module at
app/main.py
.
Here's where you import and use the class
FastAPI
.
This will be the main file in your application that ties everything together.
And as most of your logic will now live in its own specific module, the main file will be quite simple.
Import
FastAPI
You import and create a
FastAPI
class as normally.
And we can even declare
global dependencies
that will be combined with the dependencies for each
APIRouter
:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
Import the
APIRouter
Now we import the other submodules that have
APIRouter
s:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
As the files
app/routers/users.py
and
app/routers/items.py
are submodules that are part of the same Python package
app
, we can use a single dot
.
to import them using "relative imports".
How the importing works
The section:
from
.routers
import
items
,
users
means:
Starting in the same package that this module (the file
app/main.py
) lives in (the directory
app/
)...
look for the subpackage
routers
(the directory at
app/routers/
)...
and from it, import the submodule
items
(the file at
app/routers/items.py
) and
users
(the file at
app/routers/users.py
)...
The module
items
will have a variable
router
(
items.router
). This is the same one we created in the file
app/routers/items.py
, it's an
APIRouter
object.
And then we do the same for the module
users
.
We could also import them like:
from
app.routers
import
items
,
users
Info
The first version is a "relative import":
from
.routers
import
items
,
users
The second version is an "absolute import":
from
app.routers
import
items
,
users
To learn more about Python Packages and Modules, read
the official Python documentation about Modules
.
Avoid name collisions
We are importing the submodule
items
directly, instead of importing just its variable
router
.
This is because we also have another variable named
router
in the submodule
users
.
If we had imported one after the other, like:
from
.routers.items
import
router
from
.routers.users
import
router
the
router
from
users
would overwrite the one from
items
and we wouldn't be able to use them at the same time.
So, to be able to use both of them in the same file, we import the submodules directly:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
Include the
APIRouter
s for
users
and
items
Now, let's include the
router
s from the submodules
users
and
items
:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
Info
users.router
contains the
APIRouter
inside of the file
app/routers/users.py
.
And
items.router
contains the
APIRouter
inside of the file
app/routers/items.py
.
With
app.include_router()
we can add each
APIRouter
to the main
FastAPI
application.
It will include all the routes from that router as part of it.
Technical Details
It will actually internally create a
path operation
for each
path operation
that was declared in the
APIRouter
.
So, behind the scenes, it will actually work as if everything was the same single app.
Check
You don't have to worry about performance when including routers.
This will take microseconds and will only happen at startup.
So it won't affect performance. ‚ö°
Include an
APIRouter
with a custom
prefix
,
tags
,
responses
, and
dependencies
Now, let's imagine your organization gave you the
app/internal/admin.py
file.
It contains an
APIRouter
with some admin
path operations
that your organization shares between several projects.
For this example it will be super simple. But let's say that because it is shared with other projects in the organization, we cannot modify it and add a
prefix
,
dependencies
,
tags
, etc. directly to the
APIRouter
:
app/internal/admin.py
from
fastapi
import
APIRouter
router
=
APIRouter
()
@router
.
post
(
"/"
)
async
def
update_admin
():
return
{
"message"
:
"Admin getting schwifty"
}
But we still want to set a custom
prefix
when including the
APIRouter
so that all its
path operations
start with
/admin
, we want to secure it with the
dependencies
we already have for this project, and we want to include
tags
and
responses
.
We can declare all that without having to modify the original
APIRouter
by passing those parameters to
app.include_router()
:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
That way, the original
APIRouter
will stay unmodified, so we can still share that same
app/internal/admin.py
file with other projects in the organization.
The result is that in our app, each of the
path operations
from the
admin
module will have:
The prefix
/admin
.
The tag
admin
.
The dependency
get_token_header
.
The response
418
. üçµ
But that will only affect that
APIRouter
in our app, not in any other code that uses it.
So, for example, other projects could use the same
APIRouter
with a different authentication method.
Include a
path operation
We can also add
path operations
directly to the
FastAPI
app.
Here we do it... just to show that we can ü§∑:
app/main.py
from
fastapi
import
Depends
,
FastAPI
from
.dependencies
import
get_query_token
,
get_token_header
from
.internal
import
admin
from
.routers
import
items
,
users
app
=
FastAPI
(
dependencies
=
[
Depends
(
get_query_token
)])
app
.
include_router
(
users
.
router
)
app
.
include_router
(
items
.
router
)
app
.
include_router
(
admin
.
router
,
prefix
=
"/admin"
,
tags
=
[
"admin"
],
dependencies
=
[
Depends
(
get_token_header
)],
responses
=
{
418
:
{
"description"
:
"I'm a teapot"
}},
)
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello Bigger Applications!"
}
and it will work correctly, together with all the other
path operations
added with
app.include_router()
.
Very Technical Details
Note
: this is a very technical detail that you probably can
just skip
.
The
APIRouter
s are not "mounted", they are not isolated from the rest of the application.
This is because we want to include their
path operations
in the OpenAPI schema and the user interfaces.
As we cannot just isolate them and "mount" them independently of the rest, the
path operations
are "cloned" (re-created), not included directly.
Check the automatic API docs
Now, run your app:
fast ‚Üí
fastapi dev app/main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
And open the docs at
http://127.0.0.1:8000/docs
.
You will see the automatic API docs, including the paths from all the submodules, using the correct paths (and prefixes) and the correct tags:
Include the same router multiple times with different
prefix
You can also use
.include_router()
multiple times with the
same
router using different prefixes.
This could be useful, for example, to expose the same API under different prefixes, e.g.
/api/v1
and
/api/latest
.
This is an advanced usage that you might not really need, but it's there in case you do.
Include an
APIRouter
in another
The same way you can include an
APIRouter
in a
FastAPI
application, you can include an
APIRouter
in another
APIRouter
using:
router
.
include_router
(
other_router
)
Make sure you do it before including
router
in the
FastAPI
app, so that the
path operations
from
other_router
are also included.

## 111_TUTORIAL_BODY_FIELDS
Body - Fields¬∂
---

Body - Fields
The same way you can declare additional validation and metadata in
path operation function
parameters with
Query
,
Path
and
Body
, you can declare validation and metadata inside of Pydantic models using Pydantic's
Field
.
Import
Field
First, you have to import it:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Warning
Notice that
Field
is imported directly from
pydantic
, not from
fastapi
as are all the rest (
Query
,
Path
,
Body
, etc).
Declare model attributes
You can then use
Field
with model attributes:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
title
=
"The description of the item"
,
max_length
=
300
)
price
:
float
=
Field
(
gt
=
0
,
description
=
"The price must be greater than zero"
)
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Field
works the same way as
Query
,
Path
and
Body
, it has all the same parameters, etc.
Technical Details
Actually,
Query
,
Path
and others you'll see next create objects of subclasses of a common
Param
class, which is itself a subclass of Pydantic's
FieldInfo
class.
And Pydantic's
Field
returns an instance of
FieldInfo
as well.
Body
also returns objects of a subclass of
FieldInfo
directly. And there are others you will see later that are subclasses of the
Body
class.
Remember that when you import
Query
,
Path
, and others from
fastapi
, those are actually functions that return special classes.
Tip
Notice how each model's attribute with a type, default value and
Field
has the same structure as a
path operation function's
parameter, with
Field
instead of
Path
,
Query
and
Body
.
Add extra information
You can declare extra information in
Field
,
Query
,
Body
, etc. And it will be included in the generated JSON Schema.
You will learn more about adding extra information later in the docs, when learning to declare examples.
Warning
Extra keys passed to
Field
will also be present in the resulting OpenAPI schema for your application.
As these keys may not necessarily be part of the OpenAPI specification, some OpenAPI tools, for example
the OpenAPI validator
, may not work with your generated schema.
Recap
You can use Pydantic's
Field
to declare extra validations and metadata for model attributes.
You can also use the extra keyword arguments to pass additional JSON Schema metadata.

## 112_TUTORIAL_BODY_MULTIPLE_PARAMS
Body - Multiple Parameters¬∂
---

Body - Multiple Parameters
Now that we have seen how to use
Path
and
Query
, let's see more advanced uses of request body declarations.
Mix
Path
,
Query
and body parameters
First, of course, you can mix
Path
,
Query
and request body parameter declarations freely and
FastAPI
will know what to do.
And you can also declare body parameters as optional, by setting the default to
None
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
)],
q
:
str
|
None
=
None
,
item
:
Item
|
None
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
item
:
results
.
update
({
"item"
:
item
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Path
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
)],
q
:
Union
[
str
,
None
]
=
None
,
item
:
Union
[
Item
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
item
:
results
.
update
({
"item"
:
item
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
)],
q
:
Union
[
str
,
None
]
=
None
,
item
:
Union
[
Item
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
item
:
results
.
update
({
"item"
:
item
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
),
q
:
str
|
None
=
None
,
item
:
Item
|
None
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
item
:
results
.
update
({
"item"
:
item
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
),
q
:
Union
[
str
,
None
]
=
None
,
item
:
Union
[
Item
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
item
:
results
.
update
({
"item"
:
item
})
return
results
Note
Notice that, in this case, the
item
that would be taken from the body is optional. As it has a
None
default value.
Multiple body parameters
In the previous example, the
path operations
would expect a JSON body with the attributes of an
Item
, like:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
}
But you can also declare multiple body parameters, e.g.
item
and
user
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
str
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
}
return
results
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
}
return
results
In this case,
FastAPI
will notice that there is more than one body parameter in the function (there are two parameters that are Pydantic models).
So, it will then use the parameter names as keys (field names) in the body, and expect a body like:
{
"item"
:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
},
"user"
:
{
"username"
:
"dave"
,
"full_name"
:
"Dave Grohl"
}
}
Note
Notice that even though the
item
was declared the same way as before, it is now expected to be inside of the body with a key
item
.
FastAPI
will do the automatic conversion from the request, so that the parameter
item
receives its specific content and the same for
user
.
It will perform the validation of the compound data, and will document it like that for the OpenAPI schema and automatic docs.
Singular values in body
The same way there is a
Query
and
Path
to define extra data for query and path parameters,
FastAPI
provides an equivalent
Body
.
For example, extending the previous model, you could decide that you want to have another key
importance
in the same body, besides the
item
and
user
.
If you declare it as is, because it is a singular value,
FastAPI
will assume that it is a query parameter.
But you can instruct
FastAPI
to treat it as another body key using
Body
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
str
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
()]
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
()]
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
()]
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
str
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
int
=
Body
()):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
int
=
Body
()):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
return
results
In this case,
FastAPI
will expect a body like:
{
"item"
:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
},
"user"
:
{
"username"
:
"dave"
,
"full_name"
:
"Dave Grohl"
},
"importance"
:
5
}
Again, it will convert the data types, validate, document, etc.
Multiple body params and query
Of course, you can also declare additional query parameters whenever you need, additional to any body parameters.
As, by default, singular values are interpreted as query parameters, you don't have to explicitly add a
Query
, you can just do:
q
:
Union
[
str
,
None
]
=
None
Or in Python 3.10 and above:
q
:
str
|
None
=
None
For example:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
str
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
(
gt
=
0
)],
q
:
str
|
None
=
None
,
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
(
gt
=
0
)],
q
:
Union
[
str
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
Annotated
[
int
,
Body
(
gt
=
0
)],
q
:
Union
[
str
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
str
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
int
=
Body
(
gt
=
0
),
q
:
str
|
None
=
None
,
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
full_name
:
Union
[
str
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
,
user
:
User
,
importance
:
int
=
Body
(
gt
=
0
),
q
:
Union
[
str
,
None
]
=
None
,
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
,
"user"
:
user
,
"importance"
:
importance
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Info
Body
also has all the same extra validation and metadata parameters as
Query
,
Path
and others you will see later.
Embed a single body parameter
Let's say you only have a single
item
body parameter from a Pydantic model
Item
.
By default,
FastAPI
will then expect its body directly.
But if you want it to expect a JSON with a key
item
and inside of it the model contents, as it does when you declare extra body parameters, you can use the special
Body
parameter
embed
:
item
:
Item
=
Body
(
embed
=
True
)
as in:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
embed
=
True
)]):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
embed
=
True
)):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
In this case
FastAPI
will expect a body like:
{
"item"
:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
}
}
instead of:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
}
Recap
You can add multiple body parameters to your
path operation function
, even though a request can only have a single body.
But
FastAPI
will handle it, give you the correct data in your function, and validate and document the correct schema in the
path operation
.
You can also declare singular values to be received as part of the body.
And you can instruct
FastAPI
to embed the body in a key even when there is only a single parameter declared.

## 113_TUTORIAL_BODY_NESTED_MODELS
Body - Nested Models¬∂
---

Body - Nested Models
With
FastAPI
, you can define, validate, document, and use arbitrarily deeply nested models (thanks to Pydantic).
List fields
You can define an attribute to be a subtype. For example, a Python
list
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
list
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
list
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
This will make
tags
be a list, although it doesn't declare the type of the elements of the list.
List fields with type parameter
But Python has a specific way to declare lists with internal types, or "type parameters":
Import typing's
List
In Python 3.9 and above you can use the standard
list
to declare these type annotations as we'll see below. üí°
But in Python versions before 3.9 (3.6 and above), you first need to import
List
from standard Python's
typing
module:
Python 3.8+
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
List
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.10+
Python 3.9+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
list
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
list
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Declare a
list
with a type parameter
To declare types that have type parameters (internal types), like
list
,
dict
,
tuple
:
If you are in a Python version lower than 3.9, import their equivalent version from the
typing
module
Pass the internal type(s) as "type parameters" using square brackets:
[
and
]
In Python 3.9 it would be:
my_list
:
list
[
str
]
In versions of Python before 3.9, it would be:
from
typing
import
List
my_list
:
List
[
str
]
That's all standard Python syntax for type declarations.
Use that same standard syntax for model attributes with internal types.
So, in our example, we can make
tags
be specifically a "list of strings":
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
list
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
list
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
List
[
str
]
=
[]
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Set types
But then we think about it, and realize that tags shouldn't repeat, they would probably be unique strings.
And Python has a special data type for sets of unique items, the
set
.
Then we can declare
tags
as a set of strings:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
With this, even if you receive a request with duplicate data, it will be converted to a set of unique items.
And whenever you output that data, even if the source had duplicates, it will be output as a set of unique items.
And it will be annotated / documented accordingly too.
Nested Models
Each attribute of a Pydantic model has a type.
But that type can itself be another Pydantic model.
So, you can declare deeply nested JSON "objects" with specific attribute names, types and validations.
All that, arbitrarily nested.
Define a submodel
For example, we can define an
Image
model:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
image
:
Image
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Use the submodel as a type
And then we can use it as the type of an attribute:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
image
:
Image
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
str
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
This would mean that
FastAPI
would expect a body similar to:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
,
"tags"
:
[
"rock"
,
"metal"
,
"bar"
],
"image"
:
{
"url"
:
"http://example.com/baz.jpg"
,
"name"
:
"The Foo live"
}
}
Again, doing just that declaration, with
FastAPI
you get:
Editor support (completion, etc.), even for nested models
Data conversion
Data validation
Automatic documentation
Special types and validation
Apart from normal singular types like
str
,
int
,
float
, etc. you can use more complex singular types that inherit from
str
.
To see all the options you have, checkout
Pydantic's Type Overview
. You will see some examples in the next chapter.
For example, as in the
Image
model we have a
url
field, we can declare it to be an instance of Pydantic's
HttpUrl
instead of a
str
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
image
:
Image
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
image
:
Union
[
Image
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
The string will be checked to be a valid URL, and documented in JSON Schema / OpenAPI as such.
Attributes with lists of submodels
You can also use Pydantic models as subtypes of
list
,
set
, etc.:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
images
:
list
[
Image
]
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
images
:
Union
[
list
[
Image
],
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
List
,
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
images
:
Union
[
List
[
Image
],
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
This will expect (convert, validate, document, etc.) a JSON body like:
{
"name"
:
"Foo"
,
"description"
:
"The pretender"
,
"price"
:
42.0
,
"tax"
:
3.2
,
"tags"
:
[
"rock"
,
"metal"
,
"bar"
],
"images"
:
[
{
"url"
:
"http://example.com/baz.jpg"
,
"name"
:
"The Foo live"
},
{
"url"
:
"http://example.com/dave.jpg"
,
"name"
:
"The Baz"
}
]
}
Info
Notice how the
images
key now has a list of image objects.
Deeply nested models
You can define arbitrarily deeply nested models:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
images
:
list
[
Image
]
|
None
=
None
class
Offer
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
items
:
list
[
Item
]
@app
.
post
(
"/offers/"
)
async
def
create_offer
(
offer
:
Offer
):
return
offer
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
images
:
Union
[
list
[
Image
],
None
]
=
None
class
Offer
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
items
:
list
[
Item
]
@app
.
post
(
"/offers/"
)
async
def
create_offer
(
offer
:
Offer
):
return
offer
from
typing
import
List
,
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
images
:
Union
[
List
[
Image
],
None
]
=
None
class
Offer
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
items
:
List
[
Item
]
@app
.
post
(
"/offers/"
)
async
def
create_offer
(
offer
:
Offer
):
return
offer
Info
Notice how
Offer
has a list of
Item
s, which in turn have an optional list of
Image
s
Bodies of pure lists
If the top level value of the JSON body you expect is a JSON
array
(a Python
list
), you can declare the type in the parameter of the function, the same as in Pydantic models:
images
:
List
[
Image
]
or in Python 3.9 and above:
images
:
list
[
Image
]
as in:
Python 3.9+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
@app
.
post
(
"/images/multiple/"
)
async
def
create_multiple_images
(
images
:
list
[
Image
]):
return
images
ü§ì Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
HttpUrl
app
=
FastAPI
()
class
Image
(
BaseModel
):
url
:
HttpUrl
name
:
str
@app
.
post
(
"/images/multiple/"
)
async
def
create_multiple_images
(
images
:
List
[
Image
]):
return
images
Editor support everywhere
And you get editor support everywhere.
Even for items inside of lists:
You couldn't get this kind of editor support if you were working directly with
dict
instead of Pydantic models.
But you don't have to worry about them either, incoming dicts are converted automatically and your output is converted automatically to JSON too.
Bodies of arbitrary
dict
s
You can also declare a body as a
dict
with keys of some type and values of some other type.
This way, you don't have to know beforehand what the valid field/attribute names are (as would be the case with Pydantic models).
This would be useful if you want to receive keys that you don't already know.
Another useful case is when you want to have keys of another type (e.g.,
int
).
That's what we are going to see here.
In this case, you would accept any
dict
as long as it has
int
keys with
float
values:
Python 3.9+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
post
(
"/index-weights/"
)
async
def
create_index_weights
(
weights
:
dict
[
int
,
float
]):
return
weights
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Dict
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
post
(
"/index-weights/"
)
async
def
create_index_weights
(
weights
:
Dict
[
int
,
float
]):
return
weights
Tip
Keep in mind that JSON only supports
str
as keys.
But Pydantic has automatic data conversion.
This means that, even though your API clients can only send strings as keys, as long as those strings contain pure integers, Pydantic will convert them and validate them.
And the
dict
you receive as
weights
will actually have
int
keys and
float
values.
Recap
With
FastAPI
you have the maximum flexibility provided by Pydantic models, while keeping your code simple, short and elegant.
But with all the benefits:
Editor support (completion everywhere!)
Data conversion (a.k.a. parsing / serialization)
Data validation
Schema documentation
Automatic docs

## 114_TUTORIAL_BODY_UPDATES
Body - Updates¬∂
---

Body - Updates
Update replacing with
PUT
To update an item you can use the
HTTP
PUT
operation.
You can use the
jsonable_encoder
to convert the input data to data that can be stored as JSON (e.g. with a NoSQL database). For example, converting
datetime
to
str
.
Python 3.10+
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
|
None
=
None
description
:
str
|
None
=
None
price
:
float
|
None
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
put
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
update_item_encoded
=
jsonable_encoder
(
item
)
items
[
item_id
]
=
update_item_encoded
return
update_item_encoded
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
put
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
update_item_encoded
=
jsonable_encoder
(
item
)
items
[
item_id
]
=
update_item_encoded
return
update_item_encoded
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
put
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
update_item_encoded
=
jsonable_encoder
(
item
)
items
[
item_id
]
=
update_item_encoded
return
update_item_encoded
PUT
is used to receive data that should replace the existing data.
Warning about replacing
That means that if you want to update the item
bar
using
PUT
with a body containing:
{
"name"
:
"Barz"
,
"price"
:
3
,
"description"
:
None
,
}
because it doesn't include the already stored attribute
"tax": 20.2
, the input model would take the default value of
"tax": 10.5
.
And the data would be saved with that "new"
tax
of
10.5
.
Partial updates with
PATCH
You can also use the
HTTP
PATCH
operation to
partially
update data.
This means that you can send only the data that you want to update, leaving the rest intact.
Note
PATCH
is less commonly used and known than
PUT
.
And many teams use only
PUT
, even for partial updates.
You are
free
to use them however you want,
FastAPI
doesn't impose any restrictions.
But this guide shows you, more or less, how they are intended to be used.
Using Pydantic's
exclude_unset
parameter
If you want to receive partial updates, it's very useful to use the parameter
exclude_unset
in Pydantic's model's
.model_dump()
.
Like
item.model_dump(exclude_unset=True)
.
Info
In Pydantic v1 the method was called
.dict()
, it was deprecated (but still supported) in Pydantic v2, and renamed to
.model_dump()
.
The examples here use
.dict()
for compatibility with Pydantic v1, but you should use
.model_dump()
instead if you can use Pydantic v2.
That would generate a
dict
with only the data that was set when creating the
item
model, excluding default values.
Then you can use this to generate a
dict
with only the data that was set (sent in the request), omitting default values:
Python 3.10+
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
|
None
=
None
description
:
str
|
None
=
None
price
:
float
|
None
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
Using Pydantic's
update
parameter
Now, you can create a copy of the existing model using
.model_copy()
, and pass the
update
parameter with a
dict
containing the data to update.
Info
In Pydantic v1 the method was called
.copy()
, it was deprecated (but still supported) in Pydantic v2, and renamed to
.model_copy()
.
The examples here use
.copy()
for compatibility with Pydantic v1, but you should use
.model_copy()
instead if you can use Pydantic v2.
Like
stored_item_model.model_copy(update=update_data)
:
Python 3.10+
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
|
None
=
None
description
:
str
|
None
=
None
price
:
float
|
None
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
Partial updates recap
In summary, to apply partial updates you would:
(Optionally) use
PATCH
instead of
PUT
.
Retrieve the stored data.
Put that data in a Pydantic model.
Generate a
dict
without default values from the input model (using
exclude_unset
).
This way you can update only the values actually set by the user, instead of overriding values already stored with default values in your model.
Create a copy of the stored model, updating its attributes with the received partial updates (using the
update
parameter).
Convert the copied model to something that can be stored in your DB (for example, using the
jsonable_encoder
).
This is comparable to using the model's
.model_dump()
method again, but it makes sure (and converts) the values to data types that can be converted to JSON, for example,
datetime
to
str
.
Save the data to your DB.
Return the updated model.
Python 3.10+
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
|
None
=
None
description
:
str
|
None
=
None
price
:
float
|
None
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
Union
[
str
,
None
]
=
None
description
:
Union
[
str
,
None
]
=
None
price
:
Union
[
float
,
None
]
=
None
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
patch
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
update_item
(
item_id
:
str
,
item
:
Item
):
stored_item_data
=
items
[
item_id
]
stored_item_model
=
Item
(
**
stored_item_data
)
update_data
=
item
.
dict
(
exclude_unset
=
True
)
updated_item
=
stored_item_model
.
copy
(
update
=
update_data
)
items
[
item_id
]
=
jsonable_encoder
(
updated_item
)
return
updated_item
Tip
You can actually use this same technique with an HTTP
PUT
operation.
But the example here uses
PATCH
because it was created for these use cases.
Note
Notice that the input model is still validated.
So, if you want to receive partial updates that can omit all the attributes, you need to have a model with all the attributes marked as optional (with default values or
None
).
To distinguish from the models with all optional values for
updates
and models with required values for
creation
, you can use the ideas described in
Extra Models
.

## 115_TUTORIAL_BODY
Request Body¬∂
---

Request Body
When you need to send data from a client (let's say, a browser) to your API, you send it as a
request body
.
A
request
body is data sent by the client to your API. A
response
body is the data your API sends to the client.
Your API almost always has to send a
response
body. But clients don't necessarily need to send
request bodies
all the time, sometimes they only request a path, maybe with some query parameters, but don't send a body.
To declare a
request
body, you use
Pydantic
models with all their power and benefits.
Info
To send data, you should use one of:
POST
(the more common),
PUT
,
DELETE
or
PATCH
.
Sending a body with a
GET
request has an undefined behavior in the specifications, nevertheless, it is supported by FastAPI, only for very complex/extreme use cases.
As it is discouraged, the interactive docs with Swagger UI won't show the documentation for the body when using
GET
, and proxies in the middle might not support it.
Import Pydantic's
BaseModel
First, you need to import
BaseModel
from
pydantic
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
Create your data model
Then you declare your data model as a class that inherits from
BaseModel
.
Use standard Python types for all the attributes:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
The same as when declaring query parameters, when a model attribute has a default value, it is not required. Otherwise, it is required. Use
None
to make it just optional.
For example, this model above declares a JSON "
object
" (or Python
dict
) like:
{
"name"
:
"Foo"
,
"description"
:
"An optional description"
,
"price"
:
45.2
,
"tax"
:
3.5
}
...as
description
and
tax
are optional (with a default value of
None
), this JSON "
object
" would also be valid:
{
"name"
:
"Foo"
,
"price"
:
45.2
}
Declare it as a parameter
To add it to your
path operation
, declare it the same way you declared path and query parameters:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
...and declare its type as the model you created,
Item
.
Results
With just that Python type declaration,
FastAPI
will:
Read the body of the request as JSON.
Convert the corresponding types (if needed).
Validate the data.
If the data is invalid, it will return a nice and clear error, indicating exactly where and what was the incorrect data.
Give you the received data in the parameter
item
.
As you declared it in the function to be of type
Item
, you will also have all the editor support (completion, etc) for all of the attributes and their types.
Generate
JSON Schema
definitions for your model, you can also use them anywhere else you like if it makes sense for your project.
Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation
UIs
.
Automatic docs
The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs:
And will also be used in the API docs inside each
path operation
that needs them:
Editor support
In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a
dict
instead of a Pydantic model):
You also get error checks for incorrect type operations:
This is not by chance, the whole framework was built around that design.
And it was thoroughly tested at the design phase, before any implementation, to ensure it would work with all the editors.
There were even some changes to Pydantic itself to support this.
The previous screenshots were taken with
Visual Studio Code
.
But you would get the same editor support with
PyCharm
and most of the other Python editors:
Tip
If you use
PyCharm
as your editor, you can use the
Pydantic PyCharm Plugin
.
It improves editor support for Pydantic models, with:
auto-completion
type checks
refactoring
searching
inspections
Use the model
Inside of the function, you can access all the attributes of the model object directly:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
item_dict
=
item
.
dict
()
if
item
.
tax
is
not
None
:
price_with_tax
=
item
.
price
+
item
.
tax
item_dict
.
update
({
"price_with_tax"
:
price_with_tax
})
return
item_dict
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
item_dict
=
item
.
dict
()
if
item
.
tax
is
not
None
:
price_with_tax
=
item
.
price
+
item
.
tax
item_dict
.
update
({
"price_with_tax"
:
price_with_tax
})
return
item_dict
Request body + path parameters
You can declare path parameters and request body at the same time.
FastAPI
will recognize that the function parameters that match path parameters should be
taken from the path
, and that function parameters that are declared to be Pydantic models should be
taken from the request body
.
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_id"
:
item_id
,
**
item
.
dict
()}
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_id"
:
item_id
,
**
item
.
dict
()}
Request body + path + query parameters
You can also declare
body
,
path
and
query
parameters, all at the same time.
FastAPI
will recognize each of them and take the data from the correct place.
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
q
:
str
|
None
=
None
):
result
=
{
"item_id"
:
item_id
,
**
item
.
dict
()}
if
q
:
result
.
update
({
"q"
:
q
})
return
result
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
,
q
:
Union
[
str
,
None
]
=
None
):
result
=
{
"item_id"
:
item_id
,
**
item
.
dict
()}
if
q
:
result
.
update
({
"q"
:
q
})
return
result
The function parameters will be recognized as follows:
If the parameter is also declared in the
path
, it will be used as a path parameter.
If the parameter is of a
singular type
(like
int
,
float
,
str
,
bool
, etc) it will be interpreted as a
query
parameter.
If the parameter is declared to be of the type of a
Pydantic model
, it will be interpreted as a request
body
.
Note
FastAPI will know that the value of
q
is not required because of the default value
= None
.
The
str | None
(Python 3.10+) or
Union
in
Union[str, None]
(Python 3.8+) is not used by FastAPI to determine that the value is not required, it will know it's not required because it has a default value of
= None
.
But adding the type annotations will allow your editor to give you better support and detect errors.
Without Pydantic
If you don't want to use Pydantic models, you can also use
Body
parameters. See the docs for
Body - Multiple Parameters: Singular values in body
.

## 116_TUTORIAL_COOKIE_PARAM_MODELS
Cookie Parameter Models¬∂
---

Cookie Parameter Models
If you have a group of
cookies
that are related, you can create a
Pydantic model
to declare them. üç™
This would allow you to
re-use the model
in
multiple places
and also to declare validations and metadata for all the parameters at once. üòé
Note
This is supported since FastAPI version
0.115.0
. ü§ì
Tip
This same technique applies to
Query
,
Cookie
, and
Header
. üòé
Cookies with a Pydantic Model
Declare the
cookie
parameters that you need in a
Pydantic model
, and then declare the parameter as
Cookie
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
str
|
None
=
None
googall_tracker
:
str
|
None
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
str
|
None
=
None
googall_tracker
:
str
|
None
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Cookies
=
Cookie
()):
return
cookies
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Cookies
=
Cookie
()):
return
cookies
FastAPI
will
extract
the data for
each field
from the
cookies
received in the request and give you the Pydantic model you defined.
Check the Docs
You can see the defined cookies in the docs UI at
/docs
:
Info
Have in mind that, as
browsers handle cookies
in special ways and behind the scenes, they
don't
easily allow
JavaScript
to touch them.
If you go to the
API docs UI
at
/docs
you will be able to see the
documentation
for cookies for your
path operations
.
But even if you
fill the data
and click "Execute", because the docs UI works with
JavaScript
, the cookies won't be sent, and you will see an
error
message as if you didn't write any values.
Forbid Extra Cookies
In some special use cases (probably not very common), you might want to
restrict
the cookies that you want to receive.
Your API now has the power to control its own
cookie consent
. ü§™üç™
You can use Pydantic's model configuration to
forbid
any
extra
fields:
Python 3.9+
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
ü§ì Other versions and variants
Python 3.10+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
session_id
:
str
fatebook_tracker
:
str
|
None
=
None
googall_tracker
:
str
|
None
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Annotated
[
Cookies
,
Cookie
()]):
return
cookies
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
session_id
:
str
fatebook_tracker
:
str
|
None
=
None
googall_tracker
:
str
|
None
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Cookies
=
Cookie
()):
return
cookies
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Cookies
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
session_id
:
str
fatebook_tracker
:
Union
[
str
,
None
]
=
None
googall_tracker
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/"
)
async
def
read_items
(
cookies
:
Cookies
=
Cookie
()):
return
cookies
If a client tries to send some
extra cookies
, they will receive an
error
response.
Poor cookie banners with all their effort to get your consent for the
API to reject it
. üç™
For example, if the client tries to send a
santa_tracker
cookie with a value of
good-list-please
, the client will receive an
error
response telling them that the
santa_tracker
cookie is not allowed
:
{
"detail"
:
[
{
"type"
:
"extra_forbidden"
,
"loc"
:
[
"cookie"
,
"santa_tracker"
],
"msg"
:
"Extra inputs are not permitted"
,
"input"
:
"good-list-please"
,
}
]
}
Summary
You can use
Pydantic models
to declare
cookies
in
FastAPI
. üòé

## 117_TUTORIAL_COOKIE_PARAMS
Cookie Parameters¬∂
---

Cookie Parameters
You can define Cookie parameters the same way you define
Query
and
Path
parameters.
Import
Cookie
First import
Cookie
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
str
|
None
=
Cookie
(
default
=
None
)):
return
{
"ads_id"
:
ads_id
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
)):
return
{
"ads_id"
:
ads_id
}
Declare
Cookie
parameters
Then declare the cookie parameters using the same structure as with
Path
and
Query
.
You can define the default value as well as all the extra validation or annotation parameters:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
):
return
{
"ads_id"
:
ads_id
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
str
|
None
=
Cookie
(
default
=
None
)):
return
{
"ads_id"
:
ads_id
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
ads_id
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
)):
return
{
"ads_id"
:
ads_id
}
Technical Details
Cookie
is a "sister" class of
Path
and
Query
. It also inherits from the same common
Param
class.
But remember that when you import
Query
,
Path
,
Cookie
and others from
fastapi
, those are actually functions that return special classes.
Info
To declare cookies, you need to use
Cookie
, because otherwise the parameters would be interpreted as query parameters.
Recap
Declare cookies with
Cookie
, using the same common pattern as
Query
and
Path
.

## 118_TUTORIAL_CORS
CORS (Cross-Origin Resource Sharing)¬∂
---

CORS (Cross-Origin Resource Sharing)
CORS or "Cross-Origin Resource Sharing"
refers to the situations when a frontend running in a browser has JavaScript code that communicates with a backend, and the backend is in a different "origin" than the frontend.
Origin
An origin is the combination of protocol (
http
,
https
), domain (
myapp.com
,
localhost
,
localhost.tiangolo.com
), and port (
80
,
443
,
8080
).
So, all these are different origins:
http://localhost
https://localhost
http://localhost:8080
Even if they are all in
localhost
, they use different protocols or ports, so, they are different "origins".
Steps
So, let's say you have a frontend running in your browser at
http://localhost:8080
, and its JavaScript is trying to communicate with a backend running at
http://localhost
(because we don't specify a port, the browser will assume the default port
80
).
Then, the browser will send an HTTP
OPTIONS
request to the
:80
-backend, and if the backend sends the appropriate headers authorizing the communication from this different origin (
http://localhost:8080
) then the
:8080
-browser will let the JavaScript in the frontend send its request to the
:80
-backend.
To achieve this, the
:80
-backend must have a list of "allowed origins".
In this case, the list would have to include
http://localhost:8080
for the
:8080
-frontend to work correctly.
Wildcards
It's also possible to declare the list as
"*"
(a "wildcard") to say that all are allowed.
But that will only allow certain types of communication, excluding everything that involves credentials: Cookies, Authorization headers like those used with Bearer Tokens, etc.
So, for everything to work correctly, it's better to specify explicitly the allowed origins.
Use
CORSMiddleware
You can configure it in your
FastAPI
application using the
CORSMiddleware
.
Import
CORSMiddleware
.
Create a list of allowed origins (as strings).
Add it as a "middleware" to your
FastAPI
application.
You can also specify whether your backend allows:
Credentials (Authorization headers, Cookies, etc).
Specific HTTP methods (
POST
,
PUT
) or all of them with the wildcard
"*"
.
Specific HTTP headers or all of them with the wildcard
"*"
.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.middleware.cors
import
CORSMiddleware
app
=
FastAPI
()
origins
=
[
"http://localhost.tiangolo.com"
,
"https://localhost.tiangolo.com"
,
"http://localhost"
,
"http://localhost:8080"
,
]
app
.
add_middleware
(
CORSMiddleware
,
allow_origins
=
origins
,
allow_credentials
=
True
,
allow_methods
=
[
"*"
],
allow_headers
=
[
"*"
],
)
@app
.
get
(
"/"
)
async
def
main
():
return
{
"message"
:
"Hello World"
}
The default parameters used by the
CORSMiddleware
implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context.
The following arguments are supported:
allow_origins
- A list of origins that should be permitted to make cross-origin requests. E.g.
['https://example.org', 'https://www.example.org']
. You can use
['*']
to allow any origin.
allow_origin_regex
- A regex string to match against origins that should be permitted to make cross-origin requests. e.g.
'https://.*\.example\.org'
.
allow_methods
- A list of HTTP methods that should be allowed for cross-origin requests. Defaults to
['GET']
. You can use
['*']
to allow all standard methods.
allow_headers
- A list of HTTP request headers that should be supported for cross-origin requests. Defaults to
[]
. You can use
['*']
to allow all headers. The
Accept
,
Accept-Language
,
Content-Language
and
Content-Type
headers are always allowed for
simple CORS requests
.
allow_credentials
- Indicate that cookies should be supported for cross-origin requests. Defaults to
False
.
None of
allow_origins
,
allow_methods
and
allow_headers
can be set to
['*']
if
allow_credentials
is set to
True
. All of them must be
explicitly specified
.
expose_headers
- Indicate any response headers that should be made accessible to the browser. Defaults to
[]
.
max_age
- Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to
600
.
The middleware responds to two particular types of HTTP request...
CORS preflight requests
These are any
OPTIONS
request with
Origin
and
Access-Control-Request-Method
headers.
In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a
200
or
400
response for informational purposes.
Simple requests
Any request with an
Origin
header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.
More info
For more info about
CORS
, check the
Mozilla CORS documentation
.
Technical Details
You could also use
from starlette.middleware.cors import CORSMiddleware
.
FastAPI
provides several middlewares in
fastapi.middleware
just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette.

## 119_TUTORIAL_DEBUGGING
Debugging¬∂
---

Debugging
You can connect the debugger in your editor, for example with Visual Studio Code or PyCharm.
Call
uvicorn
In your FastAPI application, import and run
uvicorn
directly:
Python 3.8+
import
uvicorn
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
root
():
a
=
"a"
b
=
"b"
+
a
return
{
"hello world"
:
b
}
if
__name__
==
"__main__"
:
uvicorn
.
run
(
app
,
host
=
"0.0.0.0"
,
port
=
8000
)
About
__name__ == "__main__"
The main purpose of the
__name__ == "__main__"
is to have some code that is executed when your file is called with:
fast ‚Üí
python myapp.py
restart ‚Üª
but is not called when another file imports it, like in:
from
myapp
import
app
More details
Let's say your file is named
myapp.py
.
If you run it with:
fast ‚Üí
python myapp.py
restart ‚Üª
then the internal variable
__name__
in your file, created automatically by Python, will have as value the string
"__main__"
.
So, the section:
uvicorn
.
run
(
app
,
host
=
"0.0.0.0"
,
port
=
8000
)
will run.
This won't happen if you import that module (file).
So, if you have another file
importer.py
with:
from
myapp
import
app
## Some more code
in that case, the automatically created variable inside of
myapp.py
will not have the variable
__name__
with a value of
"__main__"
.
So, the line:
uvicorn
.
run
(
app
,
host
=
"0.0.0.0"
,
port
=
8000
)
will not be executed.
Info
For more information, check
the official Python docs
.
Run your code with your debugger
Because you are running the Uvicorn server directly from your code, you can call your Python program (your FastAPI application) directly from the debugger.
For example, in Visual Studio Code, you can:
Go to the "Debug" panel.
"Add configuration...".
Select "Python"
Run the debugger with the option "
Python: Current File (Integrated Terminal)
".
It will then start the server with your
FastAPI
code, stop at your breakpoints, etc.
Here's how it might look:
If you use Pycharm, you can:
Open the "Run" menu.
Select the option "Debug...".
Then a context menu shows up.
Select the file to debug (in this case,
main.py
).
It will then start the server with your
FastAPI
code, stop at your breakpoints, etc.
Here's how it might look:

## 120_TUTORIAL_DEPENDENCIES
Dependencies¬∂
---

Dependencies
FastAPI
has a very powerful but intuitive
Dependency Injection
system.
It is designed to be very simple to use, and to make it very easy for any developer to integrate other components with
FastAPI
.
What is "Dependency Injection"
"Dependency Injection"
means, in programming, that there is a way for your code (in this case, your
path operation functions
) to declare things that it requires to work and use: "dependencies".
And then, that system (in this case
FastAPI
) will take care of doing whatever is needed to provide your code with those needed dependencies ("inject" the dependencies).
This is very useful when you need to:
Have shared logic (the same code logic again and again).
Share database connections.
Enforce security, authentication, role requirements, etc.
And many other things...
All these, while minimizing code repetition.
First Steps
Let's see a very simple example. It will be so simple that it is not very useful, for now.
But this way we can focus on how the
Dependency Injection
system works.
Create a dependency, or "dependable"
Let's first focus on the dependency.
It is just a function that can take all the same parameters that a
path operation function
can take:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
That's it.
2 lines
.
And it has the same shape and structure that all your
path operation functions
have.
You can think of it as a
path operation function
without the "decorator" (without the
@app.get("/some-path")
).
And it can return anything you want.
In this case, this dependency expects:
An optional query parameter
q
that is a
str
.
An optional query parameter
skip
that is an
int
, and by default is
0
.
An optional query parameter
limit
that is an
int
, and by default is
100
.
And then it just returns a
dict
containing those values.
Info
FastAPI added support for
Annotated
(and started recommending it) in version 0.95.0.
If you have an older version, you would get errors when trying to use
Annotated
.
Make sure you
Upgrade the FastAPI version
to at least 0.95.1 before using
Annotated
.
Import
Depends
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Declare the dependency, in the "dependant"
The same way you use
Body
,
Query
, etc. with your
path operation function
parameters, use
Depends
with a new parameter:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Although you use
Depends
in the parameters of your function the same way you use
Body
,
Query
, etc,
Depends
works a bit differently.
You only give
Depends
a single parameter.
This parameter must be something like a function.
You
don't call it
directly (don't add the parenthesis at the end), you just pass it as a parameter to
Depends()
.
And that function takes parameters in the same way that
path operation functions
do.
Tip
You'll see what other "things", apart from functions, can be used as dependencies in the next chapter.
Whenever a new request arrives,
FastAPI
will take care of:
Calling your dependency ("dependable") function with the correct parameters.
Get the result from your function.
Assign that result to the parameter in your
path operation function
.
This way you write shared code once and
FastAPI
takes care of calling it for your
path operations
.
Check
Notice that you don't have to create a special class and pass it somewhere to
FastAPI
to "register" it or anything similar.
You just pass it to
Depends
and
FastAPI
knows how to do the rest.
Share
Annotated
dependencies
In the examples above, you see that there's a tiny bit of
code duplication
.
When you need to use the
common_parameters()
dependency, you have to write the whole parameter with the type annotation and
Depends()
:
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]
But because we are using
Annotated
, we can store that
Annotated
value in a variable and use it in multiple places:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
CommonsDep
=
Annotated
[
dict
,
Depends
(
common_parameters
)]
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonsDep
):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
CommonsDep
):
return
commons
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
CommonsDep
=
Annotated
[
dict
,
Depends
(
common_parameters
)]
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonsDep
):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
CommonsDep
):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
CommonsDep
=
Annotated
[
dict
,
Depends
(
common_parameters
)]
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonsDep
):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
CommonsDep
):
return
commons
Tip
This is just standard Python, it's called a "type alias", it's actually not specific to
FastAPI
.
But because
FastAPI
is based on the Python standards, including
Annotated
, you can use this trick in your code. üòé
The dependencies will keep working as expected, and the
best part
is that the
type information will be preserved
, which means that your editor will be able to keep providing you with
autocompletion
,
inline errors
, etc. The same for other tools like
mypy
.
This will be especially useful when you use it in a
large code base
where you use
the same dependencies
over and over again in
many
path operations
.
To
async
or not to
async
As dependencies will also be called by
FastAPI
(the same as your
path operation functions
), the same rules apply while defining your functions.
You can use
async def
or normal
def
.
And you can declare dependencies with
async def
inside of normal
def
path operation functions
, or
def
dependencies inside of
async def
path operation functions
, etc.
It doesn't matter.
FastAPI
will know what to do.
Note
If you don't know, check the
Async:
"In a hurry?"
section about
async
and
await
in the docs.
Integrated with OpenAPI
All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema.
So, the interactive docs will have all the information from these dependencies too:
Simple usage
If you look at it,
path operation functions
are declared to be used whenever a
path
and
operation
matches, and then
FastAPI
takes care of calling the function with the correct parameters, extracting the data from the request.
Actually, all (or most) of the web frameworks work in this same way.
You never call those functions directly. They are called by your framework (in this case,
FastAPI
).
With the Dependency Injection system, you can also tell
FastAPI
that your
path operation function
also "depends" on something else that should be executed before your
path operation function
, and
FastAPI
will take care of executing it and "injecting" the results.
Other common terms for this same idea of "dependency injection" are:
resources
providers
services
injectables
components
FastAPI
plug-ins
Integrations and "plug-ins" can be built using the
Dependency Injection
system. But in fact, there is actually
no need to create "plug-ins"
, as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your
path operation functions
.
And dependencies can be created in a very simple and intuitive way that allows you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code,
literally
.
You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc.
FastAPI
compatibility
The simplicity of the dependency injection system makes
FastAPI
compatible with:
all the relational databases
NoSQL databases
external packages
external APIs
authentication and authorization systems
API usage monitoring systems
response data injection systems
etc.
Simple and Powerful
Although the hierarchical dependency injection system is very simple to define and use, it's still very powerful.
You can define dependencies that in turn can define dependencies themselves.
In the end, a hierarchical tree of dependencies is built, and the
Dependency Injection
system takes care of solving all these dependencies for you (and their sub-dependencies) and providing (injecting) the results at each step.
For example, let's say you have 4 API endpoints (
path operations
):
/items/public/
/items/private/
/users/{user_id}/activate
/items/pro/
then you could add different permission requirements for each of them just with dependencies and sub-dependencies:
Integrated with
OpenAPI
All these dependencies, while declaring their requirements, also add parameters, validations, etc. to your
path operations
.
FastAPI
will take care of adding it all to the OpenAPI schema, so that it is shown in the interactive documentation systems.

## 121_TUTORIAL_DEPENDENCIES_CLASSES_AS_DEPENDENCIES
Classes as Dependencies¬∂
---

Classes as Dependencies
Before diving deeper into the
Dependency Injection
system, let's upgrade the previous example.
A
dict
from the previous example
In the previous example, we were returning a
dict
from our dependency ("dependable"):
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
But then we get a
dict
in the parameter
commons
of the
path operation function
.
And we know that editors can't provide a lot of support (like completion) for
dict
s, because they can't know their keys and value types.
We can do better...
What makes a dependency
Up to now you have seen dependencies declared as functions.
But that's not the only way to declare dependencies (although it would probably be the more common).
The key factor is that a dependency should be a "callable".
A "
callable
" in Python is anything that Python can "call" like a function.
So, if you have an object
something
(that might
not
be a function) and you can "call" it (execute it) like:
something
()
or
something
(
some_argument
,
some_keyword_argument
=
"foo"
)
then it is a "callable".
Classes as dependencies
You might notice that to create an instance of a Python class, you use that same syntax.
For example:
class
Cat
:
def
__init__
(
self
,
name
:
str
):
self
.
name
=
name
fluffy
=
Cat
(
name
=
"Mr Fluffy"
)
In this case,
fluffy
is an instance of the class
Cat
.
And to create
fluffy
, you are "calling"
Cat
.
So, a Python class is also a
callable
.
Then, in
FastAPI
, you could use a Python class as a dependency.
What FastAPI actually checks is that it is a "callable" (function, class or anything else) and the parameters defined.
If you pass a "callable" as a dependency in
FastAPI
, it will analyze the parameters for that "callable", and process them in the same way as the parameters for a
path operation function
. Including sub-dependencies.
That also applies to callables with no parameters at all. The same as it would be for
path operation functions
with no parameters.
Then, we can change the dependency "dependable"
common_parameters
from above to the class
CommonQueryParams
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Pay attention to the
__init__
method used to create the instance of the class:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
...it has the same parameters as our previous
common_parameters
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
Annotated
[
dict
,
Depends
(
common_parameters
)]):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
async
def
common_parameters
(
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
return
{
"q"
:
q
,
"skip"
:
skip
,
"limit"
:
limit
}
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
@app
.
get
(
"/users/"
)
async
def
read_users
(
commons
:
dict
=
Depends
(
common_parameters
)):
return
commons
Those parameters are what
FastAPI
will use to "solve" the dependency.
In both cases, it will have:
An optional
q
query parameter that is a
str
.
A
skip
query parameter that is an
int
, with a default of
0
.
A
limit
query parameter that is an
int
, with a default of
100
.
In both cases the data will be converted, validated, documented on the OpenAPI schema, etc.
Use it
Now you can declare your dependency using this class.
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
FastAPI
calls the
CommonQueryParams
class. This creates an "instance" of that class and the instance will be passed as the parameter
commons
to your function.
Type annotation vs
Depends
Notice how we write
CommonQueryParams
twice in the above code:
Python 3.8+
Python 3.8+ non-Annotated
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]
Tip
Prefer to use the
Annotated
version if possible.
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)
The last
CommonQueryParams
, in:
...
Depends
(
CommonQueryParams
)
...is what
FastAPI
will actually use to know what is the dependency.
It is from this one that FastAPI will extract the declared parameters and that is what FastAPI will actually call.
In this case, the first
CommonQueryParams
, in:
Python 3.8+
Python 3.8+ non-Annotated
commons
:
Annotated
[
CommonQueryParams
,
...
Tip
Prefer to use the
Annotated
version if possible.
commons
:
CommonQueryParams
...
...doesn't have any special meaning for
FastAPI
. FastAPI won't use it for data conversion, validation, etc. (as it is using the
Depends(CommonQueryParams)
for that).
You could actually write just:
Python 3.8+
Python 3.8+ non-Annotated
commons
:
Annotated
[
Any
,
Depends
(
CommonQueryParams
)]
Tip
Prefer to use the
Annotated
version if possible.
commons
=
Depends
(
CommonQueryParams
)
...as in:
Python 3.10+
from
typing
import
Annotated
,
Any
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
Any
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Any
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
Any
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
from
typing
import
Any
,
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
Any
,
Depends
(
CommonQueryParams
)]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
=
Depends
(
CommonQueryParams
)):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
But declaring the type is encouraged as that way your editor will know what will be passed as the parameter
commons
, and then it can help you with code completion, type checks, etc:
Shortcut
But you see that we are having some code repetition here, writing
CommonQueryParams
twice:
Python 3.8+
Python 3.8+ non-Annotated
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]
Tip
Prefer to use the
Annotated
version if possible.
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)
FastAPI
provides a shortcut for these cases, in where the dependency is
specifically
a class that
FastAPI
will "call" to create an instance of the class itself.
For those specific cases, you can do the following:
Instead of writing:
Python 3.8+
Python 3.8+ non-Annotated
commons
:
Annotated
[
CommonQueryParams
,
Depends
(
CommonQueryParams
)]
Tip
Prefer to use the
Annotated
version if possible.
commons
:
CommonQueryParams
=
Depends
(
CommonQueryParams
)
...you write:
Python 3.8+
Python 3.8 non-Annotated
commons
:
Annotated
[
CommonQueryParams
,
Depends
()]
Tip
Prefer to use the
Annotated
version if possible.
commons
:
CommonQueryParams
=
Depends
()
You declare the dependency as the type of the parameter, and you use
Depends()
without any parameter, instead of having to write the full class
again
inside of
Depends(CommonQueryParams)
.
The same example would then look like:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
()]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
()]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
Annotated
[
CommonQueryParams
,
Depends
()]):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
str
|
None
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
()):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
class
CommonQueryParams
:
def
__init__
(
self
,
q
:
Union
[
str
,
None
]
=
None
,
skip
:
int
=
0
,
limit
:
int
=
100
):
self
.
q
=
q
self
.
skip
=
skip
self
.
limit
=
limit
@app
.
get
(
"/items/"
)
async
def
read_items
(
commons
:
CommonQueryParams
=
Depends
()):
response
=
{}
if
commons
.
q
:
response
.
update
({
"q"
:
commons
.
q
})
items
=
fake_items_db
[
commons
.
skip
:
commons
.
skip
+
commons
.
limit
]
response
.
update
({
"items"
:
items
})
return
response
...and
FastAPI
will know what to do.
Tip
If that seems more confusing than helpful, disregard it, you don't
need
it.
It is just a shortcut. Because
FastAPI
cares about helping you minimize code repetition.

## 122_TUTORIAL_DEPENDENCIES_DEPENDENCIES_IN_PATH_OPERATION_DECORATORS
Dependencies in path operation decorators¬∂
---

Dependencies in path operation decorators
In some cases you don't really need the return value of a dependency inside your
path operation function
.
Or the dependency doesn't return a value.
But you still need it to be executed/solved.
For those cases, instead of declaring a
path operation function
parameter with
Depends
, you can add a
list
of
dependencies
to the
path operation decorator
.
Add
dependencies
to the
path operation decorator
The
path operation decorator
receives an optional argument
dependencies
.
It should be a
list
of
Depends()
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
str
=
Header
()):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
These dependencies will be executed/solved the same way as normal dependencies. But their value (if they return any) won't be passed to your
path operation function
.
Tip
Some editors check for unused function parameters, and show them as errors.
Using these
dependencies
in the
path operation decorator
you can make sure they are executed while avoiding editor/tooling errors.
It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.
Info
In this example we use invented custom headers
X-Key
and
X-Token
.
But in real cases, when implementing security, you would get more benefits from using the integrated
Security utilities (the next chapter)
.
Dependencies errors and return values
You can use the same dependency
functions
you use normally.
Dependency requirements
They can declare request requirements (like headers) or other sub-dependencies:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
str
=
Header
()):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Raise exceptions
These dependencies can
raise
exceptions, the same as normal dependencies:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
str
=
Header
()):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Return values
And they can return values or not, the values won't be used.
So, you can reuse a normal dependency (that returns a value) you already use somewhere else, and even though the value won't be used, the dependency will be executed:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
app
=
FastAPI
()
async
def
verify_token
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
str
=
Header
()):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
@app
.
get
(
"/items/"
,
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
async
def
read_items
():
return
[{
"item"
:
"Foo"
},
{
"item"
:
"Bar"
}]
Dependencies for a group of
path operations
Later, when reading about how to structure bigger applications (
Bigger Applications - Multiple Files
), possibly with multiple files, you will learn how to declare a single
dependencies
parameter for a group of
path operations
.
Global Dependencies
Next we will see how to add dependencies to the whole
FastAPI
application, so that they apply to each
path operation
.

## 123_TUTORIAL_DEPENDENCIES_DEPENDENCIES_WITH_YIELD
Dependencies with yield¬∂
---

Dependencies with yield
FastAPI supports dependencies that do some
extra steps after finishing
.
To do this, use
yield
instead of
return
, and write the extra steps (code) after.
Tip
Make sure to use
yield
one single time per dependency.
Technical Details
Any function that is valid to use with:
@contextlib.contextmanager
or
@contextlib.asynccontextmanager
would be valid to use as a
FastAPI
dependency.
In fact, FastAPI uses those two decorators internally.
A database dependency with
yield
For example, you could use this to create a database session and close it after finishing.
Only the code prior to and including the
yield
statement is executed before creating a response:
Python 3.8+
async
def
get_db
():
db
=
DBSession
()
try
:
yield
db
finally
:
db
.
close
()
The yielded value is what is injected into
path operations
and other dependencies:
Python 3.8+
async
def
get_db
():
db
=
DBSession
()
try
:
yield
db
finally
:
db
.
close
()
The code following the
yield
statement is executed after creating the response but before sending it:
Python 3.8+
async
def
get_db
():
db
=
DBSession
()
try
:
yield
db
finally
:
db
.
close
()
Tip
You can use
async
or regular functions.
FastAPI
will do the right thing with each, the same as with normal dependencies.
A dependency with
yield
and
try
If you use a
try
block in a dependency with
yield
, you'll receive any exception that was thrown when using the dependency.
For example, if some code at some point in the middle, in another dependency or in a
path operation
, made a database transaction "rollback" or create any other error, you will receive the exception in your dependency.
So, you can look for that specific exception inside the dependency with
except SomeException
.
In the same way, you can use
finally
to make sure the exit steps are executed, no matter if there was an exception or not.
Python 3.8+
async
def
get_db
():
db
=
DBSession
()
try
:
yield
db
finally
:
db
.
close
()
Sub-dependencies with
yield
You can have sub-dependencies and "trees" of sub-dependencies of any size and shape, and any or all of them can use
yield
.
FastAPI
will make sure that the "exit code" in each dependency with
yield
is run in the correct order.
For example,
dependency_c
can have a dependency on
dependency_b
, and
dependency_b
on
dependency_a
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
:
Annotated
[
DepA
,
Depends
(
dependency_a
)]):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
:
Annotated
[
DepB
,
Depends
(
dependency_b
)]):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
from
typing_extensions
import
Annotated
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
:
Annotated
[
DepA
,
Depends
(
dependency_a
)]):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
:
Annotated
[
DepB
,
Depends
(
dependency_b
)]):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
=
Depends
(
dependency_a
)):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
=
Depends
(
dependency_b
)):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
And all of them can use
yield
.
In this case
dependency_c
, to execute its exit code, needs the value from
dependency_b
(here named
dep_b
) to still be available.
And, in turn,
dependency_b
needs the value from
dependency_a
(here named
dep_a
) to be available for its exit code.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
:
Annotated
[
DepA
,
Depends
(
dependency_a
)]):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
:
Annotated
[
DepB
,
Depends
(
dependency_b
)]):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
from
typing_extensions
import
Annotated
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
:
Annotated
[
DepA
,
Depends
(
dependency_a
)]):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
:
Annotated
[
DepB
,
Depends
(
dependency_b
)]):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
async
def
dependency_a
():
dep_a
=
generate_dep_a
()
try
:
yield
dep_a
finally
:
dep_a
.
close
()
async
def
dependency_b
(
dep_a
=
Depends
(
dependency_a
)):
dep_b
=
generate_dep_b
()
try
:
yield
dep_b
finally
:
dep_b
.
close
(
dep_a
)
async
def
dependency_c
(
dep_b
=
Depends
(
dependency_b
)):
dep_c
=
generate_dep_c
()
try
:
yield
dep_c
finally
:
dep_c
.
close
(
dep_b
)
The same way, you could have some dependencies with
yield
and some other dependencies with
return
, and have some of those depend on some of the others.
And you could have a single dependency that requires several other dependencies with
yield
, etc.
You can have any combinations of dependencies that you want.
FastAPI
will make sure everything is run in the correct order.
Technical Details
This works thanks to Python's
Context Managers
.
FastAPI
uses them internally to achieve this.
Dependencies with
yield
and
HTTPException
You saw that you can use dependencies with
yield
and have
try
blocks that catch exceptions.
The same way, you could raise an
HTTPException
or similar in the exit code, after the
yield
.
Tip
This is a somewhat advanced technique, and in most of the cases you won't really need it, as you can raise exceptions (including
HTTPException
) from inside of the rest of your application code, for example, in the
path operation function
.
But it's there for you if you need it. ü§ì
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
data
=
{
"plumbus"
:
{
"description"
:
"Freshly pickled plumbus"
,
"owner"
:
"Morty"
},
"portal-gun"
:
{
"description"
:
"Gun to create portals"
,
"owner"
:
"Rick"
},
}
class
OwnerError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
OwnerError
as
e
:
raise
HTTPException
(
status_code
=
400
,
detail
=
f
"Owner error:
{
e
}
"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
not
in
data
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
item
=
data
[
item_id
]
if
item
[
"owner"
]
!=
username
:
raise
OwnerError
(
username
)
return
item
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
data
=
{
"plumbus"
:
{
"description"
:
"Freshly pickled plumbus"
,
"owner"
:
"Morty"
},
"portal-gun"
:
{
"description"
:
"Gun to create portals"
,
"owner"
:
"Rick"
},
}
class
OwnerError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
OwnerError
as
e
:
raise
HTTPException
(
status_code
=
400
,
detail
=
f
"Owner error:
{
e
}
"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
not
in
data
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
item
=
data
[
item_id
]
if
item
[
"owner"
]
!=
username
:
raise
OwnerError
(
username
)
return
item
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
data
=
{
"plumbus"
:
{
"description"
:
"Freshly pickled plumbus"
,
"owner"
:
"Morty"
},
"portal-gun"
:
{
"description"
:
"Gun to create portals"
,
"owner"
:
"Rick"
},
}
class
OwnerError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
OwnerError
as
e
:
raise
HTTPException
(
status_code
=
400
,
detail
=
f
"Owner error:
{
e
}
"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
str
=
Depends
(
get_username
)):
if
item_id
not
in
data
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
item
=
data
[
item_id
]
if
item
[
"owner"
]
!=
username
:
raise
OwnerError
(
username
)
return
item
An alternative you could use to catch exceptions (and possibly also raise another
HTTPException
) is to create a
Custom Exception Handler
.
Dependencies with
yield
and
except
If you catch an exception using
except
in a dependency with
yield
and you don't raise it again (or raise a new exception), FastAPI won't be able to notice there was an exception, the same way that would happen with regular Python:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"Oops, we didn't raise again, Britney üò±"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"Oops, we didn't raise again, Britney üò±"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"Oops, we didn't raise again, Britney üò±"
)
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
str
=
Depends
(
get_username
)):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
In this case, the client will see an
HTTP 500 Internal Server Error
response as it should, given that we are not raising an
HTTPException
or similar, but the server will
not have any logs
or any other indication of what was the error. üò±
Always
raise
in Dependencies with
yield
and
except
If you catch an exception in a dependency with
yield
, unless you are raising another
HTTPException
or similar, you should re-raise the original exception.
You can re-raise the same exception using
raise
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"We don't swallow the internal error here, we raise again üòé"
)
raise
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"We don't swallow the internal error here, we raise again üòé"
)
raise
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
Annotated
[
str
,
Depends
(
get_username
)]):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
app
=
FastAPI
()
class
InternalError
(
Exception
):
pass
def
get_username
():
try
:
yield
"Rick"
except
InternalError
:
print
(
"We don't swallow the internal error here, we raise again üòé"
)
raise
@app
.
get
(
"/items/
{item_id}
"
)
def
get_item
(
item_id
:
str
,
username
:
str
=
Depends
(
get_username
)):
if
item_id
==
"portal-gun"
:
raise
InternalError
(
f
"The portal gun is too dangerous to be owned by
{
username
}
"
)
if
item_id
!=
"plumbus"
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found, there's only a plumbus here"
)
return
item_id
Now the client will get the same
HTTP 500 Internal Server Error
response, but the server will have our custom
InternalError
in the logs. üòé
Execution of dependencies with
yield
The sequence of execution is more or less like this diagram. Time flows from top to bottom. And each column is one of the parts interacting or executing code.
Info
Only
one response
will be sent to the client. It might be one of the error responses or it will be the response from the
path operation
.
After one of those responses is sent, no other response can be sent.
Tip
This diagram shows
HTTPException
, but you could also raise any other exception that you catch in a dependency with
yield
or with a
Custom Exception Handler
.
If you raise any exception, it will be passed to the dependencies with yield, including
HTTPException
. In most cases you will want to re-raise that same exception or a new one from the dependency with
yield
to make sure it's properly handled.
Dependencies with
yield
,
HTTPException
,
except
and Background Tasks
Warning
You most probably don't need these technical details, you can skip this section and continue below.
These details are useful mainly if you were using a version of FastAPI prior to 0.106.0 and used resources from dependencies with
yield
in background tasks.
Dependencies with
yield
and
except
, Technical Details
Before FastAPI 0.110.0, if you used a dependency with
yield
, and then you captured an exception with
except
in that dependency, and you didn't raise the exception again, the exception would be automatically raised/forwarded to any exception handlers or the internal server error handler.
This was changed in version 0.110.0 to fix unhandled memory consumption from forwarded exceptions without a handler (internal server errors), and to make it consistent with the behavior of regular Python code.
Background Tasks and Dependencies with
yield
, Technical Details
Before FastAPI 0.106.0, raising exceptions after
yield
was not possible, the exit code in dependencies with
yield
was executed
after
the response was sent, so
Exception Handlers
would have already run.
This was designed this way mainly to allow using the same objects "yielded" by dependencies inside of background tasks, because the exit code would be executed after the background tasks were finished.
Nevertheless, as this would mean waiting for the response to travel through the network while unnecessarily holding a resource in a dependency with yield (for example a database connection), this was changed in FastAPI 0.106.0.
Tip
Additionally, a background task is normally an independent set of logic that should be handled separately, with its own resources (e.g. its own database connection).
So, this way you will probably have cleaner code.
If you used to rely on this behavior, now you should create the resources for background tasks inside the background task itself, and use internally only data that doesn't depend on the resources of dependencies with
yield
.
For example, instead of using the same database session, you would create a new database session inside of the background task, and you would obtain the objects from the database using this new session. And then instead of passing the object from the database as a parameter to the background task function, you would pass the ID of that object and then obtain the object again inside the background task function.
Context Managers
What are "Context Managers"
"Context Managers" are any of those Python objects that you can use in a
with
statement.
For example,
you can use
with
to read a file
:
with
open
(
"./somefile.txt"
)
as
f
:
contents
=
f
.
read
()
print
(
contents
)
Underneath, the
open("./somefile.txt")
creates an object that is called a "Context Manager".
When the
with
block finishes, it makes sure to close the file, even if there were exceptions.
When you create a dependency with
yield
,
FastAPI
will internally create a context manager for it, and combine it with some other related tools.
Using context managers in dependencies with
yield
Warning
This is, more or less, an "advanced" idea.
If you are just starting with
FastAPI
you might want to skip it for now.
In Python, you can create Context Managers by
creating a class with two methods:
__enter__()
and
__exit__()
.
You can also use them inside of
FastAPI
dependencies with
yield
by using
with
or
async with
statements inside of the dependency function:
Python 3.8+
class
MySuperContextManager
:
def
__init__
(
self
):
self
.
db
=
DBSession
()
def
__enter__
(
self
):
return
self
.
db
def
__exit__
(
self
,
exc_type
,
exc_value
,
traceback
):
self
.
db
.
close
()
async
def
get_db
():
with
MySuperContextManager
()
as
db
:
yield
db
Tip
Another way to create a context manager is with:
@contextlib.contextmanager
or
@contextlib.asynccontextmanager
using them to decorate a function with a single
yield
.
That's what
FastAPI
uses internally for dependencies with
yield
.
But you don't have to use the decorators for FastAPI dependencies (and you shouldn't).
FastAPI will do it for you internally.

## 124_TUTORIAL_DEPENDENCIES_GLOBAL_DEPENDENCIES
Global Dependencies¬∂
---

Global Dependencies
For some types of applications you might want to add dependencies to the whole application.
Similar to the way you can
add
dependencies
to the
path operation decorators
, you can add them to the
FastAPI
application.
In that case, they will be applied to all the
path operations
in the application:
Python 3.9+
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
app
=
FastAPI
(
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item"
:
"Portal Gun"
},
{
"item"
:
"Plumbus"
}]
@app
.
get
(
"/users/"
)
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
from
typing_extensions
import
Annotated
async
def
verify_token
(
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
Annotated
[
str
,
Header
()]):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
app
=
FastAPI
(
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item"
:
"Portal Gun"
},
{
"item"
:
"Plumbus"
}]
@app
.
get
(
"/users/"
)
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
Header
,
HTTPException
async
def
verify_token
(
x_token
:
str
=
Header
()):
if
x_token
!=
"fake-super-secret-token"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Token header invalid"
)
async
def
verify_key
(
x_key
:
str
=
Header
()):
if
x_key
!=
"fake-super-secret-key"
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"X-Key header invalid"
)
return
x_key
app
=
FastAPI
(
dependencies
=
[
Depends
(
verify_token
),
Depends
(
verify_key
)])
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"item"
:
"Portal Gun"
},
{
"item"
:
"Plumbus"
}]
@app
.
get
(
"/users/"
)
async
def
read_users
():
return
[{
"username"
:
"Rick"
},
{
"username"
:
"Morty"
}]
And all the ideas in the section about
adding
dependencies
to the
path operation decorators
still apply, but in this case, to all of the
path operations
in the app.
Dependencies for groups of
path operations
Later, when reading about how to structure bigger applications (
Bigger Applications - Multiple Files
), possibly with multiple files, you will learn how to declare a single
dependencies
parameter for a group of
path operations
.

## 125_TUTORIAL_DEPENDENCIES_SUB_DEPENDENCIES
Sub-dependencies¬∂
---

Sub-dependencies
You can create dependencies that have
sub-dependencies
.
They can be as
deep
as you need them to be.
FastAPI
will take care of solving them.
First dependency "dependable"
You could create a first dependency ("dependable") like:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
str
|
None
=
Cookie
(
default
=
None
)
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
),
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
It declares an optional query parameter
q
as a
str
, and then it just returns it.
This is quite simple (not very useful), but will help us focus on how the sub-dependencies work.
Second dependency, "dependable" and "dependant"
Then you can create another dependency function (a "dependable") that at the same time declares a dependency of its own (so it is a "dependant" too):
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
str
|
None
=
Cookie
(
default
=
None
)
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
),
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
Let's focus on the parameters declared:
Even though this function is a dependency ("dependable") itself, it also declares another dependency (it "depends" on something else).
It depends on the
query_extractor
, and assigns the value returned by it to the parameter
q
.
It also declares an optional
last_query
cookie, as a
str
.
If the user didn't provide any query
q
, we use the last query used, which we saved to a cookie before.
Use the dependency
Then we can use the dependency with:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
str
|
None
,
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
Annotated
[
str
,
Depends
(
query_extractor
)],
last_query
:
Annotated
[
Union
[
str
,
None
],
Cookie
()]
=
None
,
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
Annotated
[
str
,
Depends
(
query_or_cookie_extractor
)],
):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
str
|
None
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
str
|
None
=
Cookie
(
default
=
None
)
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Cookie
,
Depends
,
FastAPI
app
=
FastAPI
()
def
query_extractor
(
q
:
Union
[
str
,
None
]
=
None
):
return
q
def
query_or_cookie_extractor
(
q
:
str
=
Depends
(
query_extractor
),
last_query
:
Union
[
str
,
None
]
=
Cookie
(
default
=
None
),
):
if
not
q
:
return
last_query
return
q
@app
.
get
(
"/items/"
)
async
def
read_query
(
query_or_default
:
str
=
Depends
(
query_or_cookie_extractor
)):
return
{
"q_or_cookie"
:
query_or_default
}
Info
Notice that we are only declaring one dependency in the
path operation function
, the
query_or_cookie_extractor
.
But
FastAPI
will know that it has to solve
query_extractor
first, to pass the results of that to
query_or_cookie_extractor
while calling it.
Using the same dependency multiple times
If one of your dependencies is declared multiple times for the same
path operation
, for example, multiple dependencies have a common sub-dependency,
FastAPI
will know to call that sub-dependency only once per request.
And it will save the returned value in a
"cache"
and pass it to all the "dependants" that need it in that specific request, instead of calling the dependency multiple times for the same request.
In an advanced scenario where you know you need the dependency to be called at every step (possibly multiple times) in the same request instead of using the "cached" value, you can set the parameter
use_cache=False
when using
Depends
:
Python 3.8+
Python 3.8+ non-Annotated
async
def
needy_dependency
(
fresh_value
:
Annotated
[
str
,
Depends
(
get_value
,
use_cache
=
False
)]):
return
{
"fresh_value"
:
fresh_value
}
Tip
Prefer to use the
Annotated
version if possible.
async
def
needy_dependency
(
fresh_value
:
str
=
Depends
(
get_value
,
use_cache
=
False
)):
return
{
"fresh_value"
:
fresh_value
}
Recap
Apart from all the fancy words used here, the
Dependency Injection
system is quite simple.
Just functions that look the same as the
path operation functions
.
But still, it is very powerful, and allows you to declare arbitrarily deeply nested dependency "graphs" (trees).
Tip
All this might not seem as useful with these simple examples.
But you will see how useful it is in the chapters about
security
.
And you will also see the amounts of code it will save you.

## 126_TUTORIAL_ENCODER
JSON Compatible Encoder¬∂
---

JSON Compatible Encoder
There are some cases where you might need to convert a data type (like a Pydantic model) to something compatible with JSON (like a
dict
,
list
, etc).
For example, if you need to store it in a database.
For that,
FastAPI
provides a
jsonable_encoder()
function.
Using the
jsonable_encoder
Let's imagine that you have a database
fake_db
that only receives JSON compatible data.
For example, it doesn't receive
datetime
objects, as those are not compatible with JSON.
So, a
datetime
object would have to be converted to a
str
containing the data in
ISO format
.
The same way, this database wouldn't receive a Pydantic model (an object with attributes), only a
dict
.
You can use
jsonable_encoder
for that.
It receives an object, like a Pydantic model, and returns a JSON compatible version:
Python 3.10+
from
datetime
import
datetime
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
fake_db
=
{}
class
Item
(
BaseModel
):
title
:
str
timestamp
:
datetime
description
:
str
|
None
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{id}
"
)
def
update_item
(
id
:
str
,
item
:
Item
):
json_compatible_item_data
=
jsonable_encoder
(
item
)
fake_db
[
id
]
=
json_compatible_item_data
ü§ì Other versions and variants
Python 3.8+
from
datetime
import
datetime
from
typing
import
Union
from
fastapi
import
FastAPI
from
fastapi.encoders
import
jsonable_encoder
from
pydantic
import
BaseModel
fake_db
=
{}
class
Item
(
BaseModel
):
title
:
str
timestamp
:
datetime
description
:
Union
[
str
,
None
]
=
None
app
=
FastAPI
()
@app
.
put
(
"/items/
{id}
"
)
def
update_item
(
id
:
str
,
item
:
Item
):
json_compatible_item_data
=
jsonable_encoder
(
item
)
fake_db
[
id
]
=
json_compatible_item_data
In this example, it would convert the Pydantic model to a
dict
, and the
datetime
to a
str
.
The result of calling it is something that can be encoded with the Python standard
json.dumps()
.
It doesn't return a large
str
containing the data in JSON format (as a string). It returns a Python standard data structure (e.g. a
dict
) with values and sub-values that are all compatible with JSON.
Note
jsonable_encoder
is actually used by
FastAPI
internally to convert data. But it is useful in many other scenarios.

## 127_TUTORIAL_EXTRA_DATA_TYPES
Extra Data Types¬∂
---

Extra Data Types
Up to now, you have been using common data types, like:
int
float
str
bool
But you can also use more complex data types.
And you will still have the same features as seen up to now:
Great editor support.
Data conversion from incoming requests.
Data conversion for response data.
Data validation.
Automatic annotation and documentation.
Other data types
Here are some of the additional data types you can use:
UUID
:
A standard "Universally Unique Identifier", common as an ID in many databases and systems.
In requests and responses will be represented as a
str
.
datetime.datetime
:
A Python
datetime.datetime
.
In requests and responses will be represented as a
str
in ISO 8601 format, like:
2008-09-15T15:53:00+05:00
.
datetime.date
:
Python
datetime.date
.
In requests and responses will be represented as a
str
in ISO 8601 format, like:
2008-09-15
.
datetime.time
:
A Python
datetime.time
.
In requests and responses will be represented as a
str
in ISO 8601 format, like:
14:23:55.003
.
datetime.timedelta
:
A Python
datetime.timedelta
.
In requests and responses will be represented as a
float
of total seconds.
Pydantic also allows representing it as a "ISO 8601 time diff encoding",
see the docs for more info
.
frozenset
:
In requests and responses, treated the same as a
set
:
In requests, a list will be read, eliminating duplicates and converting it to a
set
.
In responses, the
set
will be converted to a
list
.
The generated schema will specify that the
set
values are unique (using JSON Schema's
uniqueItems
).
bytes
:
Standard Python
bytes
.
In requests and responses will be treated as
str
.
The generated schema will specify that it's a
str
with
binary
"format".
Decimal
:
Standard Python
Decimal
.
In requests and responses, handled the same as a
float
.
You can check all the valid Pydantic data types here:
Pydantic data types
.
Example
Here's an example
path operation
with parameters using some of the above types.
Python 3.10+
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Annotated
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
time
|
None
,
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Annotated
,
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
Union
[
time
,
None
],
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
Union
[
time
,
None
],
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
time
,
timedelta
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
datetime
=
Body
(),
end_datetime
:
datetime
=
Body
(),
process_after
:
timedelta
=
Body
(),
repeat_at
:
time
|
None
=
Body
(
default
=
None
),
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
datetime
=
Body
(),
end_datetime
:
datetime
=
Body
(),
process_after
:
timedelta
=
Body
(),
repeat_at
:
Union
[
time
,
None
]
=
Body
(
default
=
None
),
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
Note that the parameters inside the function have their natural data type, and you can, for example, perform normal date manipulations, like:
Python 3.10+
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Annotated
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
time
|
None
,
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Annotated
,
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
Union
[
time
,
None
],
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
Annotated
[
datetime
,
Body
()],
end_datetime
:
Annotated
[
datetime
,
Body
()],
process_after
:
Annotated
[
timedelta
,
Body
()],
repeat_at
:
Annotated
[
Union
[
time
,
None
],
Body
()]
=
None
,
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
time
,
timedelta
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
datetime
=
Body
(),
end_datetime
:
datetime
=
Body
(),
process_after
:
timedelta
=
Body
(),
repeat_at
:
time
|
None
=
Body
(
default
=
None
),
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
time
,
timedelta
from
typing
import
Union
from
uuid
import
UUID
from
fastapi
import
Body
,
FastAPI
app
=
FastAPI
()
@app
.
put
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
UUID
,
start_datetime
:
datetime
=
Body
(),
end_datetime
:
datetime
=
Body
(),
process_after
:
timedelta
=
Body
(),
repeat_at
:
Union
[
time
,
None
]
=
Body
(
default
=
None
),
):
start_process
=
start_datetime
+
process_after
duration
=
end_datetime
-
start_process
return
{
"item_id"
:
item_id
,
"start_datetime"
:
start_datetime
,
"end_datetime"
:
end_datetime
,
"process_after"
:
process_after
,
"repeat_at"
:
repeat_at
,
"start_process"
:
start_process
,
"duration"
:
duration
,
}

## 128_TUTORIAL_EXTRA_MODELS
Extra Models¬∂
---

Extra Models
Continuing with the previous example, it will be common to have more than one related model.
This is especially the case for user models, because:
The
input model
needs to be able to have a password.
The
output model
should not have a password.
The
database model
would probably need to have a hashed password.
Danger
Never store user's plaintext passwords. Always store a "secure hash" that you can then verify.
If you don't know, you will learn what a "password hash" is in the
security chapters
.
Multiple models
Here's a general idea of how the models could look like with their password fields and the places where they are used:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserInDB
(
BaseModel
):
username
:
str
hashed_password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
def
fake_password_hasher
(
raw_password
:
str
):
return
"supersecret"
+
raw_password
def
fake_save_user
(
user_in
:
UserIn
):
hashed_password
=
fake_password_hasher
(
user_in
.
password
)
user_in_db
=
UserInDB
(
**
user_in
.
dict
(),
hashed_password
=
hashed_password
)
print
(
"User saved! ..not really"
)
return
user_in_db
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user_in
:
UserIn
):
user_saved
=
fake_save_user
(
user_in
)
return
user_saved
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserInDB
(
BaseModel
):
username
:
str
hashed_password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
def
fake_password_hasher
(
raw_password
:
str
):
return
"supersecret"
+
raw_password
def
fake_save_user
(
user_in
:
UserIn
):
hashed_password
=
fake_password_hasher
(
user_in
.
password
)
user_in_db
=
UserInDB
(
**
user_in
.
dict
(),
hashed_password
=
hashed_password
)
print
(
"User saved! ..not really"
)
return
user_in_db
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user_in
:
UserIn
):
user_saved
=
fake_save_user
(
user_in
)
return
user_saved
Info
In Pydantic v1 the method was called
.dict()
, it was deprecated (but still supported) in Pydantic v2, and renamed to
.model_dump()
.
The examples here use
.dict()
for compatibility with Pydantic v1, but you should use
.model_dump()
instead if you can use Pydantic v2.
About
**user_in.dict()
Pydantic's
.dict()
user_in
is a Pydantic model of class
UserIn
.
Pydantic models have a
.dict()
method that returns a
dict
with the model's data.
So, if we create a Pydantic object
user_in
like:
user_in
=
UserIn
(
username
=
"john"
,
password
=
"secret"
,
email
=
"john.doe@example.com"
)
and then we call:
user_dict
=
user_in
.
dict
()
we now have a
dict
with the data in the variable
user_dict
(it's a
dict
instead of a Pydantic model object).
And if we call:
print
(
user_dict
)
we would get a Python
dict
with:
{
'username'
:
'john'
,
'password'
:
'secret'
,
'email'
:
'john.doe@example.com'
,
'full_name'
:
None
,
}
Unpacking a
dict
If we take a
dict
like
user_dict
and pass it to a function (or class) with
**user_dict
, Python will "unpack" it. It will pass the keys and values of the
user_dict
directly as key-value arguments.
So, continuing with the
user_dict
from above, writing:
UserInDB
(
**
user_dict
)
would result in something equivalent to:
UserInDB
(
username
=
"john"
,
password
=
"secret"
,
email
=
"john.doe@example.com"
,
full_name
=
None
,
)
Or more exactly, using
user_dict
directly, with whatever contents it might have in the future:
UserInDB
(
username
=
user_dict
[
"username"
],
password
=
user_dict
[
"password"
],
email
=
user_dict
[
"email"
],
full_name
=
user_dict
[
"full_name"
],
)
A Pydantic model from the contents of another
As in the example above we got
user_dict
from
user_in.dict()
, this code:
user_dict
=
user_in
.
dict
()
UserInDB
(
**
user_dict
)
would be equivalent to:
UserInDB
(
**
user_in
.
dict
())
...because
user_in.dict()
is a
dict
, and then we make Python "unpack" it by passing it to
UserInDB
prefixed with
**
.
So, we get a Pydantic model from the data in another Pydantic model.
Unpacking a
dict
and extra keywords
And then adding the extra keyword argument
hashed_password=hashed_password
, like in:
UserInDB
(
**
user_in
.
dict
(),
hashed_password
=
hashed_password
)
...ends up being like:
UserInDB
(
username
=
user_dict
[
"username"
],
password
=
user_dict
[
"password"
],
email
=
user_dict
[
"email"
],
full_name
=
user_dict
[
"full_name"
],
hashed_password
=
hashed_password
,
)
Warning
The supporting additional functions
fake_password_hasher
and
fake_save_user
are just to demo a possible flow of the data, but they of course are not providing any real security.
Reduce duplication
Reducing code duplication is one of the core ideas in
FastAPI
.
As code duplication increments the chances of bugs, security issues, code desynchronization issues (when you update in one place but not in the others), etc.
And these models are all sharing a lot of the data and duplicating attribute names and types.
We could do better.
We can declare a
UserBase
model that serves as a base for our other models. And then we can make subclasses of that model that inherit its attributes (type declarations, validation, etc).
All the data conversion, validation, documentation, etc. will still work as normally.
That way, we can declare just the differences between the models (with plaintext
password
, with
hashed_password
and without password):
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserBase
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserIn
(
UserBase
):
password
:
str
class
UserOut
(
UserBase
):
pass
class
UserInDB
(
UserBase
):
hashed_password
:
str
def
fake_password_hasher
(
raw_password
:
str
):
return
"supersecret"
+
raw_password
def
fake_save_user
(
user_in
:
UserIn
):
hashed_password
=
fake_password_hasher
(
user_in
.
password
)
user_in_db
=
UserInDB
(
**
user_in
.
dict
(),
hashed_password
=
hashed_password
)
print
(
"User saved! ..not really"
)
return
user_in_db
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user_in
:
UserIn
):
user_saved
=
fake_save_user
(
user_in
)
return
user_saved
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserBase
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserIn
(
UserBase
):
password
:
str
class
UserOut
(
UserBase
):
pass
class
UserInDB
(
UserBase
):
hashed_password
:
str
def
fake_password_hasher
(
raw_password
:
str
):
return
"supersecret"
+
raw_password
def
fake_save_user
(
user_in
:
UserIn
):
hashed_password
=
fake_password_hasher
(
user_in
.
password
)
user_in_db
=
UserInDB
(
**
user_in
.
dict
(),
hashed_password
=
hashed_password
)
print
(
"User saved! ..not really"
)
return
user_in_db
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user_in
:
UserIn
):
user_saved
=
fake_save_user
(
user_in
)
return
user_saved
Union
or
anyOf
You can declare a response to be the
Union
of two or more types, that means, that the response would be any of them.
It will be defined in OpenAPI with
anyOf
.
To do that, use the standard Python type hint
typing.Union
:
Note
When defining a
Union
, include the most specific type first, followed by the less specific type. In the example below, the more specific
PlaneItem
comes before
CarItem
in
Union[PlaneItem, CarItem]
.
Python 3.10+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
BaseItem
(
BaseModel
):
description
:
str
type
:
str
class
CarItem
(
BaseItem
):
type
:
str
=
"car"
class
PlaneItem
(
BaseItem
):
type
:
str
=
"plane"
size
:
int
items
=
{
"item1"
:
{
"description"
:
"All my friends drive a low rider"
,
"type"
:
"car"
},
"item2"
:
{
"description"
:
"Music is my aeroplane, it's my aeroplane"
,
"type"
:
"plane"
,
"size"
:
5
,
},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Union
[
PlaneItem
,
CarItem
])
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
BaseItem
(
BaseModel
):
description
:
str
type
:
str
class
CarItem
(
BaseItem
):
type
:
str
=
"car"
class
PlaneItem
(
BaseItem
):
type
:
str
=
"plane"
size
:
int
items
=
{
"item1"
:
{
"description"
:
"All my friends drive a low rider"
,
"type"
:
"car"
},
"item2"
:
{
"description"
:
"Music is my aeroplane, it's my aeroplane"
,
"type"
:
"plane"
,
"size"
:
5
,
},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Union
[
PlaneItem
,
CarItem
])
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
Union
in Python 3.10
In this example we pass
Union[PlaneItem, CarItem]
as the value of the argument
response_model
.
Because we are passing it as a
value to an argument
instead of putting it in a
type annotation
, we have to use
Union
even in Python 3.10.
If it was in a type annotation we could have used the vertical bar, as:
some_variable
:
PlaneItem
|
CarItem
But if we put that in the assignment
response_model=PlaneItem | CarItem
we would get an error, because Python would try to perform an
invalid operation
between
PlaneItem
and
CarItem
instead of interpreting that as a type annotation.
List of models
The same way, you can declare responses of lists of objects.
For that, use the standard Python
typing.List
(or just
list
in Python 3.9 and above):
Python 3.9+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
items
=
[
{
"name"
:
"Foo"
,
"description"
:
"There comes my hero"
},
{
"name"
:
"Red"
,
"description"
:
"It's my aeroplane"
},
]
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
])
async
def
read_items
():
return
items
ü§ì Other versions and variants
Python 3.8+
from
typing
import
List
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
items
=
[
{
"name"
:
"Foo"
,
"description"
:
"There comes my hero"
},
{
"name"
:
"Red"
,
"description"
:
"It's my aeroplane"
},
]
@app
.
get
(
"/items/"
,
response_model
=
List
[
Item
])
async
def
read_items
():
return
items
Response with arbitrary
dict
You can also declare a response using a plain arbitrary
dict
, declaring just the type of the keys and values, without using a Pydantic model.
This is useful if you don't know the valid field/attribute names (that would be needed for a Pydantic model) beforehand.
In this case, you can use
typing.Dict
(or just
dict
in Python 3.9 and above):
Python 3.9+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/keyword-weights/"
,
response_model
=
dict
[
str
,
float
])
async
def
read_keyword_weights
():
return
{
"foo"
:
2.3
,
"bar"
:
3.4
}
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Dict
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/keyword-weights/"
,
response_model
=
Dict
[
str
,
float
])
async
def
read_keyword_weights
():
return
{
"foo"
:
2.3
,
"bar"
:
3.4
}
Recap
Use multiple Pydantic models and inherit freely for each case.
You don't need to have a single data model per entity if that entity must be able to have different "states". As the case with the user "entity" with a state including
password
,
password_hash
and no password.

## 129_TUTORIAL_FIRST_STEPS
First Steps¬∂
---

First Steps
The simplest FastAPI file could look like this:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
Copy that to a file
main.py
.
Run the live server:
fast ‚Üí
fastapi dev main.py
FastAPI
Starting development server üöÄ
Searching for package file structure from directories
with
__init__.py
files
Importing from
/home/user/code/
awesomeapp
module
üêç main.py
code
Importing the FastAPI app object from the module with
the following code:
from
main
import
app
app
Using import string:
main:app
server
Server started at
http://127.0.0.1:8000
server
Documentation at
http://127.0.0.1:8000/docs
tip
Running in development mode, for production use:
fastapi run
Logs:
INFO
Will watch for changes in these directories:
[
'/home/user/code/awesomeapp'
]
INFO
Uvicorn running on
http://127.0.0.1:8000
(
Press CTRL+C
to quit
)
INFO
Started reloader process
[
383138
]
using WatchFiles
INFO
Started server process
[
383153
]
INFO
Waiting for application startup.
INFO
Application startup complete.
In the output, there's a line with something like:
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
That line shows the URL where your app is being served, in your local machine.
Check it
Open your browser at
http://127.0.0.1:8000
.
You will see the JSON response as:
{
"message"
:
"Hello World"
}
Interactive API docs
Now go to
http://127.0.0.1:8000/docs
.
You will see the automatic interactive API documentation (provided by
Swagger UI
):
Alternative API docs
And now, go to
http://127.0.0.1:8000/redoc
.
You will see the alternative automatic documentation (provided by
ReDoc
):
OpenAPI
FastAPI
generates a "schema" with all your API using the
OpenAPI
standard for defining APIs.
"Schema"
A "schema" is a definition or description of something. Not the code that implements it, but just an abstract description.
API "schema"
In this case,
OpenAPI
is a specification that dictates how to define a schema of your API.
This schema definition includes your API paths, the possible parameters they take, etc.
Data "schema"
The term "schema" might also refer to the shape of some data, like a JSON content.
In that case, it would mean the JSON attributes, and data types they have, etc.
OpenAPI and JSON Schema
OpenAPI defines an API schema for your API. And that schema includes definitions (or "schemas") of the data sent and received by your API using
JSON Schema
, the standard for JSON data schemas.
Check the
openapi.json
If you are curious about how the raw OpenAPI schema looks like, FastAPI automatically generates a JSON (schema) with the descriptions of all your API.
You can see it directly at:
http://127.0.0.1:8000/openapi.json
.
It will show a JSON starting with something like:
{
"openapi"
:
"3.1.0"
,
"info"
:
{
"title"
:
"FastAPI"
,
"version"
:
"0.1.0"
},
"paths"
:
{
"/items/"
:
{
"get"
:
{
"responses"
:
{
"200"
:
{
"description"
:
"Successful Response"
,
"content"
:
{
"application/json"
:
{
...
What is OpenAPI for
The OpenAPI schema is what powers the two interactive documentation systems included.
And there are dozens of alternatives, all based on OpenAPI. You could easily add any of those alternatives to your application built with
FastAPI
.
You could also use it to generate code automatically, for clients that communicate with your API. For example, frontend, mobile or IoT applications.
Recap, step by step
Step 1: import
FastAPI
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
FastAPI
is a Python class that provides all the functionality for your API.
Technical Details
FastAPI
is a class that inherits directly from
Starlette
.
You can use all the
Starlette
functionality with
FastAPI
too.
Step 2: create a
FastAPI
"instance"
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
Here the
app
variable will be an "instance" of the class
FastAPI
.
This will be the main point of interaction to create all your API.
Step 3: create a
path operation
Path
"Path" here refers to the last part of the URL starting from the first
/
.
So, in a URL like:
https://example.com/items/foo
...the path would be:
/items/foo
Info
A "path" is also commonly called an "endpoint" or a "route".
While building an API, the "path" is the main way to separate "concerns" and "resources".
Operation
"Operation" here refers to one of the HTTP "methods".
One of:
POST
GET
PUT
DELETE
...and the more exotic ones:
OPTIONS
HEAD
PATCH
TRACE
In the HTTP protocol, you can communicate to each path using one (or more) of these "methods".
When building APIs, you normally use these specific HTTP methods to perform a specific action.
Normally you use:
POST
: to create data.
GET
: to read data.
PUT
: to update data.
DELETE
: to delete data.
So, in OpenAPI, each of the HTTP methods is called an "operation".
We are going to call them "
operations
" too.
Define a
path operation decorator
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
The
@app.get("/")
tells
FastAPI
that the function right below is in charge of handling requests that go to:
the path
/
using a
get
operation
@decorator
Info
That
@something
syntax in Python is called a "decorator".
You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from).
A "decorator" takes the function below and does something with it.
In our case, this decorator tells
FastAPI
that the function below corresponds to the
path
/
with an
operation
get
.
It is the "
path operation decorator
".
You can also use the other operations:
@app.post()
@app.put()
@app.delete()
And the more exotic ones:
@app.options()
@app.head()
@app.patch()
@app.trace()
Tip
You are free to use each operation (HTTP method) as you wish.
FastAPI
doesn't enforce any specific meaning.
The information here is presented as a guideline, not a requirement.
For example, when using GraphQL you normally perform all the actions using only
POST
operations.
Step 4: define the
path operation function
This is our "
path operation function
":
path
: is
/
.
operation
: is
get
.
function
: is the function below the "decorator" (below
@app.get("/")
).
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
This is a Python function.
It will be called by
FastAPI
whenever it receives a request to the URL "
/
" using a
GET
operation.
In this case, it is an
async
function.
You could also define it as a normal function instead of
async def
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
root
():
return
{
"message"
:
"Hello World"
}
Note
If you don't know the difference, check the
Async:
"In a hurry?"
.
Step 5: return the content
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
root
():
return
{
"message"
:
"Hello World"
}
You can return a
dict
,
list
, singular values as
str
,
int
, etc.
You can also return Pydantic models (you'll see more about that later).
There are many other objects and models that will be automatically converted to JSON (including ORMs, etc). Try using your favorite ones, it's highly probable that they are already supported.
Recap
Import
FastAPI
.
Create an
app
instance.
Write a
path operation decorator
using decorators like
@app.get("/")
.
Define a
path operation function
; for example,
def root(): ...
.
Run the development server using the command
fastapi dev
.

## 130_TUTORIAL_HANDLING_ERRORS
Handling Errors¬∂
---

Handling Errors
There are many situations in which you need to notify an error to a client that is using your API.
This client could be a browser with a frontend, a code from someone else, an IoT device, etc.
You could need to tell the client that:
The client doesn't have enough privileges for that operation.
The client doesn't have access to that resource.
The item the client was trying to access doesn't exist.
etc.
In these cases, you would normally return an
HTTP status code
in the range of
400
(from 400 to 499).
This is similar to the 200 HTTP status codes (from 200 to 299). Those "200" status codes mean that somehow there was a "success" in the request.
The status codes in the 400 range mean that there was an error from the client.
Remember all those
"404 Not Found"
errors (and jokes)?
Use
HTTPException
To return HTTP responses with errors to the client you use
HTTPException
.
Import
HTTPException
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
app
=
FastAPI
()
items
=
{
"foo"
:
"The Foo Wrestlers"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
items
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"item"
:
items
[
item_id
]}
Raise an
HTTPException
in your code
HTTPException
is a normal Python exception with additional data relevant for APIs.
Because it's a Python exception, you don't
return
it, you
raise
it.
This also means that if you are inside a utility function that you are calling inside of your
path operation function
, and you raise the
HTTPException
from inside of that utility function, it won't run the rest of the code in the
path operation function
, it will terminate that request right away and send the HTTP error from the
HTTPException
to the client.
The benefit of raising an exception over returning a value will be more evident in the section about Dependencies and Security.
In this example, when the client requests an item by an ID that doesn't exist, raise an exception with a status code of
404
:
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
app
=
FastAPI
()
items
=
{
"foo"
:
"The Foo Wrestlers"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
):
if
item_id
not
in
items
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
{
"item"
:
items
[
item_id
]}
The resulting response
If the client requests
http://example.com/items/foo
(an
item_id
"foo"
), that client will receive an HTTP status code of 200, and a JSON response of:
{
"item"
:
"The Foo Wrestlers"
}
But if the client requests
http://example.com/items/bar
(a non-existent
item_id
"bar"
), that client will receive an HTTP status code of 404 (the "not found" error), and a JSON response of:
{
"detail"
:
"Item not found"
}
Tip
When raising an
HTTPException
, you can pass any value that can be converted to JSON as the parameter
detail
, not only
str
.
You could pass a
dict
, a
list
, etc.
They are handled automatically by
FastAPI
and converted to JSON.
Add custom headers
There are some situations in where it's useful to be able to add custom headers to the HTTP error. For example, for some types of security.
You probably won't need to use it directly in your code.
But in case you needed it for an advanced scenario, you can add custom headers:
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
app
=
FastAPI
()
items
=
{
"foo"
:
"The Foo Wrestlers"
}
@app
.
get
(
"/items-header/
{item_id}
"
)
async
def
read_item_header
(
item_id
:
str
):
if
item_id
not
in
items
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
,
headers
=
{
"X-Error"
:
"There goes my error"
},
)
return
{
"item"
:
items
[
item_id
]}
Install custom exception handlers
You can add custom exception handlers with
the same exception utilities from Starlette
.
Let's say you have a custom exception
UnicornException
that you (or a library you use) might
raise
.
And you want to handle this exception globally with FastAPI.
You could add a custom exception handler with
@app.exception_handler()
:
Python 3.8+
from
fastapi
import
FastAPI
,
Request
from
fastapi.responses
import
JSONResponse
class
UnicornException
(
Exception
):
def
__init__
(
self
,
name
:
str
):
self
.
name
=
name
app
=
FastAPI
()
@app
.
exception_handler
(
UnicornException
)
async
def
unicorn_exception_handler
(
request
:
Request
,
exc
:
UnicornException
):
return
JSONResponse
(
status_code
=
418
,
content
=
{
"message"
:
f
"Oops!
{
exc
.
name
}
did something. There goes a rainbow..."
},
)
@app
.
get
(
"/unicorns/
{name}
"
)
async
def
read_unicorn
(
name
:
str
):
if
name
==
"yolo"
:
raise
UnicornException
(
name
=
name
)
return
{
"unicorn_name"
:
name
}
Here, if you request
/unicorns/yolo
, the
path operation
will
raise
a
UnicornException
.
But it will be handled by the
unicorn_exception_handler
.
So, you will receive a clean error, with an HTTP status code of
418
and a JSON content of:
{
"message"
:
"Oops! yolo did something. There goes a rainbow..."
}
Technical Details
You could also use
from starlette.requests import Request
and
from starlette.responses import JSONResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with
Request
.
Override the default exception handlers
FastAPI
has some default exception handlers.
These handlers are in charge of returning the default JSON responses when you
raise
an
HTTPException
and when the request has invalid data.
You can override these exception handlers with your own.
Override request validation exceptions
When a request contains invalid data,
FastAPI
internally raises a
RequestValidationError
.
And it also includes a default exception handler for it.
To override it, import the
RequestValidationError
and use it with
@app.exception_handler(RequestValidationError)
to decorate the exception handler.
The exception handler will receive a
Request
and the exception.
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
from
fastapi.exceptions
import
RequestValidationError
from
fastapi.responses
import
PlainTextResponse
from
starlette.exceptions
import
HTTPException
as
StarletteHTTPException
app
=
FastAPI
()
@app
.
exception_handler
(
StarletteHTTPException
)
async
def
http_exception_handler
(
request
,
exc
):
return
PlainTextResponse
(
str
(
exc
.
detail
),
status_code
=
exc
.
status_code
)
@app
.
exception_handler
(
RequestValidationError
)
async
def
validation_exception_handler
(
request
,
exc
):
return
PlainTextResponse
(
str
(
exc
),
status_code
=
400
)
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
):
if
item_id
==
3
:
raise
HTTPException
(
status_code
=
418
,
detail
=
"Nope! I don't like 3."
)
return
{
"item_id"
:
item_id
}
Now, if you go to
/items/foo
, instead of getting the default JSON error with:
{
"detail"
:
[
{
"loc"
:
[
"path"
,
"item_id"
],
"msg"
:
"value is not a valid integer"
,
"type"
:
"type_error.integer"
}
]
}
you will get a text version, with:
1 validation error
path -> item_id
value is not a valid integer (type=type_error.integer)
RequestValidationError
vs
ValidationError
Warning
These are technical details that you might skip if it's not important for you now.
RequestValidationError
is a sub-class of Pydantic's
ValidationError
.
FastAPI
uses it so that, if you use a Pydantic model in
response_model
, and your data has an error, you will see the error in your log.
But the client/user will not see it. Instead, the client will receive an "Internal Server Error" with an HTTP status code
500
.
It should be this way because if you have a Pydantic
ValidationError
in your
response
or anywhere in your code (not in the client's
request
), it's actually a bug in your code.
And while you fix it, your clients/users shouldn't have access to internal information about the error, as that could expose a security vulnerability.
Override the
HTTPException
error handler
The same way, you can override the
HTTPException
handler.
For example, you could want to return a plain text response instead of JSON for these errors:
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
from
fastapi.exceptions
import
RequestValidationError
from
fastapi.responses
import
PlainTextResponse
from
starlette.exceptions
import
HTTPException
as
StarletteHTTPException
app
=
FastAPI
()
@app
.
exception_handler
(
StarletteHTTPException
)
async
def
http_exception_handler
(
request
,
exc
):
return
PlainTextResponse
(
str
(
exc
.
detail
),
status_code
=
exc
.
status_code
)
@app
.
exception_handler
(
RequestValidationError
)
async
def
validation_exception_handler
(
request
,
exc
):
return
PlainTextResponse
(
str
(
exc
),
status_code
=
400
)
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
):
if
item_id
==
3
:
raise
HTTPException
(
status_code
=
418
,
detail
=
"Nope! I don't like 3."
)
return
{
"item_id"
:
item_id
}
Technical Details
You could also use
from starlette.responses import PlainTextResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
Use the
RequestValidationError
body
The
RequestValidationError
contains the
body
it received with invalid data.
You could use it while developing your app to log the body and debug it, return it to the user, etc.
Python 3.8+
from
fastapi
import
FastAPI
,
Request
,
status
from
fastapi.encoders
import
jsonable_encoder
from
fastapi.exceptions
import
RequestValidationError
from
fastapi.responses
import
JSONResponse
from
pydantic
import
BaseModel
app
=
FastAPI
()
@app
.
exception_handler
(
RequestValidationError
)
async
def
validation_exception_handler
(
request
:
Request
,
exc
:
RequestValidationError
):
return
JSONResponse
(
status_code
=
status
.
HTTP_422_UNPROCESSABLE_ENTITY
,
content
=
jsonable_encoder
({
"detail"
:
exc
.
errors
(),
"body"
:
exc
.
body
}),
)
class
Item
(
BaseModel
):
title
:
str
size
:
int
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
):
return
item
Now try sending an invalid item like:
{
"title"
:
"towel"
,
"size"
:
"XL"
}
You will receive a response telling you that the data is invalid containing the received body:
{
"detail"
:
[
{
"loc"
:
[
"body"
,
"size"
],
"msg"
:
"value is not a valid integer"
,
"type"
:
"type_error.integer"
}
],
"body"
:
{
"title"
:
"towel"
,
"size"
:
"XL"
}
}
FastAPI's
HTTPException
vs Starlette's
HTTPException
FastAPI
has its own
HTTPException
.
And
FastAPI
's
HTTPException
error class inherits from Starlette's
HTTPException
error class.
The only difference is that
FastAPI
's
HTTPException
accepts any JSON-able data for the
detail
field, while Starlette's
HTTPException
only accepts strings for it.
So, you can keep raising
FastAPI
's
HTTPException
as normally in your code.
But when you register an exception handler, you should register it for Starlette's
HTTPException
.
This way, if any part of Starlette's internal code, or a Starlette extension or plug-in, raises a Starlette
HTTPException
, your handler will be able to catch and handle it.
In this example, to be able to have both
HTTPException
s in the same code, Starlette's exceptions is renamed to
StarletteHTTPException
:
from
starlette.exceptions
import
HTTPException
as
StarletteHTTPException
Reuse
FastAPI
's exception handlers
If you want to use the exception along with the same default exception handlers from
FastAPI
, you can import and reuse the default exception handlers from
fastapi.exception_handlers
:
Python 3.8+
from
fastapi
import
FastAPI
,
HTTPException
from
fastapi.exception_handlers
import
(
http_exception_handler
,
request_validation_exception_handler
,
)
from
fastapi.exceptions
import
RequestValidationError
from
starlette.exceptions
import
HTTPException
as
StarletteHTTPException
app
=
FastAPI
()
@app
.
exception_handler
(
StarletteHTTPException
)
async
def
custom_http_exception_handler
(
request
,
exc
):
print
(
f
"OMG! An HTTP error!:
{
repr
(
exc
)
}
"
)
return
await
http_exception_handler
(
request
,
exc
)
@app
.
exception_handler
(
RequestValidationError
)
async
def
validation_exception_handler
(
request
,
exc
):
print
(
f
"OMG! The client sent invalid data!:
{
exc
}
"
)
return
await
request_validation_exception_handler
(
request
,
exc
)
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
):
if
item_id
==
3
:
raise
HTTPException
(
status_code
=
418
,
detail
=
"Nope! I don't like 3."
)
return
{
"item_id"
:
item_id
}
In this example you are just printing the error with a very expressive message, but you get the idea. You can use the exception and then just reuse the default exception handlers.

## 131_TUTORIAL_HEADER_PARAM_MODELS
Header Parameter Models¬∂
---

Header Parameter Models
If you have a group of related
header parameters
, you can create a
Pydantic model
to declare them.
This would allow you to
re-use the model
in
multiple places
and also to declare validations and metadata for all the parameters at once. üòé
Note
This is supported since FastAPI version
0.115.0
. ü§ì
Header Parameters with a Pydantic Model
Declare the
header parameters
that you need in a
Pydantic model
, and then declare the parameter as
Header
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
FastAPI
will
extract
the data for
each field
from the
headers
in the request and give you the Pydantic model you defined.
Check the Docs
You can see the required headers in the docs UI at
/docs
:
Forbid Extra Headers
In some special use cases (probably not very common), you might want to
restrict
the headers that you want to receive.
You can use Pydantic's model configuration to
forbid
any
extra
fields:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
()]):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
()):
return
headers
If a client tries to send some
extra headers
, they will receive an
error
response.
For example, if the client tries to send a
tool
header with a value of
plumbus
, they will receive an
error
response telling them that the header parameter
tool
is not allowed:
{
"detail"
:
[
{
"type"
:
"extra_forbidden"
,
"loc"
:
[
"header"
,
"tool"
],
"msg"
:
"Extra inputs are not permitted"
,
"input"
:
"plumbus"
,
}
]
}
Disable Convert Underscores
The same way as with regular header parameters, when you have underscore characters in the parameter names, they are
automatically converted to hyphens
.
For example, if you have a header parameter
save_data
in the code, the expected HTTP header will be
save-data
, and it will show up like that in the docs.
If for some reason you need to disable this automatic conversion, you can do it as well for Pydantic models for header parameters.
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
(
convert_underscores
=
False
)],
):
return
headers
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
(
convert_underscores
=
False
)],
):
return
headers
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
Annotated
[
CommonHeaders
,
Header
(
convert_underscores
=
False
)],
):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
str
|
None
=
None
traceparent
:
str
|
None
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
(
convert_underscores
=
False
)):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
(
convert_underscores
=
False
)):
return
headers
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
CommonHeaders
(
BaseModel
):
host
:
str
save_data
:
bool
if_modified_since
:
Union
[
str
,
None
]
=
None
traceparent
:
Union
[
str
,
None
]
=
None
x_tag
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
headers
:
CommonHeaders
=
Header
(
convert_underscores
=
False
)):
return
headers
Warning
Before setting
convert_underscores
to
False
, bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.
Summary
You can use
Pydantic models
to declare
headers
in
FastAPI
. üòé

## 132_TUTORIAL_HEADER_PARAMS
Header Parameters¬∂
---

Header Parameters
You can define Header parameters the same way you define
Query
,
Path
and
Cookie
parameters.
Import
Header
First import
Header
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
str
|
None
,
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
Union
[
str
,
None
],
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
Union
[
str
,
None
],
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
str
|
None
=
Header
(
default
=
None
)):
return
{
"User-Agent"
:
user_agent
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Union
[
str
,
None
]
=
Header
(
default
=
None
)):
return
{
"User-Agent"
:
user_agent
}
Declare
Header
parameters
Then declare the header parameters using the same structure as with
Path
,
Query
and
Cookie
.
You can define the default value as well as all the extra validation or annotation parameters:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
str
|
None
,
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
Union
[
str
,
None
],
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Annotated
[
Union
[
str
,
None
],
Header
()]
=
None
):
return
{
"User-Agent"
:
user_agent
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
str
|
None
=
Header
(
default
=
None
)):
return
{
"User-Agent"
:
user_agent
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
user_agent
:
Union
[
str
,
None
]
=
Header
(
default
=
None
)):
return
{
"User-Agent"
:
user_agent
}
Technical Details
Header
is a "sister" class of
Path
,
Query
and
Cookie
. It also inherits from the same common
Param
class.
But remember that when you import
Query
,
Path
,
Header
, and others from
fastapi
, those are actually functions that return special classes.
Info
To declare headers, you need to use
Header
, because otherwise the parameters would be interpreted as query parameters.
Automatic conversion
Header
has a little extra functionality on top of what
Path
,
Query
and
Cookie
provide.
Most of the standard headers are separated by a "hyphen" character, also known as the "minus symbol" (
-
).
But a variable like
user-agent
is invalid in Python.
So, by default,
Header
will convert the parameter names characters from underscore (
_
) to hyphen (
-
) to extract and document the headers.
Also, HTTP headers are case-insensitive, so, you can declare them with standard Python style (also known as "snake_case").
So, you can use
user_agent
as you normally would in Python code, instead of needing to capitalize the first letters as
User_Agent
or something similar.
If for some reason you need to disable automatic conversion of underscores to hyphens, set the parameter
convert_underscores
of
Header
to
False
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
strange_header
:
Annotated
[
str
|
None
,
Header
(
convert_underscores
=
False
)]
=
None
,
):
return
{
"strange_header"
:
strange_header
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
strange_header
:
Annotated
[
Union
[
str
,
None
],
Header
(
convert_underscores
=
False
)
]
=
None
,
):
return
{
"strange_header"
:
strange_header
}
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
strange_header
:
Annotated
[
Union
[
str
,
None
],
Header
(
convert_underscores
=
False
)
]
=
None
,
):
return
{
"strange_header"
:
strange_header
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
strange_header
:
str
|
None
=
Header
(
default
=
None
,
convert_underscores
=
False
),
):
return
{
"strange_header"
:
strange_header
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
strange_header
:
Union
[
str
,
None
]
=
Header
(
default
=
None
,
convert_underscores
=
False
),
):
return
{
"strange_header"
:
strange_header
}
Warning
Before setting
convert_underscores
to
False
, bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.
Duplicate headers
It is possible to receive duplicate headers. That means, the same header with multiple values.
You can define those cases using a list in the type declaration.
You will receive all the values from the duplicate header as a Python
list
.
For example, to declare a header of
X-Token
that can appear more than once, you can write:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
Annotated
[
list
[
str
]
|
None
,
Header
()]
=
None
):
return
{
"X-Token values"
:
x_token
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
List
,
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
Annotated
[
Union
[
List
[
str
],
None
],
Header
()]
=
None
):
return
{
"X-Token values"
:
x_token
}
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
Annotated
[
Union
[
List
[
str
],
None
],
Header
()]
=
None
):
return
{
"X-Token values"
:
x_token
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
list
[
str
]
|
None
=
Header
(
default
=
None
)):
return
{
"X-Token values"
:
x_token
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
Union
[
list
[
str
],
None
]
=
Header
(
default
=
None
)):
return
{
"X-Token values"
:
x_token
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Header
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
x_token
:
Union
[
List
[
str
],
None
]
=
Header
(
default
=
None
)):
return
{
"X-Token values"
:
x_token
}
If you communicate with that
path operation
sending two HTTP headers like:
X-Token: foo
X-Token: bar
The response would be like:
{
"X-Token values"
:
[
"bar"
,
"foo"
]
}
Recap
Declare headers with
Header
, using the same common pattern as
Query
,
Path
and
Cookie
.
And don't worry about underscores in your variables,
FastAPI
will take care of converting them.

## 133_TUTORIAL_METADATA
Metadata and Docs URLs¬∂
---

Metadata and Docs URLs
You can customize several metadata configurations in your
FastAPI
application.
Metadata for API
You can set the following fields that are used in the OpenAPI specification and the automatic API docs UIs:
Parameter
Type
Description
title
str
The title of the API.
summary
str
A short summary of the API.
Available since OpenAPI 3.1.0, FastAPI 0.99.0.
description
str
A short description of the API. It can use Markdown.
version
string
The version of the API. This is the version of your own application, not of OpenAPI. For example
2.5.0
.
terms_of_service
str
A URL to the Terms of Service for the API. If provided, this has to be a URL.
contact
dict
The contact information for the exposed API. It can contain several fields.
contact
fields
Parameter
Type
Description
name
str
The identifying name of the contact person/organization.
url
str
The URL pointing to the contact information. MUST be in the format of a URL.
email
str
The email address of the contact person/organization. MUST be in the format of an email address.
license_info
dict
The license information for the exposed API. It can contain several fields.
license_info
fields
Parameter
Type
Description
name
str
REQUIRED
(if a
license_info
is set). The license name used for the API.
identifier
str
An
SPDX
license expression for the API. The
identifier
field is mutually exclusive of the
url
field.
Available since OpenAPI 3.1.0, FastAPI 0.99.0.
url
str
A URL to the license used for the API. MUST be in the format of a URL.
You can set them as follows:
Python 3.8+
from
fastapi
import
FastAPI
description
=
"""
ChimichangApp API helps you do awesome stuff. üöÄ
## Items
You can **read items**.
## Users
You will be able to:
* **Create users** (_not implemented_).
* **Read users** (_not implemented_).
"""
app
=
FastAPI
(
title
=
"ChimichangApp"
,
description
=
description
,
summary
=
"Deadpool's favorite app. Nuff said."
,
version
=
"0.0.1"
,
terms_of_service
=
"http://example.com/terms/"
,
contact
=
{
"name"
:
"Deadpoolio the Amazing"
,
"url"
:
"http://x-force.example.com/contact/"
,
"email"
:
"dp@x-force.example.com"
,
},
license_info
=
{
"name"
:
"Apache 2.0"
,
"url"
:
"https://www.apache.org/licenses/LICENSE-2.0.html"
,
},
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Katana"
}]
Tip
You can write Markdown in the
description
field and it will be rendered in the output.
With this configuration, the automatic API docs would look like:
License identifier
Since OpenAPI 3.1.0 and FastAPI 0.99.0, you can also set the
license_info
with an
identifier
instead of a
url
.
For example:
Python 3.8+
from
fastapi
import
FastAPI
description
=
"""
ChimichangApp API helps you do awesome stuff. üöÄ
## Items
You can **read items**.
## Users
You will be able to:
* **Create users** (_not implemented_).
* **Read users** (_not implemented_).
"""
app
=
FastAPI
(
title
=
"ChimichangApp"
,
description
=
description
,
summary
=
"Deadpool's favorite app. Nuff said."
,
version
=
"0.0.1"
,
terms_of_service
=
"http://example.com/terms/"
,
contact
=
{
"name"
:
"Deadpoolio the Amazing"
,
"url"
:
"http://x-force.example.com/contact/"
,
"email"
:
"dp@x-force.example.com"
,
},
license_info
=
{
"name"
:
"Apache 2.0"
,
"identifier"
:
"MIT"
,
},
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Katana"
}]
Metadata for tags
You can also add additional metadata for the different tags used to group your path operations with the parameter
openapi_tags
.
It takes a list containing one dictionary for each tag.
Each dictionary can contain:
name
(
required
): a
str
with the same tag name you use in the
tags
parameter in your
path operations
and
APIRouter
s.
description
: a
str
with a short description for the tag. It can have Markdown and will be shown in the docs UI.
externalDocs
: a
dict
describing external documentation with:
description
: a
str
with a short description for the external docs.
url
(
required
): a
str
with the URL for the external documentation.
Create metadata for tags
Let's try that in an example with tags for
users
and
items
.
Create metadata for your tags and pass it to the
openapi_tags
parameter:
Python 3.8+
from
fastapi
import
FastAPI
tags_metadata
=
[
{
"name"
:
"users"
,
"description"
:
"Operations with users. The **login** logic is also here."
,
},
{
"name"
:
"items"
,
"description"
:
"Manage items. So _fancy_ they have their own docs."
,
"externalDocs"
:
{
"description"
:
"Items external docs"
,
"url"
:
"https://fastapi.tiangolo.com/"
,
},
},
]
app
=
FastAPI
(
openapi_tags
=
tags_metadata
)
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
get_users
():
return
[{
"name"
:
"Harry"
},
{
"name"
:
"Ron"
}]
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
get_items
():
return
[{
"name"
:
"wand"
},
{
"name"
:
"flying broom"
}]
Notice that you can use Markdown inside of the descriptions, for example "login" will be shown in bold (
login
) and "fancy" will be shown in italics (
fancy
).
Tip
You don't have to add metadata for all the tags that you use.
Use your tags
Use the
tags
parameter with your
path operations
(and
APIRouter
s) to assign them to different tags:
Python 3.8+
from
fastapi
import
FastAPI
tags_metadata
=
[
{
"name"
:
"users"
,
"description"
:
"Operations with users. The **login** logic is also here."
,
},
{
"name"
:
"items"
,
"description"
:
"Manage items. So _fancy_ they have their own docs."
,
"externalDocs"
:
{
"description"
:
"Items external docs"
,
"url"
:
"https://fastapi.tiangolo.com/"
,
},
},
]
app
=
FastAPI
(
openapi_tags
=
tags_metadata
)
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
get_users
():
return
[{
"name"
:
"Harry"
},
{
"name"
:
"Ron"
}]
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
get_items
():
return
[{
"name"
:
"wand"
},
{
"name"
:
"flying broom"
}]
Info
Read more about tags in
Path Operation Configuration
.
Check the docs
Now, if you check the docs, they will show all the additional metadata:
Order of tags
The order of each tag metadata dictionary also defines the order shown in the docs UI.
For example, even though
users
would go after
items
in alphabetical order, it is shown before them, because we added their metadata as the first dictionary in the list.
OpenAPI URL
By default, the OpenAPI schema is served at
/openapi.json
.
But you can configure it with the parameter
openapi_url
.
For example, to set it to be served at
/api/v1/openapi.json
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
(
openapi_url
=
"/api/v1/openapi.json"
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]
If you want to disable the OpenAPI schema completely you can set
openapi_url=None
, that will also disable the documentation user interfaces that use it.
Docs URLs
You can configure the two documentation user interfaces included:
Swagger UI
: served at
/docs
.
You can set its URL with the parameter
docs_url
.
You can disable it by setting
docs_url=None
.
ReDoc
: served at
/redoc
.
You can set its URL with the parameter
redoc_url
.
You can disable it by setting
redoc_url=None
.
For example, to set Swagger UI to be served at
/documentation
and disable ReDoc:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
(
docs_url
=
"/documentation"
,
redoc_url
=
None
)
@app
.
get
(
"/items/"
)
async
def
read_items
():
return
[{
"name"
:
"Foo"
}]

## 134_TUTORIAL_MIDDLEWARE
Middleware¬∂
---

Middleware
You can add middleware to
FastAPI
applications.
A "middleware" is a function that works with every
request
before it is processed by any specific
path operation
. And also with every
response
before returning it.
It takes each
request
that comes to your application.
It can then do something to that
request
or run any needed code.
Then it passes the
request
to be processed by the rest of the application (by some
path operation
).
It then takes the
response
generated by the application (by some
path operation
).
It can do something to that
response
or run any needed code.
Then it returns the
response
.
Technical Details
If you have dependencies with
yield
, the exit code will run
after
the middleware.
If there were any background tasks (covered in the
Background Tasks
section, you will see it later), they will run
after
all the middleware.
Create a middleware
To create a middleware you use the decorator
@app.middleware("http")
on top of a function.
The middleware function receives:
The
request
.
A function
call_next
that will receive the
request
as a parameter.
This function will pass the
request
to the corresponding
path operation
.
Then it returns the
response
generated by the corresponding
path operation
.
You can then further modify the
response
before returning it.
Python 3.8+
import
time
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
@app
.
middleware
(
"http"
)
async
def
add_process_time_header
(
request
:
Request
,
call_next
):
start_time
=
time
.
perf_counter
()
response
=
await
call_next
(
request
)
process_time
=
time
.
perf_counter
()
-
start_time
response
.
headers
[
"X-Process-Time"
]
=
str
(
process_time
)
return
response
Tip
Keep in mind that custom proprietary headers can be added
using the 'X-' prefix
.
But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (
CORS (Cross-Origin Resource Sharing)
) using the parameter
expose_headers
documented in
Starlette's CORS docs
.
Technical Details
You could also use
from starlette.requests import Request
.
FastAPI
provides it as a convenience for you, the developer. But it comes directly from Starlette.
Before and after the
response
You can add code to be run with the
request
, before any
path operation
receives it.
And also after the
response
is generated, before returning it.
For example, you could add a custom header
X-Process-Time
containing the time in seconds that it took to process the request and generate a response:
Python 3.8+
import
time
from
fastapi
import
FastAPI
,
Request
app
=
FastAPI
()
@app
.
middleware
(
"http"
)
async
def
add_process_time_header
(
request
:
Request
,
call_next
):
start_time
=
time
.
perf_counter
()
response
=
await
call_next
(
request
)
process_time
=
time
.
perf_counter
()
-
start_time
response
.
headers
[
"X-Process-Time"
]
=
str
(
process_time
)
return
response
Tip
Here we use
time.perf_counter()
instead of
time.time()
because it can be more precise for these use cases. ü§ì
Multiple middleware execution order
When you add multiple middlewares using either
@app.middleware()
decorator or
app.add_middleware()
method, each new middleware wraps the application, forming a stack. The last middleware added is the
outermost
, and the first is the
innermost
.
On the request path, the
outermost
middleware runs first.
On the response path, it runs last.
For example:
app
.
add_middleware
(
MiddlewareA
)
app
.
add_middleware
(
MiddlewareB
)
This results in the following execution order:
Request
: MiddlewareB ‚Üí MiddlewareA ‚Üí route
Response
: route ‚Üí MiddlewareA ‚Üí MiddlewareB
This stacking behavior ensures that middlewares are executed in a predictable and controllable order.
Other middlewares
You can later read more about other middlewares in the
Advanced User Guide: Advanced Middleware
.
You will read about how to handle
CORS
with a middleware in the next section.

## 135_TUTORIAL_PATH_OPERATION_CONFIGURATION
Path Operation Configuration¬∂
---

Path Operation Configuration
There are several parameters that you can pass to your
path operation decorator
to configure it.
Warning
Notice that these parameters are passed directly to the
path operation decorator
, not to your
path operation function
.
Response Status Code
You can define the (HTTP)
status_code
to be used in the response of your
path operation
.
You can pass directly the
int
code, like
404
.
But if you don't remember what each number code is for, you can use the shortcut constants in
status
:
Python 3.10+
from
fastapi
import
FastAPI
,
status
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
status_code
=
status
.
HTTP_201_CREATED
)
async
def
create_item
(
item
:
Item
):
return
item
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
,
status
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
status_code
=
status
.
HTTP_201_CREATED
)
async
def
create_item
(
item
:
Item
):
return
item
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
,
status
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
status_code
=
status
.
HTTP_201_CREATED
)
async
def
create_item
(
item
:
Item
):
return
item
That status code will be used in the response and will be added to the OpenAPI schema.
Technical Details
You could also use
from starlette import status
.
FastAPI
provides the same
starlette.status
as
fastapi.status
just as a convenience for you, the developer. But it comes directly from Starlette.
Tags
You can add tags to your
path operation
, pass the parameter
tags
with a
list
of
str
(commonly just one
str
):
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
read_items
():
return
[{
"name"
:
"Foo"
,
"price"
:
42
}]
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"johndoe"
}]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
read_items
():
return
[{
"name"
:
"Foo"
,
"price"
:
42
}]
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"johndoe"
}]
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
tags
=
[
"items"
])
async
def
create_item
(
item
:
Item
):
return
item
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
read_items
():
return
[{
"name"
:
"Foo"
,
"price"
:
42
}]
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"johndoe"
}]
They will be added to the OpenAPI schema and used by the automatic documentation interfaces:
Tags with Enums
If you have a big application, you might end up accumulating
several tags
, and you would want to make sure you always use the
same tag
for related
path operations
.
In these cases, it could make sense to store the tags in an
Enum
.
FastAPI
supports that the same way as with plain strings:
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
app
=
FastAPI
()
class
Tags
(
Enum
):
items
=
"items"
users
=
"users"
@app
.
get
(
"/items/"
,
tags
=
[
Tags
.
items
])
async
def
get_items
():
return
[
"Portal gun"
,
"Plumbus"
]
@app
.
get
(
"/users/"
,
tags
=
[
Tags
.
users
])
async
def
read_users
():
return
[
"Rick"
,
"Morty"
]
Summary and description
You can add a
summary
and
description
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
description
=
"Create an item with all the information, name, description, price, tax and a set of unique tags"
,
)
async
def
create_item
(
item
:
Item
):
return
item
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
description
=
"Create an item with all the information, name, description, price, tax and a set of unique tags"
,
)
async
def
create_item
(
item
:
Item
):
return
item
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
description
=
"Create an item with all the information, name, description, price, tax and a set of unique tags"
,
)
async
def
create_item
(
item
:
Item
):
return
item
Description from docstring
As descriptions tend to be long and cover multiple lines, you can declare the
path operation
description in the function
docstring
and
FastAPI
will read it from there.
You can write
Markdown
in the docstring, it will be interpreted and displayed correctly (taking into account docstring indentation).
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
It will be used in the interactive docs:
Response description
You can specify the response description with the parameter
response_description
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
response_description
=
"The created item"
,
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
response_description
=
"The created item"
,
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
from
typing
import
Set
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
Set
[
str
]
=
set
()
@app
.
post
(
"/items/"
,
response_model
=
Item
,
summary
=
"Create an item"
,
response_description
=
"The created item"
,
)
async
def
create_item
(
item
:
Item
):
"""
Create an item with all the information:
- **name**: each item must have a name
- **description**: a long description
- **price**: required
- **tax**: if the item doesn't have tax, you can omit this
- **tags**: a set of unique tag strings for this item
"""
return
item
Info
Notice that
response_description
refers specifically to the response, the
description
refers to the
path operation
in general.
Check
OpenAPI specifies that each
path operation
requires a response description.
So, if you don't provide one,
FastAPI
will automatically generate one of "Successful response".
Deprecate a
path operation
If you need to mark a
path operation
as
deprecated
, but without removing it, pass the parameter
deprecated
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
,
tags
=
[
"items"
])
async
def
read_items
():
return
[{
"name"
:
"Foo"
,
"price"
:
42
}]
@app
.
get
(
"/users/"
,
tags
=
[
"users"
])
async
def
read_users
():
return
[{
"username"
:
"johndoe"
}]
@app
.
get
(
"/elements/"
,
tags
=
[
"items"
],
deprecated
=
True
)
async
def
read_elements
():
return
[{
"item_id"
:
"Foo"
}]
It will be clearly marked as deprecated in the interactive docs:
Check how deprecated and non-deprecated
path operations
look like:
Recap
You can configure and add metadata for your
path operations
easily by passing parameters to the
path operation decorators
.

## 136_TUTORIAL_PATH_PARAMS_NUMERIC_VALIDATIONS
Path Parameters and Numeric Validations¬∂
---

Path Parameters and Numeric Validations
In the same way that you can declare more validations and metadata for query parameters with
Query
, you can declare the same type of validations and metadata for path parameters with
Path
.
Import Path
First, import
Path
from
fastapi
, and import
Annotated
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
str
|
None
,
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
str
|
None
=
Query
(
default
=
None
,
alias
=
"item-query"
),
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
alias
=
"item-query"
),
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Info
FastAPI added support for
Annotated
(and started recommending it) in version 0.95.0.
If you have an older version, you would get errors when trying to use
Annotated
.
Make sure you
Upgrade the FastAPI version
to at least 0.95.1 before using
Annotated
.
Declare metadata
You can declare all the same parameters as for
Query
.
For example, to declare a
title
metadata value for the path parameter
item_id
you can type:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
str
|
None
,
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
str
|
None
=
Query
(
default
=
None
,
alias
=
"item-query"
),
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
alias
=
"item-query"
),
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Note
A path parameter is always required as it has to be part of the path. Even if you declared it with
None
or set a default value, it would not affect anything, it would still be always required.
Order the parameters as you need
Tip
This is probably not as important or necessary if you use
Annotated
.
Let's say that you want to declare the query parameter
q
as a required
str
.
And you don't need to declare anything else for that parameter, so you don't really need to use
Query
.
But you still need to use
Path
for the
item_id
path parameter. And you don't want to use
Annotated
for some reason.
Python will complain if you put a value with a "default" before a value that doesn't have a "default".
But you can re-order them, and have the value without a default (the query parameter
q
) first.
It doesn't matter for
FastAPI
. It will detect the parameters by their names, types and default declarations (
Query
,
Path
, etc), it doesn't care about the order.
So, you can declare your function as:
Python 3.8 non-Annotated
Tip
Prefer to use the
Annotated
version if possible.
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
)):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)]
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)]
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
But keep in mind that if you use
Annotated
, you won't have this problem, it won't matter as you're not using the function parameter default values for
Query()
or
Path()
.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)]
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)]
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
q
:
str
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
)):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Order the parameters as you need, tricks
Tip
This is probably not as important or necessary if you use
Annotated
.
Here's a
small trick
that can be handy, but you won't need it often.
If you want to:
declare the
q
query parameter without a
Query
nor any default value
declare the path parameter
item_id
using
Path
have them in a different order
not use
Annotated
...Python has a little special syntax for that.
Pass
*
, as the first parameter of the function.
Python won't do anything with that
*
, but it will know that all the following parameters should be called as keyword arguments (key-value pairs), also known as
kwargs
. Even if they don't have a default value.
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Better with
Annotated
Keep in mind that if you use
Annotated
, as you are not using function parameter default values, you won't have this problem, and you probably won't need to use
*
.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
),
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Number validations: greater than or equal
With
Query
and
Path
(and others you'll see later) you can declare number constraints.
Here, with
ge=1
,
item_id
will need to be an integer number "
g
reater than or
e
qual" to
1
.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
1
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
1
)],
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
,
ge
=
1
),
q
:
str
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Number validations: greater than and less than or equal
The same applies for:
gt
:
g
reater
t
han
le
:
l
ess than or
e
qual
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
gt
=
0
,
le
=
1000
)],
q
:
str
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
gt
=
0
,
le
=
1000
)],
q
:
str
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
,
gt
=
0
,
le
=
1000
),
q
:
str
,
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Number validations: floats, greater than and less than
Number validations also work for
float
values.
Here's where it becomes important to be able to declare
gt
and not just
ge
. As with it you can require, for example, that a value must be greater than
0
, even if it is less than
1
.
So,
0.5
would be a valid value. But
0.0
or
0
would not.
And the same for
lt
.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
)],
q
:
str
,
size
:
Annotated
[
float
,
Query
(
gt
=
0
,
lt
=
10.5
)],
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
size
:
results
.
update
({
"size"
:
size
})
return
results
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Path
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
Annotated
[
int
,
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
)],
q
:
str
,
size
:
Annotated
[
float
,
Query
(
gt
=
0
,
lt
=
10.5
)],
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
size
:
results
.
update
({
"size"
:
size
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Path
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_items
(
*
,
item_id
:
int
=
Path
(
title
=
"The ID of the item to get"
,
ge
=
0
,
le
=
1000
),
q
:
str
,
size
:
float
=
Query
(
gt
=
0
,
lt
=
10.5
),
):
results
=
{
"item_id"
:
item_id
}
if
q
:
results
.
update
({
"q"
:
q
})
if
size
:
results
.
update
({
"size"
:
size
})
return
results
Recap
With
Query
,
Path
(and others you haven't seen yet) you can declare metadata and string validations in the same ways as with
Query Parameters and String Validations
.
And you can also declare numeric validations:
gt
:
g
reater
t
han
ge
:
g
reater than or
e
qual
lt
:
l
ess
t
han
le
:
l
ess than or
e
qual
Info
Query
,
Path
, and other classes you will see later are subclasses of a common
Param
class.
All of them share the same parameters for additional validation and metadata you have seen.
Technical Details
When you import
Query
,
Path
and others from
fastapi
, they are actually functions.
That when called, return instances of classes of the same name.
So, you import
Query
, which is a function. And when you call it, it returns an instance of a class also named
Query
.
These functions are there (instead of just using the classes directly) so that your editor doesn't mark errors about their types.
That way you can use your normal editor and coding tools without having to add custom configurations to disregard those errors.

## 137_TUTORIAL_PATH_PARAMS
Path Parameters¬∂
---

Path Parameters
You can declare path "parameters" or "variables" with the same syntax used by Python format strings:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
):
return
{
"item_id"
:
item_id
}
The value of the path parameter
item_id
will be passed to your function as the argument
item_id
.
So, if you run this example and go to
http://127.0.0.1:8000/items/foo
, you will see a response of:
{
"item_id"
:
"foo"
}
Path parameters with types
You can declare the type of a path parameter in the function, using standard Python type annotations:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
):
return
{
"item_id"
:
item_id
}
In this case,
item_id
is declared to be an
int
.
Check
This will give you editor support inside of your function, with error checks, completion, etc.
Data
conversion
If you run this example and open your browser at
http://127.0.0.1:8000/items/3
, you will see a response of:
{
"item_id"
:
3
}
Check
Notice that the value your function received (and returned) is
3
, as a Python
int
, not a string
"3"
.
So, with that type declaration,
FastAPI
gives you automatic request
"parsing"
.
Data validation
But if you go to the browser at
http://127.0.0.1:8000/items/foo
, you will see a nice HTTP error of:
{
"detail"
:
[
{
"type"
:
"int_parsing"
,
"loc"
:
[
"path"
,
"item_id"
],
"msg"
:
"Input should be a valid integer, unable to parse string as an integer"
,
"input"
:
"foo"
,
"url"
:
"https://errors.pydantic.dev/2.1/v/int_parsing"
}
]
}
because the path parameter
item_id
had a value of
"foo"
, which is not an
int
.
The same error would appear if you provided a
float
instead of an
int
, as in:
http://127.0.0.1:8000/items/4.2
Check
So, with the same Python type declaration,
FastAPI
gives you data validation.
Notice that the error also clearly states exactly the point where the validation didn't pass.
This is incredibly helpful while developing and debugging code that interacts with your API.
Documentation
And when you open your browser at
http://127.0.0.1:8000/docs
, you will see an automatic, interactive, API documentation like:
Check
Again, just with that same Python type declaration,
FastAPI
gives you automatic, interactive documentation (integrating Swagger UI).
Notice that the path parameter is declared to be an integer.
Standards-based benefits, alternative documentation
And because the generated schema is from the
OpenAPI
standard, there are many compatible tools.
Because of this,
FastAPI
itself provides an alternative API documentation (using ReDoc), which you can access at
http://127.0.0.1:8000/redoc
:
The same way, there are many compatible tools. Including code generation tools for many languages.
Pydantic
All the data validation is performed under the hood by
Pydantic
, so you get all the benefits from it. And you know you are in good hands.
You can use the same type declarations with
str
,
float
,
bool
and many other complex data types.
Several of these are explored in the next chapters of the tutorial.
Order matters
When creating
path operations
, you can find situations where you have a fixed path.
Like
/users/me
, let's say that it's to get data about the current user.
And then you can also have a path
/users/{user_id}
to get data about a specific user by some user ID.
Because
path operations
are evaluated in order, you need to make sure that the path for
/users/me
is declared before the one for
/users/{user_id}
:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/users/me"
)
async
def
read_user_me
():
return
{
"user_id"
:
"the current user"
}
@app
.
get
(
"/users/
{user_id}
"
)
async
def
read_user
(
user_id
:
str
):
return
{
"user_id"
:
user_id
}
Otherwise, the path for
/users/{user_id}
would match also for
/users/me
, "thinking" that it's receiving a parameter
user_id
with a value of
"me"
.
Similarly, you cannot redefine a path operation:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/users"
)
async
def
read_users
():
return
[
"Rick"
,
"Morty"
]
@app
.
get
(
"/users"
)
async
def
read_users2
():
return
[
"Bean"
,
"Elfo"
]
The first one will always be used since the path matches first.
Predefined values
If you have a
path operation
that receives a
path parameter
, but you want the possible valid
path parameter
values to be predefined, you can use a standard Python
Enum
.
Create an
Enum
class
Import
Enum
and create a sub-class that inherits from
str
and from
Enum
.
By inheriting from
str
the API docs will be able to know that the values must be of type
string
and will be able to render correctly.
Then create class attributes with fixed values, which will be the available valid values:
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
class
ModelName
(
str
,
Enum
):
alexnet
=
"alexnet"
resnet
=
"resnet"
lenet
=
"lenet"
app
=
FastAPI
()
@app
.
get
(
"/models/
{model_name}
"
)
async
def
get_model
(
model_name
:
ModelName
):
if
model_name
is
ModelName
.
alexnet
:
return
{
"model_name"
:
model_name
,
"message"
:
"Deep Learning FTW!"
}
if
model_name
.
value
==
"lenet"
:
return
{
"model_name"
:
model_name
,
"message"
:
"LeCNN all the images"
}
return
{
"model_name"
:
model_name
,
"message"
:
"Have some residuals"
}
Info
Enumerations (or enums) are available in Python
since version 3.4.
Tip
If you are wondering, "AlexNet", "ResNet", and "LeNet" are just names of Machine Learning
models
.
Declare a
path parameter
Then create a
path parameter
with a type annotation using the enum class you created (
ModelName
):
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
class
ModelName
(
str
,
Enum
):
alexnet
=
"alexnet"
resnet
=
"resnet"
lenet
=
"lenet"
app
=
FastAPI
()
@app
.
get
(
"/models/
{model_name}
"
)
async
def
get_model
(
model_name
:
ModelName
):
if
model_name
is
ModelName
.
alexnet
:
return
{
"model_name"
:
model_name
,
"message"
:
"Deep Learning FTW!"
}
if
model_name
.
value
==
"lenet"
:
return
{
"model_name"
:
model_name
,
"message"
:
"LeCNN all the images"
}
return
{
"model_name"
:
model_name
,
"message"
:
"Have some residuals"
}
Check the docs
Because the available values for the
path parameter
are predefined, the interactive docs can show them nicely:
Working with Python
enumerations
The value of the
path parameter
will be an
enumeration member
.
Compare
enumeration members
You can compare it with the
enumeration member
in your created enum
ModelName
:
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
class
ModelName
(
str
,
Enum
):
alexnet
=
"alexnet"
resnet
=
"resnet"
lenet
=
"lenet"
app
=
FastAPI
()
@app
.
get
(
"/models/
{model_name}
"
)
async
def
get_model
(
model_name
:
ModelName
):
if
model_name
is
ModelName
.
alexnet
:
return
{
"model_name"
:
model_name
,
"message"
:
"Deep Learning FTW!"
}
if
model_name
.
value
==
"lenet"
:
return
{
"model_name"
:
model_name
,
"message"
:
"LeCNN all the images"
}
return
{
"model_name"
:
model_name
,
"message"
:
"Have some residuals"
}
Get the
enumeration value
You can get the actual value (a
str
in this case) using
model_name.value
, or in general,
your_enum_member.value
:
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
class
ModelName
(
str
,
Enum
):
alexnet
=
"alexnet"
resnet
=
"resnet"
lenet
=
"lenet"
app
=
FastAPI
()
@app
.
get
(
"/models/
{model_name}
"
)
async
def
get_model
(
model_name
:
ModelName
):
if
model_name
is
ModelName
.
alexnet
:
return
{
"model_name"
:
model_name
,
"message"
:
"Deep Learning FTW!"
}
if
model_name
.
value
==
"lenet"
:
return
{
"model_name"
:
model_name
,
"message"
:
"LeCNN all the images"
}
return
{
"model_name"
:
model_name
,
"message"
:
"Have some residuals"
}
Tip
You could also access the value
"lenet"
with
ModelName.lenet.value
.
Return
enumeration members
You can return
enum members
from your
path operation
, even nested in a JSON body (e.g. a
dict
).
They will be converted to their corresponding values (strings in this case) before returning them to the client:
Python 3.8+
from
enum
import
Enum
from
fastapi
import
FastAPI
class
ModelName
(
str
,
Enum
):
alexnet
=
"alexnet"
resnet
=
"resnet"
lenet
=
"lenet"
app
=
FastAPI
()
@app
.
get
(
"/models/
{model_name}
"
)
async
def
get_model
(
model_name
:
ModelName
):
if
model_name
is
ModelName
.
alexnet
:
return
{
"model_name"
:
model_name
,
"message"
:
"Deep Learning FTW!"
}
if
model_name
.
value
==
"lenet"
:
return
{
"model_name"
:
model_name
,
"message"
:
"LeCNN all the images"
}
return
{
"model_name"
:
model_name
,
"message"
:
"Have some residuals"
}
In your client you will get a JSON response like:
{
"model_name"
:
"alexnet"
,
"message"
:
"Deep Learning FTW!"
}
Path parameters containing paths
Let's say you have a
path operation
with a path
/files/{file_path}
.
But you need
file_path
itself to contain a
path
, like
home/johndoe/myfile.txt
.
So, the URL for that file would be something like:
/files/home/johndoe/myfile.txt
.
OpenAPI support
OpenAPI doesn't support a way to declare a
path parameter
to contain a
path
inside, as that could lead to scenarios that are difficult to test and define.
Nevertheless, you can still do it in
FastAPI
, using one of the internal tools from Starlette.
And the docs would still work, although not adding any documentation telling that the parameter should contain a path.
Path convertor
Using an option directly from Starlette you can declare a
path parameter
containing a
path
using a URL like:
/files/{file_path:path}
In this case, the name of the parameter is
file_path
, and the last part,
:path
, tells it that the parameter should match any
path
.
So, you can use it with:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/files/{file_path:path}"
)
async
def
read_file
(
file_path
:
str
):
return
{
"file_path"
:
file_path
}
Tip
You could need the parameter to contain
/home/johndoe/myfile.txt
, with a leading slash (
/
).
In that case, the URL would be:
/files//home/johndoe/myfile.txt
, with a double slash (
//
) between
files
and
home
.
Recap
With
FastAPI
, by using short, intuitive and standard Python type declarations, you get:
Editor support: error checks, autocompletion, etc.
Data "
parsing
"
Data validation
API annotation and automatic documentation
And you only have to declare them once.
That's probably the main visible advantage of
FastAPI
compared to alternative frameworks (apart from the raw performance).

## 138_TUTORIAL_QUERY_PARAM_MODELS
Query Parameter Models¬∂
---

Query Parameter Models
If you have a group of
query parameters
that are related, you can create a
Pydantic model
to declare them.
This would allow you to
re-use the model
in
multiple places
and also to declare validations and metadata for all the parameters at once. üòé
Note
This is supported since FastAPI version
0.115.0
. ü§ì
Query Parameters with a Pydantic Model
Declare the
query parameters
that you need in a
Pydantic model
, and then declare the parameter as
Query
:
Python 3.10+
from
typing
import
Annotated
,
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
,
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
,
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
FastAPI
will
extract
the data for
each field
from the
query parameters
in the request and give you the Pydantic model you defined.
Check the Docs
You can see the query parameters in the docs UI at
/docs
:
Forbid Extra Query Parameters
In some special use cases (probably not very common), you might want to
restrict
the query parameters that you want to receive.
You can use Pydantic's model configuration to
forbid
any
extra
fields:
Python 3.10+
from
typing
import
Annotated
,
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
,
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Annotated
,
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
Annotated
[
FilterParams
,
Query
()]):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Literal
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
list
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
from
pydantic
import
BaseModel
,
Field
from
typing_extensions
import
Literal
app
=
FastAPI
()
class
FilterParams
(
BaseModel
):
model_config
=
{
"extra"
:
"forbid"
}
limit
:
int
=
Field
(
100
,
gt
=
0
,
le
=
100
)
offset
:
int
=
Field
(
0
,
ge
=
0
)
order_by
:
Literal
[
"created_at"
,
"updated_at"
]
=
"created_at"
tags
:
List
[
str
]
=
[]
@app
.
get
(
"/items/"
)
async
def
read_items
(
filter_query
:
FilterParams
=
Query
()):
return
filter_query
If a client tries to send some
extra
data in the
query parameters
, they will receive an
error
response.
For example, if the client tries to send a
tool
query parameter with a value of
plumbus
, like:
https://example.com/items/?limit=10&tool=plumbus
They will receive an
error
response telling them that the query parameter
tool
is not allowed:
{
"detail"
:
[
{
"type"
:
"extra_forbidden"
,
"loc"
:
[
"query"
,
"tool"
],
"msg"
:
"Extra inputs are not permitted"
,
"input"
:
"plumbus"
}
]
}
Summary
You can use
Pydantic models
to declare
query parameters
in
FastAPI
. üòé
Tip
Spoiler alert: you can also use Pydantic models to declare cookies and headers, but you will read about that later in the tutorial. ü§´

## 139_TUTORIAL_QUERY_PARAMS_STR_VALIDATIONS
Query Parameters and String Validations¬∂
---

Query Parameters and String Validations
FastAPI
allows you to declare additional information and validation for your parameters.
Let's take this application as example:
Python 3.10+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
The query parameter
q
is of type
str | None
, that means that it's of type
str
but could also be
None
, and indeed, the default value is
None
, so FastAPI will know it's not required.
Note
FastAPI will know that the value of
q
is not required because of the default value
= None
.
Having
str | None
will allow your editor to give you better support and detect errors.
Additional validation
We are going to enforce that even though
q
is optional, whenever it is provided,
its length doesn't exceed 50 characters
.
Import
Query
and
Annotated
To achieve that, first import:
Query
from
fastapi
Annotated
from
typing
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Info
FastAPI added support for
Annotated
(and started recommending it) in version 0.95.0.
If you have an older version, you would get errors when trying to use
Annotated
.
Make sure you
Upgrade the FastAPI version
to at least 0.95.1 before using
Annotated
.
Use
Annotated
in the type for the
q
parameter
Remember I told you before that
Annotated
can be used to add metadata to your parameters in the
Python Types Intro
?
Now it's the time to use it with FastAPI. üöÄ
We had this type annotation:
Python 3.10+
Python 3.8+
q
:
str
|
None
=
None
q
:
Union
[
str
,
None
]
=
None
What we will do is wrap that with
Annotated
, so it becomes:
Python 3.10+
Python 3.8+
q
:
Annotated
[
str
|
None
]
=
None
q
:
Annotated
[
Union
[
str
,
None
]]
=
None
Both of those versions mean the same thing,
q
is a parameter that can be a
str
or
None
, and by default, it is
None
.
Now let's jump to the fun stuff. üéâ
Add
Query
to
Annotated
in the
q
parameter
Now that we have this
Annotated
where we can put more information (in this case some additional validation), add
Query
inside of
Annotated
, and set the parameter
max_length
to
50
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Notice that the default value is still
None
, so the parameter is still optional.
But now, having
Query(max_length=50)
inside of
Annotated
, we are telling FastAPI that we want it to have
additional validation
for this value, we want it to have maximum 50 characters. üòé
Tip
Here we are using
Query()
because this is a
query parameter
. Later we will see others like
Path()
,
Body()
,
Header()
, and
Cookie()
, that also accept the same arguments as
Query()
.
FastAPI will now:
Validate
the data making sure that the max length is 50 characters
Show a
clear error
for the client when the data is not valid
Document
the parameter in the OpenAPI schema
path operation
(so it will show up in the
automatic docs UI
)
Alternative (old):
Query
as the default value
Previous versions of FastAPI (before
0.95.0
) required you to use
Query
as the default value of your parameter, instead of putting it in
Annotated
, there's a high chance that you will see code using it around, so I'll explain it to you.
Tip
For new code and whenever possible, use
Annotated
as explained above. There are multiple advantages (explained below) and no disadvantages. üç∞
This is how you would use
Query()
as the default value of your function parameter, setting the parameter
max_length
to 50:
Python 3.10+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.10+
Python 3.8+
Python 3.8+ - non-Annotated
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
max_length
=
50
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
As in this case (without using
Annotated
) we have to replace the default value
None
in the function with
Query()
, we now need to set the default value with the parameter
Query(default=None)
, it serves the same purpose of defining that default value (at least for FastAPI).
So:
q
:
str
|
None
=
Query
(
default
=
None
)
...makes the parameter optional, with a default value of
None
, the same as:
q
:
str
|
None
=
None
But the
Query
version declares it explicitly as being a query parameter.
Then, we can pass more parameters to
Query
. In this case, the
max_length
parameter that applies to strings:
q
:
str
|
None
=
Query
(
default
=
None
,
max_length
=
50
)
This will validate the data, show a clear error when the data is not valid, and document the parameter in the OpenAPI schema
path operation
.
Query
as the default value or in
Annotated
Keep in mind that when using
Query
inside of
Annotated
you cannot use the
default
parameter for
Query
.
Instead, use the actual default value of the function parameter. Otherwise, it would be inconsistent.
For example, this is not allowed:
q
:
Annotated
[
str
,
Query
(
default
=
"rick"
)]
=
"morty"
...because it's not clear if the default value should be
"rick"
or
"morty"
.
So, you would use (preferably):
q
:
Annotated
[
str
,
Query
()]
=
"rick"
...or in older code bases you will find:
q
:
str
=
Query
(
default
=
"rick"
)
Advantages of
Annotated
Using
Annotated
is recommended
instead of the default value in function parameters, it is
better
for multiple reasons. ü§ì
The
default
value of the
function parameter
is the
actual default
value, that's more intuitive with Python in general. üòå
You could
call
that same function in
other places
without FastAPI, and it would
work as expected
. If there's a
required
parameter (without a default value), your
editor
will let you know with an error,
Python
will also complain if you run it without passing the required parameter.
When you don't use
Annotated
and instead use the
(old) default value style
, if you call that function without FastAPI in
other places
, you have to
remember
to pass the arguments to the function for it to work correctly, otherwise the values will be different from what you expect (e.g.
QueryInfo
or something similar instead of
str
). And your editor won't complain, and Python won't complain running that function, only when the operations inside error out.
Because
Annotated
can have more than one metadata annotation, you could now even use the same function with other tools, like
Typer
. üöÄ
Add more validations
You can also add a parameter
min_length
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
min_length
=
3
,
max_length
=
50
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
,
max_length
=
50
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
,
max_length
=
50
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
min_length
=
3
,
max_length
=
50
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
min_length
=
3
,
max_length
=
50
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Add regular expressions
You can define a
regular expression
pattern
that the parameter should match:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
)
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
)
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
)
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
This specific regular expression pattern checks that the received parameter value:
^
: starts with the following characters, doesn't have characters before.
fixedquery
: has the exact value
fixedquery
.
$
: ends there, doesn't have any more characters after
fixedquery
.
If you feel lost with all these
"regular expression"
ideas, don't worry. They are a hard topic for many people. You can still do a lot of stuff without needing regular expressions yet.
Now you know that whenever you need them you can use them in
FastAPI
.
Pydantic v1
regex
instead of
pattern
Before Pydantic version 2 and before FastAPI 0.100.0, the parameter was called
regex
instead of
pattern
, but it's now deprecated.
You could still see some code using it:
Pydantic v1
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
min_length
=
3
,
max_length
=
50
,
regex
=
"^fixedquery$"
)
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
But know that this is deprecated and it should be updated to use the new parameter
pattern
. ü§ì
Default values
You can, of course, use default values other than
None
.
Let's say that you want to declare the
q
query parameter to have a
min_length
of
3
, and to have a default value of
"fixedquery"
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
,
Query
(
min_length
=
3
)]
=
"fixedquery"
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
,
Query
(
min_length
=
3
)]
=
"fixedquery"
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
=
Query
(
default
=
"fixedquery"
,
min_length
=
3
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Note
Having a default value of any type, including
None
, makes the parameter optional (not required).
Required parameters
When we don't need to declare more validations or metadata, we can make the
q
query parameter required just by not declaring a default value, like:
q
:
str
instead of:
q
:
str
|
None
=
None
But we are now declaring it with
Query
, for example like:
Annotated
q
:
Annotated
[
str
|
None
,
Query
(
min_length
=
3
)]
=
None
So, when you need to declare a value as required while using
Query
, you can simply not declare a default value:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
,
Query
(
min_length
=
3
)]):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
,
Query
(
min_length
=
3
)]):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
=
Query
(
min_length
=
3
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Required, can be
None
You can declare that a parameter can accept
None
, but that it's still required. This would force clients to send a value, even if the value is
None
.
To do that, you can declare that
None
is a valid type but simply do not declare a default value:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
min_length
=
3
)]):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
)]):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
min_length
=
3
)]):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
min_length
=
3
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
min_length
=
3
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Query parameter list / multiple values
When you define a query parameter explicitly with
Query
you can also declare it to receive a list of values, or said in another way, to receive multiple values.
For example, to declare a query parameter
q
that can appear multiple times in the URL, you can write:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
list
[
str
]
|
None
,
Query
()]
=
None
):
query_items
=
{
"q"
:
q
}
return
query_items
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
list
[
str
],
None
],
Query
()]
=
None
):
query_items
=
{
"q"
:
q
}
return
query_items
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
List
[
str
],
None
],
Query
()]
=
None
):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
list
[
str
]
|
None
=
Query
(
default
=
None
)):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
list
[
str
],
None
]
=
Query
(
default
=
None
)):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
List
[
str
],
None
]
=
Query
(
default
=
None
)):
query_items
=
{
"q"
:
q
}
return
query_items
Then, with a URL like:
http://localhost:8000/items/?q=foo&q=bar
you would receive the multiple
q
query parameters'
values (
foo
and
bar
) in a Python
list
inside your
path operation function
, in the
function parameter
q
.
So, the response to that URL would be:
{
"q"
:
[
"foo"
,
"bar"
]
}
Tip
To declare a query parameter with a type of
list
, like in the example above, you need to explicitly use
Query
, otherwise it would be interpreted as a request body.
The interactive API docs will update accordingly, to allow multiple values:
Query parameter list / multiple values with defaults
You can also define a default
list
of values if none are provided:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
list
[
str
],
Query
()]
=
[
"foo"
,
"bar"
]):
query_items
=
{
"q"
:
q
}
return
query_items
ü§ì Other versions and variants
Python 3.8+
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
List
[
str
],
Query
()]
=
[
"foo"
,
"bar"
]):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
list
[
str
]
=
Query
(
default
=
[
"foo"
,
"bar"
])):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
List
[
str
]
=
Query
(
default
=
[
"foo"
,
"bar"
])):
query_items
=
{
"q"
:
q
}
return
query_items
If you go to:
http://localhost:8000/items/
the default of
q
will be:
["foo", "bar"]
and your response will be:
{
"q"
:
[
"foo"
,
"bar"
]
}
Using just
list
You can also use
list
directly instead of
list[str]
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
list
,
Query
()]
=
[]):
query_items
=
{
"q"
:
q
}
return
query_items
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
list
,
Query
()]
=
[]):
query_items
=
{
"q"
:
q
}
return
query_items
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
list
=
Query
(
default
=
[])):
query_items
=
{
"q"
:
q
}
return
query_items
Note
Keep in mind that in this case, FastAPI won't check the contents of the list.
For example,
list[int]
would check (and document) that the contents of the list are integers. But
list
alone wouldn't.
Declare more metadata
You can add more information about the parameter.
That information will be included in the generated OpenAPI and used by the documentation user interfaces and external tools.
Note
Keep in mind that different tools might have different levels of OpenAPI support.
Some of them might not show all the extra information declared yet, although in most of the cases, the missing feature is already planned for development.
You can add a
title
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
title
=
"Query string"
,
min_length
=
3
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
title
=
"Query string"
,
min_length
=
3
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
title
=
"Query string"
,
min_length
=
3
)]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
title
=
"Query string"
,
min_length
=
3
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
title
=
"Query string"
,
min_length
=
3
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
And a
description
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Alias parameters
Imagine that you want the parameter to be
item-query
.
Like in:
http://127.0.0.1:8000/items/?item-query=foobaritems
But
item-query
is not a valid Python variable name.
The closest would be
item_query
.
But you still need it to be exactly
item-query
...
Then you can declare an
alias
, and that alias is what will be used to find the parameter value:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
alias
=
"item-query"
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
)]
=
None
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
alias
=
"item-query"
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
alias
=
"item-query"
)):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Deprecating parameters
Now let's say you don't like this parameter anymore.
You have to leave it there a while because there are clients using it, but you want the docs to clearly show it as
deprecated
.
Then pass the parameter
deprecated=True
to
Query
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
str
|
None
,
Query
(
alias
=
"item-query"
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
,
deprecated
=
True
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
,
deprecated
=
True
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Annotated
[
Union
[
str
,
None
],
Query
(
alias
=
"item-query"
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
,
deprecated
=
True
,
),
]
=
None
,
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
str
|
None
=
Query
(
default
=
None
,
alias
=
"item-query"
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
,
deprecated
=
True
,
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
q
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
alias
=
"item-query"
,
title
=
"Query string"
,
description
=
"Query string for the items to search in the database that have a good match"
,
min_length
=
3
,
max_length
=
50
,
pattern
=
"^fixedquery$"
,
deprecated
=
True
,
),
):
results
=
{
"items"
:
[{
"item_id"
:
"Foo"
},
{
"item_id"
:
"Bar"
}]}
if
q
:
results
.
update
({
"q"
:
q
})
return
results
The docs will show it like this:
Exclude parameters from OpenAPI
To exclude a query parameter from the generated OpenAPI schema (and thus, from the automatic documentation systems), set the parameter
include_in_schema
of
Query
to
False
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
hidden_query
:
Annotated
[
str
|
None
,
Query
(
include_in_schema
=
False
)]
=
None
,
):
if
hidden_query
:
return
{
"hidden_query"
:
hidden_query
}
else
:
return
{
"hidden_query"
:
"Not found"
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
hidden_query
:
Annotated
[
Union
[
str
,
None
],
Query
(
include_in_schema
=
False
)]
=
None
,
):
if
hidden_query
:
return
{
"hidden_query"
:
hidden_query
}
else
:
return
{
"hidden_query"
:
"Not found"
}
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
hidden_query
:
Annotated
[
Union
[
str
,
None
],
Query
(
include_in_schema
=
False
)]
=
None
,
):
if
hidden_query
:
return
{
"hidden_query"
:
hidden_query
}
else
:
return
{
"hidden_query"
:
"Not found"
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
hidden_query
:
str
|
None
=
Query
(
default
=
None
,
include_in_schema
=
False
),
):
if
hidden_query
:
return
{
"hidden_query"
:
hidden_query
}
else
:
return
{
"hidden_query"
:
"Not found"
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Query
app
=
FastAPI
()
@app
.
get
(
"/items/"
)
async
def
read_items
(
hidden_query
:
Union
[
str
,
None
]
=
Query
(
default
=
None
,
include_in_schema
=
False
),
):
if
hidden_query
:
return
{
"hidden_query"
:
hidden_query
}
else
:
return
{
"hidden_query"
:
"Not found"
}
Custom Validation
There could be cases where you need to do some
custom validation
that can't be done with the parameters shown above.
In those cases, you can use a
custom validator function
that is applied after the normal validation (e.g. after validating that the value is a
str
).
You can achieve that using
Pydantic's
AfterValidator
inside of
Annotated
.
Tip
Pydantic also has
BeforeValidator
and others. ü§ì
For example, this custom validator checks that the item ID starts with
isbn-
for an
ISBN
book number or with
imdb-
for an
IMDB
movie URL ID:
Python 3.10+
import
random
from
typing
import
Annotated
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
str
|
None
,
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
import
random
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
import
random
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
from
typing_extensions
import
Annotated
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
Info
This is available with Pydantic version 2 or above. üòé
Tip
If you need to do any type of validation that requires communicating with any
external component
, like a database or another API, you should instead use
FastAPI Dependencies
, you will learn about them later.
These custom validators are for things that can be checked with
only
the
same data
provided in the request.
Understand that Code
The important point is just using
AfterValidator
with a function inside
Annotated
. Feel free to skip this part. ü§∏
But if you're curious about this specific code example and you're still entertained, here are some extra details.
String with
value.startswith()
Did you notice? a string using
value.startswith()
can take a tuple, and it will check each value in the tuple:
Python 3.10+
## Code above omitted üëÜ
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
import
random
from
typing
import
Annotated
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
str
|
None
,
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
import
random
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
import
random
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
from
typing_extensions
import
Annotated
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
A Random Item
With
data.items()
we get an
iterable object
with tuples containing the key and value for each dictionary item.
We convert this iterable object into a proper
list
with
list(data.items())
.
Then with
random.choice()
we can get a
random value
from the list, so, we get a tuple with
(id, name)
. It will be something like
("imdb-tt0371724", "The Hitchhiker's Guide to the Galaxy")
.
Then we
assign those two values
of the tuple to the variables
id
and
name
.
So, if the user didn't provide an item ID, they will still receive a random suggestion.
...we do all this in a
single simple line
. ü§Ø Don't you love Python? üêç
Python 3.10+
## Code above omitted üëÜ
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
str
|
None
,
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
üëÄ Full file preview
Python 3.10+
import
random
from
typing
import
Annotated
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
str
|
None
,
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
import
random
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
import
random
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
AfterValidator
from
typing_extensions
import
Annotated
app
=
FastAPI
()
data
=
{
"isbn-9781529046137"
:
"The Hitchhiker's Guide to the Galaxy"
,
"imdb-tt0371724"
:
"The Hitchhiker's Guide to the Galaxy"
,
"isbn-9781439512982"
:
"Isaac Asimov: The Complete Stories, Vol. 2"
,
}
def
check_valid_id
(
id
:
str
):
if
not
id
.
startswith
((
"isbn-"
,
"imdb-"
)):
raise
ValueError
(
'Invalid ID format, it must start with "isbn-" or "imdb-"'
)
return
id
@app
.
get
(
"/items/"
)
async
def
read_items
(
id
:
Annotated
[
Union
[
str
,
None
],
AfterValidator
(
check_valid_id
)]
=
None
,
):
if
id
:
item
=
data
.
get
(
id
)
else
:
id
,
item
=
random
.
choice
(
list
(
data
.
items
()))
return
{
"id"
:
id
,
"name"
:
item
}
Recap
You can declare additional validations and metadata for your parameters.
Generic validations and metadata:
alias
title
description
deprecated
Validations specific for strings:
min_length
max_length
pattern
Custom validations using
AfterValidator
.
In these examples you saw how to declare validations for
str
values.
See the next chapters to learn how to declare validations for other types, like numbers.

## 140_TUTORIAL_QUERY_PARAMS
Query Parameters¬∂
---

Query Parameters
When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as "query" parameters.
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
fake_items_db
=
[{
"item_name"
:
"Foo"
},
{
"item_name"
:
"Bar"
},
{
"item_name"
:
"Baz"
}]
@app
.
get
(
"/items/"
)
async
def
read_item
(
skip
:
int
=
0
,
limit
:
int
=
10
):
return
fake_items_db
[
skip
:
skip
+
limit
]
The query is the set of key-value pairs that go after the
?
in a URL, separated by
&
characters.
For example, in the URL:
http://127.0.0.1:8000/items/?skip=0&limit=10
...the query parameters are:
skip
: with a value of
0
limit
: with a value of
10
As they are part of the URL, they are "naturally" strings.
But when you declare them with Python types (in the example above, as
int
), they are converted to that type and validated against it.
All the same process that applied for path parameters also applies for query parameters:
Editor support (obviously)
Data
"parsing"
Data validation
Automatic documentation
Defaults
As query parameters are not a fixed part of a path, they can be optional and can have default values.
In the example above they have default values of
skip=0
and
limit=10
.
So, going to the URL:
http://127.0.0.1:8000/items/
would be the same as going to:
http://127.0.0.1:8000/items/?skip=0&limit=10
But if you go to, for example:
http://127.0.0.1:8000/items/?skip=20
The parameter values in your function will be:
skip=20
: because you set it in the URL
limit=10
: because that was the default value
Optional parameters
The same way, you can declare optional query parameters, by setting their default to
None
:
Python 3.10+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
,
q
:
str
|
None
=
None
):
if
q
:
return
{
"item_id"
:
item_id
,
"q"
:
q
}
return
{
"item_id"
:
item_id
}
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
,
q
:
Union
[
str
,
None
]
=
None
):
if
q
:
return
{
"item_id"
:
item_id
,
"q"
:
q
}
return
{
"item_id"
:
item_id
}
In this case, the function parameter
q
will be optional, and will be
None
by default.
Check
Also notice that
FastAPI
is smart enough to notice that the path parameter
item_id
is a path parameter and
q
is not, so, it's a query parameter.
Query parameter type conversion
You can also declare
bool
types, and they will be converted:
Python 3.10+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
,
q
:
str
|
None
=
None
,
short
:
bool
=
False
):
item
=
{
"item_id"
:
item_id
}
if
q
:
item
.
update
({
"q"
:
q
})
if
not
short
:
item
.
update
(
{
"description"
:
"This is an amazing item that has a long description"
}
)
return
item
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
str
,
q
:
Union
[
str
,
None
]
=
None
,
short
:
bool
=
False
):
item
=
{
"item_id"
:
item_id
}
if
q
:
item
.
update
({
"q"
:
q
})
if
not
short
:
item
.
update
(
{
"description"
:
"This is an amazing item that has a long description"
}
)
return
item
In this case, if you go to:
http://127.0.0.1:8000/items/foo?short=1
or
http://127.0.0.1:8000/items/foo?short=True
or
http://127.0.0.1:8000/items/foo?short=true
or
http://127.0.0.1:8000/items/foo?short=on
or
http://127.0.0.1:8000/items/foo?short=yes
or any other case variation (uppercase, first letter in uppercase, etc), your function will see the parameter
short
with a
bool
value of
True
. Otherwise as
False
.
Multiple path and query parameters
You can declare multiple path parameters and query parameters at the same time,
FastAPI
knows which is which.
And you don't have to declare them in any specific order.
They will be detected by name:
Python 3.10+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/users/
{user_id}
/items/
{item_id}
"
)
async
def
read_user_item
(
user_id
:
int
,
item_id
:
str
,
q
:
str
|
None
=
None
,
short
:
bool
=
False
):
item
=
{
"item_id"
:
item_id
,
"owner_id"
:
user_id
}
if
q
:
item
.
update
({
"q"
:
q
})
if
not
short
:
item
.
update
(
{
"description"
:
"This is an amazing item that has a long description"
}
)
return
item
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/users/
{user_id}
/items/
{item_id}
"
)
async
def
read_user_item
(
user_id
:
int
,
item_id
:
str
,
q
:
Union
[
str
,
None
]
=
None
,
short
:
bool
=
False
):
item
=
{
"item_id"
:
item_id
,
"owner_id"
:
user_id
}
if
q
:
item
.
update
({
"q"
:
q
})
if
not
short
:
item
.
update
(
{
"description"
:
"This is an amazing item that has a long description"
}
)
return
item
Required query parameters
When you declare a default value for non-path parameters (for now, we have only seen query parameters), then it is not required.
If you don't want to add a specific value but just make it optional, set the default as
None
.
But when you want to make a query parameter required, you can just not declare any default value:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_user_item
(
item_id
:
str
,
needy
:
str
):
item
=
{
"item_id"
:
item_id
,
"needy"
:
needy
}
return
item
Here the query parameter
needy
is a required query parameter of type
str
.
If you open in your browser a URL like:
http://127.0.0.1:8000/items/foo-item
...without adding the required parameter
needy
, you will see an error like:
{
"detail"
:
[
{
"type"
:
"missing"
,
"loc"
:
[
"query"
,
"needy"
],
"msg"
:
"Field required"
,
"input"
:
null
,
"url"
:
"https://errors.pydantic.dev/2.1/v/missing"
}
]
}
As
needy
is a required parameter, you would need to set it in the URL:
http://127.0.0.1:8000/items/foo-item?needy=sooooneedy
...this would work:
{
"item_id"
:
"foo-item"
,
"needy"
:
"sooooneedy"
}
And of course, you can define some parameters as required, some as having a default value, and some entirely optional:
Python 3.10+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_user_item
(
item_id
:
str
,
needy
:
str
,
skip
:
int
=
0
,
limit
:
int
|
None
=
None
):
item
=
{
"item_id"
:
item_id
,
"needy"
:
needy
,
"skip"
:
skip
,
"limit"
:
limit
}
return
item
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_user_item
(
item_id
:
str
,
needy
:
str
,
skip
:
int
=
0
,
limit
:
Union
[
int
,
None
]
=
None
):
item
=
{
"item_id"
:
item_id
,
"needy"
:
needy
,
"skip"
:
skip
,
"limit"
:
limit
}
return
item
In this case, there are 3 query parameters:
needy
, a required
str
.
skip
, an
int
with a default value of
0
.
limit
, an optional
int
.
Tip
You could also use
Enum
s the same way as with
Path Parameters
.

## 141_TUTORIAL_REQUEST_FILES
Request Files¬∂
---

Request Files
You can define files to be uploaded by the client using
File
.
Info
To receive uploaded files, first install
python-multipart
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
python-multipart
This is because uploaded files are sent as "form data".
Import
File
Import
File
and
UploadFile
from
fastapi
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
()):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Define
File
Parameters
Create file parameters the same way you would for
Body
or
Form
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
()):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Info
File
is a class that inherits directly from
Form
.
But remember that when you import
Query
,
Path
,
File
and others from
fastapi
, those are actually functions that return special classes.
Tip
To declare File bodies, you need to use
File
, because otherwise the parameters would be interpreted as query parameters or body (JSON) parameters.
The files will be uploaded as "form data".
If you declare the type of your
path operation function
parameter as
bytes
,
FastAPI
will read the file for you and you will receive the contents as
bytes
.
Keep in mind that this means that the whole contents will be stored in memory. This will work well for small files.
But there are several cases in which you might benefit from using
UploadFile
.
File Parameters with
UploadFile
Define a file parameter with a type of
UploadFile
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
()):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
):
return
{
"filename"
:
file
.
filename
}
Using
UploadFile
has several advantages over
bytes
:
You don't have to use
File()
in the default value of the parameter.
It uses a "spooled" file:
A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk.
This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory.
You can get metadata from the uploaded file.
It has a
file-like
async
interface.
It exposes an actual Python
SpooledTemporaryFile
object that you can pass directly to other libraries that expect a file-like object.
UploadFile
UploadFile
has the following attributes:
filename
: A
str
with the original file name that was uploaded (e.g.
myimage.jpg
).
content_type
: A
str
with the content type (MIME type / media type) (e.g.
image/jpeg
).
file
: A
SpooledTemporaryFile
(a
file-like
object). This is the actual Python file object that you can pass directly to other functions or libraries that expect a "file-like" object.
UploadFile
has the following
async
methods. They all call the corresponding file methods underneath (using the internal
SpooledTemporaryFile
).
write(data)
: Writes
data
(
str
or
bytes
) to the file.
read(size)
: Reads
size
(
int
) bytes/characters of the file.
seek(offset)
: Goes to the byte position
offset
(
int
) in the file.
E.g.,
await myfile.seek(0)
would go to the start of the file.
This is especially useful if you run
await myfile.read()
once and then need to read the contents again.
close()
: Closes the file.
As all these methods are
async
methods, you need to "await" them.
For example, inside of an
async
path operation function
you can get the contents with:
contents
=
await
myfile
.
read
()
If you are inside of a normal
def
path operation function
, you can access the
UploadFile.file
directly, for example:
contents
=
myfile
.
file
.
read
()
async
Technical Details
When you use the
async
methods,
FastAPI
runs the file methods in a threadpool and awaits for them.
Starlette Technical Details
FastAPI
's
UploadFile
inherits directly from
Starlette
's
UploadFile
, but adds some necessary parts to make it compatible with
Pydantic
and the other parts of FastAPI.
What is "Form Data"
The way HTML forms (
<form></form>
) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.
FastAPI
will make sure to read that data from the right place instead of JSON.
Technical Details
Data from forms is normally encoded using the "media type"
application/x-www-form-urlencoded
when it doesn't include files.
But when the form includes files, it is encoded as
multipart/form-data
. If you use
File
,
FastAPI
will know it has to get the files from the correct part of the body.
If you want to read more about these encodings and form fields, head to the
MDN
web docs for
POST
.
Warning
You can declare multiple
File
and
Form
parameters in a
path operation
, but you can't also declare
Body
fields that you expect to receive as JSON, as the request will have the body encoded using
multipart/form-data
instead of
application/json
.
This is not a limitation of
FastAPI
, it's part of the HTTP protocol.
Optional File Upload
You can make a file optional by using standard type annotations and setting a default value of
None
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
|
None
,
File
()]
=
None
):
if
not
file
:
return
{
"message"
:
"No file sent"
}
else
:
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
|
None
=
None
):
if
not
file
:
return
{
"message"
:
"No upload file sent"
}
else
:
return
{
"filename"
:
file
.
filename
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
Union
[
bytes
,
None
],
File
()]
=
None
):
if
not
file
:
return
{
"message"
:
"No file sent"
}
else
:
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
Union
[
UploadFile
,
None
]
=
None
):
if
not
file
:
return
{
"message"
:
"No upload file sent"
}
else
:
return
{
"filename"
:
file
.
filename
}
from
typing
import
Union
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
Union
[
bytes
,
None
],
File
()]
=
None
):
if
not
file
:
return
{
"message"
:
"No file sent"
}
else
:
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
Union
[
UploadFile
,
None
]
=
None
):
if
not
file
:
return
{
"message"
:
"No upload file sent"
}
else
:
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
|
None
=
File
(
default
=
None
)):
if
not
file
:
return
{
"message"
:
"No file sent"
}
else
:
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
|
None
=
None
):
if
not
file
:
return
{
"message"
:
"No upload file sent"
}
else
:
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Union
[
bytes
,
None
]
=
File
(
default
=
None
)):
if
not
file
:
return
{
"message"
:
"No file sent"
}
else
:
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
Union
[
UploadFile
,
None
]
=
None
):
if
not
file
:
return
{
"message"
:
"No upload file sent"
}
else
:
return
{
"filename"
:
file
.
filename
}
UploadFile
with Additional Metadata
You can also use
File()
with
UploadFile
, for example, to set additional metadata:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
(
description
=
"A file read as bytes"
)]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
Annotated
[
UploadFile
,
File
(
description
=
"A file read as UploadFile"
)],
):
return
{
"filename"
:
file
.
filename
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
(
description
=
"A file read as bytes"
)]):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
Annotated
[
UploadFile
,
File
(
description
=
"A file read as UploadFile"
)],
):
return
{
"filename"
:
file
.
filename
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
(
description
=
"A file read as bytes"
)):
return
{
"file_size"
:
len
(
file
)}
@app
.
post
(
"/uploadfile/"
)
async
def
create_upload_file
(
file
:
UploadFile
=
File
(
description
=
"A file read as UploadFile"
),
):
return
{
"filename"
:
file
.
filename
}
Multiple File Uploads
It's possible to upload several files at the same time.
They would be associated to the same "form field" sent using "form data".
To use that, declare a list of
bytes
or
UploadFile
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
Annotated
[
list
[
bytes
],
File
()]):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
list
[
UploadFile
]):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
ü§ì Other versions and variants
Python 3.8+
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
List
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
Annotated
[
List
[
bytes
],
File
()]):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
List
[
UploadFile
]):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
list
[
bytes
]
=
File
()):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
list
[
UploadFile
]):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
List
[
bytes
]
=
File
()):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
List
[
UploadFile
]):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
You will receive, as declared, a
list
of
bytes
or
UploadFile
s.
Technical Details
You could also use
from starlette.responses import HTMLResponse
.
FastAPI
provides the same
starlette.responses
as
fastapi.responses
just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
Multiple File Uploads with Additional Metadata
And the same way as before, you can use
File()
to set additional parameters, even for
UploadFile
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
Annotated
[
list
[
bytes
],
File
(
description
=
"Multiple files as bytes"
)],
):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
Annotated
[
list
[
UploadFile
],
File
(
description
=
"Multiple files as UploadFile"
)
],
):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
ü§ì Other versions and variants
Python 3.8+
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
List
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
Annotated
[
List
[
bytes
],
File
(
description
=
"Multiple files as bytes"
)],
):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
Annotated
[
List
[
UploadFile
],
File
(
description
=
"Multiple files as UploadFile"
)
],
):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
list
[
bytes
]
=
File
(
description
=
"Multiple files as bytes"
),
):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
list
[
UploadFile
]
=
File
(
description
=
"Multiple files as UploadFile"
),
):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
from
fastapi
import
FastAPI
,
File
,
UploadFile
from
fastapi.responses
import
HTMLResponse
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_files
(
files
:
List
[
bytes
]
=
File
(
description
=
"Multiple files as bytes"
),
):
return
{
"file_sizes"
:
[
len
(
file
)
for
file
in
files
]}
@app
.
post
(
"/uploadfiles/"
)
async
def
create_upload_files
(
files
:
List
[
UploadFile
]
=
File
(
description
=
"Multiple files as UploadFile"
),
):
return
{
"filenames"
:
[
file
.
filename
for
file
in
files
]}
@app
.
get
(
"/"
)
async
def
main
():
content
=
"""
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
"""
return
HTMLResponse
(
content
=
content
)
Recap
Use
File
,
bytes
, and
UploadFile
to declare files to be uploaded in the request, sent as form data.

## 142_TUTORIAL_REQUEST_FORM_MODELS
Form Models¬∂
---

Form Models
You can use
Pydantic models
to declare
form fields
in FastAPI.
Info
To use forms, first install
python-multipart
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
python-multipart
Note
This is supported since FastAPI version
0.113.0
. ü§ì
Pydantic Models for Forms
You just need to declare a
Pydantic model
with the fields you want to receive as
form fields
, and then declare the parameter as
Form
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
FormData
=
Form
()):
return
data
FastAPI
will
extract
the data for
each field
from the
form data
in the request and give you the Pydantic model you defined.
Check the Docs
You can verify it in the docs UI at
/docs
:
Forbid Extra Form Fields
In some special use cases (probably not very common), you might want to
restrict
the form fields to only those declared in the Pydantic model. And
forbid
any
extra
fields.
Note
This is supported since FastAPI version
0.114.0
. ü§ì
You can use Pydantic's model configuration to
forbid
any
extra
fields:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
model_config
=
{
"extra"
:
"forbid"
}
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
model_config
=
{
"extra"
:
"forbid"
}
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
Annotated
[
FormData
,
Form
()]):
return
data
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Form
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
FormData
(
BaseModel
):
username
:
str
password
:
str
model_config
=
{
"extra"
:
"forbid"
}
@app
.
post
(
"/login/"
)
async
def
login
(
data
:
FormData
=
Form
()):
return
data
If a client tries to send some extra data, they will receive an
error
response.
For example, if the client tries to send the form fields:
username
:
Rick
password
:
Portal Gun
extra
:
Mr. Poopybutthole
They will receive an error response telling them that the field
extra
is not allowed:
{
"detail"
:
[
{
"type"
:
"extra_forbidden"
,
"loc"
:
[
"body"
,
"extra"
],
"msg"
:
"Extra inputs are not permitted"
,
"input"
:
"Mr. Poopybutthole"
}
]
}
Summary
You can use Pydantic models to declare form fields in FastAPI. üòé

## 143_TUTORIAL_REQUEST_FORMS_AND_FILES
Request Forms and Files¬∂
---

Request Forms and Files
You can define files and form fields at the same time using
File
and
Form
.
Info
To receive uploaded files and/or form data, first install
python-multipart
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
python-multipart
Import
File
and
Form
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()],
fileb
:
Annotated
[
UploadFile
,
File
()],
token
:
Annotated
[
str
,
Form
()],
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()],
fileb
:
Annotated
[
UploadFile
,
File
()],
token
:
Annotated
[
str
,
Form
()],
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
(),
fileb
:
UploadFile
=
File
(),
token
:
str
=
Form
()
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
Define
File
and
Form
parameters
Create file and form parameters the same way you would for
Body
or
Query
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()],
fileb
:
Annotated
[
UploadFile
,
File
()],
token
:
Annotated
[
str
,
Form
()],
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
Annotated
[
bytes
,
File
()],
fileb
:
Annotated
[
UploadFile
,
File
()],
token
:
Annotated
[
str
,
Form
()],
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
File
,
Form
,
UploadFile
app
=
FastAPI
()
@app
.
post
(
"/files/"
)
async
def
create_file
(
file
:
bytes
=
File
(),
fileb
:
UploadFile
=
File
(),
token
:
str
=
Form
()
):
return
{
"file_size"
:
len
(
file
),
"token"
:
token
,
"fileb_content_type"
:
fileb
.
content_type
,
}
The files and form fields will be uploaded as form data and you will receive the files and form fields.
And you can declare some of the files as
bytes
and some as
UploadFile
.
Warning
You can declare multiple
File
and
Form
parameters in a
path operation
, but you can't also declare
Body
fields that you expect to receive as JSON, as the request will have the body encoded using
multipart/form-data
instead of
application/json
.
This is not a limitation of
FastAPI
, it's part of the HTTP protocol.
Recap
Use
File
and
Form
together when you need to receive data and files in the same request.

## 144_TUTORIAL_REQUEST_FORMS
Form Data¬∂
---

Form Data
When you need to receive form fields instead of JSON, you can use
Form
.
Info
To use forms, first install
python-multipart
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
python-multipart
Import
Form
Import
Form
from
fastapi
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
Annotated
[
str
,
Form
()],
password
:
Annotated
[
str
,
Form
()]):
return
{
"username"
:
username
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Form
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
Annotated
[
str
,
Form
()],
password
:
Annotated
[
str
,
Form
()]):
return
{
"username"
:
username
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Form
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
str
=
Form
(),
password
:
str
=
Form
()):
return
{
"username"
:
username
}
Define
Form
parameters
Create form parameters the same way you would for
Body
or
Query
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Form
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
Annotated
[
str
,
Form
()],
password
:
Annotated
[
str
,
Form
()]):
return
{
"username"
:
username
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
FastAPI
,
Form
from
typing_extensions
import
Annotated
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
Annotated
[
str
,
Form
()],
password
:
Annotated
[
str
,
Form
()]):
return
{
"username"
:
username
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Form
app
=
FastAPI
()
@app
.
post
(
"/login/"
)
async
def
login
(
username
:
str
=
Form
(),
password
:
str
=
Form
()):
return
{
"username"
:
username
}
For example, in one of the ways the OAuth2 specification can be used (called "password flow") it is required to send a
username
and
password
as form fields.
The
spec
requires the fields to be exactly named
username
and
password
, and to be sent as form fields, not JSON.
With
Form
you can declare the same configurations as with
Body
(and
Query
,
Path
,
Cookie
), including validation, examples, an alias (e.g.
user-name
instead of
username
), etc.
Info
Form
is a class that inherits directly from
Body
.
Tip
To declare form bodies, you need to use
Form
explicitly, because without it the parameters would be interpreted as query parameters or body (JSON) parameters.
About "Form Fields"
The way HTML forms (
<form></form>
) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.
FastAPI
will make sure to read that data from the right place instead of JSON.
Technical Details
Data from forms is normally encoded using the "media type"
application/x-www-form-urlencoded
.
But when the form includes files, it is encoded as
multipart/form-data
. You'll read about handling files in the next chapter.
If you want to read more about these encodings and form fields, head to the
MDN
web docs for
POST
.
Warning
You can declare multiple
Form
parameters in a
path operation
, but you can't also declare
Body
fields that you expect to receive as JSON, as the request will have the body encoded using
application/x-www-form-urlencoded
instead of
application/json
.
This is not a limitation of
FastAPI
, it's part of the HTTP protocol.
Recap
Use
Form
to declare form data input parameters.

## 145_TUTORIAL_RESPONSE_MODEL
Response Model - Return Type¬∂
---

Response Model - Return Type
You can declare the type used for the response by annotating the
path operation function
return type
.
You can use
type annotations
the same way you would for input data in function
parameters
, you can use Pydantic models, lists, dictionaries, scalar values like integers, booleans, etc.
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
list
[
str
]
=
[]
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
)
->
Item
:
return
item
@app
.
get
(
"/items/"
)
async
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
price
=
42.0
),
Item
(
name
=
"Plumbus"
,
price
=
32.0
),
]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
list
[
str
]
=
[]
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
)
->
Item
:
return
item
@app
.
get
(
"/items/"
)
async
def
read_items
()
->
list
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
price
=
42.0
),
Item
(
name
=
"Plumbus"
,
price
=
32.0
),
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
List
[
str
]
=
[]
@app
.
post
(
"/items/"
)
async
def
create_item
(
item
:
Item
)
->
Item
:
return
item
@app
.
get
(
"/items/"
)
async
def
read_items
()
->
List
[
Item
]:
return
[
Item
(
name
=
"Portal Gun"
,
price
=
42.0
),
Item
(
name
=
"Plumbus"
,
price
=
32.0
),
]
FastAPI will use this return type to:
Validate
the returned data.
If the data is invalid (e.g. you are missing a field), it means that
your
app code is broken, not returning what it should, and it will return a server error instead of returning incorrect data. This way you and your clients can be certain that they will receive the data and the data shape expected.
Add a
JSON Schema
for the response, in the OpenAPI
path operation
.
This will be used by the
automatic docs
.
It will also be used by automatic client code generation tools.
But most importantly:
It will
limit and filter
the output data to what is defined in the return type.
This is particularly important for
security
, we'll see more of that below.
response_model
Parameter
There are some cases where you need or want to return some data that is not exactly what the type declares.
For example, you could want to
return a dictionary
or a database object, but
declare it as a Pydantic model
. This way the Pydantic model would do all the data documentation, validation, etc. for the object that you returned (e.g. a dictionary or database object).
If you added the return type annotation, tools and editors would complain with a (correct) error telling you that your function is returning a type (e.g. a dict) that is different from what you declared (e.g. a Pydantic model).
In those cases, you can use the
path operation decorator
parameter
response_model
instead of the return type.
You can use the
response_model
parameter in any of the
path operations
:
@app.get()
@app.post()
@app.put()
@app.delete()
etc.
Python 3.10+
from
typing
import
Any
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
tags
:
list
[
str
]
=
[]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
)
->
Any
:
return
item
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
])
async
def
read_items
()
->
Any
:
return
[
{
"name"
:
"Portal Gun"
,
"price"
:
42.0
},
{
"name"
:
"Plumbus"
,
"price"
:
32.0
},
]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Any
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
list
[
str
]
=
[]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
)
->
Any
:
return
item
@app
.
get
(
"/items/"
,
response_model
=
list
[
Item
])
async
def
read_items
()
->
Any
:
return
[
{
"name"
:
"Portal Gun"
,
"price"
:
42.0
},
{
"name"
:
"Plumbus"
,
"price"
:
32.0
},
]
from
typing
import
Any
,
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
tags
:
List
[
str
]
=
[]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
)
->
Any
:
return
item
@app
.
get
(
"/items/"
,
response_model
=
List
[
Item
])
async
def
read_items
()
->
Any
:
return
[
{
"name"
:
"Portal Gun"
,
"price"
:
42.0
},
{
"name"
:
"Plumbus"
,
"price"
:
32.0
},
]
Note
Notice that
response_model
is a parameter of the "decorator" method (
get
,
post
, etc). Not of your
path operation function
, like all the parameters and body.
response_model
receives the same type you would declare for a Pydantic model field, so, it can be a Pydantic model, but it can also be, e.g. a
list
of Pydantic models, like
List[Item]
.
FastAPI will use this
response_model
to do all the data documentation, validation, etc. and also to
convert and filter the output data
to its type declaration.
Tip
If you have strict type checks in your editor, mypy, etc, you can declare the function return type as
Any
.
That way you tell the editor that you are intentionally returning anything. But FastAPI will still do the data documentation, validation, filtering, etc. with the
response_model
.
response_model
Priority
If you declare both a return type and a
response_model
, the
response_model
will take priority and be used by FastAPI.
This way you can add correct type annotations to your functions even when you are returning a type different than the response model, to be used by the editor and tools like mypy. And still you can have FastAPI do the data validation, documentation, etc. using the
response_model
.
You can also use
response_model=None
to disable creating a response model for that
path operation
, you might need to do it if you are adding type annotations for things that are not valid Pydantic fields, you will see an example of that in one of the sections below.
Return the same input data
Here we are declaring a
UserIn
model, it will contain a plaintext password:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
## Don't do this in production!
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
UserIn
:
return
user
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
## Don't do this in production!
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
UserIn
:
return
user
Info
To use
EmailStr
, first install
email-validator
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
email-validator
or with:
$
pip
install
"pydantic[email]"
And we are using this model to declare our input and the same model to declare our output:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
## Don't do this in production!
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
UserIn
:
return
user
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
## Don't do this in production!
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
UserIn
:
return
user
Now, whenever a browser is creating a user with a password, the API will return the same password in the response.
In this case, it might not be a problem, because it's the same user sending the password.
But if we use the same model for another
path operation
, we could be sending our user's passwords to every client.
Danger
Never store the plain password of a user or send it in a response like this, unless you know all the caveats and you know what you are doing.
Add an output model
We can instead create an input model with the plaintext password and an output model without it:
Python 3.10+
from
typing
import
Any
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Any
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
Here, even though our
path operation function
is returning the same input user that contains the password:
Python 3.10+
from
typing
import
Any
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Any
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
...we declared the
response_model
to be our model
UserOut
, that doesn't include the password:
Python 3.10+
from
typing
import
Any
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Any
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
UserIn
(
BaseModel
):
username
:
str
password
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserOut
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
@app
.
post
(
"/user/"
,
response_model
=
UserOut
)
async
def
create_user
(
user
:
UserIn
)
->
Any
:
return
user
So,
FastAPI
will take care of filtering out all the data that is not declared in the output model (using Pydantic).
response_model
or Return Type
In this case, because the two models are different, if we annotated the function return type as
UserOut
, the editor and tools would complain that we are returning an invalid type, as those are different classes.
That's why in this example we have to declare it in the
response_model
parameter.
...but continue reading below to see how to overcome that.
Return Type and Data Filtering
Let's continue from the previous example. We wanted to
annotate the function with one type
, but we wanted to be able to return from the function something that actually includes
more data
.
We want FastAPI to keep
filtering
the data using the response model. So that even though the function returns more data, the response will only include the fields declared in the response model.
In the previous example, because the classes were different, we had to use the
response_model
parameter. But that also means that we don't get the support from the editor and tools checking the function return type.
But in most of the cases where we need to do something like this, we want the model just to
filter/remove
some of the data as in this example.
And in those cases, we can use classes and inheritance to take advantage of function
type annotations
to get better support in the editor and tools, and still get the FastAPI
data filtering
.
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
BaseUser
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
str
|
None
=
None
class
UserIn
(
BaseUser
):
password
:
str
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
BaseUser
:
return
user
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
EmailStr
app
=
FastAPI
()
class
BaseUser
(
BaseModel
):
username
:
str
email
:
EmailStr
full_name
:
Union
[
str
,
None
]
=
None
class
UserIn
(
BaseUser
):
password
:
str
@app
.
post
(
"/user/"
)
async
def
create_user
(
user
:
UserIn
)
->
BaseUser
:
return
user
With this, we get tooling support, from editors and mypy as this code is correct in terms of types, but we also get the data filtering from FastAPI.
How does this work? Let's check that out. ü§ì
Type Annotations and Tooling
First let's see how editors, mypy and other tools would see this.
BaseUser
has the base fields. Then
UserIn
inherits from
BaseUser
and adds the
password
field, so, it will include all the fields from both models.
We annotate the function return type as
BaseUser
, but we are actually returning a
UserIn
instance.
The editor, mypy, and other tools won't complain about this because, in typing terms,
UserIn
is a subclass of
BaseUser
, which means it's a
valid
type when what is expected is anything that is a
BaseUser
.
FastAPI Data Filtering
Now, for FastAPI, it will see the return type and make sure that what you return includes
only
the fields that are declared in the type.
FastAPI does several things internally with Pydantic to make sure that those same rules of class inheritance are not used for the returned data filtering, otherwise you could end up returning much more data than what you expected.
This way, you can get the best of both worlds: type annotations with
tooling support
and
data filtering
.
See it in the docs
When you see the automatic docs, you can check that the input model and output model will both have their own JSON Schema:
And both models will be used for the interactive API documentation:
Other Return Type Annotations
There might be cases where you return something that is not a valid Pydantic field and you annotate it in the function, only to get the support provided by tooling (the editor, mypy, etc).
Return a Response Directly
The most common case would be
returning a Response directly as explained later in the advanced docs
.
Python 3.8+
from
fastapi
import
FastAPI
,
Response
from
fastapi.responses
import
JSONResponse
,
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/portal"
)
async
def
get_portal
(
teleport
:
bool
=
False
)
->
Response
:
if
teleport
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
return
JSONResponse
(
content
=
{
"message"
:
"Here's your interdimensional portal."
})
This simple case is handled automatically by FastAPI because the return type annotation is the class (or a subclass of)
Response
.
And tools will also be happy because both
RedirectResponse
and
JSONResponse
are subclasses of
Response
, so the type annotation is correct.
Annotate a Response Subclass
You can also use a subclass of
Response
in the type annotation:
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/teleport"
)
async
def
get_teleport
()
->
RedirectResponse
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
This will also work because
RedirectResponse
is a subclass of
Response
, and FastAPI will automatically handle this simple case.
Invalid Return Type Annotations
But when you return some other arbitrary object that is not a valid Pydantic type (e.g. a database object) and you annotate it like that in the function, FastAPI will try to create a Pydantic response model from that type annotation, and will fail.
The same would happen if you had something like a
union
between different types where one or more of them are not valid Pydantic types, for example this would fail üí•:
Python 3.10+
from
fastapi
import
FastAPI
,
Response
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/portal"
)
async
def
get_portal
(
teleport
:
bool
=
False
)
->
Response
|
dict
:
if
teleport
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
return
{
"message"
:
"Here's your interdimensional portal."
}
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
,
Response
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/portal"
)
async
def
get_portal
(
teleport
:
bool
=
False
)
->
Union
[
Response
,
dict
]:
if
teleport
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
return
{
"message"
:
"Here's your interdimensional portal."
}
...this fails because the type annotation is not a Pydantic type and is not just a single
Response
class or subclass, it's a union (any of the two) between a
Response
and a
dict
.
Disable Response Model
Continuing from the example above, you might not want to have the default data validation, documentation, filtering, etc. that is performed by FastAPI.
But you might want to still keep the return type annotation in the function to get the support from tools like editors and type checkers (e.g. mypy).
In this case, you can disable the response model generation by setting
response_model=None
:
Python 3.10+
from
fastapi
import
FastAPI
,
Response
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/portal"
,
response_model
=
None
)
async
def
get_portal
(
teleport
:
bool
=
False
)
->
Response
|
dict
:
if
teleport
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
return
{
"message"
:
"Here's your interdimensional portal."
}
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
,
Response
from
fastapi.responses
import
RedirectResponse
app
=
FastAPI
()
@app
.
get
(
"/portal"
,
response_model
=
None
)
async
def
get_portal
(
teleport
:
bool
=
False
)
->
Union
[
Response
,
dict
]:
if
teleport
:
return
RedirectResponse
(
url
=
"https://www.youtube.com/watch?v=dQw4w9WgXcQ"
)
return
{
"message"
:
"Here's your interdimensional portal."
}
This will make FastAPI skip the response model generation and that way you can have any return type annotations you need without it affecting your FastAPI application. ü§ì
Response Model encoding parameters
Your response model could have default values, like:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
description: Union[str, None] = None
(or
str | None = None
in Python 3.10) has a default of
None
.
tax: float = 10.5
has a default of
10.5
.
tags: List[str] = []
has a default of an empty list:
[]
.
but you might want to omit them from the result if they were not actually stored.
For example, if you have models with many optional attributes in a NoSQL database, but you don't want to send very long JSON responses full of default values.
Use the
response_model_exclude_unset
parameter
You can set the
path operation decorator
parameter
response_model_exclude_unset=True
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
tags
:
list
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
from
typing
import
List
,
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
tags
:
List
[
str
]
=
[]
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]},
}
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
,
response_model_exclude_unset
=
True
)
async
def
read_item
(
item_id
:
str
):
return
items
[
item_id
]
and those default values won't be included in the response, only the values actually set.
So, if you send a request to that
path operation
for the item with ID
foo
, the response (not including default values) will be:
{
"name"
:
"Foo"
,
"price"
:
50.2
}
Info
In Pydantic v1 the method was called
.dict()
, it was deprecated (but still supported) in Pydantic v2, and renamed to
.model_dump()
.
The examples here use
.dict()
for compatibility with Pydantic v1, but you should use
.model_dump()
instead if you can use Pydantic v2.
Info
FastAPI uses Pydantic model's
.dict()
with
its
exclude_unset
parameter
to achieve this.
Info
You can also use:
response_model_exclude_defaults=True
response_model_exclude_none=True
as described in
the Pydantic docs
for
exclude_defaults
and
exclude_none
.
Data with values for fields with defaults
But if your data has values for the model's fields with default values, like the item with ID
bar
:
{
"name"
:
"Bar"
,
"description"
:
"The bartenders"
,
"price"
:
62
,
"tax"
:
20.2
}
they will be included in the response.
Data with the same values as the defaults
If the data has the same values as the default ones, like the item with ID
baz
:
{
"name"
:
"Baz"
,
"description"
:
None
,
"price"
:
50.2
,
"tax"
:
10.5
,
"tags"
:
[]
}
FastAPI is smart enough (actually, Pydantic is smart enough) to realize that, even though
description
,
tax
, and
tags
have the same values as the defaults, they were set explicitly (instead of taken from the defaults).
So, they will be included in the JSON response.
Tip
Notice that the default values can be anything, not only
None
.
They can be a list (
[]
), a
float
of
10.5
, etc.
response_model_include
and
response_model_exclude
You can also use the
path operation decorator
parameters
response_model_include
and
response_model_exclude
.
They take a
set
of
str
with the name of the attributes to include (omitting the rest) or to exclude (including the rest).
This can be used as a quick shortcut if you have only one Pydantic model and want to remove some data from the output.
Tip
But it is still recommended to use the ideas above, using multiple classes, instead of these parameters.
This is because the JSON Schema generated in your app's OpenAPI (and the docs) will still be the one for the complete model, even if you use
response_model_include
or
response_model_exclude
to omit some attributes.
This also applies to
response_model_by_alias
that works similarly.
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
=
10.5
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The Bar fighters"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
"There goes my baz"
,
"price"
:
50.2
,
"tax"
:
10.5
,
},
}
@app
.
get
(
"/items/
{item_id}
/name"
,
response_model
=
Item
,
response_model_include
=
{
"name"
,
"description"
},
)
async
def
read_item_name
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
get
(
"/items/
{item_id}
/public"
,
response_model
=
Item
,
response_model_exclude
=
{
"tax"
})
async
def
read_item_public_data
(
item_id
:
str
):
return
items
[
item_id
]
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The Bar fighters"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
"There goes my baz"
,
"price"
:
50.2
,
"tax"
:
10.5
,
},
}
@app
.
get
(
"/items/
{item_id}
/name"
,
response_model
=
Item
,
response_model_include
=
{
"name"
,
"description"
},
)
async
def
read_item_name
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
get
(
"/items/
{item_id}
/public"
,
response_model
=
Item
,
response_model_exclude
=
{
"tax"
})
async
def
read_item_public_data
(
item_id
:
str
):
return
items
[
item_id
]
Tip
The syntax
{"name", "description"}
creates a
set
with those two values.
It is equivalent to
set(["name", "description"])
.
Using
list
s instead of
set
s
If you forget to use a
set
and use a
list
or
tuple
instead, FastAPI will still convert it to a
set
and it will work correctly:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
=
10.5
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The Bar fighters"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
"There goes my baz"
,
"price"
:
50.2
,
"tax"
:
10.5
,
},
}
@app
.
get
(
"/items/
{item_id}
/name"
,
response_model
=
Item
,
response_model_include
=
[
"name"
,
"description"
],
)
async
def
read_item_name
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
get
(
"/items/
{item_id}
/public"
,
response_model
=
Item
,
response_model_exclude
=
[
"tax"
])
async
def
read_item_public_data
(
item_id
:
str
):
return
items
[
item_id
]
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
float
=
10.5
items
=
{
"foo"
:
{
"name"
:
"Foo"
,
"price"
:
50.2
},
"bar"
:
{
"name"
:
"Bar"
,
"description"
:
"The Bar fighters"
,
"price"
:
62
,
"tax"
:
20.2
},
"baz"
:
{
"name"
:
"Baz"
,
"description"
:
"There goes my baz"
,
"price"
:
50.2
,
"tax"
:
10.5
,
},
}
@app
.
get
(
"/items/
{item_id}
/name"
,
response_model
=
Item
,
response_model_include
=
[
"name"
,
"description"
],
)
async
def
read_item_name
(
item_id
:
str
):
return
items
[
item_id
]
@app
.
get
(
"/items/
{item_id}
/public"
,
response_model
=
Item
,
response_model_exclude
=
[
"tax"
])
async
def
read_item_public_data
(
item_id
:
str
):
return
items
[
item_id
]
Recap
Use the
path operation decorator's
parameter
response_model
to define response models and especially to ensure private data is filtered out.
Use
response_model_exclude_unset
to return only the values explicitly set.

## 146_TUTORIAL_RESPONSE_STATUS_CODE
Response Status Code¬∂
---

Response Status Code
The same way you can specify a response model, you can also declare the HTTP status code used for the response with the parameter
status_code
in any of the
path operations
:
@app.get()
@app.post()
@app.put()
@app.delete()
etc.
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
post
(
"/items/"
,
status_code
=
201
)
async
def
create_item
(
name
:
str
):
return
{
"name"
:
name
}
Note
Notice that
status_code
is a parameter of the "decorator" method (
get
,
post
, etc). Not of your
path operation function
, like all the parameters and body.
The
status_code
parameter receives a number with the HTTP status code.
Info
status_code
can alternatively also receive an
IntEnum
, such as Python's
http.HTTPStatus
.
It will:
Return that status code in the response.
Document it as such in the OpenAPI schema (and so, in the user interfaces):
Note
Some response codes (see the next section) indicate that the response does not have a body.
FastAPI knows this, and will produce OpenAPI docs that state there is no response body.
About HTTP status codes
Note
If you already know what HTTP status codes are, skip to the next section.
In HTTP, you send a numeric status code of 3 digits as part of the response.
These status codes have a name associated to recognize them, but the important part is the number.
In short:
100 - 199
are for "Information". You rarely use them directly. Responses with these status codes cannot have a body.
200 - 299
are for "Successful" responses. These are the ones you would use the most.
200
is the default status code, which means everything was "OK".
Another example would be
201
, "Created". It is commonly used after creating a new record in the database.
A special case is
204
, "No Content". This response is used when there is no content to return to the client, and so the response must not have a body.
300 - 399
are for "Redirection". Responses with these status codes may or may not have a body, except for
304
, "Not Modified", which must not have one.
400 - 499
are for "Client error" responses. These are the second type you would probably use the most.
An example is
404
, for a "Not Found" response.
For generic errors from the client, you can just use
400
.
500 - 599
are for server errors. You almost never use them directly. When something goes wrong at some part in your application code, or server, it will automatically return one of these status codes.
Tip
To know more about each status code and which code is for what, check the
MDN
documentation about HTTP status codes
.
Shortcut to remember the names
Let's see the previous example again:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
post
(
"/items/"
,
status_code
=
201
)
async
def
create_item
(
name
:
str
):
return
{
"name"
:
name
}
201
is the status code for "Created".
But you don't have to memorize what each of these codes mean.
You can use the convenience variables from
fastapi.status
.
Python 3.8+
from
fastapi
import
FastAPI
,
status
app
=
FastAPI
()
@app
.
post
(
"/items/"
,
status_code
=
status
.
HTTP_201_CREATED
)
async
def
create_item
(
name
:
str
):
return
{
"name"
:
name
}
They are just a convenience, they hold the same number, but that way you can use the editor's autocomplete to find them:
Technical Details
You could also use
from starlette import status
.
FastAPI
provides the same
starlette.status
as
fastapi.status
just as a convenience for you, the developer. But it comes directly from Starlette.
Changing the default
Later, in the
Advanced User Guide
, you will see how to return a different status code than the default you are declaring here.

## 147_TUTORIAL_SCHEMA_EXTRA_EXAMPLE
Declare Request Example Data¬∂
---

Declare Request Example Data
You can declare examples of the data your app can receive.
Here are several ways to do it.
Extra JSON Schema data in Pydantic models
You can declare
examples
for a Pydantic model that will be added to the generated JSON Schema.
Pydantic v2
Pydantic v1
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
model_config
=
{
"json_schema_extra"
:
{
"examples"
:
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
]
}
}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
model_config
=
{
"json_schema_extra"
:
{
"examples"
:
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
]
}
}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
class
Config
:
schema_extra
=
{
"examples"
:
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
]
}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
class
Config
:
schema_extra
=
{
"examples"
:
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
]
}
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
That extra info will be added as-is to the output
JSON Schema
for that model, and it will be used in the API docs.
Pydantic v2
Pydantic v1
In Pydantic version 2, you would use the attribute
model_config
, that takes a
dict
as described in
Pydantic's docs: Configuration
.
You can set
"json_schema_extra"
with a
dict
containing any additional data you would like to show up in the generated JSON Schema, including
examples
.
In Pydantic version 1, you would use an internal class
Config
and
schema_extra
, as described in
Pydantic's docs: Schema customization
.
You can set
schema_extra
with a
dict
containing any additional data you would like to show up in the generated JSON Schema, including
examples
.
Tip
You could use the same technique to extend the JSON Schema and add your own custom extra info.
For example you could use it to add metadata for a frontend user interface, etc.
Info
OpenAPI 3.1.0 (used since FastAPI 0.99.0) added support for
examples
, which is part of the
JSON Schema
standard.
Before that, it only supported the keyword
example
with a single example. That is still supported by OpenAPI 3.1.0, but is deprecated and is not part of the JSON Schema standard. So you are encouraged to migrate
example
to
examples
. ü§ì
You can read more at the end of this page.
Field
additional arguments
When using
Field()
with Pydantic models, you can also declare additional
examples
:
Python 3.10+
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
=
Field
(
examples
=
[
"Foo"
])
description
:
str
|
None
=
Field
(
default
=
None
,
examples
=
[
"A very nice Item"
])
price
:
float
=
Field
(
examples
=
[
35.4
])
tax
:
float
|
None
=
Field
(
default
=
None
,
examples
=
[
3.2
])
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.8+
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
,
Field
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
=
Field
(
examples
=
[
"Foo"
])
description
:
Union
[
str
,
None
]
=
Field
(
default
=
None
,
examples
=
[
"A very nice Item"
])
price
:
float
=
Field
(
examples
=
[
35.4
])
tax
:
Union
[
float
,
None
]
=
Field
(
default
=
None
,
examples
=
[
3.2
])
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
examples
in JSON Schema - OpenAPI
When using any of:
Path()
Query()
Header()
Cookie()
Body()
Form()
File()
you can also declare a group of
examples
with additional information that will be added to their
JSON Schemas
inside of
OpenAPI
.
Body
with
examples
Here we pass
examples
containing one example of the data expected in
Body()
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
],
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
item_id
:
int
,
item
:
Item
=
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
}
],
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Example in the docs UI
With any of the methods above it would look like this in the
/docs
:
Body
with multiple
examples
You can of course also pass multiple
examples
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
],
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
=
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
],
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
=
Body
(
examples
=
[
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
],
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
When you do this, the examples will be part of the internal
JSON Schema
for that body data.
Nevertheless, at the
time of writing this
, Swagger UI, the tool in charge of showing the docs UI, doesn't support showing multiple examples for the data in
JSON Schema
. But read below for a workaround.
OpenAPI-specific
examples
Since before
JSON Schema
supported
examples
OpenAPI had support for a different field also called
examples
.
This
OpenAPI-specific
examples
goes in another section in the OpenAPI specification. It goes in the
details for each
path operation
, not inside each JSON Schema.
And Swagger UI has supported this particular
examples
field for a while. So, you can use it to
show
different
examples in the docs UI
.
The shape of this OpenAPI-specific field
examples
is a
dict
with
multiple examples
(instead of a
list
), each with extra information that will be added to
OpenAPI
too.
This doesn't go inside of each JSON Schema contained in OpenAPI, this goes outside, in the
path operation
directly.
Using the
openapi_examples
Parameter
You can declare the OpenAPI-specific
examples
in FastAPI with the parameter
openapi_examples
for:
Path()
Query()
Header()
Cookie()
Body()
Form()
File()
The keys of the
dict
identify each example, and each value is another
dict
.
Each specific example
dict
in the
examples
can contain:
summary
: Short description for the example.
description
: A long description that can contain Markdown text.
value
: This is the actual example shown, e.g. a
dict
.
externalValue
: alternative to
value
, a URL pointing to the example. Although this might not be supported by as many tools as
value
.
You can use it like this:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
openapi_examples
=
{
"normal"
:
{
"summary"
:
"A normal example"
,
"description"
:
"A **normal** item works correctly."
,
"value"
:
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
},
"converted"
:
{
"summary"
:
"An example with converted data"
,
"description"
:
"FastAPI can convert price `strings` to actual `numbers` automatically"
,
"value"
:
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
},
"invalid"
:
{
"summary"
:
"Invalid data is rejected with an error"
,
"value"
:
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
},
},
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
openapi_examples
=
{
"normal"
:
{
"summary"
:
"A normal example"
,
"description"
:
"A **normal** item works correctly."
,
"value"
:
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
},
"converted"
:
{
"summary"
:
"An example with converted data"
,
"description"
:
"FastAPI can convert price `strings` to actual `numbers` automatically"
,
"value"
:
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
},
"invalid"
:
{
"summary"
:
"Invalid data is rejected with an error"
,
"value"
:
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
},
},
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Annotated
[
Item
,
Body
(
openapi_examples
=
{
"normal"
:
{
"summary"
:
"A normal example"
,
"description"
:
"A **normal** item works correctly."
,
"value"
:
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
},
"converted"
:
{
"summary"
:
"An example with converted data"
,
"description"
:
"FastAPI can convert price `strings` to actual `numbers` automatically"
,
"value"
:
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
},
"invalid"
:
{
"summary"
:
"Invalid data is rejected with an error"
,
"value"
:
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
},
},
),
],
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
str
|
None
=
None
price
:
float
tax
:
float
|
None
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
=
Body
(
openapi_examples
=
{
"normal"
:
{
"summary"
:
"A normal example"
,
"description"
:
"A **normal** item works correctly."
,
"value"
:
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
},
"converted"
:
{
"summary"
:
"An example with converted data"
,
"description"
:
"FastAPI can convert price `strings` to actual `numbers` automatically"
,
"value"
:
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
},
"invalid"
:
{
"summary"
:
"Invalid data is rejected with an error"
,
"value"
:
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
},
},
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Body
,
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
description
:
Union
[
str
,
None
]
=
None
price
:
float
tax
:
Union
[
float
,
None
]
=
None
@app
.
put
(
"/items/
{item_id}
"
)
async
def
update_item
(
*
,
item_id
:
int
,
item
:
Item
=
Body
(
openapi_examples
=
{
"normal"
:
{
"summary"
:
"A normal example"
,
"description"
:
"A **normal** item works correctly."
,
"value"
:
{
"name"
:
"Foo"
,
"description"
:
"A very nice Item"
,
"price"
:
35.4
,
"tax"
:
3.2
,
},
},
"converted"
:
{
"summary"
:
"An example with converted data"
,
"description"
:
"FastAPI can convert price `strings` to actual `numbers` automatically"
,
"value"
:
{
"name"
:
"Bar"
,
"price"
:
"35.4"
,
},
},
"invalid"
:
{
"summary"
:
"Invalid data is rejected with an error"
,
"value"
:
{
"name"
:
"Baz"
,
"price"
:
"thirty five point four"
,
},
},
},
),
):
results
=
{
"item_id"
:
item_id
,
"item"
:
item
}
return
results
OpenAPI Examples in the Docs UI
With
openapi_examples
added to
Body()
the
/docs
would look like:
Technical Details
Tip
If you are already using
FastAPI
version
0.99.0 or above
, you can probably
skip
these details.
They are more relevant for older versions, before OpenAPI 3.1.0 was available.
You can consider this a brief OpenAPI and JSON Schema
history lesson
. ü§ì
Warning
These are very technical details about the standards
JSON Schema
and
OpenAPI
.
If the ideas above already work for you, that might be enough, and you probably don't need these details, feel free to skip them.
Before OpenAPI 3.1.0, OpenAPI used an older and modified version of
JSON Schema
.
JSON Schema didn't have
examples
, so OpenAPI added its own
example
field to its own modified version.
OpenAPI also added
example
and
examples
fields to other parts of the specification:
Parameter Object
(in the specification)
that was used by FastAPI's:
Path()
Query()
Header()
Cookie()
Request Body Object
, in the field
content
, on the
Media Type Object
(in the specification)
that was used by FastAPI's:
Body()
File()
Form()
Info
This old OpenAPI-specific
examples
parameter is now
openapi_examples
since FastAPI
0.103.0
.
JSON Schema's
examples
field
But then JSON Schema added an
examples
field to a new version of the specification.
And then the new OpenAPI 3.1.0 was based on the latest version (JSON Schema 2020-12) that included this new field
examples
.
And now this new
examples
field takes precedence over the old single (and custom)
example
field, that is now deprecated.
This new
examples
field in JSON Schema is
just a
list
of examples, not a dict with extra metadata as in the other places in OpenAPI (described above).
Info
Even after OpenAPI 3.1.0 was released with this new simpler integration with JSON Schema, for a while, Swagger UI, the tool that provides the automatic docs, didn't support OpenAPI 3.1.0 (it does since version 5.0.0 üéâ).
Because of that, versions of FastAPI previous to 0.99.0 still used versions of OpenAPI lower than 3.1.0.
Pydantic and FastAPI
examples
When you add
examples
inside a Pydantic model, using
schema_extra
or
Field(examples=["something"])
that example is added to the
JSON Schema
for that Pydantic model.
And that
JSON Schema
of the Pydantic model is included in the
OpenAPI
of your API, and then it's used in the docs UI.
In versions of FastAPI before 0.99.0 (0.99.0 and above use the newer OpenAPI 3.1.0) when you used
example
or
examples
with any of the other utilities (
Query()
,
Body()
, etc.) those examples were not added to the JSON Schema that describes that data (not even to OpenAPI's own version of JSON Schema), they were added directly to the
path operation
declaration in OpenAPI (outside the parts of OpenAPI that use JSON Schema).
But now that FastAPI 0.99.0 and above uses OpenAPI 3.1.0, that uses JSON Schema 2020-12, and Swagger UI 5.0.0 and above, everything is more consistent and the examples are included in JSON Schema.
Swagger UI and OpenAPI-specific
examples
Now, as Swagger UI didn't support multiple JSON Schema examples (as of 2023-08-26), users didn't have a way to show multiple examples in the docs.
To solve that, FastAPI
0.103.0
added support
for declaring the same old
OpenAPI-specific
examples
field with the new parameter
openapi_examples
. ü§ì
Summary
I used to say I didn't like history that much... and look at me now giving "tech history" lessons. üòÖ
In short,
upgrade to FastAPI 0.99.0 or above
, and things are much
simpler, consistent, and intuitive
, and you don't have to know all these historic details. üòé

## 148_TUTORIAL_SECURITY
Security¬∂
---

Security
There are many ways to handle security, authentication and authorization.
And it normally is a complex and "difficult" topic.
In many frameworks and systems just handling security and authentication takes a big amount of effort and code (in many cases it can be 50% or more of all the code written).
FastAPI
provides several tools to help you deal with
Security
easily, rapidly, in a standard way, without having to study and learn all the security specifications.
But first, let's check some small concepts.
In a hurry?
If you don't care about any of these terms and you just need to add security with authentication based on username and password
right now
, skip to the next chapters.
OAuth2
OAuth2 is a specification that defines several ways to handle authentication and authorization.
It is quite an extensive specification and covers several complex use cases.
It includes ways to authenticate using a "third party".
That's what all the systems with "login with Facebook, Google, Twitter, GitHub" use underneath.
OAuth 1
There was an OAuth 1, which is very different from OAuth2, and more complex, as it included direct specifications on how to encrypt the communication.
It is not very popular or used nowadays.
OAuth2 doesn't specify how to encrypt the communication, it expects you to have your application served with HTTPS.
Tip
In the section about
deployment
you will see how to set up HTTPS for free, using Traefik and Let's Encrypt.
OpenID Connect
OpenID Connect is another specification, based on
OAuth2
.
It just extends OAuth2 specifying some things that are relatively ambiguous in OAuth2, to try to make it more interoperable.
For example, Google login uses OpenID Connect (which underneath uses OAuth2).
But Facebook login doesn't support OpenID Connect. It has its own flavor of OAuth2.
OpenID (not "OpenID Connect")
There was also an "OpenID" specification. That tried to solve the same thing as
OpenID Connect
, but was not based on OAuth2.
So, it was a complete additional system.
It is not very popular or used nowadays.
OpenAPI
OpenAPI (previously known as Swagger) is the open specification for building APIs (now part of the Linux Foundation).
FastAPI
is based on
OpenAPI
.
That's what makes it possible to have multiple automatic interactive documentation interfaces, code generation, etc.
OpenAPI has a way to define multiple security "schemes".
By using them, you can take advantage of all these standard-based tools, including these interactive documentation systems.
OpenAPI defines the following security schemes:
apiKey
: an application specific key that can come from:
A query parameter.
A header.
A cookie.
http
: standard HTTP authentication systems, including:
bearer
: a header
Authorization
with a value of
Bearer
plus a token. This is inherited from OAuth2.
HTTP Basic authentication.
HTTP Digest, etc.
oauth2
: all the OAuth2 ways to handle security (called "flows").
Several of these flows are appropriate for building an OAuth 2.0 authentication provider (like Google, Facebook, Twitter, GitHub, etc):
implicit
clientCredentials
authorizationCode
But there is one specific "flow" that can be perfectly used for handling authentication in the same application directly:
password
: some next chapters will cover examples of this.
openIdConnect
: has a way to define how to discover OAuth2 authentication data automatically.
This automatic discovery is what is defined in the OpenID Connect specification.
Tip
Integrating other authentication/authorization providers like Google, Facebook, Twitter, GitHub, etc. is also possible and relatively easy.
The most complex problem is building an authentication/authorization provider like those, but
FastAPI
gives you the tools to do it easily, while doing the heavy lifting for you.
FastAPI
utilities
FastAPI provides several tools for each of these security schemes in the
fastapi.security
module that simplify using these security mechanisms.
In the next chapters you will see how to add security to your API using those tools provided by
FastAPI
.
And you will also see how it gets automatically integrated into the interactive documentation system.

## 149_TUTORIAL_SECURITY_FIRST_STEPS
Security - First Steps¬∂
---

Security - First Steps
Let's imagine that you have your
backend
API in some domain.
And you have a
frontend
in another domain or in a different path of the same domain (or in a mobile application).
And you want to have a way for the frontend to authenticate with the backend, using a
username
and
password
.
We can use
OAuth2
to build that with
FastAPI
.
But let's save you the time of reading the full long specification just to find those little pieces of information you need.
Let's use the tools provided by
FastAPI
to handle security.
How it looks
Let's first just use the code and see how it works, and then we'll come back to understand what's happening.
Create
main.py
Copy the example in a file
main.py
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
str
=
Depends
(
oauth2_scheme
)):
return
{
"token"
:
token
}
Run it
Info
The
python-multipart
package is automatically installed with
FastAPI
when you run the
pip install "fastapi[standard]"
command.
However, if you use the
pip install fastapi
command, the
python-multipart
package is not included by default.
To install it manually, make sure you create a
virtual environment
, activate it, and then install it with:
$
pip
install
python-multipart
This is because
OAuth2
uses "form data" for sending the
username
and
password
.
Run the example with:
fast ‚Üí
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
Check it
Go to the interactive docs at:
http://127.0.0.1:8000/docs
.
You will see something like this:
Authorize button!
You already have a shiny new "Authorize" button.
And your
path operation
has a little lock in the top-right corner that you can click.
And if you click it, you have a little authorization form to type a
username
and
password
(and other optional fields):
Note
It doesn't matter what you type in the form, it won't work yet. But we'll get there.
This is of course not the frontend for the final users, but it's a great automatic tool to document interactively all your API.
It can be used by the frontend team (that can also be yourself).
It can be used by third party applications and systems.
And it can also be used by yourself, to debug, check and test the same application.
The
password
flow
Now let's go back a bit and understand what is all that.
The
password
"flow" is one of the ways ("flows") defined in OAuth2, to handle security and authentication.
OAuth2 was designed so that the backend or API could be independent of the server that authenticates the user.
But in this case, the same
FastAPI
application will handle the API and the authentication.
So, let's review it from that simplified point of view:
The user types the
username
and
password
in the frontend, and hits
Enter
.
The frontend (running in the user's browser) sends that
username
and
password
to a specific URL in our API (declared with
tokenUrl="token"
).
The API checks that
username
and
password
, and responds with a "token" (we haven't implemented any of this yet).
A "token" is just a string with some content that we can use later to verify this user.
Normally, a token is set to expire after some time.
So, the user will have to log in again at some point later.
And if the token is stolen, the risk is less. It is not like a permanent key that will work forever (in most of the cases).
The frontend stores that token temporarily somewhere.
The user clicks in the frontend to go to another section of the frontend web app.
The frontend needs to fetch some more data from the API.
But it needs authentication for that specific endpoint.
So, to authenticate with our API, it sends a header
Authorization
with a value of
Bearer
plus the token.
If the token contains
foobar
, the content of the
Authorization
header would be:
Bearer foobar
.
FastAPI
's
OAuth2PasswordBearer
FastAPI
provides several tools, at different levels of abstraction, to implement these security features.
In this example we are going to use
OAuth2
, with the
Password
flow, using a
Bearer
token. We do that using the
OAuth2PasswordBearer
class.
Info
A "bearer" token is not the only option.
But it's the best one for our use case.
And it might be the best for most use cases, unless you are an OAuth2 expert and know exactly why there's another option that better suits your needs.
In that case,
FastAPI
also provides you with the tools to build it.
When we create an instance of the
OAuth2PasswordBearer
class we pass in the
tokenUrl
parameter. This parameter contains the URL that the client (the frontend running in the user's browser) will use to send the
username
and
password
in order to get a token.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
str
=
Depends
(
oauth2_scheme
)):
return
{
"token"
:
token
}
Tip
Here
tokenUrl="token"
refers to a relative URL
token
that we haven't created yet. As it's a relative URL, it's equivalent to
./token
.
Because we are using a relative URL, if your API was located at
https://example.com/
, then it would refer to
https://example.com/token
. But if your API was located at
https://example.com/api/v1/
, then it would refer to
https://example.com/api/v1/token
.
Using a relative URL is important to make sure your application keeps working even in an advanced use case like
Behind a Proxy
.
This parameter doesn't create that endpoint /
path operation
, but declares that the URL
/token
will be the one that the client should use to get the token. That information is used in OpenAPI, and then in the interactive API documentation systems.
We will soon also create the actual path operation.
Info
If you are a very strict "Pythonista" you might dislike the style of the parameter name
tokenUrl
instead of
token_url
.
That's because it is using the same name as in the OpenAPI spec. So that if you need to investigate more about any of these security schemes you can just copy and paste it to find more information about it.
The
oauth2_scheme
variable is an instance of
OAuth2PasswordBearer
, but it is also a "callable".
It could be called as:
oauth2_scheme
(
some
,
parameters
)
So, it can be used with
Depends
.
Use it
Now you can pass that
oauth2_scheme
in a dependency with
Depends
.
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
str
=
Depends
(
oauth2_scheme
)):
return
{
"token"
:
token
}
This dependency will provide a
str
that is assigned to the parameter
token
of the
path operation function
.
FastAPI
will know that it can use this dependency to define a "security scheme" in the OpenAPI schema (and the automatic API docs).
Technical Details
FastAPI
will know that it can use the class
OAuth2PasswordBearer
(declared in a dependency) to define the security scheme in OpenAPI because it inherits from
fastapi.security.oauth2.OAuth2
, which in turn inherits from
fastapi.security.base.SecurityBase
.
All the security utilities that integrate with OpenAPI (and the automatic API docs) inherit from
SecurityBase
, that's how
FastAPI
can know how to integrate them in OpenAPI.
What it does
It will go and look in the request for that
Authorization
header, check if the value is
Bearer
plus some token, and will return the token as a
str
.
If it doesn't see an
Authorization
header, or the value doesn't have a
Bearer
token, it will respond with a 401 status code error (
UNAUTHORIZED
) directly.
You don't even have to check if the token exists to return an error. You can be sure that if your function is executed, it will have a
str
in that token.
You can try it already in the interactive docs:
We are not verifying the validity of the token yet, but that's a start already.
Recap
So, in just 3 or 4 extra lines, you already have some primitive form of security.

## 150_TUTORIAL_SECURITY_GET_CURRENT_USER
Get Current User¬∂
---

Get Current User
In the previous chapter the security system (which is based on the dependency injection system) was giving the
path operation function
a
token
as a
str
:
Python 3.9+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
ü§ì Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
return
{
"token"
:
token
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
@app
.
get
(
"/items/"
)
async
def
read_items
(
token
:
str
=
Depends
(
oauth2_scheme
)):
return
{
"token"
:
token
}
But that is still not that useful.
Let's make it give us the current user.
Create a user model
First, let's create a Pydantic user model.
The same way we use Pydantic to declare bodies, we can use it anywhere else:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Create a
get_current_user
dependency
Let's create a dependency
get_current_user
.
Remember that dependencies can have sub-dependencies?
get_current_user
will have a dependency with the same
oauth2_scheme
we created before.
The same as we were doing before in the
path operation
directly, our new dependency
get_current_user
will receive a
token
as a
str
from the sub-dependency
oauth2_scheme
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Get the user
get_current_user
will use a (fake) utility function we created, that takes a token as a
str
and returns our Pydantic
User
model:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Inject the current user
So now we can use the same
Depends
with our
get_current_user
in the
path operation
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Notice that we declare the type of
current_user
as the Pydantic model
User
.
This will help us inside of the function with all the completion and type checks.
Tip
You might remember that request bodies are also declared with Pydantic models.
Here
FastAPI
won't get confused because you are using
Depends
.
Check
The way this dependency system is designed allows us to have different dependencies (different "dependables") that all return a
User
model.
We are not restricted to having only one dependency that can return that type of data.
Other models
You can now get the current user directly in the
path operation functions
and deal with the security mechanisms at the
Dependency Injection
level, using
Depends
.
And you can use any model or data for the security requirements (in this case, a Pydantic model
User
).
But you are not restricted to using some specific data model, class or type.
Do you want to have an
id
and
email
and not have any
username
in your model? Sure. You can use these same tools.
Do you want to just have a
str
? Or just a
dict
? Or a database class model instance directly? It all works the same way.
You actually don't have users that log in to your application but robots, bots, or other systems, that have just an access token? Again, it all works the same.
Just use any kind of model, any kind of class, any kind of database that you need for your application.
FastAPI
has you covered with the dependency injection system.
Code size
This example might seem verbose. Keep in mind that we are mixing security, data models, utility functions and
path operations
in the same file.
But here's the key point.
The security and dependency injection stuff is written once.
And you can make it as complex as you want. And still, have it written only once, in a single place. With all the flexibility.
But you can have thousands of endpoints (
path operations
) using the same security system.
And all of them (or any portion of them that you want) can take advantage of re-using these dependencies or any other dependencies you create.
And all these thousands of
path operations
can be as small as 3 lines:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)]):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
from
fastapi.security
import
OAuth2PasswordBearer
from
pydantic
import
BaseModel
app
=
FastAPI
()
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
def
fake_decode_token
(
token
):
return
User
(
username
=
token
+
"fakedecoded"
,
email
=
"john@example.com"
,
full_name
=
"John Doe"
)
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
return
user
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_user
)):
return
current_user
Recap
You can now get the current user directly in your
path operation function
.
We are already halfway there.
We just need to add a
path operation
for the user/client to actually send the
username
and
password
.
That comes next.

## 151_TUTORIAL_SECURITY_OAUTH2_JWT
OAuth2 with Password (and hashing), Bearer with JWT tokens¬∂
---

OAuth2 with Password (and hashing), Bearer with JWT tokens
Now that we have all the security flow, let's make the application actually secure, using
JWT
tokens and secure password hashing.
This code is something you can actually use in your application, save the password hashes in your database, etc.
We are going to start from where we left in the previous chapter and increment it.
About JWT
JWT means "JSON Web Tokens".
It's a standard to codify a JSON object in a long dense string without spaces. It looks like this:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
It is not encrypted, so, anyone could recover the information from the contents.
But it's signed. So, when you receive a token that you emitted, you can verify that you actually emitted it.
That way, you can create a token with an expiration of, let's say, 1 week. And then when the user comes back the next day with the token, you know that user is still logged in to your system.
After a week, the token will be expired and the user will not be authorized and will have to sign in again to get a new token. And if the user (or a third party) tried to modify the token to change the expiration, you would be able to discover it, because the signatures would not match.
If you want to play with JWT tokens and see how they work, check
https://jwt.io
.
Install
PyJWT
We need to install
PyJWT
to generate and verify the JWT tokens in Python.
Make sure you create a
virtual environment
, activate it, and then install
pyjwt
:
fast ‚Üí
pip install pyjwt
restart ‚Üª
Info
If you are planning to use digital signature algorithms like RSA or ECDSA, you should install the cryptography library dependency
pyjwt[crypto]
.
You can read more about it in the
PyJWT Installation docs
.
Password hashing
"Hashing" means converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.
Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.
But you cannot convert from the gibberish back to the password.
Why use password hashing
If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.
So, the thief won't be able to try to use that password in another system (as many users use the same password everywhere, this would be dangerous).
Install
passlib
PassLib is a great Python package to handle password hashes.
It supports many secure hashing algorithms and utilities to work with them.
The recommended algorithm is "Bcrypt".
Make sure you create a
virtual environment
, activate it, and then install PassLib with Bcrypt:
fast ‚Üí
pip install "passlib[bcrypt]"
restart ‚Üª
Tip
With
passlib
, you could even configure it to be able to read passwords created by
Django
, a
Flask
security plug-in or many others.
So, you would be able to, for example, share the same data from a Django application in a database with a FastAPI application. Or gradually migrate a Django application using the same database.
And your users would be able to login from your Django app or from your
FastAPI
app, at the same time.
Hash and verify the passwords
Import the tools we need from
passlib
.
Create a PassLib "context". This is what will be used to hash and verify passwords.
Tip
The PassLib context also has functionality to use different hashing algorithms, including deprecated old ones only to allow verifying them, etc.
For example, you could use it to read and verify passwords generated by another system (like Django) but hash any new passwords with a different algorithm like Bcrypt.
And be compatible with all of them at the same time.
Create a utility function to hash a password coming from the user.
And another utility to verify if a received password matches the hash stored.
And another one to authenticate and return a user.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Note
If you check the new (fake) database
fake_users_db
, you will see how the hashed password looks like now:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
.
Handle JWT tokens
Import the modules installed.
Create a random secret key that will be used to sign the JWT tokens.
To generate a secure random secret key use the command:
fast ‚Üí
openssl rand -hex 32
09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7
restart ‚Üª
And copy the output to the variable
SECRET_KEY
(don't use the one in the example).
Create a variable
ALGORITHM
with the algorithm used to sign the JWT token and set it to
"HS256"
.
Create a variable for the expiration of the token.
Define a Pydantic Model that will be used in the token endpoint for the response.
Create a utility function to generate a new access token.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Update the dependencies
Update
get_current_user
to receive the same token as before, but this time, using JWT tokens.
Decode the received token, verify it, and return the current user.
If the token is invalid, return an HTTP error right away.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Update the
/token
path operation
Create a
timedelta
with the expiration time of the token.
Create a real JWT access token and return it.
Python 3.10+
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Annotated
,
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()],
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
str
|
None
=
None
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
timedelta
|
None
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Tip
Prefer to use the
Annotated
version if possible.
from
datetime
import
datetime
,
timedelta
,
timezone
from
typing
import
Union
import
jwt
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
jwt.exceptions
import
InvalidTokenError
from
passlib.context
import
CryptContext
from
pydantic
import
BaseModel
## to get a string like this run:
## openssl rand -hex 32
SECRET_KEY
=
"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM
=
"HS256"
ACCESS_TOKEN_EXPIRE_MINUTES
=
30
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"
,
"disabled"
:
False
,
}
}
class
Token
(
BaseModel
):
access_token
:
str
token_type
:
str
class
TokenData
(
BaseModel
):
username
:
Union
[
str
,
None
]
=
None
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
pwd_context
=
CryptContext
(
schemes
=
[
"bcrypt"
],
deprecated
=
"auto"
)
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
app
=
FastAPI
()
def
verify_password
(
plain_password
,
hashed_password
):
return
pwd_context
.
verify
(
plain_password
,
hashed_password
)
def
get_password_hash
(
password
):
return
pwd_context
.
hash
(
password
)
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
authenticate_user
(
fake_db
,
username
:
str
,
password
:
str
):
user
=
get_user
(
fake_db
,
username
)
if
not
user
:
return
False
if
not
verify_password
(
password
,
user
.
hashed_password
):
return
False
return
user
def
create_access_token
(
data
:
dict
,
expires_delta
:
Union
[
timedelta
,
None
]
=
None
):
to_encode
=
data
.
copy
()
if
expires_delta
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
expires_delta
else
:
expire
=
datetime
.
now
(
timezone
.
utc
)
+
timedelta
(
minutes
=
15
)
to_encode
.
update
({
"exp"
:
expire
})
encoded_jwt
=
jwt
.
encode
(
to_encode
,
SECRET_KEY
,
algorithm
=
ALGORITHM
)
return
encoded_jwt
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
credentials_exception
=
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Could not validate credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
try
:
payload
=
jwt
.
decode
(
token
,
SECRET_KEY
,
algorithms
=
[
ALGORITHM
])
username
=
payload
.
get
(
"sub"
)
if
username
is
None
:
raise
credentials_exception
token_data
=
TokenData
(
username
=
username
)
except
InvalidTokenError
:
raise
credentials_exception
user
=
get_user
(
fake_users_db
,
username
=
token_data
.
username
)
if
user
is
None
:
raise
credentials_exception
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login_for_access_token
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
(),
)
->
Token
:
user
=
authenticate_user
(
fake_users_db
,
form_data
.
username
,
form_data
.
password
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Incorrect username or password"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
access_token_expires
=
timedelta
(
minutes
=
ACCESS_TOKEN_EXPIRE_MINUTES
)
access_token
=
create_access_token
(
data
=
{
"sub"
:
user
.
username
},
expires_delta
=
access_token_expires
)
return
Token
(
access_token
=
access_token
,
token_type
=
"bearer"
)
@app
.
get
(
"/users/me/"
,
response_model
=
User
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
@app
.
get
(
"/users/me/items/"
)
async
def
read_own_items
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
[{
"item_id"
:
"Foo"
,
"owner"
:
current_user
.
username
}]
Technical details about the JWT "subject"
sub
The JWT specification says that there's a key
sub
, with the subject of the token.
It's optional to use it, but that's where you would put the user's identification, so we are using it here.
JWT might be used for other things apart from identifying a user and allowing them to perform operations directly on your API.
For example, you could identify a "car" or a "blog post".
Then you could add permissions about that entity, like "drive" (for the car) or "edit" (for the blog).
And then, you could give that JWT token to a user (or bot), and they could use it to perform those actions (drive the car, or edit the blog post) without even needing to have an account, just with the JWT token your API generated for that.
Using these ideas, JWT can be used for way more sophisticated scenarios.
In those cases, several of those entities could have the same ID, let's say
foo
(a user
foo
, a car
foo
, and a blog post
foo
).
So, to avoid ID collisions, when creating the JWT token for the user, you could prefix the value of the
sub
key, e.g. with
username:
. So, in this example, the value of
sub
could have been:
username:johndoe
.
The important thing to keep in mind is that the
sub
key should have a unique identifier across the entire application, and it should be a string.
Check it
Run the server and go to the docs:
http://127.0.0.1:8000/docs
.
You'll see the user interface like:
Authorize the application the same way as before.
Using the credentials:
Username:
johndoe
Password:
secret
Check
Notice that nowhere in the code is the plaintext password "
secret
", we only have the hashed version.
Call the endpoint
/users/me/
, you will get the response as:
{
"username"
:
"johndoe"
,
"email"
:
"johndoe@example.com"
,
"full_name"
:
"John Doe"
,
"disabled"
:
false
}
If you open the developer tools, you could see how the data sent only includes the token, the password is only sent in the first request to authenticate the user and get that access token, but not afterwards:
Note
Notice the header
Authorization
, with a value that starts with
Bearer
.
Advanced usage with
scopes
OAuth2 has the notion of "scopes".
You can use them to add a specific set of permissions to a JWT token.
Then you can give this token to a user directly or a third party, to interact with your API with a set of restrictions.
You can learn how to use them and how they are integrated into
FastAPI
later in the
Advanced User Guide
.
Recap
With what you have seen up to now, you can set up a secure
FastAPI
application using standards like OAuth2 and JWT.
In almost any framework handling the security becomes a rather complex subject quite quickly.
Many packages that simplify it a lot have to make many compromises with the data model, database, and available features. And some of these packages that simplify things too much actually have security flaws underneath.
FastAPI
doesn't make any compromise with any database, data model or tool.
It gives you all the flexibility to choose the ones that fit your project the best.
And you can use directly many well maintained and widely used packages like
passlib
and
PyJWT
, because
FastAPI
doesn't require any complex mechanisms to integrate external packages.
But it provides you the tools to simplify the process as much as possible without compromising flexibility, robustness, or security.
And you can use and implement secure, standard protocols, like OAuth2 in a relatively simple way.
You can learn more in the
Advanced User Guide
about how to use OAuth2 "scopes", for a more fine-grained permission system, following these same standards. OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. to authorize third party applications to interact with their APIs on behalf of their users.

## 152_TUTORIAL_SECURITY_SIMPLE_OAUTH2
Simple OAuth2 with Password and Bearer¬∂
---

Simple OAuth2 with Password and Bearer
Now let's build from the previous chapter and add the missing parts to have a complete security flow.
Get the
username
and
password
We are going to use
FastAPI
security utilities to get the
username
and
password
.
OAuth2 specifies that when using the "password flow" (that we are using) the client/user must send a
username
and
password
fields as form data.
And the spec says that the fields have to be named like that. So
user-name
or
email
wouldn't work.
But don't worry, you can show it as you wish to your final users in the frontend.
And your database models can use any other names you want.
But for the login
path operation
, we need to use these names to be compatible with the spec (and be able to, for example, use the integrated API documentation system).
The spec also states that the
username
and
password
must be sent as form data (so, no JSON here).
scope
The spec also says that the client can send another form field "
scope
".
The form field name is
scope
(in singular), but it is actually a long string with "scopes" separated by spaces.
Each "scope" is just a string (without spaces).
They are normally used to declare specific security permissions, for example:
users:read
or
users:write
are common examples.
instagram_basic
is used by Facebook / Instagram.
https://www.googleapis.com/auth/drive
is used by Google.
Info
In OAuth2 a "scope" is just a string that declares a specific permission required.
It doesn't matter if it has other characters like
:
or if it is a URL.
Those details are implementation specific.
For OAuth2 they are just strings.
Code to get the
username
and
password
Now let's use the utilities provided by
FastAPI
to handle this.
OAuth2PasswordRequestForm
First, import
OAuth2PasswordRequestForm
, and use it as a dependency with
Depends
in the
path operation
for
/token
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
OAuth2PasswordRequestForm
is a class dependency that declares a form body with:
The
username
.
The
password
.
An optional
scope
field as a big string, composed of strings separated by spaces.
An optional
grant_type
.
Tip
The OAuth2 spec actually
requires
a field
grant_type
with a fixed value of
password
, but
OAuth2PasswordRequestForm
doesn't enforce it.
If you need to enforce it, use
OAuth2PasswordRequestFormStrict
instead of
OAuth2PasswordRequestForm
.
An optional
client_id
(we don't need it for our example).
An optional
client_secret
(we don't need it for our example).
Info
The
OAuth2PasswordRequestForm
is not a special class for
FastAPI
as is
OAuth2PasswordBearer
.
OAuth2PasswordBearer
makes
FastAPI
know that it is a security scheme. So it is added that way to OpenAPI.
But
OAuth2PasswordRequestForm
is just a class dependency that you could have written yourself, or you could have declared
Form
parameters directly.
But as it's a common use case, it is provided by
FastAPI
directly, just to make it easier.
Use the form data
Tip
The instance of the dependency class
OAuth2PasswordRequestForm
won't have an attribute
scope
with the long string separated by spaces, instead, it will have a
scopes
attribute with the actual list of strings for each scope sent.
We are not using
scopes
in this example, but the functionality is there if you need it.
Now, get the user data from the (fake) database, using the
username
from the form field.
If there is no such user, we return an error saying "Incorrect username or password".
For the error, we use the exception
HTTPException
:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Check the password
At this point we have the user data from our database, but we haven't checked the password.
Let's put that data in the Pydantic
UserInDB
model first.
You should never save plaintext passwords, so, we'll use the (fake) password hashing system.
If the passwords don't match, we return the same error.
Password hashing
"Hashing" means: converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.
Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.
But you cannot convert from the gibberish back to the password.
Why use password hashing
If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.
So, the thief won't be able to try to use those same passwords in another system (as many users use the same password everywhere, this would be dangerous).
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
About
**user_dict
UserInDB(**user_dict)
means:
Pass the keys and values of the
user_dict
directly as key-value arguments, equivalent to:
UserInDB
(
username
=
user_dict
[
"username"
],
email
=
user_dict
[
"email"
],
full_name
=
user_dict
[
"full_name"
],
disabled
=
user_dict
[
"disabled"
],
hashed_password
=
user_dict
[
"hashed_password"
],
)
Info
For a more complete explanation of
**user_dict
check back in
the documentation for
Extra Models
.
Return the token
The response of the
token
endpoint must be a JSON object.
It should have a
token_type
. In our case, as we are using "Bearer" tokens, the token type should be "
bearer
".
And it should have an
access_token
, with a string containing our access token.
For this simple example, we are going to just be completely insecure and return the same
username
as the token.
Tip
In the next chapter, you will see a real secure implementation, with password hashing and
JWT
tokens.
But for now, let's focus on the specific details we need.
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
By the spec, you should return a JSON with an
access_token
and a
token_type
, the same as in this example.
This is something that you have to do yourself in your code, and make sure you use those JSON keys.
It's almost the only thing that you have to remember to do correctly yourself, to be compliant with the specifications.
For the rest,
FastAPI
handles it for you.
Update the dependencies
Now we are going to update our dependencies.
We want to get the
current_user
only
if this user is active.
So, we create an additional dependency
get_current_active_user
that in turn uses
get_current_user
as a dependency.
Both of these dependencies will just return an HTTP error if the user doesn't exist, or if is inactive.
So, in our endpoint, we will only get a user if the user exists, was correctly authenticated, and is active:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
Annotated
[
str
,
Depends
(
oauth2_scheme
)]):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_user
)],
):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
Annotated
[
OAuth2PasswordRequestForm
,
Depends
()]):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
Annotated
[
User
,
Depends
(
get_current_active_user
)],
):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
str
|
None
=
None
full_name
:
str
|
None
=
None
disabled
:
bool
|
None
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
status
from
fastapi.security
import
OAuth2PasswordBearer
,
OAuth2PasswordRequestForm
from
pydantic
import
BaseModel
fake_users_db
=
{
"johndoe"
:
{
"username"
:
"johndoe"
,
"full_name"
:
"John Doe"
,
"email"
:
"johndoe@example.com"
,
"hashed_password"
:
"fakehashedsecret"
,
"disabled"
:
False
,
},
"alice"
:
{
"username"
:
"alice"
,
"full_name"
:
"Alice Wonderson"
,
"email"
:
"alice@example.com"
,
"hashed_password"
:
"fakehashedsecret2"
,
"disabled"
:
True
,
},
}
app
=
FastAPI
()
def
fake_hash_password
(
password
:
str
):
return
"fakehashed"
+
password
oauth2_scheme
=
OAuth2PasswordBearer
(
tokenUrl
=
"token"
)
class
User
(
BaseModel
):
username
:
str
email
:
Union
[
str
,
None
]
=
None
full_name
:
Union
[
str
,
None
]
=
None
disabled
:
Union
[
bool
,
None
]
=
None
class
UserInDB
(
User
):
hashed_password
:
str
def
get_user
(
db
,
username
:
str
):
if
username
in
db
:
user_dict
=
db
[
username
]
return
UserInDB
(
**
user_dict
)
def
fake_decode_token
(
token
):
## This doesn't provide any security at all
## Check the next version
user
=
get_user
(
fake_users_db
,
token
)
return
user
async
def
get_current_user
(
token
:
str
=
Depends
(
oauth2_scheme
)):
user
=
fake_decode_token
(
token
)
if
not
user
:
raise
HTTPException
(
status_code
=
status
.
HTTP_401_UNAUTHORIZED
,
detail
=
"Invalid authentication credentials"
,
headers
=
{
"WWW-Authenticate"
:
"Bearer"
},
)
return
user
async
def
get_current_active_user
(
current_user
:
User
=
Depends
(
get_current_user
)):
if
current_user
.
disabled
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Inactive user"
)
return
current_user
@app
.
post
(
"/token"
)
async
def
login
(
form_data
:
OAuth2PasswordRequestForm
=
Depends
()):
user_dict
=
fake_users_db
.
get
(
form_data
.
username
)
if
not
user_dict
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
user
=
UserInDB
(
**
user_dict
)
hashed_password
=
fake_hash_password
(
form_data
.
password
)
if
not
hashed_password
==
user
.
hashed_password
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Incorrect username or password"
)
return
{
"access_token"
:
user
.
username
,
"token_type"
:
"bearer"
}
@app
.
get
(
"/users/me"
)
async
def
read_users_me
(
current_user
:
User
=
Depends
(
get_current_active_user
)):
return
current_user
Info
The additional header
WWW-Authenticate
with value
Bearer
we are returning here is also part of the spec.
Any HTTP (error) status code 401 "UNAUTHORIZED" is supposed to also return a
WWW-Authenticate
header.
In the case of bearer tokens (our case), the value of that header should be
Bearer
.
You can actually skip that extra header and it would still work.
But it's provided here to be compliant with the specifications.
Also, there might be tools that expect and use it (now or in the future) and that might be useful for you or your users, now or in the future.
That's the benefit of standards...
See it in action
Open the interactive docs:
http://127.0.0.1:8000/docs
.
Authenticate
Click the "Authorize" button.
Use the credentials:
User:
johndoe
Password:
secret
After authenticating in the system, you will see it like:
Get your own user data
Now use the operation
GET
with the path
/users/me
.
You will get your user's data, like:
{
"username"
:
"johndoe"
,
"email"
:
"johndoe@example.com"
,
"full_name"
:
"John Doe"
,
"disabled"
:
false
,
"hashed_password"
:
"fakehashedsecret"
}
If you click the lock icon and logout, and then try the same operation again, you will get an HTTP 401 error of:
{
"detail"
:
"Not authenticated"
}
Inactive user
Now try with an inactive user, authenticate with:
User:
alice
Password:
secret2
And try to use the operation
GET
with the path
/users/me
.
You will get an "Inactive user" error, like:
{
"detail"
:
"Inactive user"
}
Recap
You now have the tools to implement a complete security system based on
username
and
password
for your API.
Using these tools, you can make the security system compatible with any database and with any user or data model.
The only detail missing is that it is not actually "secure" yet.
In the next chapter you'll see how to use a secure password hashing library and
JWT
tokens.

## 153_TUTORIAL_SQL_DATABASES
SQL (Relational) Databases¬∂
---

SQL (Relational) Databases
FastAPI
doesn't require you to use a SQL (relational) database. But you can use
any database
that you want.
Here we'll see an example using
SQLModel
.
SQLModel
is built on top of
SQLAlchemy
and Pydantic. It was made by the same author of
FastAPI
to be the perfect match for FastAPI applications that need to use
SQL databases
.
Tip
You could use any other SQL or NoSQL database library you want (in some cases called
"ORMs"
), FastAPI doesn't force you to use anything. üòé
As SQLModel is based on SQLAlchemy, you can easily use
any database supported
by SQLAlchemy (which makes them also supported by SQLModel), like:
PostgreSQL
MySQL
SQLite
Oracle
Microsoft SQL Server, etc.
In this example, we'll use
SQLite
, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is.
Later, for your production application, you might want to use a database server like
PostgreSQL
.
Tip
There is an official project generator with
FastAPI
and
PostgreSQL
including a frontend and more tools:
https://github.com/fastapi/full-stack-fastapi-template
This is a very simple and short tutorial, if you want to learn about databases in general, about SQL, or more advanced features, go to the
SQLModel docs
.
Install
SQLModel
First, make sure you create your
virtual environment
, activate it, and then install
sqlmodel
:
fast ‚Üí
pip install sqlmodel
restart ‚Üª
Create the App with a Single Model
We'll create the simplest first version of the app with a single
SQLModel
model first.
Later we'll improve it increasing security and versatility with
multiple models
below. ü§ì
Create Models
Import
SQLModel
and create a database model:
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
The
Hero
class is very similar to a Pydantic model (in fact, underneath, it actually
is a Pydantic model
).
There are a few differences:
table=True
tells SQLModel that this is a
table model
, it should represent a
table
in the SQL database, it's not just a
data model
(as would be any other regular Pydantic class).
Field(primary_key=True)
tells SQLModel that the
id
is the
primary key
in the SQL database (you can learn more about SQL primary keys in the SQLModel docs).
By having the type as
int | None
, SQLModel will know that this column should be an
INTEGER
in the SQL database and that it should be
NULLABLE
.
Field(index=True)
tells SQLModel that it should create a
SQL index
for this column, that would allow faster lookups in the database when reading data filtered by this column.
SQLModel will know that something declared as
str
will be a SQL column of type
TEXT
(or
VARCHAR
, depending on the database).
Create an Engine
A SQLModel
engine
(underneath it's actually a SQLAlchemy
engine
) is what
holds the connections
to the database.
You would have
one single
engine
object
for all your code to connect to the same database.
Python 3.10+
## Code above omitted üëÜ
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Using
check_same_thread=False
allows FastAPI to use the same SQLite database in different threads. This is necessary as
one single request
could use
more than one thread
(for example in dependencies).
Don't worry, with the way the code is structured, we'll make sure we use
a single SQLModel
session
per request
later, this is actually what the
check_same_thread
is trying to achieve.
Create the Tables
We then add a function that uses
SQLModel.metadata.create_all(engine)
to
create the tables
for all the
table models
.
Python 3.10+
## Code above omitted üëÜ
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Create a Session Dependency
A
Session
is what stores the
objects in memory
and keeps track of any changes needed in the data, then it
uses the
engine
to communicate with the database.
We will create a FastAPI
dependency
with
yield
that will provide a new
Session
for each request. This is what ensures that we use a single session per request. ü§ì
Then we create an
Annotated
dependency
SessionDep
to simplify the rest of the code that will use this dependency.
Python 3.10+
## Code above omitted üëÜ
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Create Database Tables on Startup
We will create the database tables when the application starts.
Python 3.10+
## Code above omitted üëÜ
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Here we create the tables on an application startup event.
For production you would probably use a migration script that runs before you start your app. ü§ì
Tip
SQLModel will have migration utilities wrapping Alembic, but for now, you can use
Alembic
directly.
Create a Hero
Because each SQLModel model is also a Pydantic model, you can use it in the same
type annotations
that you could use Pydantic models.
For example, if you declare a parameter of type
Hero
, it will be read from the
JSON body
.
The same way, you can declare it as the function's
return type
, and then the shape of the data will show up in the automatic API docs UI.
Python 3.10+
## Code above omitted üëÜ
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Here we use the
SessionDep
dependency (a
Session
) to add the new
Hero
to the
Session
instance, commit the changes to the database, refresh the data in the
hero
, and then return it.
Read Heroes
We can
read
Hero
s from the database using a
select()
. We can include a
limit
and
offset
to paginate the results.
Python 3.10+
## Code above omitted üëÜ
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Read One Hero
We can
read
a single
Hero
.
Python 3.10+
## Code above omitted üëÜ
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Delete a Hero
We can also
delete
a
Hero
.
Python 3.10+
## Code above omitted üëÜ
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
SessionDep
)
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
)
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
list
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
Hero
(
SQLModel
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
secret_name
:
str
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
)
def
create_hero
(
hero
:
Hero
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
session
.
add
(
hero
)
session
.
commit
()
session
.
refresh
(
hero
)
return
hero
@app
.
get
(
"/heroes/"
)
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
)
->
List
[
Hero
]:
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
))
->
Hero
:
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Run the App
You can run the app:
fast ‚Üí
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
Then go to the
/docs
UI, you will see that
FastAPI
is using these
models
to
document
the API, and it will use them to
serialize
and
validate
the data too.
Update the App with Multiple Models
Now let's
refactor
this app a bit to increase
security
and
versatility
.
If you check the previous app, in the UI you can see that, up to now, it lets the client decide the
id
of the
Hero
to create. üò±
We shouldn't let that happen, they could overwrite an
id
we already have assigned in the DB. Deciding the
id
should be done by the
backend
or the
database
,
not by the client
.
Additionally, we create a
secret_name
for the hero, but so far, we are returning it everywhere, that's not very
secret
... üòÖ
We'll fix these things by adding a few
extra models
. Here's where SQLModel will shine. ‚ú®
Create Multiple Models
In
SQLModel
, any model class that has
table=True
is a
table model
.
And any model class that doesn't have
table=True
is a
data model
, these ones are actually just Pydantic models (with a couple of small extra features). ü§ì
With SQLModel, we can use
inheritance
to
avoid duplicating
all the fields in all the cases.
HeroBase
- the base class
Let's start with a
HeroBase
model that has all the
fields that are shared
by all the models:
name
age
Python 3.10+
## Code above omitted üëÜ
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Hero
- the
table model
Then let's create
Hero
, the actual
table model
, with the
extra fields
that are not always in the other models:
id
secret_name
Because
Hero
inherits form
HeroBase
, it
also
has the
fields
declared in
HeroBase
, so all the fields for
Hero
are:
id
name
age
secret_name
Python 3.10+
## Code above omitted üëÜ
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
HeroPublic
- the public
data model
Next, we create a
HeroPublic
model, this is the one that will be
returned
to the clients of the API.
It has the same fields as
HeroBase
, so it won't include
secret_name
.
Finally, the identity of our heroes is protected! ü•∑
It also re-declares
id: int
. By doing this, we are making a
contract
with the API clients, so that they can always expect the
id
to be there and to be an
int
(it will never be
None
).
Tip
Having the return model ensure that a value is always available and always
int
(not
None
) is very useful for the API clients, they can write much simpler code having this certainty.
Also,
automatically generated clients
will have simpler interfaces, so that the developers communicating with your API can have a much better time working with your API. üòé
All the fields in
HeroPublic
are the same as in
HeroBase
, with
id
declared as
int
(not
None
):
id
name
age
Python 3.10+
## Code above omitted üëÜ
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
HeroCreate
- the
data model
to create a hero
Now we create a
HeroCreate
model, this is the one that will
validate
the data from the clients.
It has the same fields as
HeroBase
, and it also has
secret_name
.
Now, when the clients
create a new hero
, they will send the
secret_name
, it will be stored in the database, but those secret names won't be returned in the API to the clients.
Tip
This is how you would handle
passwords
. Receive them, but don't return them in the API.
You would also
hash
the values of the passwords before storing them,
never store them in plain text
.
The fields of
HeroCreate
are:
name
age
secret_name
Python 3.10+
## Code above omitted üëÜ
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
HeroUpdate
- the
data model
to update a hero
We didn't have a way to
update a hero
in the previous version of the app, but now with
multiple models
, we can do it. üéâ
The
HeroUpdate
data model
is somewhat special, it has
all the same fields
that would be needed to create a new hero, but all the fields are
optional
(they all have a default value). This way, when you update a hero, you can send just the fields that you want to update.
Because all the
fields actually change
(the type now includes
None
and they now have a default value of
None
), we need to
re-declare
them.
We don't really need to inherit from
HeroBase
because we are re-declaring all the fields. I'll leave it inheriting just for consistency, but this is not necessary. It's more a matter of personal taste. ü§∑
The fields of
HeroUpdate
are:
name
age
secret_name
Python 3.10+
## Code above omitted üëÜ
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Create with
HeroCreate
and return a
HeroPublic
Now that we have
multiple models
, we can update the parts of the app that use them.
We receive in the request a
HeroCreate
data model
, and from it, we create a
Hero
table model
.
This new
table model
Hero
will have the fields sent by the client, and will also have an
id
generated by the database.
Then we return the same
table model
Hero
as is from the function. But as we declare the
response_model
with the
HeroPublic
data model
,
FastAPI
will use
HeroPublic
to validate and serialize the data.
Python 3.10+
## Code above omitted üëÜ
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Now we use
response_model=HeroPublic
instead of the
return type annotation
-> HeroPublic
because the value that we are returning is actually
not
a
HeroPublic
.
If we had declared
-> HeroPublic
, your editor and linter would complain (rightfully so) that you are returning a
Hero
instead of a
HeroPublic
.
By declaring it in
response_model
we are telling
FastAPI
to do its thing, without interfering with the type annotations and the help from your editor and other tools.
Read Heroes with
HeroPublic
We can do the same as before to
read
Hero
s, again, we use
response_model=list[HeroPublic]
to ensure that the data is validated and serialized correctly.
Python 3.10+
## Code above omitted üëÜ
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Read One Hero with
HeroPublic
We can
read
a single hero:
Python 3.10+
## Code above omitted üëÜ
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Update a Hero with
HeroUpdate
We can
update a hero
. For this we use an HTTP
PATCH
operation.
And in the code, we get a
dict
with all the data sent by the client,
only the data sent by the client
, excluding any values that would be there just for being the default values. To do it we use
exclude_unset=True
. This is the main trick. ü™Ñ
Then we use
hero_db.sqlmodel_update(hero_data)
to update the
hero_db
with the data from
hero_data
.
Python 3.10+
## Code above omitted üëÜ
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
## Code below omitted üëá
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Delete a Hero Again
Deleting
a hero stays pretty much the same.
We won't satisfy the desire to refactor everything in this one. üòÖ
Python 3.10+
## Code above omitted üëÜ
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
üëÄ Full file preview
Python 3.10+
from
typing
import
Annotated
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
ü§ì Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated
from
typing
import
Annotated
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
from
typing_extensions
import
Annotated
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
SessionDep
=
Annotated
[
Session
,
Depends
(
get_session
)]
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
SessionDep
):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
SessionDep
,
offset
:
int
=
0
,
limit
:
Annotated
[
int
,
Query
(
le
=
100
)]
=
100
,
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
SessionDep
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
SessionDep
):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
int
|
None
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
int
|
None
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
str
|
None
=
None
age
:
int
|
None
=
None
secret_name
:
str
|
None
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
list
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
List
,
Union
from
fastapi
import
Depends
,
FastAPI
,
HTTPException
,
Query
from
sqlmodel
import
Field
,
Session
,
SQLModel
,
create_engine
,
select
class
HeroBase
(
SQLModel
):
name
:
str
=
Field
(
index
=
True
)
age
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
index
=
True
)
class
Hero
(
HeroBase
,
table
=
True
):
id
:
Union
[
int
,
None
]
=
Field
(
default
=
None
,
primary_key
=
True
)
secret_name
:
str
class
HeroPublic
(
HeroBase
):
id
:
int
class
HeroCreate
(
HeroBase
):
secret_name
:
str
class
HeroUpdate
(
HeroBase
):
name
:
Union
[
str
,
None
]
=
None
age
:
Union
[
int
,
None
]
=
None
secret_name
:
Union
[
str
,
None
]
=
None
sqlite_file_name
=
"database.db"
sqlite_url
=
f
"sqlite:///
{
sqlite_file_name
}
"
connect_args
=
{
"check_same_thread"
:
False
}
engine
=
create_engine
(
sqlite_url
,
connect_args
=
connect_args
)
def
create_db_and_tables
():
SQLModel
.
metadata
.
create_all
(
engine
)
def
get_session
():
with
Session
(
engine
)
as
session
:
yield
session
app
=
FastAPI
()
@app
.
on_event
(
"startup"
)
def
on_startup
():
create_db_and_tables
()
@app
.
post
(
"/heroes/"
,
response_model
=
HeroPublic
)
def
create_hero
(
hero
:
HeroCreate
,
session
:
Session
=
Depends
(
get_session
)):
db_hero
=
Hero
.
model_validate
(
hero
)
session
.
add
(
db_hero
)
session
.
commit
()
session
.
refresh
(
db_hero
)
return
db_hero
@app
.
get
(
"/heroes/"
,
response_model
=
List
[
HeroPublic
])
def
read_heroes
(
session
:
Session
=
Depends
(
get_session
),
offset
:
int
=
0
,
limit
:
int
=
Query
(
default
=
100
,
le
=
100
),
):
heroes
=
session
.
exec
(
select
(
Hero
)
.
offset
(
offset
)
.
limit
(
limit
))
.
all
()
return
heroes
@app
.
get
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
read_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
return
hero
@app
.
patch
(
"/heroes/
{hero_id}
"
,
response_model
=
HeroPublic
)
def
update_hero
(
hero_id
:
int
,
hero
:
HeroUpdate
,
session
:
Session
=
Depends
(
get_session
)
):
hero_db
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
hero_data
=
hero
.
model_dump
(
exclude_unset
=
True
)
hero_db
.
sqlmodel_update
(
hero_data
)
session
.
add
(
hero_db
)
session
.
commit
()
session
.
refresh
(
hero_db
)
return
hero_db
@app
.
delete
(
"/heroes/
{hero_id}
"
)
def
delete_hero
(
hero_id
:
int
,
session
:
Session
=
Depends
(
get_session
)):
hero
=
session
.
get
(
Hero
,
hero_id
)
if
not
hero
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Hero not found"
)
session
.
delete
(
hero
)
session
.
commit
()
return
{
"ok"
:
True
}
Run the App Again
You can run the app again:
fast ‚Üí
fastapi dev main.py
INFO
: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
restart ‚Üª
If you go to the
/docs
API UI, you will see that it is now updated, and it won't expect to receive the
id
from the client when creating a hero, etc.
Recap
You can use
SQLModel
to interact with a SQL database and simplify the code with
data models
and
table models
.
You can learn a lot more at the
SQLModel
docs, there's a longer mini
tutorial on using SQLModel with
FastAPI
. üöÄ

## 154_TUTORIAL_STATIC_FILES
Static Files¬∂
---

Static Files
You can serve static files automatically from a directory using
StaticFiles
.
Use
StaticFiles
Import
StaticFiles
.
"Mount" a
StaticFiles()
instance in a specific path.
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.staticfiles
import
StaticFiles
app
=
FastAPI
()
app
.
mount
(
"/static"
,
StaticFiles
(
directory
=
"static"
),
name
=
"static"
)
Technical Details
You could also use
from starlette.staticfiles import StaticFiles
.
FastAPI
provides the same
starlette.staticfiles
as
fastapi.staticfiles
just as a convenience for you, the developer. But it actually comes directly from Starlette.
What is "Mounting"
"Mounting" means adding a complete "independent" application in a specific path, that then takes care of handling all the sub-paths.
This is different from using an
APIRouter
as a mounted application is completely independent. The OpenAPI and docs from your main application won't include anything from the mounted application, etc.
You can read more about this in the
Advanced User Guide
.
Details
The first
"/static"
refers to the sub-path this "sub-application" will be "mounted" on. So, any path that starts with
"/static"
will be handled by it.
The
directory="static"
refers to the name of the directory that contains your static files.
The
name="static"
gives it a name that can be used internally by
FastAPI
.
All these parameters can be different than "
static
", adjust them with the needs and specific details of your own application.
More info
For more details and options check
Starlette's docs about Static Files
.

## 155_TUTORIAL_TESTING
Testing¬∂
---

Testing
Thanks to
Starlette
, testing
FastAPI
applications is easy and enjoyable.
It is based on
HTTPX
, which in turn is designed based on Requests, so it's very familiar and intuitive.
With it, you can use
pytest
directly with
FastAPI
.
Using
TestClient
Info
To use
TestClient
, first install
httpx
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
$
pip
install
httpx
Import
TestClient
.
Create a
TestClient
by passing your
FastAPI
application to it.
Create functions with a name that starts with
test_
(this is standard
pytest
conventions).
Use the
TestClient
object the same way as you do with
httpx
.
Write simple
assert
statements with the standard Python expressions that you need to check (again, standard
pytest
).
Python 3.8+
from
fastapi
import
FastAPI
from
fastapi.testclient
import
TestClient
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_main
():
return
{
"msg"
:
"Hello World"
}
client
=
TestClient
(
app
)
def
test_read_main
():
response
=
client
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"msg"
:
"Hello World"
}
Tip
Notice that the testing functions are normal
def
, not
async def
.
And the calls to the client are also normal calls, not using
await
.
This allows you to use
pytest
directly without complications.
Technical Details
You could also use
from starlette.testclient import TestClient
.
FastAPI
provides the same
starlette.testclient
as
fastapi.testclient
just as a convenience for you, the developer. But it comes directly from Starlette.
Tip
If you want to call
async
functions in your tests apart from sending requests to your FastAPI application (e.g. asynchronous database functions), have a look at the
Async Tests
in the advanced tutorial.
Separating tests
In a real application, you probably would have your tests in a different file.
And your
FastAPI
application might also be composed of several files/modules, etc.
FastAPI
app file
Let's say you have a file structure as described in
Bigger Applications
:
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.py
In the file
main.py
you have your
FastAPI
app:
Python 3.8+
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_main
():
return
{
"msg"
:
"Hello World"
}
Testing file
Then you could have a file
test_main.py
with your tests. It could live on the same Python package (the same directory with a
__init__.py
file):
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_main.py
Because this file is in the same package, you can use relative imports to import the object
app
from the
main
module (
main.py
):
Python 3.8+
from
fastapi.testclient
import
TestClient
from
.main
import
app
client
=
TestClient
(
app
)
def
test_read_main
():
response
=
client
.
get
(
"/"
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"msg"
:
"Hello World"
}
...and have the code for the tests just like before.
Testing: extended example
Now let's extend this example and add more details to see how to test different parts.
Extended
FastAPI
app file
Let's continue with the same file structure as before:
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_main.py
Let's say that now the file
main.py
with your
FastAPI
app has some other
path operations
.
It has a
GET
operation that could return an error.
It has a
POST
operation that could return several errors.
Both
path operations
require an
X-Token
header.
Python 3.10+
Python 3.9+
Python 3.8+
Python 3.10+ non-Annotated
Python 3.8+ non-Annotated
from
typing
import
Annotated
from
fastapi
import
FastAPI
,
Header
,
HTTPException
from
pydantic
import
BaseModel
fake_secret_token
=
"coneofsilence"
fake_db
=
{
"foo"
:
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
},
"bar"
:
{
"id"
:
"bar"
,
"title"
:
"Bar"
,
"description"
:
"The bartenders"
},
}
app
=
FastAPI
()
class
Item
(
BaseModel
):
id
:
str
title
:
str
description
:
str
|
None
=
None
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_main
(
item_id
:
str
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item_id
not
in
fake_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
fake_db
[
item_id
]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item
.
id
in
fake_db
:
raise
HTTPException
(
status_code
=
409
,
detail
=
"Item already exists"
)
fake_db
[
item
.
id
]
=
item
return
item
from
typing
import
Annotated
,
Union
from
fastapi
import
FastAPI
,
Header
,
HTTPException
from
pydantic
import
BaseModel
fake_secret_token
=
"coneofsilence"
fake_db
=
{
"foo"
:
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
},
"bar"
:
{
"id"
:
"bar"
,
"title"
:
"Bar"
,
"description"
:
"The bartenders"
},
}
app
=
FastAPI
()
class
Item
(
BaseModel
):
id
:
str
title
:
str
description
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_main
(
item_id
:
str
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item_id
not
in
fake_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
fake_db
[
item_id
]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item
.
id
in
fake_db
:
raise
HTTPException
(
status_code
=
409
,
detail
=
"Item already exists"
)
fake_db
[
item
.
id
]
=
item
return
item
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
,
HTTPException
from
pydantic
import
BaseModel
from
typing_extensions
import
Annotated
fake_secret_token
=
"coneofsilence"
fake_db
=
{
"foo"
:
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
},
"bar"
:
{
"id"
:
"bar"
,
"title"
:
"Bar"
,
"description"
:
"The bartenders"
},
}
app
=
FastAPI
()
class
Item
(
BaseModel
):
id
:
str
title
:
str
description
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_main
(
item_id
:
str
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item_id
not
in
fake_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
fake_db
[
item_id
]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
,
x_token
:
Annotated
[
str
,
Header
()]):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item
.
id
in
fake_db
:
raise
HTTPException
(
status_code
=
409
,
detail
=
"Item already exists"
)
fake_db
[
item
.
id
]
=
item
return
item
Tip
Prefer to use the
Annotated
version if possible.
from
fastapi
import
FastAPI
,
Header
,
HTTPException
from
pydantic
import
BaseModel
fake_secret_token
=
"coneofsilence"
fake_db
=
{
"foo"
:
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
},
"bar"
:
{
"id"
:
"bar"
,
"title"
:
"Bar"
,
"description"
:
"The bartenders"
},
}
app
=
FastAPI
()
class
Item
(
BaseModel
):
id
:
str
title
:
str
description
:
str
|
None
=
None
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_main
(
item_id
:
str
,
x_token
:
str
=
Header
()):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item_id
not
in
fake_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
fake_db
[
item_id
]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
,
x_token
:
str
=
Header
()):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item
.
id
in
fake_db
:
raise
HTTPException
(
status_code
=
409
,
detail
=
"Item already exists"
)
fake_db
[
item
.
id
]
=
item
return
item
Tip
Prefer to use the
Annotated
version if possible.
from
typing
import
Union
from
fastapi
import
FastAPI
,
Header
,
HTTPException
from
pydantic
import
BaseModel
fake_secret_token
=
"coneofsilence"
fake_db
=
{
"foo"
:
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
},
"bar"
:
{
"id"
:
"bar"
,
"title"
:
"Bar"
,
"description"
:
"The bartenders"
},
}
app
=
FastAPI
()
class
Item
(
BaseModel
):
id
:
str
title
:
str
description
:
Union
[
str
,
None
]
=
None
@app
.
get
(
"/items/
{item_id}
"
,
response_model
=
Item
)
async
def
read_main
(
item_id
:
str
,
x_token
:
str
=
Header
()):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item_id
not
in
fake_db
:
raise
HTTPException
(
status_code
=
404
,
detail
=
"Item not found"
)
return
fake_db
[
item_id
]
@app
.
post
(
"/items/"
,
response_model
=
Item
)
async
def
create_item
(
item
:
Item
,
x_token
:
str
=
Header
()):
if
x_token
!=
fake_secret_token
:
raise
HTTPException
(
status_code
=
400
,
detail
=
"Invalid X-Token header"
)
if
item
.
id
in
fake_db
:
raise
HTTPException
(
status_code
=
409
,
detail
=
"Item already exists"
)
fake_db
[
item
.
id
]
=
item
return
item
Extended testing file
You could then update
test_main.py
with the extended tests:
Python 3.8+
from
fastapi.testclient
import
TestClient
from
.main
import
app
client
=
TestClient
(
app
)
def
test_read_item
():
response
=
client
.
get
(
"/items/foo"
,
headers
=
{
"X-Token"
:
"coneofsilence"
})
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"id"
:
"foo"
,
"title"
:
"Foo"
,
"description"
:
"There goes my hero"
,
}
def
test_read_item_bad_token
():
response
=
client
.
get
(
"/items/foo"
,
headers
=
{
"X-Token"
:
"hailhydra"
})
assert
response
.
status_code
==
400
assert
response
.
json
()
==
{
"detail"
:
"Invalid X-Token header"
}
def
test_read_nonexistent_item
():
response
=
client
.
get
(
"/items/baz"
,
headers
=
{
"X-Token"
:
"coneofsilence"
})
assert
response
.
status_code
==
404
assert
response
.
json
()
==
{
"detail"
:
"Item not found"
}
def
test_create_item
():
response
=
client
.
post
(
"/items/"
,
headers
=
{
"X-Token"
:
"coneofsilence"
},
json
=
{
"id"
:
"foobar"
,
"title"
:
"Foo Bar"
,
"description"
:
"The Foo Barters"
},
)
assert
response
.
status_code
==
200
assert
response
.
json
()
==
{
"id"
:
"foobar"
,
"title"
:
"Foo Bar"
,
"description"
:
"The Foo Barters"
,
}
def
test_create_item_bad_token
():
response
=
client
.
post
(
"/items/"
,
headers
=
{
"X-Token"
:
"hailhydra"
},
json
=
{
"id"
:
"bazz"
,
"title"
:
"Bazz"
,
"description"
:
"Drop the bazz"
},
)
assert
response
.
status_code
==
400
assert
response
.
json
()
==
{
"detail"
:
"Invalid X-Token header"
}
def
test_create_existing_item
():
response
=
client
.
post
(
"/items/"
,
headers
=
{
"X-Token"
:
"coneofsilence"
},
json
=
{
"id"
:
"foo"
,
"title"
:
"The Foo ID Stealers"
,
"description"
:
"There goes my stealer"
,
},
)
assert
response
.
status_code
==
409
assert
response
.
json
()
==
{
"detail"
:
"Item already exists"
}
Whenever you need the client to pass information in the request and you don't know how to, you can search (Google) how to do it in
httpx
, or even how to do it with
requests
, as HTTPX's design is based on Requests' design.
Then you just do the same in your tests.
E.g.:
To pass a
path
or
query
parameter, add it to the URL itself.
To pass a JSON body, pass a Python object (e.g. a
dict
) to the parameter
json
.
If you need to send
Form Data
instead of JSON, use the
data
parameter instead.
To pass
headers
, use a
dict
in the
headers
parameter.
For
cookies
, a
dict
in the
cookies
parameter.
For more information about how to pass data to the backend (using
httpx
or the
TestClient
) check the
HTTPX documentation
.
Info
Note that the
TestClient
receives data that can be converted to JSON, not Pydantic models.
If you have a Pydantic model in your test and you want to send its data to the application during testing, you can use the
jsonable_encoder
described in
JSON Compatible Encoder
.
Run it
After that, you just need to install
pytest
.
Make sure you create a
virtual environment
, activate it, and then install it, for example:
fast ‚Üí
pip install pytest
restart ‚Üª
It will detect the files and tests automatically, execute them, and report the results back to you.
Run the tests with:
fast ‚Üí
pytest
--- test session starts ---
platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
rootdir: /home/user/code/superawesome-cli/app
plugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1
collected 6 items
test_main.py
...... [100%]
--- 1 passed in 0.03s ---
restart ‚Üª

## 156_UK
FastAPI
–ì–æ—Ç–æ–≤–∏–π –¥–æ –ø—Ä–æ–¥–∞–∫—à–∏–Ω—É, –≤–∏—Å–æ–∫–æ–ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–∏–π, –ø—Ä–æ—Å—Ç–∏–π —É –≤–∏–≤—á–µ–Ω–Ω—ñ —Ç–∞ —à–≤–∏–¥–∫–∏–π –¥–ª—è –Ω–∞–ø–∏—Å–∞–Ω–Ω—è –∫–æ–¥—É —Ñ—Ä–µ–π–º–≤–æ—Ä–∫
–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è
:
https://fastapi.tiangolo.com
–ü—Ä–æ–≥—Ä–∞–º–Ω–∏–π –∫–æ–¥
:
https://github.com/fastapi/fastapi
FastAPI - —Ü–µ —Å—É—á–∞—Å–Ω–∏–π, —à–≤–∏–¥–∫–∏–π (–≤–∏—Å–æ–∫–æ–ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–∏–π), –≤–µ–±—Ñ—Ä–µ–π–º–≤–æ—Ä–∫ –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è API –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é Python,–≤ –æ—Å–Ω–æ–≤—ñ —è–∫–æ–≥–æ –ª–µ–∂–∏—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ –∞–Ω–æ—Ç–∞—Ü—ñ—è —Ç–∏–ø—ñ–≤ Python.
–ö–ª—é—á–æ–≤—ñ –æ—Å–æ–±–ª–∏–≤–æ—Å—Ç—ñ:
–®–≤–∏–¥–∫–∏–π
: –î—É–∂–µ –≤–∏—Å–æ–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å, –Ω–∞ —Ä—ñ–≤–Ω—ñ –∑
NodeJS
—Ç–∞
Go
(–∑–∞–≤–¥—è–∫–∏ Starlette —Ç–∞ Pydantic).
–û–¥–∏–Ω —ñ–∑ –Ω–∞–π—à–≤–∏–¥—à–∏—Ö —Ñ—Ä–µ–π–º–≤–æ—Ä–∫—ñ–≤
.
–®–≤–∏–¥–∫–µ –Ω–∞–ø–∏—Å–∞–Ω–Ω—è –∫–æ–¥—É
: –ü—Ä–∏—à–≤–∏–¥—à—É—î —Ä–æ–∑—Ä–æ–±–∫—É —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—É –ø—Ä–∏–±–ª–∏–∑–Ω–æ –Ω–∞ 200%-300%. *
–ú–µ–Ω—à–µ –ø–æ–º–∏–ª–æ–∫
: –ó–º–µ–Ω—à–∏—Ç—å –∫—ñ–ª—å–∫—ñ—Å—Ç—å –ø–æ–º–∏–ª–æ–∫ —Å–ø—Ä–∏—á–∏–Ω–µ–Ω–∏—Ö –ª—é–¥–∏–Ω–æ—é (—Ä–æ–∑—Ä–æ–±–Ω–∏–∫–æ–º) –Ω–∞ 40%. *
–Ü–Ω—Ç—É—ó—Ç–∏–≤–Ω–∏–π
: –ß—É–¥–æ–≤–∞ –ø—ñ–¥—Ç—Ä–∏–º–∫–∞ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞–º–∏ –∫–æ–¥—É.
–î–æ–ø–æ–≤–Ω–µ–Ω–Ω—è
–≤—Å—é–¥–∏. –ó–º–µ–Ω—à—Ç–µ —á–∞—Å –Ω–∞ –Ω–∞–ª–∞–≥–æ–¥–∂–µ–Ω–Ω—è.
–ü—Ä–æ—Å—Ç–∏–π
: –°–ø—Ä–æ–µ–∫—Ç–æ–≤–∞–Ω–∏–π, –¥–ª—è –ª–µ–≥–∫–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Ç–∞ –Ω–∞–≤—á–∞–Ω–Ω—è. –ó–Ω–∞–¥–æ–±–∏—Ç—å—Å—è –º–µ–Ω—à–µ —á–∞—Å—É –Ω–∞ —á–∏—Ç–∞–Ω–Ω—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó.
–ö–æ—Ä–æ—Ç–∫–∏–π
: –ó–≤–µ–¥–µ –¥–æ –º—ñ–Ω—ñ–º—É–º—É –¥—É–±–ª—é–≤–∞–Ω–Ω—è –∫–æ–¥—É. –ö–æ–∂–µ–Ω –æ–≥–æ–ª–æ—à–µ–Ω–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä –º–æ–∂–µ –≤–∏–∫–æ–Ω—É–≤–∞—Ç–∏ –∫—ñ–ª—å–∫–∞ —Ñ—É–Ω–∫—Ü—ñ–π.
–ù–∞–¥—ñ–π–Ω–∏–π
: –í–∏ –º–∞—Ç–∏–º–µ—Ç–µ —Å—Ç–∞–±—ñ–ª—å–Ω–∏–π –∫–æ–¥ –≥–æ—Ç–æ–≤–∏–π –¥–æ –ø—Ä–æ–¥–∞–∫—à–∏–Ω—É –∑ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ—é —ñ–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—î—é.
–°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–æ–≤–∞–Ω–∏–π
: –û—Å–Ω–æ–≤–∞–Ω–∏–π —Ç–∞ –ø–æ–≤–Ω—ñ—Å—Ç—é —Å—É–º—ñ—Å–Ω–∏–π –∑ –≤—ñ–¥–∫—Ä–∏—Ç–∏–º–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º–∏ –¥–ª—è API:
OpenAPI
(–ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ –≤—ñ–¥–æ–º–∏–π —è–∫ Swagger) —Ç–∞
JSON Schema
.
* –æ—Ü—ñ–Ω–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ç–µ—Å—Ç—ñ–≤ –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ—ó –∫–æ–º–∞–Ω–¥–∏ —Ä–æ–∑—Ä–æ–±–Ω–∏–∫—ñ–≤, —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø—Ä–æ–¥—É–∫—Ç–æ–≤–∏—Ö –∑–∞—Å—Ç–æ—Å—É–Ω–∫—ñ–≤.
–°–ø–æ–Ω—Å–æ—Ä–∏
Other sponsors
–í—Ä–∞–∂–µ–Ω–Ω—è
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I‚Äôm over the moon excited about
FastAPI
. It‚Äôs so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Typer
, FastAPI CLI
–°—Ç–≤–æ—Ä—é—é—á–∏
CLI
–∑–∞—Å—Ç–æ—Å—É–Ω–æ–∫ –¥–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –≤ —Ç–µ—Ä–º—ñ–Ω–∞–ª—ñ, –∑–∞–º—ñ—Å—Ç—å –≤–µ–±-API –∑–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É –Ω–∞
Typer
.
Typer
—î –º–æ–ª–æ–¥—à–∏–º –±—Ä–∞—Ç–æ–º FastAPI. –Ü —Ü–µ
FastAPI –¥–ª—è CLI
. ‚å®Ô∏è üöÄ
–í–∏–º–æ–≥–∏
FastAPI —Å—Ç–æ—ó—Ç—å –Ω–∞ –ø–ª–µ—á–∞—Ö –≥—ñ–≥–∞–Ω—Ç—ñ–≤:
Starlette
–¥–ª—è web —á–∞—Å—Ç–∏–Ω–∏.
Pydantic
–¥–ª—è —á–∞—Å—Ç–∏–Ω–∏ –¥–∞–Ω–∏—Ö.
–í—Å—Ç–∞–≤–Ω–æ–≤–ª–µ–Ω–Ω—è
fast ‚Üí
pip install fastapi
restart ‚Üª
–í–∞–º —Ç–∞–∫–æ–∂ –∑–Ω–∞–¥–æ–±–∏—Ç—å—Å—è —Å–µ—Ä–≤–µ—Ä ASGI –¥–ª—è –ø—Ä–æ–¥–∞–∫—à–∏–Ω—É, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥
Uvicorn
–∞–±–æ
Hypercorn
.
fast ‚Üí
pip install uvicorn[standard]
restart ‚Üª
–ü—Ä–∏–∫–ª–∞–¥
–°—Ç–≤–æ—Ä—ñ—Ç—å
–°—Ç–≤–æ—Ä—ñ—Ç—å —Ñ–∞–π–ª
main.py
–∑:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
–ê–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ
async def
...
–Ø–∫—â–æ –≤–∞—à –∫–æ–¥ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î
async
/
await
, —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—è
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
–ü—Ä–∏–º—ñ—Ç–∫–∞
:
–°—Ç–∏–∫–Ω—É–≤—à–∏—Å—å –∑ –ø—Ä–æ–±–ª–µ–º–∞–º–∏, –Ω–µ –∑–∞–π–≤–∏–º –±—É–¥–µ –æ–∑–Ω–∞–π–æ–º–∏—Ç–∏—Å—è –∑ —Ä–æ–∑–¥—ñ–ª–æ–º
"In a hurry?"
–ø—Ä–æ
async
—Ç–∞
await
—É –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
.
–ó–∞–ø—É—Å—Ç—ñ—Ç—å
–ó–∞–ø—É—Å—Ç—ñ—Ç—å server –∑:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
–ü—Ä–æ –∫–æ–º–∞–Ω–¥–∏
uvicorn main:app --reload
...
–ö–æ–º–∞–Ω–¥–∞
uvicorn main:app
–ø–æ—Å–∏–ª–∞—î—Ç—å—Å—è –Ω–∞:
main
: —Ñ–∞–π–ª
main.py
("–ú–æ–¥—É–ª—å" Python).
app
: –æ–±‚Äô—î–∫—Ç —Å—Ç–≤–æ—Ä–µ–Ω–∏–π —É—Å–µ—Ä–µ–¥–∏–Ω—ñ
main.py
—Ä—è–¥–∫–æ–º
app = FastAPI()
.
--reload
: –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—î —Å–µ—Ä–≤–µ—Ä –ø—ñ—Å–ª—è –∑–º—ñ–Ω–∏ –∫–æ–¥—É. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –≤–∏–∫–ª—é—á–Ω–æ –¥–ª—è —Ä–æ–∑—Ä–æ–±–∫–∏.
–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ
–í—ñ–¥–∫—Ä–∏–π—Ç–µ –±—Ä–∞—É–∑–µ—Ä —Ç–∞ –≤–≤–µ–¥—ñ—Ç—å –∞–¥—Ä–µ—Å—É
http://127.0.0.1:8000/items/5?q=somequery
.
–í–∏ –ø–æ–±–∞—á–∏—Ç–µ —É –≤—ñ–¥–ø–æ–≤—ñ–¥—å –ø–æ–¥—ñ–±–Ω–∏–π JSON:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
–í–∏ –≤–∂–µ —Å—Ç–≤–æ—Ä–∏–ª–∏ API, —è–∫–∏–π:
–û—Ç—Ä–∏–º—É—î HTTP –∑–∞–ø–∏—Ç–∏ –∑–∞
—à–ª—è—Ö–∞–º–∏
/
—Ç–∞
/items/{item_id}
.
–û–±–∏–¥–≤–∞
—à–ª—è—Ö–∏
–ø—Ä–∏–π–º–∞—é—Ç—å
GET
–æ–ø–µ—Ä–∞—Ü—ñ—ó
(—Ç–∞–∫–æ–∂ –≤—ñ–¥–æ–º—ñ —è–∫ HTTP
–º–µ—Ç–æ–¥–∏
).
–®–ª—è—Ö
/items/{item_id}
–º—ñ—Å—Ç–∏—Ç—å
–ø–∞—Ä–∞–º–µ—Ç—Ä —à–ª—è—Ö—É
item_id
—è–∫–∏–π –º–∞—î –±—É—Ç–∏ —Ç–∏–ø—É
int
.
–®–ª—è—Ö
/items/{item_id}
–º—ñ—Å—Ç–∏—Ç—å –Ω–µ–æ–±–æ–≤ º—è–∑–∫–æ–≤–∏–π
str
–ø–∞—Ä–∞–º–µ—Ç—Ä –∑–∞–ø–∏—Ç—É
q
.
–Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ñ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó API
–ü–µ—Ä–µ–π–¥–µ–º–æ —Å—é–¥–∏
http://127.0.0.1:8000/docs
.
–í–∏ –ø–æ–±–∞—á–∏—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω—É —ñ–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—É API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—é (—Å—Ç–≤–æ—Ä–µ–Ω—É –∑–∞–≤–¥—è–∫–∏
Swagger UI
):
–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ñ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó API
–¢–µ–ø–µ—Ä –ø–µ—Ä–µ–π–¥–µ–º–æ —Å—é–¥–∏
http://127.0.0.1:8000/redoc
.
–í–∏ –ø–æ–±–∞—á–∏—Ç–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—É –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω—É –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—é (—Å—Ç–≤–æ—Ä–µ–Ω—É –∑–∞–≤–¥—è–∫–∏
ReDoc
):
–ü—Ä–∏–∫–ª–∞–¥ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
–¢–µ–ø–µ—Ä –º–æ–¥–∏—Ñ—ñ–∫—É–π—Ç–µ —Ñ–∞–π–ª
main.py
, —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ –≤–º—ñ—Å—Ç –∑–∞–ø–∏—Ç—É
PUT
.
–û–≥–æ–ª–æ—à—É–π—Ç–µ –≤–º—ñ—Å—Ç –∑–∞–ø–∏—Ç—É –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏—Ö —Ç–∏–ø—ñ–≤ Python –∑–∞–≤–¥—è–∫–∏ Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
–°–µ—Ä–≤–µ—Ä –ø–æ–≤–∏–Ω–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—Ç–∏—Å—è (—Ç–æ–º—É —â–æ –í–∏ –¥–æ–¥–∞–ª–∏
--reload
–¥–æ
uvicorn
–∫–æ–º–∞–Ω–¥–∏ –≤–∏—â–µ).
–û–Ω–æ–≤–ª–µ–Ω–Ω—è —ñ–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—ó API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
–¢–µ–ø–µ—Ä –ø–µ—Ä–µ–π–¥–µ–º–æ —Å—é–¥–∏
http://127.0.0.1:8000/docs
.
–Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è API –±—É–¥–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –æ–Ω–æ–≤–ª–µ–Ω–∞, –≤–∫–ª—é—á–∞—é—á–∏ –Ω–æ–≤–∏–π –≤–º—ñ—Å—Ç:
–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É "Try it out", —Ü–µ –¥–æ–∑–≤–æ–ª–∏—Ç—å –≤–∞–º –∑–∞–ø–æ–≤–Ω–∏—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ç–∞ –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ –≤–∑–∞—î–º–æ–¥—ñ—è—Ç–∏ –∑ API:
–ü–æ—Ç—ñ–º –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É "Execute", —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑–≤'—è–∂–µ—Ç—å—Å—è –∑ –≤–∞—à–∏–º API, –Ω–∞–¥—ñ—à–ª–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏, —É –≤—ñ–¥–ø–æ–≤—ñ–¥—å –æ—Ç—Ä–∏–º–∞—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ —Ç–∞ –ø–æ–∫–∞–∂–µ —ó—Ö –Ω–∞ –µ–∫—Ä–∞–Ω—ñ:
–û–Ω–æ–≤–ª–µ–Ω–Ω—è –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ—ó API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó
–ó–∞—Ä–∞–∑ –ø–µ—Ä–µ–π–¥–µ–º–æ
http://127.0.0.1:8000/redoc
.
–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è —Ç–∞–∫–æ–∂ –ø–æ–∫–∞–∑—É–≤–∞—Ç–∏–º–µ –Ω–æ–≤–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä —ñ –≤–º—ñ—Å—Ç –∑–∞–ø–∏—Ç—É:
–ü—ñ–¥—Å—É–º–∫–∏
–¢–∞–∫–∏–º —á–∏–Ω–æ–º, –í–∏
–æ–¥–∏–Ω —Ä–∞–∑
–æ–≥–æ–ª–æ—à—É—î—Ç–µ —Ç–∏–ø–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤, —Ç—ñ–ª–∞ —Ç–æ—â–æ, —è–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü—ñ—ó.
–í–∏ —Ä–æ–±–∏—Ç–µ —Ü–µ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏—Ö —Å—É—á–∞—Å–Ω–∏—Ö —Ç–∏–ø—ñ–≤ Python.
–í–∞–º –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ –≤–∏–≤—á–∞—Ç–∏ –Ω–æ–≤–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å, –º–µ—Ç–æ–¥–∏ —á–∏ –∫–ª–∞—Å–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—ó –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∏ —Ç–æ—â–æ.
–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–π
Python
.
–ù–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–ª—è
int
:
item_id
:
int
–∞–±–æ –¥–ª—è –±—ñ–ª—å—à —Å–∫–ª–∞–¥–Ω–æ—ó –º–æ–¥–µ–ª—ñ
Item
:
item
:
Item
...—ñ –∑ —Ü–∏–º —î–¥–∏–Ω–∏–º –æ–≥–æ–ª–æ—à–µ–Ω–Ω—è–º –í–∏ –æ—Ç—Ä–∏–º—É—î—Ç–µ:
–ü—ñ–¥—Ç—Ä–∏–º–∫—É —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞, –≤–∫–ª—é—á–∞—é—á–∏:
–í–∞—Ä—ñ–∞–Ω—Ç–∏ –∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è.
–ü–µ—Ä–µ–≤—ñ—Ä–∫—É —Ç–∏–ø—ñ–≤.
–ü–µ—Ä–µ–≤—ñ—Ä–∫—É –¥–∞–Ω–∏—Ö:
–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω—ñ —Ç–∞ –∑—Ä–æ–∑—É–º—ñ–ª—ñ –ø–æ–º–∏–ª–∫–∏, —É —Ä–∞–∑—ñ –Ω–µ–∫–æ—Ä–µ–∫—Ç–Ω–∏—Ö –¥–∞–Ω–∏—Ö.
–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞–≤—ñ—Ç—å –¥–ª—è JSON –∑ –≤–∏—Å–æ–∫–∏–º —Ä—ñ–≤–Ω–µ–º –≤–∫–ª–∞–¥–µ–Ω–æ—Å—Ç—ñ.
–ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è
–≤—Ö—ñ–¥–Ω–∏—Ö –¥–∞–Ω–∏—Ö: –∑ –º–µ—Ä–µ–∂—ñ –¥–æ –¥–∞–Ω–∏—Ö —ñ —Ç–∏–ø—ñ–≤ Python. –ß–∏—Ç–∞–Ω–Ω—è –∑:
JSON.
–ü–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ —à–ª—è—Ö—É.
–ü–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ –∑–∞–ø–∏—Ç—É.
Cookies.
Headers.
Forms.
–§–∞–π–ª—ñ–≤.
–ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è
–≤–∏—Ö—ñ–¥–Ω–∏—Ö –¥–∞–Ω–∏—Ö: –∑ —Ç–∏–ø—ñ–≤ —ñ –¥–∞–Ω–∏—Ö Python –¥–æ –º–µ—Ä–µ–∂–µ–≤–∏—Ö –¥–∞–Ω–∏—Ö (—è–∫ JSON):
–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è Python —Ç–∏–ø—ñ–≤ (
str
,
int
,
float
,
bool
,
list
, —Ç–æ—â–æ).
datetime
–æ–±'—î–∫—Ç–∏.
UUID
–æ–±'—î–∫—Ç–∏.
–ú–æ–¥–µ–ª—ñ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö.
...—Ç–∞ –±–∞–≥–∞—Ç–æ —ñ–Ω—à–æ–≥–æ.
–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω—É —ñ–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—É –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—é API, –≤–∫–ª—é—á–∞—é—á–∏ 2 –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ñ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞:
Swagger UI.
ReDoc.
–ü–æ–≤–µ—Ä—Ç–∞—é—á–∏—Å—å –¥–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ –ø—Ä–∏–∫–ª–∞–¥—É –∫–æ–¥—É,
FastAPI
:
–ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –Ω–∞—è–≤–Ω—ñ—Å—Ç—å
item_id
—É —à–ª—è—Ö—É –¥–ª—è –∑–∞–ø–∏—Ç—ñ–≤
GET
—Ç–∞
PUT
.
–ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å, —â–æ
item_id
–º–∞—î —Ç–∏–ø
int
–¥–ª—è –∑–∞–ø–∏—Ç—ñ–≤
GET
and
PUT
.
–Ø–∫—â–æ —Ü–µ –Ω–µ —Ç–∞–∫, –∫–ª—ñ—î–Ω—Ç –ø–æ–±–∞—á–∏—Ç—å –∫–æ—Ä–∏—Å–Ω—É, –∑—Ä–æ–∑—É–º—ñ–ª—É –ø–æ–º–∏–ª–∫—É.
–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç—å, —á–∏ —î –Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä –∑–∞–ø–∏—Ç—É –∑ –Ω–∞–∑–≤–æ—é
q
(–∞ —Å–∞–º–µ
http://127.0.0.1:8000/items/foo?q=somequery
) –¥–ª—è –∑–∞–ø–∏—Ç—ñ–≤
GET
.
–û—Å–∫—ñ–ª—å–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä
q
–æ–≥–æ–ª–æ—à–µ–Ω–æ —è–∫
= None
, –≤—ñ–Ω –Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–∏–π.
–ó–∞ –≤—ñ–¥—Å—É—Ç–Ω–æ—Å—Ç—ñ
None
–≤—ñ–Ω –±—É–≤ –±–∏ –æ–±–æ–≤'—è–∑–∫–æ–≤–∏–º (—è–∫ —ñ –≤–º—ñ—Å—Ç —É –≤–∏–ø–∞–¥–∫—É –∑
PUT
).
–î–ª—è –∑–∞–ø–∏—Ç—ñ–≤
PUT
—ñ–∑
/items/{item_id}
, —á–∏—Ç–∞—î –≤–º—ñ—Å—Ç —è–∫ JSON:
–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç—å, —á–∏ –º–∞—î –æ–±–æ–≤'—è–∑–∫–æ–≤–∏–π –∞—Ç—Ä–∏–±—É—Ç
name
—Ç–∏–ø
str
.
–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç—å, —á–∏ –º–∞—î –æ–±–æ–≤'—è–∑–∫–æ–≤–∏–π –∞—Ç—Ä–∏–±—É—Ç
price
—Ç–∏–ø
float
.
–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç—å, —á–∏ —ñ—Å–Ω—É—î –Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–∏–π –∞—Ç—Ä–∏–±—É—Ç
is_offer
—Ç–∞ —á–∏ –º–∞—î –≤—ñ–Ω —Ç–∏–ø
bool
.
–£—Å–µ —Ü–µ —Ç–∞–∫–æ–∂ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏–º–µ –¥–ª—è –≥–ª–∏–±–æ–∫–æ –≤–∫–ª–∞–¥–µ–Ω–∏—Ö –æ–±'—î–∫—Ç—ñ–≤ JSON.
–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç—É—î —ñ–∑ —Ç–∞ –≤ JSON.
–î–æ–∫—É–º–µ–Ω—Ç—É—î –≤—Å–µ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é OpenAPI, —è–∫–∏–π –º–æ–∂–µ –±—É—Ç–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ –≤:
–Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∏—Ö —Å–∏—Å—Ç–µ–º–∞—Ö –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó.
–°–∏—Å—Ç–µ–º–∞—Ö –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ—ó –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –∫–ª—ñ—î–Ω—Ç—Å—å–∫–æ–≥–æ –∫–æ–¥—É –¥–ª—è –±–∞–≥–∞—Ç—å–æ—Ö –º–æ–≤.
–ù–∞–¥–∞—î –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ 2 –≤–µ–±—ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∏ —ñ–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—ó –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó.
–ú–∏ –ª–∏—à–µ —Ç—Ä—ñ—à–∫–∏ –¥–æ—Ç–æ—Ä–∫–Ω—É–ª–∏—Å—è –¥–æ –∫–æ–¥—É, –∞–ª–µ –í–∏ –≤–∂–µ –º–∞—î—Ç–µ —É—è–≤–ª–µ–Ω–Ω—è –ø—Ä–æ —Ç–µ, —è–∫ –≤—Å–µ –ø—Ä–∞—Ü—é—î.
–°–ø—Ä–æ–±—É–π—Ç–µ –∑–º—ñ–Ω–∏—Ç–∏ —Ä—è–¥–æ–∫:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...—ñ–∑:
...
"item_name"
:
item
.
name
...
...–Ω–∞:
...
"item_price"
:
item
.
price
...
...—ñ –ø–æ–±–∞—á–∏—Ç–µ, —è–∫ –≤–∞—à —Ä–µ–¥–∞–∫—Ç–æ—Ä –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∑–∞–ø–æ–≤–Ω—é–≤–∞—Ç–∏–º–µ –∞—Ç—Ä–∏–±—É—Ç–∏ —Ç–∞ –∑–Ω–∞—Ç–∏–º–µ —ó—Ö–Ω—ñ —Ç–∏–ø–∏:
–î–ª—è –±—ñ–ª—å—à –ø–æ–≤–Ω–æ–≥–æ –æ–∑–Ω–∞–π–æ–º–ª–µ–Ω–Ω—è –∑ –¥–æ–¥–∞—Ç–∫–æ–≤–∏–º–∏ —Ñ—É–Ω–∫—Ü—ñ—è–º–∏, –ø–µ—Ä–µ–≥–ª—è–Ω—å—Ç–µ
–¢—É—Ç–æ—Ä—ñ–∞–ª - –ü–æ—Å—ñ–±–Ω–∏–∫ –ö–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
.
Spoiler alert
: —Ç—É—Ç–æ—Ä—ñ–∞–ª - –ø–æ—Å—ñ–±–Ω–∏–∫ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –º—ñ—Å—Ç–∏—Ç—å:
–û–≥–æ–ª–æ—à–µ–Ω–Ω—è
–ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤
–∑ —ñ–Ω—à–∏—Ö –º—ñ—Å—Ü—å —è–∫:
headers
,
cookies
,
form fields
—Ç–∞
files
.
–Ø–∫ –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏
–ø–µ—Ä–µ–≤—ñ—Ä–∫—É –æ–±–º–µ–∂–µ–Ω—å
—è–∫
maximum_length
–∞–±–æ
regex
.
–î—É–∂–µ –ø–æ—Ç—É–∂–Ω–∞ —ñ –ø—Ä–æ—Å—Ç–∞ —É –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—ñ —Å–∏—Å—Ç–µ–º–∞
–Ü–Ω'—î–∫—Ü—ñ—è –ó–∞–ª–µ–∂–Ω–æ—Å—Ç–µ–π
.
–ë–µ–∑–ø–µ–∫–∞ —Ç–∞ –∞–≤—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—è, –≤–∫–ª—é—á–∞—é—á–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫—É
OAuth2
–∑
JWT tokens
—Ç–∞
HTTP Basic
–∞–≤—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—é.
–î–æ—Å–∫–æ–Ω–∞–ª—ñ—à—ñ (–∞–ª–µ –æ–¥–Ω–∞–∫–æ–≤–æ –ø—Ä–æ—Å—Ç—ñ) —Ç–µ—Ö–Ω—ñ–∫–∏ –¥–ª—è –æ–≥–æ–ª–æ—à–µ–Ω–Ω—è
–≥–ª–∏–±–æ–∫–æ –≤–∫–ª–∞–¥–µ–Ω–∏—Ö –º–æ–¥–µ–ª–µ–π JSON
(–∑–∞–≤–¥—è–∫–∏ Pydantic).
–ë–∞–≥–∞—Ç–æ –¥–æ–¥–∞—Ç–∫–æ–≤–∏—Ö —Ñ—É–Ω–∫—Ü—ñ–π (–∑–∞–≤–¥—è–∫–∏ Starlette) —è–∫-–æ—Ç:
WebSockets
–Ω–∞–¥–∑–≤–∏—á–∞–π–Ω–æ –ø—Ä–æ—Å—Ç—ñ —Ç–µ—Å—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ HTTPX —Ç–∞
pytest
CORS
Cookie Sessions
...—Ç–∞ –±—ñ–ª—å—à–µ.
–ü—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
–ù–µ–∑–∞–ª–µ–∂–Ω—ñ —Ç–µ—Å—Ç–∏ TechEmpower –ø–æ–∫–∞–∑—É—é—Ç—å —â–æ –∑–∞—Å—Ç–æ—Å—É–Ω–∫–∏
FastAPI
, —è–∫—ñ –ø—Ä–∞—Ü—é—é—Ç—å –ø—ñ–¥ –∫–µ—Ä—É–≤–∞–Ω–Ω—è–º Uvicorn
—î –æ–¥–Ω–∏–º–∏ –∑ –Ω–∞–π—à–≤–∏–¥—à–∏—Ö —Å–µ—Ä–µ–¥ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Ñ—Ä–µ–π–º–≤–æ—Ä–∫—ñ–≤ –≤ Python
, –ø–æ—Å—Ç—É–ø–∞—é—á–∏—Å—å –ª–∏—à–µ Starlette —Ç–∞ Uvicorn (—è–∫—ñ –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è –≤ FastAPI). (*)
–©–æ–± –¥—ñ–∑–Ω–∞—Ç–∏—Å—è –±—ñ–ª—å—à–µ –ø—Ä–æ —Ü–µ, –ø–µ—Ä–µ–≥–ª—è–Ω—å—Ç–µ —Ä–æ–∑–¥—ñ–ª
Benchmarks
.
–ù–µ–æ–±–æ–≤'—è–∑–∫–æ–≤—ñ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ
Pydantic –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î:
email-validator
- –¥–ª—è –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó –µ–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ—ó –ø–æ—à—Ç–∏.
pydantic-settings
- –¥–ª—è —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è–º–∏.
pydantic-extra-types
- –¥–ª—è –¥–æ–¥–∞—Ç–∫–æ–≤–∏—Ö —Ç–∏–ø—ñ–≤, —â–æ –º–æ–∂—É—Ç—å –±—É—Ç–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω—ñ –∑ Pydantic.
Starlette –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î:
httpx
- –ù–µ–æ–±—Ö—ñ–¥–Ω–æ, —è–∫—â–æ –í–∏ —Ö–æ—á–µ—Ç–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏
TestClient
.
jinja2
- –ù–µ–æ–±—Ö—ñ–¥–Ω–æ, —è–∫—â–æ –í–∏ —Ö–æ—á–µ—Ç–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ —à–∞–±–ª–æ–Ω–∏ —è–∫ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º.
python-multipart
- –ù–µ–æ–±—Ö—ñ–¥–Ω–æ, —è–∫—â–æ –í–∏ —Ö–æ—á–µ—Ç–µ –ø—ñ–¥—Ç—Ä–∏–º—É–≤–∞—Ç–∏
"—Ä–æ–∑–±—ñ—Ä"
—Ñ–æ—Ä–º–∏ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é
request.form()
.
itsdangerous
- –ù–µ–æ–±—Ö—ñ–¥–Ω–æ –¥–ª—è –ø—ñ–¥—Ç—Ä–∏–º–∫–∏
SessionMiddleware
.
pyyaml
- –ù–µ–æ–±—Ö—ñ–¥–Ω–æ –¥–ª—è –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ Starlette
SchemaGenerator
(–π–º–æ–≤—ñ—Ä–Ω–æ, –≤–∞–º —Ü–µ –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑ FastAPI).
FastAPI / Starlette –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å:
uvicorn
- –¥–ª—è —Å–µ—Ä–≤–µ—Ä–∞, —è–∫–∏–π –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î —Ç–∞ –æ–±—Å–ª—É–≥–æ–≤—É—î –≤–∞—à—É –ø—Ä–æ–≥—Ä–∞–º—É.
orjson
- –ù–µ–æ–±—Ö—ñ–¥–Ω–æ, —è–∫—â–æ –í–∏ —Ö–æ—á–µ—Ç–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏
ORJSONResponse
.
ujson
- –ù–µ–æ–±—Ö—ñ–¥–Ω–æ, —è–∫—â–æ –í–∏ —Ö–æ—á–µ—Ç–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏
UJSONResponse
.
–í–∏ –º–æ–∂–µ—Ç–µ –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ –≤—Å–µ —Ü–µ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é
pip install fastapi[all]
.
–õ—ñ—Ü–µ–Ω–∑—ñ—è
–¶–µ–π –ø—Ä–æ—î–∫—Ç –ª—ñ—Ü–µ–Ω–∑–æ–≤–∞–Ω–æ –∑–≥—ñ–¥–Ω–æ –∑ —É–º–æ–≤–∞–º–∏ –ª—ñ—Ü–µ–Ω–∑—ñ—ó MIT.

## 157_UR
FastAPI¬∂
---

FastAPI
Warning
The current page still doesn't have a translation for this language.
But you can help translating it:
Contributing
.
FastAPI framework, high performance, easy to learn, fast to code, ready for production
Documentation
:
https://fastapi.tiangolo.com
Source Code
:
https://github.com/fastapi/fastapi
FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints.
The key features are:
Fast
: Very high performance, on par with
NodeJS
and
Go
(thanks to Starlette and Pydantic).
One of the fastest Python frameworks available
.
Fast to code
: Increase the speed to develop features by about 200% to 300%. *
Fewer bugs
: Reduce about 40% of human (developer) induced errors. *
Intuitive
: Great editor support.
Completion
everywhere. Less time debugging.
Easy
: Designed to be easy to use and learn. Less time reading docs.
Short
: Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs.
Robust
: Get production-ready code. With automatic interactive documentation.
Standards-based
: Based on (and fully compatible with) the open standards for APIs:
OpenAPI
(previously known as Swagger) and
JSON Schema
.
* estimation based on tests on an internal development team, building production applications.
Sponsors
Other sponsors
Opinions
"
[...] I'm using
FastAPI
a ton these days. [...] I'm actually planning to use it for all of my team's
ML services at Microsoft
. Some of them are getting integrated into the core
Windows
product and some
Office
products.
"
Kabir Khan -
Microsoft
(ref)
"
We adopted the
FastAPI
library to spawn a
REST
server that can be queried to obtain
predictions
. [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
is pleased to announce the open-source release of our
crisis management
orchestration framework:
Dispatch
! [built with
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
I‚Äôm over the moon excited about
FastAPI
. It‚Äôs so fun!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted
Hug
to be - it's really inspiring to see someone build that.
"
Timothy Crosley -
Hug
creator
(ref)
"
If you're looking to learn one
modern framework
for building REST APIs, check out
FastAPI
[...] It's fast, easy to use and easy to learn [...]
"
"
We've switched over to
FastAPI
for our
APIs
[...] I think you'll like it [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
If anyone is looking to build a production Python API, I would highly recommend
FastAPI
. It is
beautifully designed
,
simple to use
and
highly scalable
, it has become a
key component
in our API first development strategy and is driving many automations and services such as our Virtual TAC Engineer.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, the FastAPI of CLIs
If you are building a
CLI
app to be used in the terminal instead of a web API, check out
Typer
.
Typer
is FastAPI's little sibling. And it's intended to be the
FastAPI of CLIs
. ‚å®Ô∏è üöÄ
Requirements
FastAPI stands on the shoulders of giants:
Starlette
for the web parts.
Pydantic
for the data parts.
Installation
Create and activate a
virtual environment
and then install FastAPI:
fast ‚Üí
pip install "fastapi[standard]"
restart ‚Üª
Note
: Make sure you put
"fastapi[standard]"
in quotes to ensure it works in all terminals.
Example
Create it
Create a file
main.py
with:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Or use
async def
...
If your code uses
async
/
await
, use
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Note
:
If you don't know, check the
"In a hurry?"
section about
async
and
await
in the docs
.
Run it
Run the server with:
fast ‚Üí
fastapi dev main.py
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FastAPI CLI - Development mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ ‚îÇ
‚îÇ Serving at: http://127.0.0.1:8000 ‚îÇ
‚îÇ ‚îÇ
‚îÇ API docs: http://127.0.0.1:8000/docs ‚îÇ
‚îÇ ‚îÇ
‚îÇ Running in development mode, for production use: ‚îÇ
‚îÇ ‚îÇ
‚îÇ fastapi run ‚îÇ
‚îÇ ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
INFO: Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [2248755] using WatchFiles
INFO: Started server process [2248757]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
About the command
fastapi dev main.py
...
The command
fastapi dev
reads your
main.py
file, detects the
FastAPI
app in it, and starts a server using
Uvicorn
.
By default,
fastapi dev
will start with auto-reload enabled for local development.
You can read more about it in the
FastAPI CLI docs
.
Check it
Open your browser at
http://127.0.0.1:8000/items/5?q=somequery
.
You will see the JSON response as:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
You already created an API that:
Receives HTTP requests in the
paths
/
and
/items/{item_id}
.
Both
paths
take
GET
operations
(also known as HTTP
methods
).
The
path
/items/{item_id}
has a
path parameter
item_id
that should be an
int
.
The
path
/items/{item_id}
has an optional
str
query parameter
q
.
Interactive API docs
Now go to
http://127.0.0.1:8000/docs
.
You will see the automatic interactive API documentation (provided by
Swagger UI
):
Alternative API docs
And now, go to
http://127.0.0.1:8000/redoc
.
You will see the alternative automatic documentation (provided by
ReDoc
):
Example upgrade
Now modify the file
main.py
to receive a body from a
PUT
request.
Declare the body using standard Python types, thanks to Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
The
fastapi dev
server should reload automatically.
Interactive API docs upgrade
Now go to
http://127.0.0.1:8000/docs
.
The interactive API documentation will be automatically updated, including the new body:
Click on the button "Try it out", it allows you to fill the parameters and directly interact with the API:
Then click on the "Execute" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen:
Alternative API docs upgrade
And now, go to
http://127.0.0.1:8000/redoc
.
The alternative documentation will also reflect the new query parameter and body:
Recap
In summary, you declare
once
the types of parameters, body, etc. as function parameters.
You do that with standard modern Python types.
You don't have to learn a new syntax, the methods or classes of a specific library, etc.
Just standard
Python
.
For example, for an
int
:
item_id
:
int
or for a more complex
Item
model:
item
:
Item
...and with that single declaration you get:
Editor support, including:
Completion.
Type checks.
Validation of data:
Automatic and clear errors when the data is invalid.
Validation even for deeply nested JSON objects.
Conversion
of input data: coming from the network to Python data and types. Reading from:
JSON.
Path parameters.
Query parameters.
Cookies.
Headers.
Forms.
Files.
Conversion
of output data: converting from Python data and types to network data (as JSON):
Convert Python types (
str
,
int
,
float
,
bool
,
list
, etc).
datetime
objects.
UUID
objects.
Database models.
...and many more.
Automatic interactive API documentation, including 2 alternative user interfaces:
Swagger UI.
ReDoc.
Coming back to the previous code example,
FastAPI
will:
Validate that there is an
item_id
in the path for
GET
and
PUT
requests.
Validate that the
item_id
is of type
int
for
GET
and
PUT
requests.
If it is not, the client will see a useful, clear error.
Check if there is an optional query parameter named
q
(as in
http://127.0.0.1:8000/items/foo?q=somequery
) for
GET
requests.
As the
q
parameter is declared with
= None
, it is optional.
Without the
None
it would be required (as is the body in the case with
PUT
).
For
PUT
requests to
/items/{item_id}
, read the body as JSON:
Check that it has a required attribute
name
that should be a
str
.
Check that it has a required attribute
price
that has to be a
float
.
Check that it has an optional attribute
is_offer
, that should be a
bool
, if present.
All this would also work for deeply nested JSON objects.
Convert from and to JSON automatically.
Document everything with OpenAPI, that can be used by:
Interactive documentation systems.
Automatic client code generation systems, for many languages.
Provide 2 interactive documentation web interfaces directly.
We just scratched the surface, but you already get the idea of how it all works.
Try changing the line with:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...from:
...
"item_name"
:
item
.
name
...
...to:
...
"item_price"
:
item
.
price
...
...and see how your editor will auto-complete the attributes and know their types:
For a more complete example including more features, see the
Tutorial - User Guide
.
Spoiler alert
: the tutorial - user guide includes:
Declaration of
parameters
from other different places as:
headers
,
cookies
,
form fields
and
files
.
How to set
validation constraints
as
maximum_length
or
regex
.
A very powerful and easy to use
Dependency Injection
system.
Security and authentication, including support for
OAuth2
with
JWT tokens
and
HTTP Basic
auth.
More advanced (but equally easy) techniques for declaring
deeply nested JSON models
(thanks to Pydantic).
GraphQL
integration with
Strawberry
and other libraries.
Many extra features (thanks to Starlette) as:
WebSockets
extremely easy tests based on HTTPX and
pytest
CORS
Cookie Sessions
...and more.
Performance
Independent TechEmpower benchmarks show
FastAPI
applications running under Uvicorn as
one of the fastest Python frameworks available
, only below Starlette and Uvicorn themselves (used internally by FastAPI). (*)
To understand more about it, see the section
Benchmarks
.
Dependencies
FastAPI depends on Pydantic and Starlette.
standard
Dependencies
When you install FastAPI with
pip install "fastapi[standard]"
it comes with the
standard
group of optional dependencies:
Used by Pydantic:
email-validator
- for email validation.
Used by Starlette:
httpx
- Required if you want to use the
TestClient
.
jinja2
- Required if you want to use the default template configuration.
python-multipart
- Required if you want to support form
"parsing"
, with
request.form()
.
Used by FastAPI / Starlette:
uvicorn
- for the server that loads and serves your application. This includes
uvicorn[standard]
, which includes some dependencies (e.g.
uvloop
) needed for high performance serving.
fastapi-cli
- to provide the
fastapi
command.
Without
standard
Dependencies
If you don't want to include the
standard
optional dependencies, you can install with
pip install fastapi
instead of
pip install "fastapi[standard]"
.
Additional Optional Dependencies
There are some additional dependencies you might want to install.
Additional optional Pydantic dependencies:
pydantic-settings
- for settings management.
pydantic-extra-types
- for extra types to be used with Pydantic.
Additional optional FastAPI dependencies:
orjson
- Required if you want to use
ORJSONResponse
.
ujson
- Required if you want to use
UJSONResponse
.
License
This project is licensed under the terms of the MIT license.

## 158_VI
FastAPI¬∂
---

FastAPI
FastAPI framework, hi·ªáu nƒÉng cao, d·ªÖ h·ªçc, d·ªÖ code, s·∫µn s√†ng ƒë·ªÉ t·∫°o ra s·∫£n ph·∫©m
T√†i li·ªáu
:
https://fastapi.tiangolo.com
M√£ ngu·ªìn
:
https://github.com/fastapi/fastapi
FastAPI l√† m·ªôt web framework hi·ªán ƒë·∫°i, hi·ªáu nƒÉng cao ƒë·ªÉ x√¢y d·ª±ng web APIs v·ªõi Python d·ª±a tr√™n ti√™u chu·∫©n Python type hints.
Nh·ªØng t√≠nh nƒÉng nh∆∞:
Nhanh
: Hi·ªáu nƒÉng r·∫•t cao khi so s√°nh v·ªõi
NodeJS
v√†
Go
(c·∫£m ∆°n Starlette v√† Pydantic).
M·ªôt trong nh·ªØng Python framework nhanh nh·∫•t
.
Code nhanh
: TƒÉng t·ªëc ƒë·ªô ph√°t tri·ªÉn t√≠nh nƒÉng t·ª´ 200% t·ªõi 300%. *
√çt l·ªói h∆°n
: Gi·∫£m kho·∫£ng 40% nh·ªØng l·ªói ph√°t sinh b·ªüi con ng∆∞·ªùi (nh√† ph√°t tri·ªÉn). *
Tr·ª±c gi√°c t·ªët h∆°n
: ƒê∆∞·ª£c c√°c tr√¨nh so·∫°n th·∫£o h·ªó tuy·ªát v·ªùi.
Completion
m·ªçi n∆°i. √çt th·ªùi gian g·ª° l·ªói.
D·ªÖ d√†ng
: ƒê∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ d·ªÖ d√†ng h·ªçc v√† s·ª≠ d·ª•ng. √çt th·ªùi gian ƒë·ªçc t√†i li·ªáu.
Ng·∫Øn
: T·ªëi thi·ªÉu code b·ªã tr√πng l·∫∑p. Nhi·ªÅu t√≠nh nƒÉng ƒë∆∞·ª£c t√≠ch h·ª£p khi ƒë·ªãnh nghƒ©a tham s·ªë. √çt l·ªói h∆°n.
TƒÉng t·ªëc
: C√≥ ƒë∆∞·ª£c s·∫£n ph·∫©m c√πng v·ªõi t√†i li·ªáu (ƒë∆∞·ª£c t·ª± ƒë·ªông t·∫°o) c√≥ th·ªÉ t∆∞∆°ng t√°c.
ƒê∆∞·ª£c d·ª±a tr√™n c√°c ti√™u chu·∫©n
: D·ª±a tr√™n (v√† ho√†n to√†n t∆∞∆°ng th√≠ch v·ªõi) c√°c ti√™u chu·∫©n m·ªü cho APIs :
OpenAPI
(tr∆∞·ªõc ƒë√≥ ƒë∆∞·ª£c bi·∫øt ƒë·∫øn l√† Swagger) v√†
JSON Schema
.
* ∆∞·ªõc t√≠nh ƒë∆∞·ª£c d·ª±a tr√™n nh·ªØng ki·ªÉm ch·ª©ng trong nh√≥m ph√°t tri·ªÉn n·ªôi b·ªô, x√¢y d·ª±ng c√°c ·ª©ng d·ª•ng s·∫£n ph·∫©m.
Nh√† t√†i tr·ª£
Nh·ªØng nh√† t√†i tr·ª£ kh√°c
√ù ki·∫øn ƒë√°nh gi√°
"
[...] T√¥i ƒëang s·ª≠ d·ª•ng
FastAPI
v√¥ c√πng nhi·ªÅu v√†o nh·ªØng ng√†y n√†y. [...] T√¥i th·ª±c s·ª± ƒëang l√™n k·∫ø ho·∫°ch s·ª≠ d·ª•ng n√≥ cho t·∫•t c·∫£ c√°c nh√≥m
d·ªãch v·ª• ML t·∫°i Microsoft
. M·ªôt v√†i trong s·ªë ƒë√≥ ƒëang t√≠ch h·ª£p v√†o s·∫£n ph·∫©m l√µi c·ªßa
Window
v√† m·ªôt v√†i s·∫£n ph·∫©m cho
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
Ch√∫ng t√¥i t√≠ch h·ª£p th∆∞ vi·ªán
FastAPI
ƒë·ªÉ sinh ra m·ªôt
REST
server, n√≥ c√≥ th·ªÉ ƒë∆∞·ª£c truy v·∫•n ƒë·ªÉ thu ƒë∆∞·ª£c nh·ªØng
d·ª± ƒëo√°n
.
[b·ªüi Ludwid] "
Piero Molino, Yaroslav Dudin, v√† Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
vui m·ª´ng th√¥ng b√°o vi·ªác ph√°t h√†nh framework m√£ ngu·ªìn m·ªü c·ªßa ch√∫ng t√¥i cho
qu·∫£n l√≠ kh·ªßng ho·∫£ng
t·∫≠p trung:
Dispatch
! [x√¢y d·ª±ng v·ªõi
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
T√¥i v√¥ c√πng h√†o h·ª©ng v·ªÅ
FastAPI
. N√≥ r·∫•t th√∫ v·ªã
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
Th√†nh th·∫≠t, nh·ªØng g√¨ b·∫°n ƒë√£ x√¢y d·ª±ng nh√¨n si√™u ch·∫Øc ch·∫Øn v√† b√≥ng b·∫©y. Theo nhi·ªÅu c√°ch, n√≥ l√† nh·ªØng g√¨ t√¥i ƒë√£ mu·ªën Hug tr·ªü th√†nh - th·∫≠t s·ª± truy·ªÅn c·∫£m h·ª©ng ƒë·ªÉ th·∫•y ai ƒë√≥ x√¢y d·ª±ng n√≥.
"
Timothy Crosley - ng∆∞·ªùi t·∫°o ra
Hug
(ref)
"
N·∫øu b·∫°n ƒëang t√¨m ki·∫øm m·ªôt
framework hi·ªán ƒë·∫°i
ƒë·ªÉ x√¢y d·ª±ng m·ªôt REST APIs, th·ª≠ xem x√©t
FastAPI
[...] N√≥ nhanh, d·ªÖ d√πng v√† d·ªÖ h·ªçc [...]
"
"
Ch√∫ng t√¥i ƒë√£ chuy·ªÉn qua
FastAPI cho **APIs
c·ªßa ch√∫ng t√¥i [...] T√¥i nghƒ© b·∫°n s·∫Ω th√≠ch n√≥ [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
Ines Montani - Matthew Honnibal -
nh√† s√°ng l·∫≠p
Explosion AI
- ng∆∞·ªùi t·∫°o ra
spaCy
(ref)
-
(ref)
"
N·∫øu ai ƒë√≥ ƒëang t√¨m c√°ch x√¢y d·ª±ng s·∫£n ph·∫©m API b·∫±ng Python, t√¥i s·∫Ω ƒë·ªÅ xu·∫•t
FastAPI
. N√≥
ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·∫πp ƒë·∫Ω
,
s·ª≠ d·ª•ng ƒë∆°n gi·∫£n
v√†
c√≥ kh·∫£ nƒÉng m·ªü r·ªông cao
, n√≥ ƒë√£ tr·ªü th√†nh m·ªôt
th√†nh ph·∫ßn quan tr·ªçng
trong chi·∫øn l∆∞·ª£c ph√°t tri·ªÉn API c·ªßa ch√∫ng t√¥i v√† ƒëang th√∫c ƒë·∫©y nhi·ªÅu d·ªãch v·ª• v√† m·∫£ng t·ª± ƒë·ªông h√≥a nh∆∞ K·ªπ s∆∞ TAC ·∫£o c·ªßa ch√∫ng t√¥i.
"
Deon Pillsbury -
Cisco
(ref)
Typer
, giao di·ªán d√≤ng l·ªánh c·ªßa FastAPI
N·∫øu b·∫°n ƒëang x√¢y d·ª±ng m·ªôt
CLI
- ·ª©ng d·ª•ng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong giao di·ªán d√≤ng l·ªánh, xem v·ªÅ
Typer
.
Typer
l√† m·ªôt ng∆∞·ªùi anh em c·ªßa FastAPI. V√† n√≥ ƒë∆∞·ª£c d·ª± ƒë·ªãnh tr·ªü th√†nh
giao di·ªán d√≤ng l·ªánh cho FastAPI
. ‚å®Ô∏è üöÄ
Y√™u c·∫ßu
FastAPI ƒë·ª©ng tr√™n vai nh·ªØng ng∆∞·ªùi kh·ªïng l·ªì:
Starlette
cho ph·∫ßn web.
Pydantic
cho ph·∫ßn data.
C√†i ƒë·∫∑t
fast ‚Üí
pip install fastapi
restart ‚Üª
B·∫°n c≈©ng s·∫Ω c·∫ßn m·ªôt ASGI server cho production nh∆∞
Uvicorn
ho·∫∑c
Hypercorn
.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
V√≠ d·ª•
Kh·ªüi t·∫°o
T·∫°o m·ªôt t·ªáp tin
main.py
nh∆∞ sau:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Ho·∫∑c s·ª≠ d·ª•ng
async def
...
N·∫øu code c·ªßa b·∫°n s·ª≠ d·ª•ng
async
/
await
, h√£y s·ª≠ d·ª•ng
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
L∆∞u √Ω
:
N·∫øu b·∫°n kh√¥ng bi·∫øt, xem ph·∫ßn
"In a hurry?"
v·ªÅ
async
v√†
await
trong t√†i li·ªáu n√†y
.
Ch·∫°y ·ª©ng d·ª•ng
Ch·∫°y server nh∆∞ sau:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
V·ªÅ l·ªánh
uvicorn main:app --reload
...
L·ªánh
uvicorn main:app
tham chi·∫øu t·ªõi nh·ªØng th√†nh ph·∫ßn sau:
main
: t·ªáp tin
main.py
(m·ªôt Python "module").
app
: object ƒë∆∞·ª£c t·∫°o trong t·ªáp tin
main.py
t·∫°i d√≤ng
app = FastAPI()
.
--reload
: ch·∫°y l·∫°i server sau khi code thay ƒë·ªïi. Ch·ªâ s·ª≠ d·ª•ng trong qu√° tr√¨nh ph√°t tri·ªÉn.
Ki·ªÉm tra
M·ªü tr√¨nh duy·ªát c·ªßa b·∫°n t·∫°i
http://127.0.0.1:8000/items/5?q=somequery
.
B·∫°n s·∫Ω th·∫•y m·ªôt JSON response:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
B·∫°n ƒë√£ s·∫µn s√†ng ƒë·ªÉ t·∫°o m·ªôt API nh∆∞ sau:
Nh·∫≠n HTTP request v·ªõi
ƒë∆∞·ªùng d·∫´n
/
v√†
/items/{item_id}
.
C·∫£ hai
ƒë∆∞·ªùng d·∫´n
s·ª≠ d·ª•ng
to√°n t·ª≠
GET
(c≈©ng ƒë∆∞∆°c bi·∫øt ƒë·∫øn l√†
ph∆∞∆°ng th·ª©c
HTTP).
ƒê∆∞·ªùng d·∫´n
/items/{item_id}
c√≥ m·ªôt
tham s·ªë ƒë∆∞·ªùng d·∫´n
item_id
, n√≥ l√† m·ªôt tham s·ªë ki·ªÉu
int
.
ƒê∆∞·ªùng d·∫´n
/items/{item_id}
c√≥ m·ªôt
tham s·ªë query string
q
, n√≥ l√† m·ªôt tham s·ªë t√πy ch·ªçn ki·ªÉu
str
.
T√†i li·ªáu t∆∞∆°ng t√°c API
Truy c·∫≠p
http://127.0.0.1:8000/docs
.
B·∫°n s·∫Ω th·∫•y t√†i li·ªáu t∆∞∆°ng t√°c API ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông (cung c·∫•p b·ªüi
Swagger UI
):
T√†i li·ªáu API thay th·∫ø
V√† b√¢y gi·ªù, h√£y truy c·∫≠p t·ªõi
http://127.0.0.1:8000/redoc
.
B·∫°n s·∫Ω th·∫•y t√†i li·ªáu ƒë∆∞·ª£c thay th·∫ø (cung c·∫•p b·ªüi
ReDoc
):
N√¢ng c·∫•p v√≠ d·ª•
B√¢y gi·ªù s·ª≠a t·ªáp tin
main.py
ƒë·ªÉ nh·∫≠n body t·ª´ m·ªôt request
PUT
.
ƒê·ªãnh nghƒ©a c·ªßa body s·ª≠ d·ª•ng ki·ªÉu d·ªØ li·ªáu chu·∫©n c·ªßa Python, c·∫£m ∆°n Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Server n√™n t·ª± ƒë·ªông ch·∫°y l·∫°i (b·ªüi v√¨ b·∫°n ƒë√£ th√™m
--reload
trong l·ªánh
uvicorn
·ªü tr√™n).
N√¢ng c·∫•p t√†i li·ªáu API
B√¢y gi·ªù truy c·∫≠p t·ªõi
http://127.0.0.1:8000/docs
.
T√†i li·ªáu API s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông c·∫≠p nh·∫≠t, bao g·ªìm body m·ªõi:
Click v√†o n√∫t "Try it out", n√≥ cho ph√©p b·∫°n ƒëi·ªÅn nh·ªØng tham s·ªë v√† t∆∞∆°ng t√°c tr·ª±c ti·∫øp v·ªõi API:
Sau khi click v√†o n√∫t "Execute", giao di·ªán ng∆∞·ªùi d√πng s·∫Ω giao ti·∫øp v·ªõi API c·ªßa b·∫°n bao g·ªìm: g·ª≠i c√°c tham s·ªë, l·∫•y k·∫øt qu·∫£ v√† hi·ªÉn th·ªã ch√∫ng tr√™n m√†n h√¨nh:
N√¢ng c·∫•p t√†i li·ªáu API thay th·∫ø
V√† b√¢y gi·ªù truy c·∫≠p t·ªõi
http://127.0.0.1:8000/redoc
.
T√†i li·ªáu thay th·∫ø c≈©ng s·∫Ω ph·∫£n √°nh tham s·ªë v√† body m·ªõi:
T√≥m l·∫°i
B·∫°n khai b√°o
m·ªôt l·∫ßn
ki·ªÉu d·ªØ li·ªáu c·ªßa c√°c tham s·ªë, body, etc l√† c√°c tham s·ªë c·ªßa h√†m s·ªë.
B·∫°n ƒë·ªãnh nghƒ©a b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c ki·ªÉu d·ªØ li·ªáu chu·∫©n c·ªßa Python.
B·∫°n kh√¥ng ph·∫£i h·ªçc m·ªôt c√∫ ph√°p m·ªõi, c√°c ph∆∞∆°ng th·ª©c v√† class c·ªßa m·ªôt th∆∞ vi·ªán c·ª• th·ªÉ n√†o.
Ch·ªâ c·∫ßn s·ª≠ d·ª•ng c√°c chu·∫©n c·ªßa
Python
.
V√≠ d·ª•, v·ªõi m·ªôt tham s·ªë ki·ªÉu
int
:
item_id
:
int
ho·∫∑c v·ªõi m·ªôt model
Item
ph·ª©c t·∫°p h∆°n:
item
:
Item
...v√† v·ªõi ƒë·ªãnh nghƒ©a ƒë∆°n gi·∫£n ƒë√≥, b·∫°n c√≥ ƒë∆∞·ª£c:
S·ª± h·ªó tr·ª£ t·ª´ c√°c tr√¨nh so·∫°n th·∫£o, bao g·ªìm:
Completion.
Ki·ªÉm tra ki·ªÉu d·ªØ li·ªáu.
Ki·ªÉm tra ki·ªÉu d·ªØ li·ªáu:
T·ª± ƒë·ªông sinh l·ªói r√µ r√†ng khi d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá .
Ki·ªÉm tra JSON l·ªìng nhau .
Chuy·ªÉn ƒë·ªïi
d·ªØ li·ªáu ƒë·∫ßu v√†o: t·ªõi t·ª´ network sang d·ªØ li·ªáu ki·ªÉu Python. ƒê·ªçc t·ª´:
JSON.
C√°c tham s·ªë trong ƒë∆∞·ªùng d·∫´n.
C√°c tham s·ªë trong query string.
Cookies.
Headers.
Forms.
Files.
Chuy·ªÉn ƒë·ªïi
d·ªØ li·ªáu ƒë·∫ßu ra: chuy·ªÉn ƒë·ªïi t·ª´ ki·ªÉu d·ªØ li·ªáu Python sang d·ªØ li·ªáu network (nh∆∞ JSON):
Chuy·ªÉn ƒë·ªïi ki·ªÉu d·ªØ li·ªáu Python (
str
,
int
,
float
,
bool
,
list
,...).
datetime
objects.
UUID
objects.
Database models.
...v√† nhi·ªÅu h∆°n th·∫ø.
T·ª± ƒë·ªông t·∫°o t√†i li·ªáu t∆∞∆°ng t√°c API, bao g·ªìm 2 giao di·ªán ng∆∞·ªùi d√πng:
Swagger UI.
ReDoc.
Quay tr·ªü l·∫°i v√≠ d·ª• tr∆∞·ªõc,
FastAPI
s·∫Ω th·ª±c hi·ªán:
Ki·ªÉm tra xem c√≥ m·ªôt
item_id
trong ƒë∆∞·ªùng d·∫´n v·ªõi c√°c request
GET
v√†
PUT
kh√¥ng?
Ki·ªÉm tra xem
item_id
c√≥ ph·∫£i l√† ki·ªÉu
int
trong c√°c request
GET
v√†
PUT
kh√¥ng?
N·∫øu kh√¥ng, client s·∫Ω th·∫•y m·ªôt l·ªói r√µ r√†ng v√† h·ªØu √≠ch.
Ki·ªÉm tra xem n·∫øu c√≥ m·ªôt tham s·ªë
q
trong query string (v√≠ d·ª• nh∆∞
http://127.0.0.1:8000/items/foo?q=somequery
) cho request
GET
.
Tham s·ªë
q
ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a
= None
, n√≥ l√† t√πy ch·ªçn.
N·∫øu kh√¥ng ph·∫£i
None
, n√≥ l√† b·∫Øt bu·ªôc (nh∆∞ body trong tr∆∞·ªùng h·ª£p c·ªßa
PUT
).
V·ªõi request
PUT
t·ªõi
/items/{item_id}
, ƒë·ªçc body nh∆∞ JSON:
Ki·ªÉm tra xem n√≥ c√≥ m·ªôt thu·ªôc t√≠nh b·∫Øt bu·ªôc ki·ªÉu
str
l√†
name
kh√¥ng?
Ki·ªÉm tra xem n√≥ c√≥ m·ªôt thu·ªôc t√≠nh b·∫Øt bu·ªôc ki·ªÉu
float
l√†
price
kh√¥ng?
Ki·ªÉm tra xem n√≥ c√≥ m·ªôt thu·ªôc t√≠nh t√πy ch·ªçn l√†
is_offer
kh√¥ng? N·∫øu c√≥, n√≥ ph·∫£i c√≥ ki·ªÉu
bool
.
T·∫•t c·∫£ nh·ªØng ki·ªÉm tra n√†y c≈©ng ƒë∆∞·ª£c √°p d·ª•ng v·ªõi c√°c JSON l·ªìng nhau.
Chuy·ªÉn ƒë·ªïi t·ª± ƒë·ªông c√°c JSON object ƒë·∫øn v√† JSON object ƒëi.
T√†i li·ªáu h√≥a m·ªçi th·ª© v·ªõi OpenAPI, t√†i li·ªáu ƒë√≥ c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi:
C√°c h·ªá th·ªëng t√†i li·ªáu c√≥ th·ªÉ t∆∞∆°ng t√°c.
H·ªá th·ªëng sinh code t·ª± ƒë·ªông, cho nhi·ªÅu ng√¥n ng·ªØ l·∫≠p tr√¨nh.
Cung c·∫•p tr·ª±c ti·∫øp 2 giao di·ªán web cho t√†i li·ªáu t∆∞∆°ng t√°c
Ch√∫ng t√¥i ch·ªâ tr√¨nh b√†y nh·ªØng th·ª© c∆° b·∫£n b√™n ngo√†i, nh∆∞ng b·∫°n ƒë√£ hi·ªÉu c√°ch th·ª©c ho·∫°t ƒë·ªông c·ªßa n√≥.
Th·ª≠ thay ƒë·ªïi d√≤ng n√†y:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...t·ª´:
...
"item_name"
:
item
.
name
...
...sang:
...
"item_price"
:
item
.
price
...
...v√† th·∫•y tr√¨nh so·∫°n th·∫£o c·ªßa b·∫°n nh·∫≠n bi·∫øt ki·ªÉu d·ªØ li·ªáu v√† g·ª£i √Ω ho√†n thi·ªán c√°c thu·ªôc t√≠nh.
V√≠ d·ª• ho√†n ch·ªânh bao g·ªìm nhi·ªÅu t√≠nh nƒÉng h∆°n, xem
Tutorial - User Guide
.
C·∫£nh b√°o ti·∫øt l·ªó
: Tutorial - User Guide:
ƒê·ªãnh nghƒ©a
tham s·ªë
t·ª´ c√°c ngu·ªìn kh√°c nhau nh∆∞:
headers
,
cookies
,
form fields
v√†
files
.
C√°ch thi·∫øt l·∫≠p
c√°c r√†ng bu·ªôc cho validation
nh∆∞
maximum_length
ho·∫∑c
regex
.
M·ªôt h·ªá th·ªëng **
Dependency Injection
v√¥ c√πng m·∫°nh m·∫Ω v√† d·ªÖ d√†ng s·ª≠ d·ª•ng.
B·∫£o m·∫≠t v√† x√°c th·ª±c, h·ªó tr·ª£
OAuth2
(v·ªõi
JWT tokens
) v√†
HTTP Basic
.
Nh·ªØng kƒ© thu·∫≠t n√¢ng cao h∆°n (nh∆∞ng t∆∞∆°ng ƒë·ªëi d·ªÖ) ƒë·ªÉ ƒë·ªãnh nghƒ©a
JSON models l·ªìng nhau
(c·∫£m ∆°n Pydantic).
T√≠ch h·ª£p
GraphQL
v·ªõi
Strawberry
v√† c√°c th∆∞ vi·ªán kh√°c.
Nhi·ªÅu t√≠nh nƒÉng m·ªü r·ªông (c·∫£m ∆°n Starlette) nh∆∞:
WebSockets
ki·ªÉm th·ª≠ v√¥ c√πng d·ªÖ d√†ng d·ª±a tr√™n HTTPX v√†
pytest
CORS
Cookie Sessions
...v√† nhi·ªÅu h∆°n th·∫ø.
Hi·ªáu nƒÉng
Independent TechEmpower benchmarks cho th·∫•y c√°c ·ª©ng d·ª•ng
FastAPI
ch·∫°y d∆∞·ªõi Uvicorn l√†
m·ªôt trong nh·ªØng Python framework nhanh nh·∫•t
, ch·ªâ ƒë·ª©ng sau Starlette v√† Uvicorn (ƒë∆∞·ª£c s·ª≠ d·ª•ng b√™n trong FastAPI). (*)
ƒê·ªÉ hi·ªÉu r√µ h∆°n, xem ph·∫ßn
Benchmarks
.
C√°c dependency t√πy ch·ªçn
S·ª≠ d·ª•ng b·ªüi Pydantic:
email-validator
- cho email validation.
S·ª≠ d·ª•ng Starlette:
httpx
- B·∫Øt bu·ªôc n·∫øu b·∫°n mu·ªën s·ª≠ d·ª•ng
TestClient
.
jinja2
- B·∫Øt bu·ªôc n·∫øu b·∫°n mu·ªën s·ª≠ d·ª•ng c·∫•u h√¨nh template engine m·∫∑c ƒë·ªãnh.
python-multipart
- B·∫Øt bu·ªôc n·∫øu b·∫°n mu·ªën h·ªó tr·ª£
"parsing"
, form v·ªõi
request.form()
.
itsdangerous
- B·∫Øt bu·ªôc ƒë·ªÉ h·ªó tr·ª£
SessionMiddleware
.
pyyaml
- B·∫Øt bu·ªôc ƒë·ªÉ h·ªó tr·ª£
SchemaGenerator
cho Starlette (b·∫°n c√≥ th·ªÉ kh√¥ng c·∫ßn n√≥ trong FastAPI).
S·ª≠ d·ª•ng b·ªüi FastAPI / Starlette:
uvicorn
- Server ƒë·ªÉ ch·∫°y ·ª©ng d·ª•ng c·ªßa b·∫°n.
orjson
- B·∫Øt bu·ªôc n·∫øu b·∫°n mu·ªën s·ª≠ d·ª•ng
ORJSONResponse
.
ujson
- B·∫Øt bu·ªôc n·∫øu b·∫°n mu·ªën s·ª≠ d·ª•ng
UJSONResponse
.
B·∫°n c√≥ th·ªÉ c√†i ƒë·∫∑t t·∫•t c·∫£ nh·ªØng dependency tr√™n v·ªõi
pip install "fastapi[all]"
.
Gi·∫•y ph√©p
D·ª± √°n n√†y ƒë∆∞·ª£c c·∫•p ph√©p d∆∞·ªõi nh·ªØng ƒëi·ªÅu l·ªá c·ªßa gi·∫•y ph√©p MIT.

## 159_VIRTUAL_ENVIRONMENTS
Virtual Environments¬∂
---

Virtual Environments
When you work in Python projects you probably should use a
virtual environment
(or a similar mechanism) to isolate the packages you install for each project.
Info
If you already know about virtual environments, how to create them and use them, you might want to skip this section. ü§ì
Tip
A
virtual environment
is different than an
environment variable
.
An
environment variable
is a variable in the system that can be used by programs.
A
virtual environment
is a directory with some files in it.
Info
This page will teach you how to use
virtual environments
and how they work.
If you are ready to adopt a
tool that manages everything
for you (including installing Python), try
uv
.
Create a Project
First, create a directory for your project.
What I normally do is that I create a directory named
code
inside my home/user directory.
And inside of that I create one directory per project.
fast ‚Üí
üí¨ Go to the home directory
cd
üí¨ Create a directory for all your code projects
mkdir code
üí¨ Enter into that code directory
cd code
üí¨ Create a directory for this project
mkdir awesome-project
üí¨ Enter into that project directory
cd awesome-project
restart ‚Üª
Create a Virtual Environment
When you start working on a Python project
for the first time
, create a virtual environment
inside your project
.
Tip
You only need to do this
once per project
, not every time you work.
venv
uv
To create a virtual environment, you can use the
venv
module that comes with Python.
fast ‚Üí
python -m venv .venv
restart ‚Üª
What that command means
python
: use the program called
python
-m
: call a module as a script, we'll tell it which module next
venv
: use the module called
venv
that normally comes installed with Python
.venv
: create the virtual environment in the new directory
.venv
If you have
uv
installed, you can use it to create a virtual environment.
fast ‚Üí
uv venv
restart ‚Üª
Tip
By default,
uv
will create a virtual environment in a directory called
.venv
.
But you could customize it passing an additional argument with the directory name.
That command creates a new virtual environment in a directory called
.venv
.
.venv
or other name
You could create the virtual environment in a different directory, but there's a convention of calling it
.venv
.
Activate the Virtual Environment
Activate the new virtual environment so that any Python command you run or package you install uses it.
Tip
Do this
every time
you start a
new terminal session
to work on the project.
Linux, macOS
Windows PowerShell
Windows Bash
fast ‚Üí
source .venv/bin/activate
restart ‚Üª
fast ‚Üí
.venv\Scripts\Activate.ps1
Or if you use Bash for Windows (e.g.
Git Bash
):
fast ‚Üí
source .venv/Scripts/activate
Tip
Every time you install a
new package
in that environment,
activate
the environment again.
This makes sure that if you use a
terminal (
CLI
) program
installed by that package, you use the one from your virtual environment and not any other that could be installed globally, probably with a different version than what you need.
Check the Virtual Environment is Active
Check that the virtual environment is active (the previous command worked).
Tip
This is
optional
, but it's a good way to
check
that everything is working as expected and you are using the virtual environment you intended.
Linux, macOS, Windows Bash
Windows PowerShell
fast ‚Üí
which python
/home/user/code/awesome-project/.venv/bin/python
restart ‚Üª
If it shows the
python
binary at
.venv/bin/python
, inside of your project (in this case
awesome-project
), then it worked. üéâ
fast ‚Üí
Get-Command python
C:\Users\user\code\awesome-project\.venv\Scripts\python
restart ‚Üª
If it shows the
python
binary at
.venv\Scripts\python
, inside of your project (in this case
awesome-project
), then it worked. üéâ
Upgrade
pip
Tip
If you use
uv
you would use it to install things instead of
pip
, so you don't need to upgrade
pip
. üòé
If you are using
pip
to install packages (it comes by default with Python), you should
upgrade
it to the latest version.
Many exotic errors while installing a package are solved by just upgrading
pip
first.
Tip
You would normally do this
once
, right after you create the virtual environment.
Make sure the virtual environment is active (with the command above) and then run:
fast ‚Üí
python -m pip install --upgrade pip
restart ‚Üª
Add
.gitignore
If you are using
Git
(you should), add a
.gitignore
file to exclude everything in your
.venv
from Git.
Tip
If you used
uv
to create the virtual environment, it already did this for you, you can skip this step. üòé
Tip
Do this
once
, right after you create the virtual environment.
fast ‚Üí
echo "*" > .venv/.gitignore
restart ‚Üª
What that command means
echo "*"
: will "print" the text
*
in the terminal (the next part changes that a bit)
>
: anything printed to the terminal by the command to the left of
>
should not be printed but instead written to the file that goes to the right of
>
.gitignore
: the name of the file where the text should be written
And
*
for Git means "everything". So, it will ignore everything in the
.venv
directory.
That command will create a file
.gitignore
with the content:
*
Install Packages
After activating the environment, you can install packages in it.
Tip
Do this
once
when installing or upgrading the packages your project needs.
If you need to upgrade a version or add a new package you would
do this again
.
Install Packages Directly
If you're in a hurry and don't want to use a file to declare your project's package requirements, you can install them directly.
Tip
It's a (very) good idea to put the packages and versions your program needs in a file (for example
requirements.txt
or
pyproject.toml
).
pip
uv
fast ‚Üí
pip install "fastapi[standard]"
restart ‚Üª
If you have
uv
:
fast ‚Üí
uv pip install "fastapi[stand
Install from
requirements.txt
If you have a
requirements.txt
, you can now use it to install its packages.
pip
uv
fast ‚Üí
pip install -r requirements.txt
restart ‚Üª
If you have
uv
:
fast ‚Üí
uv pip install -r requirement
requirements.txt
A
requirements.txt
with some packages could look like:
fastapi[standard]==0.113.0
pydantic==2.8.0
Run Your Program
After you activated the virtual environment, you can run your program, and it will use the Python inside of your virtual environment with the packages you installed there.
fast ‚Üí
python main.py
Hello World
restart ‚Üª
Configure Your Editor
You would probably use an editor, make sure you configure it to use the same virtual environment you created (it will probably autodetect it) so that you can get autocompletion and inline errors.
For example:
VS Code
PyCharm
Tip
You normally have to do this only
once
, when you create the virtual environment.
Deactivate the Virtual Environment
Once you are done working on your project you can
deactivate
the virtual environment.
fast ‚Üí
deactivate
restart ‚Üª
This way, when you run
python
it won't try to run it from that virtual environment with the packages installed there.
Ready to Work
Now you're ready to start working on your project.
Tip
Do you want to understand what's all that above?
Continue reading. üëáü§ì
Why Virtual Environments
To work with FastAPI you need to install
Python
.
After that, you would need to
install
FastAPI and any other
packages
you want to use.
To install packages you would normally use the
pip
command that comes with Python (or similar alternatives).
Nevertheless, if you just use
pip
directly, the packages would be installed in your
global Python environment
(the global installation of Python).
The Problem
So, what's the problem with installing packages in the global Python environment?
At some point, you will probably end up writing many different programs that depend on
different packages
. And some of these projects you work on will depend on
different versions
of the same package. üò±
For example, you could create a project called
philosophers-stone
, this program depends on another package called
harry
, using the version
1
. So, you need to install
harry
.
Then, at some point later, you create another project called
prisoner-of-azkaban
, and this project also depends on
harry
, but this project needs
harry
version
3
.
But now the problem is, if you install the packages globally (in the global environment) instead of in a local
virtual environment
, you will have to choose which version of
harry
to install.
If you want to run
philosophers-stone
you will need to first install
harry
version
1
, for example with:
fast ‚Üí
pip install "harry==1"
restart ‚Üª
And then you would end up with
harry
version
1
installed in your global Python environment.
But then if you want to run
prisoner-of-azkaban
, you will need to uninstall
harry
version
1
and install
harry
version
3
(or just installing version
3
would automatically uninstall version
1
).
fast ‚Üí
pip install "harry==3"
restart ‚Üª
And then you would end up with
harry
version
3
installed in your global Python environment.
And if you try to run
philosophers-stone
again, there's a chance it would
not work
because it needs
harry
version
1
.
Tip
It's very common in Python packages to try the best to
avoid breaking changes
in
new versions
, but it's better to be safe, and install newer versions intentionally and when you can run the tests to check everything is working correctly.
Now, imagine that with
many
other
packages
that all your
projects depend on
. That's very difficult to manage. And you would probably end up running some projects with some
incompatible versions
of the packages, and not knowing why something isn't working.
Also, depending on your operating system (e.g. Linux, Windows, macOS), it could have come with Python already installed. And in that case it probably had some packages pre-installed with some specific versions
needed by your system
. If you install packages in the global Python environment, you could end up
breaking
some of the programs that came with your operating system.
Where are Packages Installed
When you install Python, it creates some directories with some files in your computer.
Some of these directories are the ones in charge of having all the packages you install.
When you run:
fast ‚Üí
üí¨ Don't run this now, it's just an example ü§ì
pip install "fastapi[standard]"
restart ‚Üª
That will download a compressed file with the FastAPI code, normally from
PyPI
.
It will also
download
files for other packages that FastAPI depends on.
Then it will
extract
all those files and put them in a directory in your computer.
By default, it will put those files downloaded and extracted in the directory that comes with your Python installation, that's the
global environment
.
What are Virtual Environments
The solution to the problems of having all the packages in the global environment is to use a
virtual environment for each project
you work on.
A virtual environment is a
directory
, very similar to the global one, where you can install the packages for a project.
This way, each project will have its own virtual environment (
.venv
directory) with its own packages.
What Does Activating a Virtual Environment Mean
When you activate a virtual environment, for example with:
Linux, macOS
Windows PowerShell
Windows Bash
fast ‚Üí
source .venv/bin/activate
restart ‚Üª
fast ‚Üí
.venv\Scripts\Activate.ps1
Or if you use Bash for Windows (e.g.
Git Bash
):
fast ‚Üí
source .venv/Scripts/activate
That command will create or modify some
environment variables
that will be available for the next commands.
One of those variables is the
PATH
variable.
Tip
You can learn more about the
PATH
environment variable in the
Environment Variables
section.
Activating a virtual environment adds its path
.venv/bin
(on Linux and macOS) or
.venv\Scripts
(on Windows) to the
PATH
environment variable.
Let's say that before activating the environment, the
PATH
variable looked like this:
Linux, macOS
Windows
/usr/bin:/bin:/usr/sbin:/sbin
That means that the system would look for programs in:
/usr/bin
/bin
/usr/sbin
/sbin
C:\Windows\System32
That means that the system would look for programs in:
C:\Windows\System32
After activating the virtual environment, the
PATH
variable would look something like this:
Linux, macOS
Windows
/home/user/code/awesome-project/.venv/bin:/usr/bin:/bin:/usr/sbin:/sbin
That means that the system will now start looking first for programs in:
/home/user/code/awesome-project/.venv/bin
before looking in the other directories.
So, when you type
python
in the terminal, the system will find the Python program in
/home/user/code/awesome-project/.venv/bin/python
and use that one.
C:\Users\user\code\awesome-project\.venv\Scripts;C:\Windows\System32
That means that the system will now start looking first for programs in:
C:\Users\user\code\awesome-project\.venv\Scripts
before looking in the other directories.
So, when you type
python
in the terminal, the system will find the Python program in
C:\Users\user\code\awesome-project\.venv\Scripts\python
and use that one.
An important detail is that it will put the virtual environment path at the
beginning
of the
PATH
variable. The system will find it
before
finding any other Python available. This way, when you run
python
, it will use the Python
from the virtual environment
instead of any other
python
(for example, a
python
from a global environment).
Activating a virtual environment also changes a couple of other things, but this is one of the most important things it does.
Checking a Virtual Environment
When you check if a virtual environment is active, for example with:
Linux, macOS, Windows Bash
Windows PowerShell
fast ‚Üí
which python
/home/user/code/awesome-project/.venv/bin/python
restart ‚Üª
fast ‚Üí
Get-Command python
C:\Users\user\code\awesome-project\.venv\Scripts\python
restart ‚Üª
That means that the
python
program that will be used is the one
in the virtual environment
.
You use
which
in Linux and macOS and
Get-Command
in Windows PowerShell.
The way that command works is that it will go and check in the
PATH
environment variable, going through
each path in order
, looking for the program called
python
. Once it finds it, it will
show you the path
to that program.
The most important part is that when you call
python
, that is the exact "
python
" that will be executed.
So, you can confirm if you are in the correct virtual environment.
Tip
It's easy to activate one virtual environment, get one Python, and then
go to another project
.
And the second project
wouldn't work
because you are using the
incorrect Python
, from a virtual environment for another project.
It's useful being able to check what
python
is being used. ü§ì
Why Deactivate a Virtual Environment
For example, you could be working on a project
philosophers-stone
,
activate that virtual environment
, install packages and work with that environment.
And then you want to work on
another project
prisoner-of-azkaban
.
You go to that project:
fast ‚Üí
cd ~/code/prisoner-of-azkaban
restart ‚Üª
If you don't deactivate the virtual environment for
philosophers-stone
, when you run
python
in the terminal, it will try to use the Python from
philosophers-stone
.
fast ‚Üí
cd ~/code/prisoner-of-azkaban
python main.py
üí¨ Error importing sirius, it's not installed üò±
Traceback (most recent call last):
File "main.py", line 1, in
import sirius
restart ‚Üª
But if you deactivate the virtual environment and activate the new one for
prisoner-of-askaban
then when you run
python
it will use the Python from the virtual environment in
prisoner-of-azkaban
.
fast ‚Üí
cd ~/code/prisoner-of-azkaban
üí¨ You don't need to be in the old directory to deactivate, you can do it wherever you are, even after going to the other project üòé
deactivate
üí¨ Activate the virtual environment in prisoner-of-azkaban/.venv üöÄ
source .venv/bin/activate
üí¨ Now when you run python, it will find the package sirius installed in this virtual environment ‚ú®
python main.py
I solemnly swear üê∫
restart ‚Üª
Alternatives
This is a simple guide to get you started and teach you how everything works
underneath
.
There are many
alternatives
to managing virtual environments, package dependencies (requirements), projects.
Once you are ready and want to use a tool to
manage the entire project
, packages dependencies, virtual environments, etc. I would suggest you try
uv
.
uv
can do a lot of things, it can:
Install Python
for you, including different versions
Manage the
virtual environment
for your projects
Install
packages
Manage package
dependencies and versions
for your project
Make sure you have an
exact
set of packages and versions to install, including their dependencies, so that you can be sure that you can run your project in production exactly the same as in your computer while developing, this is called
locking
And many other things
Conclusion
If you read and understood all this, now
you know much more
about virtual environments than many developers out there. ü§ì
Knowing these details will most probably be useful in a future time when you are debugging something that seems complex, but you will know
how it all works underneath
. üòé

## 160_YO
FastAPI¬∂
---

FastAPI
√ål√†n√† w·∫πÃÅ·∫πÃÅb√π FastAPI, i·π£·∫πÃÅ g√≠ga, √≥ r·ªçr√πn l√°ti k·ªçÃÄ, o y√°ra l√°ti k√≥√≤d√π, √≥ s√¨ ·π£et√°n f√∫n i·π£el·ªçp·ªç n√≠ l√≠lo
√Äk·ªçs√≠l·∫πÃÄ
:
https://fastapi.tiangolo.com
Orisun K√≥√≤d√π
:
https://github.com/fastapi/fastapi
FastAPI j·∫πÃÅ √¨gb√†l√≥d√©, t√≠ √≥ y√°ra (i·π£·∫π-giga), √¨l√†n√† w·∫πÃÅ·∫πÃÅb√π f√∫n kik·ªç √†w·ªçn API p·∫πÃÄl√∫ Python √®y√≠ t√≠ √≥ da lori √†w·ªçn √¨t·ªçÃÅkas√≠ √†m√¨ ir√∫f·∫πÃÅ Python.
√Äw·ªçn ·∫πya p√†t√†k√¨ ni:
√ì y√°ra
: I·π£·∫π t√≠ √≥ ga p√∫p·ªçÃÄ, t√≠ √≥ wa ni ibamu p·∫πÃÄl√∫
NodeJS
√†ti
Go
(·ªçp·∫π si Starlette √†ti Pydantic).
·ªåkan n√≠n√∫ √†w·ªçn √¨l√†n√† Python ti o y√°ra j√πl·ªç ti o wa
.
√ì y√°ra l√°ti k√≥√≤d√π
: O mu iyara p·ªç si l√°ti k·ªç √†w·ªçn ·∫πya tuntun k√≥√≤d√π nipas·∫π "Igba √¨d√° ·ªçg·ªçÃÅr√πn-√∫n" (i.e. 200%) si "·ªçÃÄ·ªçÃÅd√∫r√∫n √¨d√° ·ªçg·ªçÃÅr√πn-√∫n" (i.e. 300%).
√Ä√¨t·ªçÃÅ k√©ker√©
: O n din a·π£i·π£e ku bi ·ªçgbon √¨d√° ·ªçg·ªçÃÅr√πn-√∫n (i.e. 40%) ti eda eniyan (o·π£i·π£·∫π k√≥√≤d√π) fa. *
·ªågb·ªçÃÅn √†ti √¨m·ªçÃÄ
: Atil·∫πyin olootu nla.
√åpar√≠
nibi gbogbo. √Äk√≥k√≤ d√≠·∫πÃÄ nipa w√≠w√° ibi t√≠ √¨·π£√≤ro k√≥√≤d√π w√†.
Ir·ªçrun
: A k·ªç k√≠ √≥ le r·ªçrun l√°ti lo √†ti l√°ti k·ªç ·∫πk·ªç n√≠n√∫ r√®. √ì m√°a f√∫n ·ªç n√≠ √†k√≥k√≤ d√≠·∫πÃÄ l√°tƒ± ka √†k·ªçs√≠l·∫π.
√ì k√∫kur√∫ n√≠ kik·ªç
: √ì d√≠n √†t√∫nk·ªç √†ti √†t√∫nt√≤ k√≥√≤d√π k√π. √åk√©de √†·π£√†y√†n k·ªçÃÄ·ªçÃÄkan n√≠n√∫ r·∫πÃÄ n√≠ ·ªçÃÄp·ªçÃÄl·ªçp·ªçÃÄ √†w·ªçn √¨l√≤. O ·π£e iranl·ªçw·ªç l√°ti m√° ·π£e n√≠ ·ªçÃÄp·ªçÃÄl·ªçp·ªçÃÄ √†·π£√¨·π£e.
√ì l√°gb√°ra
: √ì ≈Ñ ·π£e √†gb√©j√°de k√≥√≤d√π t√≠ √≥ ·π£et√°n f√∫n √¨·π£el·ªçÃÅp·ªçÃÄ. P·∫πÃÄl√∫ √†k·ªçs√≠l·∫πÃÄ t√≠ √≥ m√°a ·π£√†l√†y√© ara r·∫πÃÄ f√∫n ·∫π n√≠ √¨b√°·π£ep·ªçÃÄ al√°d√†√°·π£i·π£·∫πÃÅ p·∫πÃÄl√∫ r√®.
Ajohun≈°e/√åt·ªçÃÅkas√≠
: √ì da lori (√†ti ibamu ni kikun p·∫πÃÄl√∫) √†w·ªçn √¨m·ªç ajohun≈°e/√¨t·ªçÃÅkas√≠ f√∫n √†w·ªçn API:
OpenAPI
(√®y√≠ t√≠ a m·ªç t·∫πl·∫π si Swagger) √†ti
JSON Schema
.
* i·π£iro yi da lori √†w·ªçn idanwo t√≠ ·∫πgb·∫π √¨d√†gb√†s√≥k√® FastAPI ·π£e, n√≠gb√†t√≠ w·ªçn k·ªç √†w·ªçn ohun elo i·π£el·ªçp·ªç k√≥√≤d√π p·∫πÃÄl√∫ r·∫π.
√Äw·ªçn on√≠gb·ªçÃÄw·ªçÃÅ
√Äw·ªçn on√≠gb·ªçÃÄw·ªçÃÅ m√≠r√†n
√Äw·ªçn ero √†ti √®s√¨
"
[...] M√≤ ≈Ñ lo
FastAPI
p√∫p·ªçÃÄ n√≠ l·∫πÃÅnu √†√¨p·∫πÃÅ y√¨√≠. [...] Mo n gbero l√°ti lo o p·∫πÃÄl√∫ √†w·ªçn ·∫πgb·∫π mi f√∫n gbogbo i·π£·∫π
ML wa ni Microsoft
. Di·∫π n√≠n√∫ w·ªçn ni afikun ti ifilel·∫π √†w·ªçn ·∫πya ara ti ·ªçja
Windows
wa p·∫πÃÄl√∫ √†w·ªçn ti
Office
.
"
Kabir Khan -
Microsoft
(ref)
"
A gba √†w·ªçn ohun √®l√≤ √¨w√© af·ªçw·ªçk·ªç
FastAPI
t√≠ k√≤ y√≠ pad√† l√°ti ·π£·∫πÃÄd√° ol√πp√≠n
REST
t√≠ a l√® b√©√®r√® l·ªçÃÅw·ªçÃÅ r·∫πÃÄ l√°ti gba
√†s·ªçt·∫πÃÅl·∫πÃÄ
. [f√∫n Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
ni inudidun l√°ti kede itusil·∫π orisun k√≥√≤d√π ti √¨l√†n√† i·π£·ªçkan
i·π£akoso √å·π£√≤ro
wa:
√åfir√°n·π£·∫πÃÅ
! [a k·ªç p·∫πÃÄl√∫
FastAPI
]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
In√∫ mi d√πn p√∫p·ªçÃÄ n√≠pa
FastAPI
. √ì m√∫ in√∫ ·∫πn√¨ d√πn p√∫p·ªçÃÄ!
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
N√≠ t√≤√≥t·ªçÃÅ, ohun t√≠ o k·ªç d√°ra √≥ s√¨ t√∫n d√°n. N√≠ ·ªçÃÄp·ªçÃÄl·ªçp·ªçÃÄ ·ªçÃÄn√†, ohun t√≠ mo f·∫πÃÅ k√≠
Hug
j·∫πÃÅ n√¨y·∫πn - √≥ w√∫ni l√≥r√≠ gan-an l√°ti r√≠ ·∫πn√¨kan t√≠ √≥ k·ªçÃÅ n«πkan b√≠ √®y√≠.
"
Timothy Crosley -
Hug
creator
(ref)
"
Ti o ba n wa l√°ti k·ªç ·ªçkan
√¨l√†n√† igbalode
f√∫n kik·ªç √†w·ªçn REST API, ·π£ay·∫πwo
FastAPI
[...] √ì y√°ra, √≥ r·ªçr√πn l√°ti l√≤, √≥ s√¨ r·ªçr√πn l√°ti k·ªçÃÅ[...]
"
"
A ti yipada si
FastAPI
f√∫n
APIs
wa [...] Mo l√©r√≤ p√© w√† √° f·∫πÃÅr√†n r·∫πÃÄ [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
founders -
spaCy
creators
(ref)
-
(ref)
"
Ti ·∫πnik·∫πni ba n wa l√°ti k·ªç i·π£el·ªçp·ªç API p·∫πÃÄl√∫ Python, √®mi y√≥√≤ ·π£e'd√∫r√≥ f√∫n
FastAPI
. √ì j·∫πÃÅ ohun t√≠
√†gb√©kal·∫πÃÄ r·∫πÃÄ l·∫πÃÅw√†
,
√≥ r·ªçr√πn l√°ti l√≤
√†ti wipe √≥ ni
√¨w·ªçÃÄn g√≠ga
, o t√≠ d√≠
b·ªçtini paati
n√≠n√∫ alak·ªçk·ªç API √¨d√†gb√†s√≥k√® kik·ªç f√∫n wa, √†ti pe o ni ipa lori ada·π£i·π£·∫π √†ti √†w·ªçn i·π£·∫π g·∫πÃÅg·∫πÃÅ b√≠i On√≠m·ªçÃÄ-·∫πÃÄr·ªç TAC t√≠ √≥r√≠ √ç≈Ñt√°n·∫πÃÅ·∫πÃÄt√¨
"
Deon Pillsbury -
Cisco
(ref)
Typer
, FastAPI ti CLIs
Ti o ba n k·ªç ohun √®l√≤
CLI
l√°ti ·π£e√© l·ªç n√≠n√∫ ohun √®l√≤ lori ebute k·ªçmputa dipo API, ·π£ay·∫πwo
Typer
.
Typer
j·∫πÃÅ √†b√∫r√≤ √¨y√° FastAPI k√©ker√©. √Äti p√© w·ªçÃÅn k·ªçÃÅ l√°ti j·∫πÃÅ
FastAPI ti CLIs
. ‚å®Ô∏è üöÄ
√àr√≤j√†
FastAPI d√∫r√≥ l√≥r√≠ √†w·ªçn √®j√¨k√° t√≠ √†w·ªçn √≤m√≠r√†n:
Starlette
f√∫n √†w·ªçn ·∫πÃÄy√† ay√©luj√°ra.
Pydantic
f√∫n √†w·ªçn ·∫πÃÄy√† √†k√≥j·ªçf'√°y·∫πÃÄw√≤.
Fifi s√≥r√≠ ·∫πr·ªç
fast ‚Üí
pip install fastapi
restart ‚Üª
Iw·ªç y√≥√≤ t√∫n n√≠l√≤ olupin ASGI, f√∫n i·π£el·ªçp·ªç bii
Uvicorn
tabi
Hypercorn
.
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
√Äp·∫π·∫πr·∫π
·π¢·∫πÃÄd√° r·∫πÃÄ
·π¢·∫πÃÄd√° f√°√¨l√¨
main.py (√®y√≠ t√≠√≠ ·π£e, ak·ªçk·ªç.py)
p·∫πÃÄl√∫:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
T√†b√≠ l√≤
async def
...
T√≠ k√≥√≤d√π r·∫πÃÄ b√° ≈Ñ l√≤
async
/
await
, l√≤
async def
:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Akiyesi
:
T√≠ o k√≤ b√° m·ªçÃÄ, ·π£√†y·∫πÃÄw√≤ ibi t√≠ a ti n√≠
"In a hurry?"
(i.e.
"N√≠ k√≠√°k√≠√°?"
) n√≠pa
async
and
await
n√≠n√∫ √†k·ªçs√≠l·∫πÃÄ
.
Mu ·π£i·π£·∫π
M√∫ olupin ·π£i·π£·∫π p·∫πÃÄl√∫:
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
Nipa a·π£·∫π k√≥√≤d√π n√°√†
uvicorn main:app --reload
...
√Ä·π£·∫π
uvicorn main:app
≈Ñ t·ªçÃÅka s√≠:
main
: f√°√¨l√¨ n√°√† 'main.py' (Python "module").
app
j·∫π object( i.e. n«πkan) t√≠ a ·π£·∫πÃÄd√° n√≠n√∫
main.py
p·∫πÃÄl√∫ il√†
app = FastAPI()
.
--reload
: √®y√≠ y√≥√≤ j·∫πÃÅ ki olupin t√∫n b·∫πÃÄr·∫πÃÄ l·∫πÃÅh√¨n √†w·ªçn √†y√≠pad√† k√≥√≤d√π. J·ªçÃÄw·ªçÃÅ, ·π£e √®y√≠ f√∫n √¨d√†gb√†s√≥k√® k√≥√≤d√π n√¨kan, m√° ·π£e √© ·π£e lori √†gb√©j√°de k√≥√≤d√π tabi f√∫n i·π£el·ªçp·ªç k√≥√≤d√π.
·π¢ay·∫πwo r·∫π
·π¢ii a·π£√†w√°kiri k·ªçÃÄ«πp√∫t√† r·∫π ni
http://127.0.0.1:8000/items/5?q=somequery
.
√åw·ªç y√≥√≤ s√¨ r√≠ √¨d√°h√πn JSON b√≠i:
{
"item_id"
:
5
,
"q"
:
"somequery"
}
O t√≠ ·π£·∫πÃÄd√° API √®y√≠ t√≠ y√≥√≤:
Gb√† √†w·ªçn √¨b√©√®r√® HTTP ni √†w·ªçn
ipa ·ªçÃÄn√†
/
√†ti
/items/{item_id}
.
√ày√≠ t√≠ √†w·ªçn
ipa ·ªçÃÄn√†
(i.e.
paths
) m√©j√®√®j√¨ gb√† √†w·ªçn
i·π£·∫π
GET
(a tun m·ªç si
√†w·ªçn ·ªçna
HTTP).
√ày√≠ t√≠
ipa ·ªçÃÄn√†
(i.e.
paths
)
/items/{item_id}
n√≠
√†w·ªçn ohun-ini ipa ·ªçÃÄn√†
t√≠ √≥ y·∫π k√≠ √≥ j·∫πÃÅ
int
i.e.
√í«∏K√Ä
.
√ày√≠ t√≠
ipa ·ªçÃÄn√†
(i.e.
paths
)
/items/{item_id}
n√≠ √†·π£√†y√†n
str
√†w·ªçn ohun-ini
(i.e.
query parameter
)
q
.
√åb√°·π£ep·ªçÃÄ √†k·ªçs√≠l·∫πÃÄ API
N√≠ b√°y√¨√≠, l·ªç s√≠
http://127.0.0.1:8000/docs
.
L·∫πÃÅy√¨n n√°√†, iw·ªç y√≥√≤ r√≠ √¨d√°h√πn √†k·ªçs√≠l·∫πÃÄ API t√≠ √≥ j·∫πÃÅ √¨b√°·π£ep·ªçÃÄ alaif·ªçw·ªçyi/al√°d√†√°·π£i·π£·∫πÃÅ (t√≠ a p√®·π£√® n√≠pa·π£·∫πÃÄ
Swagger UI
):
√åd√†kej√¨ √†k·ªçs√≠l·∫πÃÄ API
N√≠ b√°y√¨√≠, l·ªç s√≠
http://127.0.0.1:8000/redoc
.
W√† √° r√≠ √†w·ªçn √†k·ªçs√≠l·∫πÃÄ al√°d√†√°·π£i·π£·∫πÃÅ m√¨√≠r√†n (t√≠ a pese nipas·∫π
ReDoc
):
√Äp·∫π·∫πr·∫π √¨gb√©s√≥k√® m√¨√≠r√†n
N√≠ b√°y√¨√≠ ·π£e √†t√∫n·π£e f√°√¨l√¨
main.py
l√°ti gba k√≥k√≥ √®s√¨ l√°ti in√∫ √¨b√©√®r√®
PUT
.
N√≠ b√°y√¨√≠, ·π£e √¨k√©de k√≥k√≥ √®s√¨ API n√≠n√∫ k√≥√≤d√π r·∫π nipa l√≠lo √†w·ªçn √¨t·ªçÃÅkas√≠ √†m√¨ ir√∫f·∫πÃÅ Python, ·ªçp·∫πÃÅ p√†t√†k√¨si s√≠ Pydantic.
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
Olupin y√≥√≤ t√∫n ·π£e √†t√∫n·π£e laif·ªçw·ªçyi/al√°d√†√°·π£i·π£·∫πÃÅ (n√≠tor√≠ w√≠p√© √≥ se √†fik√∫n
-reload
si √†·π£·∫π k√≥√≤d√π
uvicorn
l√≥k√®).
√åb√°·π£ep·ªçÃÄ √¨gb√©s√≥k√® √†k·ªçs√≠l·∫πÃÄ API
N√≠ b√°y√¨√≠, l·ªç s√≠
http://127.0.0.1:8000/docs
.
√åb√°·π£ep·ªçÃÄ √†k·ªçs√≠l·∫πÃÄ API y√≥√≤ ·π£e imudojuiw·ªçn √†k·ªçs√≠l·∫πÃÄ API laif·ªçw·ªçyi, p·∫πÃÄl√∫ k√≥k√≥ √®s√¨ √¨d√°h√πn API tuntun:
T·∫π b·ªçtini "Gbiyanju r·∫π" i.e. "Try it out", y√≥√≤ gb√† ·ªçÃÅ l√°√†y√® l√°ti j·∫πÃÅ k√≠ √≥ t·∫πÃÅ √†l√†y√© t√≠ √≥ n√≠l√≤ k√≠ √≥ le s·ªçÃÄr·ªçÃÄ t√†√†r√† p·∫πÃÄl√∫ API:
L·∫πhinna t·∫π b·ªçtini "·π¢i·π£e" i.e. "Execute", ol√πm√∫l√≤ (i.e. user interface) y√≥√≤ s·ªçr·ªç p·∫πÃÄl√∫ API r·∫π, y√≥√≤ ·π£e afiran·π£·∫π √†w·ªçn √®r√≤j√†, p√†√°p√†√° j√πl·ªç y√≥√≤ gba √†w·ªçn √†b√°j√°de y√≥√≤ si ·π£afihan w·ªçn loju √¨b√≤j√∫:
√åd√†kej√¨ √¨gb√©s√≥k√® √†k·ªçs√≠l·∫πÃÄ API
N√≠ b√°y√¨√≠, l·ªç s√≠
http://127.0.0.1:8000/redoc
.
√åd√†kej√¨ √†k·ªçs√≠l·∫πÃÄ API y√≥√≤ ·π£'afihan √¨b√©√®r√® √®r√≤j√†/p√†r√°m√≠t√† tuntun √†ti k√≥k√≥ √®s√¨ ti API:
√Ät√∫ny·∫πÃÄw√≤
Ni akop·ªç, √¨w·ªç y√≥√≤ k√©de ni
kete
√†w·ªçn iru √®r√≤j√†/p√†r√°m√≠t√†, k√≥k√≥ √®s√¨ API, abbl (i.e. √†ti b·∫πb·∫π l·ªç), bi √†w·ªçn √®r√≤j√† i·π£·∫π.
O ·π£e √¨y·∫πn p·∫πÃÄl√∫ ir√∫f·∫πÃÅ √†m√¨ √¨t·ªçÃÅkas√≠ √¨gb√†l√≥d√© Python.
O √≤ n√≠l√≤ l√°ti k·ªçÃÅ s√≠≈Ñt√°√†s√¨ tuntun, √¨l√†n√† t√†b√≠ ·ªçÃÄw·ªçÃÅ k√≠l√°√†s√¨ kan p√†t√≥, abbl (i.e. √†ti b·∫πb·∫π l·ªç).
√åt·ªçÃÅkas√≠
Python
F√∫n √†p·∫π·∫πr·∫π, f√∫n
int
:
item_id
:
int
t√†b√≠ f√∫n √†w√≤·π£e
Item
t√≠ √≥ nira d√≠·∫πÃÄ s√≠i:
item
:
Item
... √†ti p·∫πÃÄl√∫ √¨k√©de kan ·π£o·π£o y·∫πn √¨w·ªç y√≥√≤ gb√†:
Atil·∫πyin olootu, p·∫πÃÄl√∫:
Pipari.
√Äy·∫πÃÄw√≤ ir√∫f·∫πÃÅ √†m√¨ √¨t·ªçÃÅkas√≠.
√åf·ªçw·ªçÃÅs√≠ √†k√≥j·ªçf'√°y·∫πÃÄw√≤ (i.e. data):
A·π£i·π£e alaif·ªçw·ªçyi/al√°d√†√°·π£i·π£·∫πÃÅ √†ti a·π£i·π£e ti √≥ h√†n kedere n√≠gb√†t√≠ √†w·ªçn √†k√≥j·ªçf'√°y·∫πÃÄw√≤ (i.e. data) k√≤ wulo tabi t√≠ k√≤ f·∫πs·∫πÃÄ m√∫l·∫πÃÄ.
√åf·ªçw·ªçÃÅs√≠ f√∫n ohun elo JSON t√≠ √≥ j√¨n gan-an.
√åy√≠pad√†
t√≠ input √†k√≥j·ªçf'√°y·∫πÃÄw√≤: t√≠ √≥ w√† l√°ti n·∫πtiw·ªç·ªçki si √†k√≥j·ªçf'√°y·∫πÃÄw√≤ √†ti ir√∫f·∫πÃÅ √†m√¨ √¨t·ªçÃÅkas√≠ Python. √ì ≈Ñ ka l√°ti:
JSON.
√®r√≤j√† ·ªçÃÄn√† t√≠ √≤ gb√© gb√†.
√®r√≤j√† √¨b√©√®r√®.
√Äw·ªçn K√∫k√¨
√Äw·ªçn √Äk·ªçl√©
√Äw·ªçn F·ªç·ªçmu
√Äw·ªçn F√°√¨l√¨
√åy√≠pad√†
√®s√¨ √†k√≥j·ªçf'√°y·∫πÃÄw√≤: y√≠y√≠pad√† l√°ti √†k√≥j·ªçf'√°y·∫πÃÄw√≤ √†ti ir√∫f·∫πÃÅ √†m√¨ √¨t·ªçÃÅkas√≠ Python si n·∫πtiw·ªç·ªçki (g·∫πÃÅg·∫πÃÅ b√≠ JSON):
Y√≠ ir√∫f·∫πÃÅ √†m√¨ √¨t·ªçÃÅkas√≠ pad√† (
str
,
int
,
float
,
bool
,
list
, abbl i.e. √†ti b√®b√® l√≥).
√Äw·ªçn ohun √®l√≤
datetime
.
√Äw·ªçn ohun √®l√≤
UUID
.
√Äw·ªçn awo·π£·∫πÃÅ ibi √¨pam·ªçÃÅ √†k√≥j·ªçf'√°y·∫πÃÄw√≤.
...√†ti ·ªçÃÄp·ªçÃÄl·ªçp·ªçÃÄ d√≠·∫πÃÄ s√≠i.
√åb√°·π£ep·ªçÃÄ √†k·ªçs√≠l·∫πÃÄ API al√°d√†√°·π£i·π£·∫πÃÅ, p·∫πÃÄl√∫ √¨d√†kej√¨ √†gb√©kal·∫πÃÄ-√†w·ªçn-ol√πm√∫l√≤ (i.e user interfaces) m√©j√¨:
√Ägb√©kal·∫πÃÄ-ol√πm√∫l√≤ Swagger.
ReDoc.
Nisinsin yi, t√≠ √≥ pad√† s√≠ √†p·∫π·∫πr·∫π ti t·∫πÃÅl·∫πÃÄ,
FastAPI
y√≥√≤:
F·ªçw·ªçÃÅ s√≠ i p√©
item_id
w√† n√≠n√∫ ·ªçÃÄn√† √¨b√©√®r√® HTTP f√∫n
GET
√†ti
PUT
.
F·ªçw·ªçÃÅ s√≠ i p√©
item_id
j·∫πÃÅ ir√∫f·∫πÃÅ √†m√¨ √¨t·ªçÃÅkas√≠
int
f√∫n √¨b√©√®r√® HTTP
GET
√†ti
PUT
.
T√≠ k√¨√≠ b√° ·π£e b·∫π, on√≠b√†√°r√† y√≥√≤ r√≠i √†·π£√¨·π£e t√≠ √≥ w√∫l√≤, kedere.
·π¢√†y·∫πÃÄw√≤ b√≥y√° √¨b√©√®r√® √†·π£√†y√†n p√†r√°m√≠t√† kan w√† t√≠ or√∫k·ªç r·∫πÃÄ ≈Ñ j·∫πÃÅ
q
(g·∫πÃÅg·∫πÃÅ b√≠i
http://127.0.0.1:8000/items/foo?q=somequery
) f√∫n √¨b√©√®r√® HTTP
GET
.
B√≠ w·ªçÃÅn ·π£e k√©de p√†r√°m√≠t√†
q
p·∫πÃÄl√∫
= None
, √≥ j·∫πÃÅ √†·π£√†y√†n (i.e optional).
L√°√¨s√≠
None
y√≥√≤ n√≠l√≤ (g·∫πÃÅg·∫πÃÅ b√≠ k√≥k√≥ √®s√¨ √¨b√©√®r√® HTTP ·π£e w√† p·∫πÃÄl√∫
PUT
).
F√∫n √†w·ªçn √¨b√©√®r√® HTTP
PUT
s√≠
/items/{item_id}
, k√† k√≥k√≥ √®s√¨ √¨b√©√®r√® HTTP g·∫πÃÅg·∫πÃÅ b√≠ JSON:
·π¢√†y·∫πÃÄw√≤ p√© √≥ n√≠ √†b√πd√° t√≠ √≥ n√≠l√≤ √®y√≠ t√≠√≠ ·π£e
name
i.e.
or√∫k·ªç
t√≠ √≥ y·∫π k√≠ √≥ j·∫πÃÅ
str
.
·π¢√†y·∫πÃÄw√≤ p√© √≥ n√≠ √†b√πd√° t√≠ √≥ n√≠l√≤ √®y√≠ t√≠√≠ ·π£e
price
i.e.
iye
t√≠ √≥ gb·ªçÃÅd·ªçÃÄ j·∫πÃÅ
float
.
·π¢√†y·∫πÃÄw√≤ p√© √≥ n√≠ √†b√πd√° √†·π£√†y√†n
is_offer
, t√≠ √≥ y·∫π k√≠ √≥ j·∫πÃÅ
bool
, t√≠ √≥ b√° w√† n√≠b·∫πÃÄ.
Gbogbo √®y√≠ y√≥√≤ t√∫n ·π£i·π£·∫πÃÅ f√∫n √†w·ªçn ohun √®l√≤ JSON t√≠ √≥ j√¨n gidi gan-an.
Y√¨√≠ pad√† l√°ti √†ti s√≠ JSON lai fi ·ªçw·ªçÃÅ yi.
·π¢e √†k·ªçs√≠l·∫πÃÄ ohun gbogbo p·∫πÃÄl√∫ OpenAPI, √®y√≠ t√≠ y√≥√≤ w√† n√≠ l√≠lo n√≠pa·π£·∫πÃÄ:
√Äw·ªçn √®t√≤ √†k·ªçs√≠l·∫πÃÄ √¨b√°·π£ep·ªçÃÄ.
Al√°d√†√°·π£i·π£·∫πÃÅ on√≠b√°r√† √®l√®t√≤ t√≠√≠ ·π£·∫πÃÄd√° k√≥√≤d√π, f√∫n ·ªçÃÄp·ªçÃÄl·ªçp·ªçÃÄ √†w·ªçn √®d√®.
Pese √†k·ªçs√≠l·∫πÃÄ √≤n√≠ √¨b√°·π£ep·ªçÃÄ ti √†w·ªçn √†gb√©kal·∫πÃÄ ay√©luj√°ra m√©j√¨ t√†√†r√†.
A ≈Ñ ·π£·∫πÃÄ·π£·∫πÃÄ ≈Ñ m√∫ ·∫πy·∫π b·ªçÃÅ l√†p√≤ n√≠, ·π£√πgb·ªçÃÅn √≥ ti ni √≤ye b√≠ gbogbo r·∫πÃÄ ·π£e ≈Ñ ·π£i·π£·∫πÃÅ.
Gbiyanju l√°ti y√≠ √¨l√† pad√† p·∫πÃÄl√∫:
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
...l√°ti:
...
"item_name"
:
item
.
name
...
...·π£√≠:
...
"item_price"
:
item
.
price
...
.. k√≠ o s√¨ wo b√≠ ol√≥√≤t√∫ r·∫π y√≥√≤ ·π£e par√≠ √†w·ªçn √†b√πd√° n√°√† f√∫nra r·∫πÃÄ, y√≥√≤ s√¨ m·ªç ir√∫f·∫πÃÅ w·ªçn:
F√∫n √†p·∫π·∫πr·∫π p√≠p√© s√≠i p·∫πÃÄl√∫ √†w·ªçn √†b√πd√° m√¨√≠r√†n, wo
√åd√°nil·∫πÃÅk·ªçÃÄ·ªçÃÅ - √åt·ªçÃÅs·ªçÃÅn√† Ol√πm√∫l√≤
.
Itaniji g·∫πÃÅg·∫πÃÅ b√≠ is·ªç'ye
: √¨d√°nil·∫πÃÅk·ªçÃÄ·ªçÃÅ - it·ªçs·ªçna ol√πm√∫l√≤ p·∫πÃÄl√∫:
√åk√©de √†·π£√†y√†n
p√†r√°m√≠t√†
l√°ti √†w·ªçn ori·π£iri·π£i ib√≤m√≠r√†n g·∫πÃÅg·∫πÃÅ b√≠i: √†w·ªçn
√†k·ªçl√© √®s√¨ API
,
k√∫k√¨
,
√†√†y√® f·ªç·ªçmu
, √†ti
f√°√¨l√¨
.
B√≠i √≥ ·π£e l√© ·π£√®t√≤
√†w·ªçn √¨d√≠w·ªçÃÅ √¨f·ªçw·ªçÃÅs√≠
b√≠
maximum_length
t√†b√≠
regex
.
√ì l√°gb√°ra p√∫p·ªçÃÄ √≥ s√¨ r·ªçr√πn l√°ti lo √®t√≤
√Äfik√∫n √ågb·∫πÃÅk·∫πÃÄl√© K√≥√≤d√π
.
√Ä√†b√≤ √†ti √¨f·ªçw·ªçÃÅsow·ªçÃÅp·ªçÃÄ, p·∫πÃÄl√∫ √†t√¨l·∫πÃÅy√¨n f√∫n
OAuth2
p·∫πÃÄl√∫
√†m√¨ JWT
√†ti
HTTP Ipil·∫π √¨f·ªçw·ªçÃÅsow·ªçÃÅp·ªçÃÄ
.
√Äw·ªçn √¨l√†n√† √¨l·ªçs√≠w√°j√∫ (·π£√πgb·ªçÃÅn t√≠ √≥ r·ªçr√πn b√°kan n√°√†) f√∫n √¨k√©de
√†w·ªçn √†w√≤·π£e JSON t√≥ jinl·∫πÃÄ
(·ªçp·∫πÃÅ p√†t√†k√¨si s√≠ Pydantic).
I·π£·ªçp·ªç
GraphQL
p·∫πÃÄl√∫
Strawberry
√†ti √†w·ªçn ohun √®l√≤ √¨w√© k√≥√≤d√π af·ªçw·ªçk·ªç m√¨√≠r√†n t√≠ k√≤ y√≠ pad√†.
·ªåp·ªçl·ªçp·ªç √†w·ªçn √†fik√∫n √†w·ªçn ·∫πÃÄy√† (·ªçp·∫πÃÅ p√†t√†k√¨si s√≠ Starlette) b√≠:
WebSockets
√†w·ªçn √¨d√°nw√≤ t√≠ √≥ r·ªçr√πn p√∫p·ªçÃÄ l√≥r√≠ HTTPX √†ti
pytest
CORS
Cookie Sessions
...√†ti s√≠w√°j√∫ s√≠i.
√å·π£es√≠
√Äw·ªçn √†l√° TechEmpower fi h√†n p√©
FastAPI
≈Ñ ·π£i·π£·∫πÃÅ l√°b·∫πÃÅ Uvicorn g·∫πÃÅg·∫πÃÅ b√≠
·ªçÃÄkan l√°ra √†w·ªçn √¨l√†n√† Python t√≠ √≥ y√°ra j√πl·ªç t√≠ √≥ w√†
, n√≠ √¨s√†l·∫πÃÄ Starlette √†ti Uvicorn f√∫nra w·ªçn (t√≠ FastAPI ≈Ñ l√≤ f√∫nra r·∫πÃÄ). (*)
L√°ti n√≠ √≤ye s√≠i n√≠pa r·∫πÃÄ, wo abala √†w·ªçn
√Äl√°
.
√Ä·π£√†y√†n √Äw·ªçn √Äfik√∫n √ågb·∫πÃÅk·∫πÃÄl√© K√≥√≤d√π
√ày√≠ t√≠ Pydantic ≈Ñ l√≤:
email-validator
- f√∫n if·ªçw·ªçsi √≠me√®l√¨.
pydantic-settings
- f√∫n √®t√≤ √¨s√†k√≥so.
pydantic-extra-types
- f√∫n √†fik√∫n or√≠·π£i l√°ti l·ªç p·∫πÃÄl√∫ Pydantic.
√ày√≠ t√≠ Starlette ≈Ñ l√≤:
httpx
- N√≠l√≤ t√≠ √≥ b√° f·∫πÃÅ l√°ti l·ªç
TestClient
.
jinja2
- N√≠l√≤ t√≠ √≥ b√° f·∫πÃÅ l√°ti l·ªç i·π£eto awo·π£e aiyipada.
python-multipart
- N√≠l√≤ t√≠ √≥ b√° f·∫πÃÅ l√°ti ·π£e √†t√¨l·∫πÃÅy√¨n f√∫n
"√†y·∫πÃÄw√≤"
f·ªç·ªçmu, p·∫πÃÄl√∫
request.form()
.
itsdangerous
- N√≠l√≤ f√∫n √†t√¨l·∫πÃÅy√¨n
SessionMiddleware
.
pyyaml
- N√≠l√≤ f√∫n √†t√¨l·∫πÃÅy√¨n Starlette's
SchemaGenerator
(√≥ ·π£e ·π£e k√≠ √≥ m√° n√≠l√≤ r·∫πÃÄ f√∫n FastAPI).
√ày√≠ t√≠ FastAPI / Starlette ≈Ñ l√≤:
uvicorn
- F√∫n olupin t√≠ y√≥√≤ s·∫πÃÅ √†m√∫y·∫π √†ti t√≠ y√≥√≤ ·π£e √¨p√®s√® f√∫n i·π£·∫πÃÅ r·∫π t√†b√≠ ohun √®l√≤ r·∫π.
orjson
- N√≠l√≤ t√≠ √≥ b√° f·∫πÃÅ l√°ti l·ªç
ORJSONResponse
.
ujson
- N√≠l√≤ t√≠ √≥ b√° f·∫πÃÅ l√°ti l·ªç
UJSONResponse
.
√ì l√® fi gbogbo √†w·ªçn w·ªçÃÄny√≠ s√≥r√≠ ·∫πr·ªç p·∫πÃÄl√∫
pip install "fastapi[all]"
.
Iwe-a·π£·∫π
I·π£·∫πÃÅ y√¨√≠ ni iwe-a·π£·∫π l√°b·∫πÃÅ √†w·ªçn √≤fin t√≠ iwe-a·π£·∫π MIT.

## 161_ZH_HANT
FastAPI
FastAPI Ê°ÜÊû∂ÔºåÈ´òÊïàËÉΩÔºåÊòìÊñºÂ≠∏ÁøíÔºåÂø´ÈÄüÈñãÁôºÔºåÈÅ©Áî®ÊñºÁîüÁî¢Áí∞Â¢É
Êñá‰ª∂
Ôºö
https://fastapi.tiangolo.com
Á®ãÂºèÁ¢º
Ôºö
https://github.com/fastapi/fastapi
FastAPI ÊòØ‰∏ÄÂÄãÁèæ‰ª£„ÄÅÂø´ÈÄüÔºàÈ´òÊïàËÉΩÔºâÁöÑ web Ê°ÜÊû∂ÔºåÁî®Êñº Python ‰∏¶Êé°Áî®Ê®ôÊ∫ñ Python ÂûãÂà•ÊèêÁ§∫„ÄÇ
‰∏ªË¶ÅÁâπÈªûÂåÖÂê´Ôºö
Âø´ÈÄü
Ôºö ÈùûÂ∏∏È´òÁöÑÊïàËÉΩÔºåÂèØËàá
NodeJS
Âíå
Go
ÊïàËÉΩÁõ∏Áï∂ (Ê≠∏ÂäüÊñº Starlette and Pydantic)„ÄÇ
FastAPI ÊòØÊúÄÂø´ÁöÑ Python web Ê°ÜÊû∂‰πã‰∏Ä
„ÄÇ
Ê•µÈÄüÈñãÁôº
Ôºö ÊèêÈ´òÈñãÁôºÂäüËÉΩÁöÑÈÄüÂ∫¶Á¥Ñ 200% Ëá≥ 300%„ÄÇ *
Êõ¥Â∞ëÁöÑ Bug
Ôºö Ê∏õÂ∞ëÁ¥Ñ 40% ÁöÑ‰∫∫ÁÇ∫ÔºàÈñãÁôºËÄÖÔºâÂ∞éËá¥ÁöÑÈåØË™§„ÄÇ *
Áõ¥Ë¶∫
Ôºö ÂÖ∑ÊúâÂá∫Ëâ≤ÁöÑÁ∑®ËºØÂô®ÊîØÊè¥ÔºåËôïËôïÈÉΩÊúâ
Ëá™ÂãïË£úÂÖ®
‰ª•Ê∏õÂ∞ëÂÅµÈåØÊôÇÈñì„ÄÇ
Á∞°ÂñÆ
Ôºö Ë®≠Ë®à‰∏äÊòìÊñº‰ΩøÁî®ÂíåÂ≠∏ÁøíÔºåÂ§ßÂπÖÊ∏õÂ∞ëÈñ±ËÆÄÊñá‰ª∂ÁöÑÊôÇÈñì„ÄÇ
Á∞°ÊΩî
Ôºö ÊúÄÂ∞èÂåñÁ®ãÂºèÁ¢ºÈáçË§áÊÄß„ÄÇÂèØ‰ª•ÈÄöÈÅé‰∏çÂêåÁöÑÂèÉÊï∏ËÅ≤Êòé‰æÜÂØ¶ÁèæÊõ¥Ë±êÂØåÁöÑÂäüËÉΩÔºåÂíåÊõ¥Â∞ëÁöÑÈåØË™§„ÄÇ
Á©©ÂÅ•
Ôºö Á´ãÂç≥Áç≤ÂæóÁîüÁî¢Á¥öÂèØÁî®ÁöÑÁ®ãÂºèÁ¢ºÔºåÈÇÑÊúâËá™ÂãïÁîüÊàê‰∫íÂãïÂºèÊñá‰ª∂„ÄÇ
Ê®ôÊ∫ñÂåñ
Ôºö Âü∫Êñº (‰∏îÂÆåÂÖ®Áõ∏ÂÆπÊñº) OpenAPIs ÁöÑÁõ∏ÈóúÊ®ôÊ∫ñÔºö
OpenAPI
Ôºà‰πãÂâçË¢´Á®±ÁÇ∫ SwaggerÔºâÂíå
JSON Schema
„ÄÇ
* Âü∫ÊñºÂÖßÈÉ®ÈñãÁôºÂúòÈöäÂú®Âª∫Á´ãÁîüÁî¢ÊáâÁî®Á®ãÂºèÊôÇÁöÑÊ∏¨Ë©¶È†ê‰º∞„ÄÇ
Ë¥äÂä©
ÂÖ∂‰ªñË¥äÂä©ÂïÜ
Ë©ïÂÉπ
"
[...] ËøëÊúüÂ§ßÈáèÁöÑ‰ΩøÁî®
FastAPI
„ÄÇ [...] ÁõÆÂâçÊ≠£Âú®Ë®àÁï´Âú®
ÂæÆËªü
ÂúòÈöäÁöÑ
Ê©üÂô®Â≠∏Áøí
ÊúçÂãô‰∏≠Â∞éÂÖ•„ÄÇÂÖ∂‰∏≠‰∏Ä‰∫õÊ≠£Âú®Êï¥ÂêàÂà∞Ê†∏ÂøÉÁöÑ
Windows
Áî¢ÂìÅÂíå‰∏Ä‰∫õ
Office
Áî¢ÂìÅ„ÄÇ
"
Kabir Khan -
Microsoft
(ref)
"
ÊàëÂÄë‰ΩøÁî®
FastAPI
‰æÜÂª∫Á´ãÁî¢Áîü
È†êÊ∏¨
ÁµêÊûúÁöÑ
REST
‰º∫ÊúçÂô®„ÄÇ [for Ludwig]
"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -
Uber
(ref)
"
Netflix
ÂæàÊ¶ÆÂπ∏Âú∞ÂÆ£Â∏ÉÈñãÊ∫ê
Âç±Ê©üÁÆ°ÁêÜ
ÂçîË™øÊ°ÜÊû∂Ôºö
Dispatch
! [ÊòØ‰ΩøÁî®
FastAPI
Âª∫Êßã]
"
Kevin Glisson, Marc Vilanova, Forest Monsen -
Netflix
(ref)
"
ÊàëÂ∞ç
FastAPI
ËààÂ•ÆÂæó‰∏çÂæó‰∫Ü„ÄÇÂÆÉÂ§™ÊúâË∂£‰∫ÜÔºÅ
"
Brian Okken -
Python Bytes
podcast host
(ref)
"
ËÄÅÂØ¶Ë™™Ôºå‰Ω†Âª∫ÈÄ†ÁöÑÊù±Ë•øÁúãËµ∑‰æÜÈùûÂ∏∏Â†ÖÂõ∫ÂíåÁ≤æÁ∑ª„ÄÇÂú®ÂæàÂ§öÊñπÈù¢ÔºåÈÄôÂ∞±ÊòØÊàëÊÉ≥Ë¶ÅÁöÑÔºåÁúãÂà∞Êúâ‰∫∫Âª∫ÈÄ†ÂÆÉÁúüÁöÑÂæàÈºìËàû‰∫∫ÂøÉ„ÄÇ
"
Timothy Crosley -
Hug
creator
(ref)
"
Â¶ÇÊûúÊÇ®ÊÉ≥Â≠∏Áøí‰∏ÄÁ®ÆÁî®ÊñºÊßãÂª∫ REST API ÁöÑ
Áèæ‰ª£Ê°ÜÊû∂
Ôºå‰∏çËÉΩÈåØÈÅé
FastAPI
[...] ÂÆÉÈùûÂ∏∏Âø´ÈÄü„ÄÅ‰∏îÊòìÊñº‰ΩøÁî®ÂíåÂ≠∏Áøí [...]
"
"
ÊàëÂÄëÁöÑ
APIs
Â∑≤Á∂ìÊîπÁî®
FastAPI
[...] ÊàëÊÉ≥‰Ω†ÊúÉÂñúÊ≠°ÂÆÉ [...]
"
Ines Montani - Matthew Honnibal -
Explosion AI
ÂâµËæ¶‰∫∫ -
spaCy
creators
(ref)
-
(ref)
"
Â¶ÇÊûúÊúâ‰∫∫ÊÉ≥Ë¶ÅÂª∫Á´ã‰∏ÄÂÄãÁîüÁî¢Áí∞Â¢ÉÁöÑ Python APIÔºåÊàëÂº∑ÁÉàÊé®Ëñ¶
FastAPI
ÔºåÂÆÉ
Ë®≠Ë®àÁ≤æÁæé
Ôºå
‰ΩøÁî®Á∞°ÂñÆ
‰∏î
È´òÂ∫¶ÂèØÊì¥ÂÖÖ
ÔºåÂÆÉÂ∑≤ÊàêÁÇ∫ÊàëÂÄë API ÂÑ™ÂÖàÈñãÁôºÁ≠ñÁï•‰∏≠ÁöÑ
ÈóúÈçµÁµÑ‰ª∂
Ôºå‰∏¶‰∏îÈ©ÖÂãï‰∫ÜË®±Â§öËá™ÂãïÂåñÊúçÂãôÔºå‰æãÂ¶ÇÊàëÂÄëÁöÑ Virtual TAC Engineer„ÄÇ
"
Deon Pillsbury -
Cisco
(ref)
Typer
ÔºåÂëΩ‰ª§Âàó‰∏≠ÁöÑ FastAPI
Â¶ÇÊûú‰Ω†‰∏çÊòØÂú®ÈñãÁôºÁ∂≤È†Å APIÔºåËÄåÊòØÊ≠£Âú®ÈñãÁôº‰∏ÄÂÄãÂú®ÁµÇÁ´ØÊ©ü‰∏≠ÈÅãË°åÁöÑ
ÂëΩ‰ª§Âàó
ÊáâÁî®Á®ãÂºèÔºå‰∏çÂ¶®ÂòóË©¶
Typer
„ÄÇ
Typer
ÊòØ FastAPI ÁöÑÂ∞èÂÖÑÂºü„ÄÇ‰ªñÁ´ãÂøóÊàêÁÇ∫ÂëΩ‰ª§ÂàóÁöÑ
FastAPI
„ÄÇ ‚å®Ô∏è üöÄ
ÂÆâË£ùÈúÄÊ±Ç
FastAPI ÊòØÁ´ôÂú®‰ª•‰∏ãÂ∑®‰∫∫ÁöÑËÇ©ËÜÄ‰∏äÔºö
Starlette
Ë≤†Ë≤¨Á∂≤È†ÅÁöÑÈÉ®ÂàÜ
Pydantic
Ë≤†Ë≤¨Ë≥áÊñôÁöÑÈÉ®ÂàÜ
ÂÆâË£ù
fast ‚Üí
pip install fastapi
restart ‚Üª
‰Ω†ÂêåÊôÇ‰πüÊúÉÈúÄË¶Å ASGI ‰º∫ÊúçÂô®Áî®ÊñºÁîüÁî¢Áí∞Â¢ÉÔºåÂÉèÊòØ
Uvicorn
Êàñ
Hypercorn
„ÄÇ
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
ÁØÑ‰æã
Âª∫Á´ã
Âª∫Á´ã‰∏ÄÂÄã python Ê™îÊ°à
main.py
Ôºå‰∏¶ÂØ´ÂÖ•‰ª•‰∏ãÁ®ãÂºèÁ¢ºÔºö
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
ÊàñÂèØ‰ª•‰ΩøÁî®
async def
...
Â¶ÇÊûú‰Ω†ÁöÑÁ®ãÂºè‰ΩøÁî®
async
/
await
ÔºåË´ã‰ΩøÁî®
async def
Ôºö
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Ê≥®ÊÑè
Ôºö
Â¶ÇÊûú‰Ω†‰∏çÁü•ÈÅìÊòØÂê¶ÊúÉÁî®Âà∞ÔºåÂèØ‰ª•Êü•Áúã
"In a hurry?"
Á´†ÁØÄ‰∏≠ÔºåÈóúÊñº
async
Âíå
await
ÁöÑÈÉ®ÂàÜ
„ÄÇ
ÈÅãË°å
‰ΩøÁî®‰ª•‰∏ãÊåá‰ª§ÈÅãË°å‰º∫ÊúçÂô®Ôºö
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
ÈóúÊñºÊåá‰ª§
uvicorn main:app --reload
...
Ë©≤Êåá‰ª§
uvicorn main:app
ÊåáÁöÑÊòØÔºö
main
Ôºö
main.py
Ê™îÊ°àÔºà‰∏ÄÂÄã python ÁöÑ "Ê®°ÁµÑ"Ôºâ„ÄÇ
app
ÔºöÂú®
main.py
Ê™îÊ°à‰∏≠Ôºå‰ΩøÁî®
app = FastAPI()
Âª∫Á´ãÁöÑÁâ©‰ª∂„ÄÇ
--reload
ÔºöÁ®ãÂºèÁ¢ºÊõ¥ÊîπÂæåÊúÉËá™ÂãïÈáçÊñ∞ÂïüÂãïÔºåË´ãÂÉÖÂú®ÈñãÁôºÊôÇ‰ΩøÁî®Ê≠§ÂèÉÊï∏„ÄÇ
Ê™¢Êü•
‰ΩøÁî®ÁÄèË¶ΩÂô®ÈñãÂïü
http://127.0.0.1:8000/items/5?q=somequery
„ÄÇ
‰Ω†Â∞áÊúÉÁúãÂà∞‰ª•‰∏ãÁöÑ JSON ÂõûÊáâÔºö
{
"item_id"
:
5
,
"q"
:
"somequery"
}
‰Ω†Â∑≤Á∂ìÂª∫Á´ã‰∫Ü‰∏ÄÂÄãÂÖ∑Êúâ‰ª•‰∏ãÂäüËÉΩÁöÑ APIÔºö
ÈÄèÈÅéË∑ØÂæë
/
Âíå
/items/{item_id}
Êé•Âèó HTTP Ë´ãÊ±Ç„ÄÇ
‰ª•‰∏äË∑ØÁ∂ìÈÉΩÊé•Âèó
GET
Ë´ãÊ±Ç
Ôºà‰πüË¢´Á®±ÁÇ∫ HTTP
ÊñπÊ≥ï
Ôºâ„ÄÇ
Ë∑ØÂæë
/items/{item_id}
Êúâ‰∏ÄÂÄã
int
ÂûãÂà•ÁöÑ
item_id
ÂèÉÊï∏„ÄÇ
Ë∑ØÂæë
/items/{item_id}
Êúâ‰∏ÄÂÄã
str
ÂûãÂà•ÁöÑÊü•Ë©¢ÂèÉÊï∏
q
„ÄÇ
‰∫íÂãïÂºè API Êñá‰ª∂
‰ΩøÁî®ÁÄèË¶ΩÂô®ÈñãÂïü
http://127.0.0.1:8000/docs
„ÄÇ
‰Ω†ÊúÉÁúãÂà∞Ëá™ÂãïÁîüÊàêÁöÑ‰∫íÂãïÂºè API Êñá‰ª∂ÔºàÁî±
Swagger UI
ÁîüÊàêÔºâÔºö
ReDoc API Êñá‰ª∂
‰ΩøÁî®ÁÄèË¶ΩÂô®ÈñãÂïü
http://127.0.0.1:8000/redoc
„ÄÇ
‰Ω†Â∞áÁúãÂà∞ ReDoc Êñá‰ª∂ (Áî±
ReDoc
ÁîüÊàê)Ôºö
ÁØÑ‰æãÂçáÁ¥ö
ÁèæÂú®ÁπºÁ∫å‰øÆÊîπ
main.py
Ê™îÊ°àÔºå‰æÜÊé•Êî∂‰∏ÄÂÄãÂ∏∂Êúâ body ÁöÑ
PUT
Ë´ãÊ±Ç„ÄÇ
ÊàëÂÄë‰ΩøÁî® Pydantic ‰æÜ‰ΩøÁî®Ê®ôÊ∫ñÁöÑ Python ÂûãÂà•ËÅ≤ÊòéË´ãÊ±Ç„ÄÇ
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
‰º∫ÊúçÂô®Â∞áËá™ÂãïÈáçÊñ∞ËºâÂÖ•ÔºàÂõ†ÁÇ∫Âú®‰∏ä‰∏ÄÊ≠•‰∏≠Ôºå‰Ω†Âêë
uvicorn
Êåá‰ª§Ê∑ªÂä†‰∫Ü
--reload
ÁöÑÈÅ∏È†ÖÔºâ„ÄÇ
‰∫íÂãïÂºè API Êñá‰ª∂ÂçáÁ¥ö
‰ΩøÁî®ÁÄèË¶ΩÂô®ÈñãÂïü
http://127.0.0.1:8000/docs
„ÄÇ
‰∫íÂãïÂºè API Êñá‰ª∂ÊúÉËá™ÂãïÊõ¥Êñ∞Ôºå‰∏¶Âä†ÂÖ•Êñ∞ÁöÑ body Ë´ãÊ±ÇÔºö
ÈªûÊìä "Try it out" ÊåâÈàïÔºå ‰Ω†ÂèØ‰ª•Â°´ÂØ´ÂèÉÊï∏‰∏¶Áõ¥Êé•Ëàá API ‰∫íÂãïÔºö
ÁÑ∂ÂæåÈªûÊìä "Execute" ÊåâÈàïÔºå‰ΩøÁî®ËÄÖ‰ªãÈù¢Â∞áÊúÉÂêë API ÁôºÈÄÅË´ãÊ±ÇÔºå‰∏¶Â∞áÁµêÊûúÈ°ØÁ§∫Âú®Ëû¢Âπï‰∏äÔºö
ReDoc API Êñá‰ª∂ÂçáÁ¥ö
‰ΩøÁî®ÁÄèË¶ΩÂô®ÈñãÂïü
http://127.0.0.1:8000/redoc
„ÄÇ
ReDoc API Êñá‰ª∂ÊúÉËá™ÂãïÊõ¥Êñ∞Ôºå‰∏¶Âä†ÂÖ•Êñ∞ÁöÑÂèÉÊï∏Âíå body Ë´ãÊ±ÇÔºö
Á∏ΩÁµê
Á∏ΩÁµê‰æÜË™™Ôºå ‰Ω†Â∞±ÂÉèÂÆ£ÂëäÂáΩÂºèÁöÑÂèÉÊï∏ÂûãÂà•‰∏ÄÊ®£ÔºåÂè™ÂÆ£Âëä‰∫Ü‰∏ÄÊ¨°Ë´ãÊ±ÇÂèÉÊï∏ÂíåË´ãÊ±Ç‰∏ªÈ´îÂèÉÊï∏Á≠âÂûãÂà•„ÄÇ
‰Ω†‰ΩøÁî® Python Ê®ôÊ∫ñÂûãÂà•‰æÜÂÆåÊàêËÅ≤Êòé„ÄÇ
‰Ω†‰∏çÈúÄË¶ÅÂ≠∏ÁøíÊñ∞ÁöÑË™ûÊ≥ï„ÄÅÈ°ûÂà•„ÄÅÊñπÊ≥ïÊàñÂáΩÂºèÂ∫´Á≠âÁ≠â„ÄÇ
Âè™ÈúÄË¶Å‰ΩøÁî®
Python ‰ª•‰∏äÁöÑÁâàÊú¨
„ÄÇ
ËàâÂÄãÁØÑ‰æãÔºåÊØîÂ¶ÇÂÆ£Âëä int ÁöÑÂûãÂà•Ôºö
item_id
:
int
ÊàñÊòØ‰∏ÄÂÄãÊõ¥Ë§áÈõúÁöÑ
Item
Ê®°ÂûãÔºö
item
:
Item
Âú®ÈÄ≤Ë°å‰∏ÄÊ¨°ÂÆ£ÂëäÂæåÔºå‰Ω†Â∞áÁç≤ÂæóÔºö
Á∑®ËºØÂô®ÊîØÊè¥Ôºö
Ëá™ÂãïË£úÂÖ®
ÂûãÂà•Ê™¢Êü•
Ë≥áÊñôÈ©óË≠âÔºö
È©óË≠âÂ§±ÊïóÊôÇËá™ÂãïÁîüÊàêÊ∏ÖÊ•öÁöÑÈåØË™§Ë®äÊÅØ
ÂèØÈ©óË≠âÂ§öÂ±§Â∑¢ÁãÄÁöÑ JSON Áâ©‰ª∂
ËΩâÊèõ
Ëº∏ÂÖ•ÁöÑË≥áÊñôÔºö ËΩâÊèõ‰æÜËá™Á∂≤Ë∑ØË´ãÊ±ÇÂà∞ Python Ë≥áÊñôÂûãÂà•„ÄÇÂåÖÂê´‰ª•‰∏ãÊï∏ÊìöÔºö
JSON
Ë∑ØÂæëÂèÉÊï∏
Êü•Ë©¢ÂèÉÊï∏
Cookies
Ë´ãÊ±ÇÊ®ôÈ†≠
Ë°®ÂñÆ
Êñá‰ª∂
ËΩâÊèõ
Ëº∏Âá∫ÁöÑË≥áÊñôÔºö ËΩâÊèõ Python Ë≥áÊñôÂûãÂà•Âà∞Á∂≤Ë∑ØÂÇ≥Ëº∏ÁöÑ JSONÔºö
ËΩâÊèõ Python ÂûãÂà• (
str
„ÄÅ
int
„ÄÅ
float
„ÄÅ
bool
„ÄÅ
list
Á≠â)
datetime
Áâ©‰ª∂
UUID
Áâ©‰ª∂
Êï∏ÊìöÊ®°Âûã
...ÈÇÑÊúâÂÖ∂‰ªñÊõ¥Â§ö
Ëá™ÂãïÁîüÊàêÁöÑ API Êñá‰ª∂ÔºåÂåÖÂê´ 2 Á®Æ‰∏çÂêåÁöÑ‰ΩøÁî®‰ªãÈù¢Ôºö
Swagger UI
ReDoc
ÂõûÂà∞ÂâçÈù¢ÁöÑÁöÑÁ®ãÂºèÁ¢ºÁØÑ‰æãÔºå
FastAPI
ÈÇÑÊúÉÔºö
È©óË≠â
GET
Âíå
PUT
Ë´ãÊ±ÇË∑ØÂæë‰∏≠ÊòØÂê¶ÂåÖÂê´
item_id
„ÄÇ
È©óË≠â
GET
Âíå
PUT
Ë´ãÊ±Ç‰∏≠ÁöÑ
item_id
ÊòØÂê¶ÊòØ
int
ÂûãÂà•„ÄÇ
Â¶ÇÊûúÈ©óË≠âÂ§±ÊïóÔºåÂ∞áÊúÉËøîÂõûÊ∏ÖÊ•öÊúâÁî®ÁöÑÈåØË™§Ë®äÊÅØ„ÄÇ
Êü•Áúã
GET
Ë´ãÊ±Ç‰∏≠ÊòØÂê¶ÊúâÂëΩÂêçÁÇ∫
q
ÁöÑÊü•Ë©¢ÂèÉÊï∏ (‰æãÂ¶Ç
http://127.0.0.1:8000/items/foo?q=somequery
)„ÄÇ
Âõ†ÁÇ∫
q
ÂèÉÊï∏Ë¢´ÂÆ£ÂëäÁÇ∫
= None
ÔºåÊâÄ‰ª•ÊòØÈÅ∏Â°´ÁöÑ„ÄÇ
Â¶ÇÊûúÊ≤íÊúâÂÆ£Âëä
None
ÔºåÂâáÊ≠§ÂèÉÊï∏Â∞áÊúÉÊòØÂøÖÂ°´ (‰æãÂ¶Ç
PUT
ÁØÑ‰æãÁöÑË´ãÊ±Ç body)„ÄÇ
Â∞çÊñº
PUT
ÁöÑË´ãÊ±Ç
/items/{item_id}
ÔºåÂ∞áÊúÉËÆÄÂèñ body ÁÇ∫ JSONÔºö
È©óË≠âÊòØÂê¶ÊúâÂøÖÂ°´Â±¨ÊÄß
name
‰∏îÂûãÂà•ÊòØ
str
„ÄÇ
È©óË≠âÊòØÂê¶ÊúâÂøÖÂ°´Â±¨ÊÄß
price
‰∏îÂûãÂà•ÊòØ
float
„ÄÇ
È©óË≠âÊòØÂê¶ÊúâÈÅ∏Â°´Â±¨ÊÄß
is_offer
‰∏îÂûãÂà•ÊòØ
bool
„ÄÇ
‰ª•‰∏äÈ©óË≠âÈÉΩÈÅ©Áî®ÊñºÂ§öÂ±§Ê¨°Â∑¢ÁãÄ JSON Áâ©‰ª∂„ÄÇ
Ëá™ÂãïËΩâÊèõ JSON Ê†ºÂºè„ÄÇ
ÈÄèÈÅé OpenAPI Êñá‰ª∂‰æÜË®òÈåÑÊâÄÊúâÂÖßÂÆπÔºåÂèØ‰ª•Ë¢´Áî®ÊñºÔºö
‰∫íÂãïÂºèÊñá‰ª∂Á≥ªÁµ±„ÄÇ
Ëá™ÂãïÁÇ∫Â§öÁ®ÆÁ®ãÂºèË™ûË®ÄÁîüÊàêÁî®Êà∂Á´ØÁöÑÁ®ãÂºèÁ¢º„ÄÇ
Êèê‰æõÂÖ©Á®Æ‰∫§‰∫íÂºèÊñá‰ª∂‰ªãÈù¢„ÄÇ
ÈõñÁÑ∂ÊàëÂÄëÂè™ÊïòËø∞‰∫ÜË°®Èù¢ÁöÑÂäüËÉΩÔºå‰ΩÜÂÖ∂ÂØ¶‰Ω†Â∑≤Á∂ìÁêÜËß£‰∫ÜÂÆÉÊòØÂ¶Ç‰ΩïÂü∑Ë°å„ÄÇ
Ë©¶Ëëó‰øÆÊîπ‰ª•‰∏ãÁ®ãÂºèÁ¢ºÔºö
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
ÂæûÔºö
...
"item_name"
:
item
.
name
...
‰øÆÊîπÁÇ∫Ôºö
...
"item_price"
:
item
.
price
...
ÁÑ∂ÂæåËßÄÂØü‰Ω†ÁöÑÁ∑®ËºØÂô®ÔºåÊúÉËá™ÂãïË£úÂÖ®‰∏¶‰∏îÈÇÑÁü•ÈÅì‰ªñÂÄëÁöÑÂûãÂà•Ôºö
ÊúâÈóúÊõ¥Â§öÂäüËÉΩÁöÑÂÆåÊï¥ÁØÑ‰æãÔºåÂèØ‰ª•ÂèÉËÄÉ
ÊïôÂ≠∏ - ‰ΩøÁî®ËÄÖÊåáÂçó
„ÄÇ
ÂäáÈÄèË≠¶Âëä
Ôºö ÊïôÂ≠∏ - ‰ΩøÁî®ËÄÖÊåáÂçóÂÖßÂÆπÊúâÔºö
Â∞ç‰æÜËá™‰∏çÂêåÂú∞ÊñπÁöÑ
ÂèÉÊï∏
ÈÄ≤Ë°åÂÆ£ÂëäÔºöÂÉèÊòØ
headers
,
cookies
,
form Ë°®ÂñÆ
‰ª•Âèä
‰∏äÂÇ≥Ê™îÊ°à
„ÄÇ
Â¶Ç‰ΩïË®≠ÂÆö
È©óË≠âÈôêÂà∂
ÂÉèÊòØ
maximum_length
or
regex
„ÄÇ
Á∞°ÂñÆ‰∏îÈùûÂ∏∏ÂÆπÊòì‰ΩøÁî®ÁöÑ
‰æùË≥¥Ê≥®ÂÖ•
Á≥ªÁµ±„ÄÇ
ÂÆâÂÖ®ÊÄßÂíåË∫´‰ªΩÈ©óË≠âÔºåÂåÖÂê´Êèê‰æõÊîØÊè¥
OAuth2
„ÄÅ
JWT tokens
Âíå
HTTP Basic
È©óË≠â„ÄÇ
Êõ¥ÈÄ≤Èöé (‰ΩÜÂêåÊ®£Á∞°ÂñÆ) ÁöÑÂÆ£Âëä
Â§öÂ±§Ê¨°ÁöÑÂ∑¢ÁãÄ JSON Ê†ºÂºè
(ÊÑüË¨ù Pydantic)„ÄÇ
GraphQL
Ëàá
Strawberry
‰ª•ÂèäÂÖ∂‰ªñÁöÑÁõ∏ÈóúÂáΩÂºèÂ∫´ÈÄ≤Ë°åÊï¥Âêà„ÄÇ
Êõ¥Â§öÂÖ∂‰ªñÁöÑÂäüËÉΩ (ÊÑüË¨ù Starlette) ÂÉèÊòØÔºö
WebSockets
Êñº HTTPX Âíå
pytest
ÁöÑÈùûÂ∏∏Á∞°ÂñÆÊ∏¨Ë©¶
CORS
Cookie Sessions
...‰ª•ÂèäÊõ¥Â§ö
ÊïàËÉΩ
‰æÜËá™Áç®Á´ãÊ©üÊßã TechEmpower ÁöÑÊ∏¨Ë©¶ÁµêÊûúÔºåÈ°ØÁ§∫Âú® Uvicorn Âü∑Ë°å‰∏ãÁöÑ
FastAPI
ÊòØ
ÊúÄÂø´ÁöÑ Python Ê°ÜÊû∂‰πã‰∏Ä
Ôºå ÂÉÖÊ¨°Êñº Starlette Âíå Uvicorn Êú¨Ë∫´ (ÂÖ©ËÄÖÊòØ FastAPI ÁöÑÂ∫ïÂ±§)„ÄÇ (*)
ÊÉ≥‰∫ÜËß£Êõ¥Â§öË®äÊÅØÔºåÂèØ‰ª•ÂèÉËÄÉ
Ê∏¨Ë©¶ÁµêÊûú
„ÄÇ
ÂèØÈÅ∏ÁöÑ‰æùË≥¥Â•ó‰ª∂
Áî®Êñº PydanticÔºö
email-validator
- Áî®ÊñºÈõªÂ≠êÈÉµ‰ª∂È©óË≠â„ÄÇ
pydantic-settings
- Áî®ÊñºË®≠ÂÆöÁÆ°ÁêÜ„ÄÇ
pydantic-extra-types
- Áî®ÊñºËàá Pydantic ‰∏ÄËµ∑‰ΩøÁî®ÁöÑÈ°çÂ§ñÂûãÂà•„ÄÇ
Áî®Êñº StarletteÔºö
httpx
- ‰ΩøÁî®
TestClient
ÊôÇÂøÖÈ†àÂÆâË£ù„ÄÇ
jinja2
- ‰ΩøÁî®È†êË®≠ÁöÑÊ®°ÊùøÈÖçÁΩÆÊôÇÂøÖÈ†àÂÆâË£ù„ÄÇ
python-multipart
- ÈúÄË¶Å‰ΩøÁî®
request.form()
Â∞çË°®ÂñÆÈÄ≤Ë°å
"Ëß£Êûê"
ÊôÇÂÆâË£ù„ÄÇ
itsdangerous
- ÈúÄË¶Å‰ΩøÁî®
SessionMiddleware
ÊîØÊè¥ÊôÇÂÆâË£ù„ÄÇ
pyyaml
- Áî®ÊñºÊîØÊè¥ Starlette ÁöÑ
SchemaGenerator
(Â¶ÇÊûú‰Ω†‰ΩøÁî® FastAPIÔºåÂèØËÉΩ‰∏çÈúÄË¶ÅÂÆÉ)„ÄÇ
Áî®Êñº FastAPI / StarletteÔºö
uvicorn
- Áî®ÊñºÂä†ËºâÂíåÈÅãË°åÊáâÁî®Á®ãÂºèÁöÑÊúçÂãôÂô®„ÄÇ
orjson
- ‰ΩøÁî®
ORJSONResponse
ÊôÇÂøÖÈ†àÂÆâË£ù„ÄÇ
ujson
- ‰ΩøÁî®
UJSONResponse
ÊôÇÂøÖÈ†àÂÆâË£ù„ÄÇ
‰Ω†ÂèØ‰ª•‰ΩøÁî®
pip install "fastapi[all]"
‰æÜÂÆâË£ùÈÄô‰∫õÊâÄÊúâ‰æùË≥¥Â•ó‰ª∂„ÄÇ
ÊéàÊ¨ä
Ë©≤È†ÖÁõÆÈÅµÂæ™ MIT Ë®±ÂèØÂçîË≠∞„ÄÇ

## 162_ZH
FastAPI¬∂
---

FastAPI
FastAPI Ê°ÜÊû∂ÔºåÈ´òÊÄßËÉΩÔºåÊòì‰∫éÂ≠¶‰π†ÔºåÈ´òÊïàÁºñÁ†ÅÔºåÁîü‰∫ßÂèØÁî®
ÊñáÊ°£
Ôºö
https://fastapi.tiangolo.com
Ê∫êÁ†Å
Ôºö
https://github.com/fastapi/fastapi
FastAPI ÊòØ‰∏Ä‰∏™Áî®‰∫éÊûÑÂª∫ API ÁöÑÁé∞‰ª£„ÄÅÂø´ÈÄüÔºàÈ´òÊÄßËÉΩÔºâÁöÑ web Ê°ÜÊû∂Ôºå‰ΩøÁî® Python Âπ∂Âü∫‰∫éÊ†áÂáÜÁöÑ Python Á±ªÂûãÊèêÁ§∫„ÄÇ
ÂÖ≥ÈîÆÁâπÊÄß:
Âø´ÈÄü
ÔºöÂèØ‰∏é
NodeJS
Âíå
Go
Âπ∂ËÇ©ÁöÑÊûÅÈ´òÊÄßËÉΩÔºàÂΩíÂäü‰∫é Starlette Âíå PydanticÔºâ„ÄÇ
ÊúÄÂø´ÁöÑ Python web Ê°ÜÊû∂‰πã‰∏Ä
„ÄÇ
È´òÊïàÁºñÁ†Å
ÔºöÊèêÈ´òÂäüËÉΩÂºÄÂèëÈÄüÂ∫¶Á∫¶ 200ÔºÖ Ëá≥ 300ÔºÖ„ÄÇ*
Êõ¥Â∞ë bug
ÔºöÂáèÂ∞ëÁ∫¶ 40ÔºÖ ÁöÑ‰∫∫‰∏∫ÔºàÂºÄÂèëËÄÖÔºâÂØºËá¥ÈîôËØØ„ÄÇ*
Êô∫ËÉΩ
ÔºöÊûÅ‰Ω≥ÁöÑÁºñËæëÂô®ÊîØÊåÅ„ÄÇÂ§ÑÂ§ÑÁöÜÂèØ
Ëá™Âä®Ë°•ÂÖ®
ÔºåÂáèÂ∞ëË∞ÉËØïÊó∂Èó¥„ÄÇ
ÁÆÄÂçï
ÔºöËÆæËÆ°ÁöÑÊòì‰∫é‰ΩøÁî®ÂíåÂ≠¶‰π†ÔºåÈòÖËØªÊñáÊ°£ÁöÑÊó∂Èó¥Êõ¥Áü≠„ÄÇ
ÁÆÄÁü≠
Ôºö‰Ωø‰ª£Á†ÅÈáçÂ§çÊúÄÂ∞èÂåñ„ÄÇÈÄöËøá‰∏çÂêåÁöÑÂèÇÊï∞Â£∞ÊòéÂÆûÁé∞‰∏∞ÂØåÂäüËÉΩ„ÄÇbug Êõ¥Â∞ë„ÄÇ
ÂÅ•Â£Æ
ÔºöÁîü‰∫ßÂèØÁî®Á∫ßÂà´ÁöÑ‰ª£Á†Å„ÄÇËøòÊúâËá™Âä®ÁîüÊàêÁöÑ‰∫§‰∫íÂºèÊñáÊ°£„ÄÇ
Ê†áÂáÜÂåñ
ÔºöÂü∫‰∫éÔºàÂπ∂ÂÆåÂÖ®ÂÖºÂÆπÔºâAPI ÁöÑÁõ∏ÂÖ≥ÂºÄÊîæÊ†áÂáÜÔºö
OpenAPI
(‰ª•ÂâçË¢´Áß∞‰∏∫ Swagger) Âíå
JSON Schema
„ÄÇ
* Ê†πÊçÆÂØπÊüê‰∏™ÊûÑÂª∫Á∫ø‰∏äÂ∫îÁî®ÁöÑÂÜÖÈÉ®ÂºÄÂèëÂõ¢ÈòüÊâÄËøõË°åÁöÑÊµãËØï‰º∞ÁÆóÂæóÂá∫„ÄÇ
Sponsors
Other sponsors
ËØÑ‰ª∑
„Äå
[...] ÊúÄËøëÊàë‰∏ÄÁõ¥Âú®‰ΩøÁî®
FastAPI
„ÄÇ[...] ÂÆûÈôÖ‰∏äÊàëÊ≠£Âú®ËÆ°ÂàíÂ∞ÜÂÖ∂Áî®‰∫éÊàëÊâÄÂú®ÁöÑ
ÂæÆËΩØ
Âõ¢ÈòüÁöÑÊâÄÊúâ
Êú∫Âô®Â≠¶‰π†ÊúçÂä°
„ÄÇÂÖ∂‰∏≠‰∏Ä‰∫õÊúçÂä°Ê≠£Ë¢´ÈõÜÊàêËøõÊ†∏ÂøÉ
Windows
‰∫ßÂìÅÂíå‰∏Ä‰∫õ
Office
‰∫ßÂìÅ„ÄÇ
„Äç
Kabir Khan -
ÂæÆËΩØ
(ref)
„Äå
Êàë‰ª¨ÈÄâÊã©‰∫Ü
FastAPI
Êù•ÂàõÂª∫Áî®‰∫éËé∑Âèñ
È¢ÑÊµãÁªìÊûú
ÁöÑ
REST
ÊúçÂä°„ÄÇ[Áî®‰∫é Ludwig]
„Äç
Piero MolinoÔºåYaroslav Dudin Âíå Sai Sumanth Miryala -
Uber
(ref)
„Äå
Netflix
ÈùûÂ∏∏È´òÂÖ¥Âú∞ÂÆ£Â∏ÉÔºåÊ≠£ÂºèÂºÄÊ∫êÊàë‰ª¨ÁöÑ
Âç±Êú∫ÁÆ°ÁêÜ
ÁºñÊéíÊ°ÜÊû∂Ôºö
Dispatch
ÔºÅ[‰ΩøÁî®
FastAPI
ÊûÑÂª∫]
„Äç
Kevin GlissonÔºåMarc VilanovaÔºåForest Monsen -
Netflix
(ref)
„Äå
FastAPI
ËÆ©ÊàëÂÖ¥Â•ãÁöÑÊ¨£ÂñúËã•ÁãÇ„ÄÇÂÆÉÂ§™Ê£í‰∫ÜÔºÅ
„Äç
Brian Okken -
Python Bytes
Êí≠ÂÆ¢‰∏ªÊåÅ‰∫∫
(ref)
„Äå
ËÄÅÂÆûËØ¥Ôºå‰Ω†ÁöÑ‰ΩúÂìÅÁúãËµ∑Êù•ÈùûÂ∏∏ÂèØÈù†Âíå‰ºòÁæé„ÄÇÂú®ÂæàÂ§öÊñπÈù¢ÔºåËøôÂ∞±ÊòØÊàëÊÉ≥ËÆ©
Hug
Êàê‰∏∫ÁöÑÊ†∑Â≠ê - ÁúãÂà∞Êúâ‰∫∫ÂÆûÁé∞‰∫ÜÂÆÉÁúüÁöÑÂæàÈºìËàû‰∫∫ÂøÉ„ÄÇ
„Äç
Timothy Crosley -
Hug
‰ΩúËÄÖ
(ref)
„Äå
Â¶ÇÊûú‰Ω†Ê≠£ÊâìÁÆóÂ≠¶‰π†‰∏Ä‰∏™
Áé∞‰ª£Ê°ÜÊû∂
Áî®Êù•ÊûÑÂª∫ REST APIÔºåÊù•Áúã‰∏ã
FastAPI
[...] ÂÆÉÂø´ÈÄü„ÄÅÊòìÁî®‰∏îÊòì‰∫éÂ≠¶‰π† [...]
„Äç
„Äå
Êàë‰ª¨Â∑≤ÁªèÂ∞Ü
API
ÊúçÂä°ÂàáÊç¢Âà∞‰∫Ü
FastAPI
[...] ÊàëËÆ§‰∏∫‰Ω†‰ºöÂñúÊ¨¢ÂÆÉÁöÑ [...]
„Äç
Ines Montani - Matthew Honnibal -
Explosion AI
ÂàõÂßã‰∫∫ -
spaCy
‰ΩúËÄÖ
(ref)
-
(ref)
Typer
ÔºåÂëΩ‰ª§Ë°å‰∏≠ÁöÑ FastAPI
Â¶ÇÊûú‰Ω†Ê≠£Âú®ÂºÄÂèë‰∏Ä‰∏™Âú®ÁªàÁ´Ø‰∏≠ËøêË°åÁöÑ
ÂëΩ‰ª§Ë°å
Â∫îÁî®ËÄå‰∏çÊòØ web APIÔºå‰∏çÂ¶®ËØï‰∏ã
Typer
„ÄÇ
Typer
ÊòØ FastAPI ÁöÑÂ∞èÂêåËÉû„ÄÇÂÆÉÊÉ≥Ë¶ÅÊàê‰∏∫
ÂëΩ‰ª§Ë°å‰∏≠ÁöÑ FastAPI
„ÄÇ ‚å®Ô∏è üöÄ
‰æùËµñ
Python ÂèäÊõ¥È´òÁâàÊú¨
FastAPI Á´ôÂú®‰ª•‰∏ãÂ∑®‰∫∫ÁöÑËÇ©ËÜÄ‰πã‰∏äÔºö
Starlette
Ë¥üË¥£ web ÈÉ®ÂàÜ„ÄÇ
Pydantic
Ë¥üË¥£Êï∞ÊçÆÈÉ®ÂàÜ„ÄÇ
ÂÆâË£Ö
fast ‚Üí
pip install fastapi
restart ‚Üª
‰Ω†Ëøò‰ºöÈúÄË¶Å‰∏Ä‰∏™ ASGI ÊúçÂä°Âô®ÔºåÁîü‰∫ßÁéØÂ¢ÉÂèØ‰ª•‰ΩøÁî®
Uvicorn
ÊàñËÄÖ
Hypercorn
„ÄÇ
fast ‚Üí
pip install "uvicorn[standard]"
restart ‚Üª
Á§∫‰æã
ÂàõÂª∫
ÂàõÂª∫‰∏Ä‰∏™
main.py
Êñá‰ª∂Âπ∂ÂÜôÂÖ•‰ª•‰∏ãÂÜÖÂÆπ:
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
ÊàñËÄÖ‰ΩøÁî®
async def
...
Â¶ÇÊûú‰Ω†ÁöÑ‰ª£Á†ÅÈáå‰ºöÂá∫Áé∞
async
/
await
ÔºåËØ∑‰ΩøÁî®
async def
Ôºö
from
typing
import
Union
from
fastapi
import
FastAPI
app
=
FastAPI
()
@app
.
get
(
"/"
)
async
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
async
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
Note
:
Â¶ÇÊûú‰Ω†‰∏çÁü•ÈÅìÊòØÂê¶‰ºöÁî®Âà∞ÔºåÂèØ‰ª•Êü•ÁúãÊñáÊ°£ÁöÑ
"In a hurry?"
Á´†ËäÇ‰∏≠
ÂÖ≥‰∫é
async
Âíå
await
ÁöÑÈÉ®ÂàÜ
„ÄÇ
ËøêË°å
ÈÄöËøá‰ª•‰∏ãÂëΩ‰ª§ËøêË°åÊúçÂä°Âô®Ôºö
fast ‚Üí
uvicorn main:app --reload
INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO: Started reloader process [28720]
INFO: Started server process [28722]
INFO: Waiting for application startup.
INFO: Application startup complete.
restart ‚Üª
ÂÖ≥‰∫é
uvicorn main:app --reload
ÂëΩ‰ª§......
uvicorn main:app
ÂëΩ‰ª§Âê´‰πâÂ¶Ç‰∏ã:
main
Ôºö
main.py
Êñá‰ª∂Ôºà‰∏Ä‰∏™ Python "Ê®°Âùó"Ôºâ„ÄÇ
app
ÔºöÂú®
main.py
Êñá‰ª∂‰∏≠ÈÄöËøá
app = FastAPI()
ÂàõÂª∫ÁöÑÂØπË±°„ÄÇ
--reload
ÔºöËÆ©ÊúçÂä°Âô®Âú®Êõ¥Êñ∞‰ª£Á†ÅÂêéÈáçÊñ∞ÂêØÂä®„ÄÇ‰ªÖÂú®ÂºÄÂèëÊó∂‰ΩøÁî®ËØ•ÈÄâÈ°π„ÄÇ
Ê£ÄÊü•
‰ΩøÁî®ÊµèËßàÂô®ËÆøÈóÆ
http://127.0.0.1:8000/items/5?q=somequery
„ÄÇ
‰Ω†Â∞Ü‰ºöÁúãÂà∞Â¶Ç‰∏ã JSON ÂìçÂ∫îÔºö
{
"item_id"
:
5
,
"q"
:
"somequery"
}
‰Ω†Â∑≤ÁªèÂàõÂª∫‰∫Ü‰∏Ä‰∏™ÂÖ∑Êúâ‰ª•‰∏ãÂäüËÉΩÁöÑ APIÔºö
ÈÄöËøá
Ë∑ØÂæÑ
/
Âíå
/items/{item_id}
Êé•Âèó HTTP ËØ∑Ê±Ç„ÄÇ
‰ª•‰∏ä
Ë∑ØÂæÑ
ÈÉΩÊé•Âèó
GET
Êìç‰Ωú
Ôºà‰πüË¢´Áß∞‰∏∫ HTTP
ÊñπÊ≥ï
Ôºâ„ÄÇ
/items/{item_id}
Ë∑ØÂæÑ
Êúâ‰∏Ä‰∏™
Ë∑ØÂæÑÂèÇÊï∞
item_id
Âπ∂‰∏îÂ∫îËØ•‰∏∫
int
Á±ªÂûã„ÄÇ
/items/{item_id}
Ë∑ØÂæÑ
Êúâ‰∏Ä‰∏™ÂèØÈÄâÁöÑ
str
Á±ªÂûãÁöÑ
Êü•ËØ¢ÂèÇÊï∞
q
„ÄÇ
‰∫§‰∫íÂºè API ÊñáÊ°£
Áé∞Âú®ËÆøÈóÆ
http://127.0.0.1:8000/docs
„ÄÇ
‰Ω†‰ºöÁúãÂà∞Ëá™Âä®ÁîüÊàêÁöÑ‰∫§‰∫íÂºè API ÊñáÊ°£ÔºàÁî±
Swagger UI
ÁîüÊàêÔºâÔºö
ÂèØÈÄâÁöÑ API ÊñáÊ°£
ËÆøÈóÆ
http://127.0.0.1:8000/redoc
„ÄÇ
‰Ω†‰ºöÁúãÂà∞Âè¶‰∏Ä‰∏™Ëá™Âä®ÁîüÊàêÁöÑÊñáÊ°£ÔºàÁî±
ReDoc
ÁîüÊàêÔºâÔºö
Á§∫‰æãÂçáÁ∫ß
Áé∞Âú®‰øÆÊîπ
main.py
Êñá‰ª∂Êù•‰ªé
PUT
ËØ∑Ê±Ç‰∏≠Êé•Êî∂ËØ∑Ê±Ç‰Ωì„ÄÇ
Êàë‰ª¨ÂÄüÂä© Pydantic Êù•‰ΩøÁî®Ê†áÂáÜÁöÑ Python Á±ªÂûãÂ£∞ÊòéËØ∑Ê±Ç‰Ωì„ÄÇ
from
typing
import
Union
from
fastapi
import
FastAPI
from
pydantic
import
BaseModel
app
=
FastAPI
()
class
Item
(
BaseModel
):
name
:
str
price
:
float
is_offer
:
Union
[
bool
,
None
]
=
None
@app
.
get
(
"/"
)
def
read_root
():
return
{
"Hello"
:
"World"
}
@app
.
get
(
"/items/
{item_id}
"
)
def
read_item
(
item_id
:
int
,
q
:
Union
[
str
,
None
]
=
None
):
return
{
"item_id"
:
item_id
,
"q"
:
q
}
@app
.
put
(
"/items/
{item_id}
"
)
def
update_item
(
item_id
:
int
,
item
:
Item
):
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
ÊúçÂä°Âô®Â∞Ü‰ºöËá™Âä®ÈáçËΩΩÔºàÂõ†‰∏∫Âú®‰∏äÈù¢ÁöÑÊ≠•È™§‰∏≠‰Ω†Âêë
uvicorn
ÂëΩ‰ª§Ê∑ªÂä†‰∫Ü
--reload
ÈÄâÈ°πÔºâ„ÄÇ
‰∫§‰∫íÂºè API ÊñáÊ°£ÂçáÁ∫ß
ËÆøÈóÆ
http://127.0.0.1:8000/docs
„ÄÇ
‰∫§‰∫íÂºè API ÊñáÊ°£Â∞Ü‰ºöËá™Âä®Êõ¥Êñ∞ÔºåÂπ∂Âä†ÂÖ•Êñ∞ÁöÑËØ∑Ê±Ç‰ΩìÔºö
ÁÇπÂáª„ÄåTry it out„ÄçÊåâÈíÆÔºå‰πãÂêé‰Ω†ÂèØ‰ª•Â°´ÂÜôÂèÇÊï∞Âπ∂Áõ¥Êé•Ë∞ÉÁî® APIÔºö
ÁÑ∂ÂêéÁÇπÂáª„ÄåExecute„ÄçÊåâÈíÆÔºåÁî®Êà∑ÁïåÈù¢Â∞Ü‰ºöÂíå API ËøõË°åÈÄö‰ø°ÔºåÂèëÈÄÅÂèÇÊï∞ÔºåËé∑ÂèñÁªìÊûúÂπ∂Âú®Â±èÂπï‰∏äÂ±ïÁ§∫Ôºö
ÂèØÈÄâÊñáÊ°£ÂçáÁ∫ß
ËÆøÈóÆ
http://127.0.0.1:8000/redoc
„ÄÇ
ÂèØÈÄâÊñáÊ°£ÂêåÊ†∑‰ºö‰ΩìÁé∞Êñ∞Âä†ÂÖ•ÁöÑËØ∑Ê±ÇÂèÇÊï∞ÂíåËØ∑Ê±Ç‰ΩìÔºö
ÊÄªÁªì
ÊÄªÁöÑÊù•ËØ¥Ôºå‰Ω†Â∞±ÂÉèÂ£∞ÊòéÂáΩÊï∞ÁöÑÂèÇÊï∞Á±ªÂûã‰∏ÄÊ†∑Âè™Â£∞Êòé‰∫Ü
‰∏ÄÊ¨°
ËØ∑Ê±ÇÂèÇÊï∞„ÄÅËØ∑Ê±Ç‰ΩìÁ≠âÁöÑÁ±ªÂûã„ÄÇ
‰Ω†‰ΩøÁî®‰∫ÜÊ†áÂáÜÁöÑÁé∞‰ª£ Python Á±ªÂûãÊù•ÂÆåÊàêÂ£∞Êòé„ÄÇ
‰Ω†‰∏çÈúÄË¶ÅÂéªÂ≠¶‰π†Êñ∞ÁöÑËØ≠Ê≥ï„ÄÅ‰∫ÜËß£ÁâπÂÆöÂ∫ìÁöÑÊñπÊ≥ïÊàñÁ±ªÔºåÁ≠âÁ≠â„ÄÇ
Âè™ÈúÄË¶Å‰ΩøÁî®Ê†áÂáÜÁöÑ
Python ÂèäÊõ¥È´òÁâàÊú¨
„ÄÇ
‰∏æ‰∏™‰æãÂ≠êÔºåÊØîÂ¶ÇÂ£∞Êòé
int
Á±ªÂûãÔºö
item_id
:
int
ÊàñËÄÖ‰∏Ä‰∏™Êõ¥Â§çÊùÇÁöÑ
Item
Ê®°ÂûãÔºö
item
:
Item
......Âú®ËøõË°å‰∏ÄÊ¨°Â£∞Êòé‰πãÂêéÔºå‰Ω†Â∞ÜËé∑ÂæóÔºö
ÁºñËæëÂô®ÊîØÊåÅÔºåÂåÖÊã¨Ôºö
Ëá™Âä®Ë°•ÂÖ®
Á±ªÂûãÊ£ÄÊü•
Êï∞ÊçÆÊ†°È™åÔºö
Âú®Ê†°È™åÂ§±Ë¥•Êó∂Ëá™Âä®ÁîüÊàêÊ∏ÖÊô∞ÁöÑÈîôËØØ‰ø°ÊÅØ
ÂØπÂ§öÂ±ÇÂµåÂ•óÁöÑ JSON ÂØπË±°‰æùÁÑ∂ÊâßË°åÊ†°È™å
ËΩ¨Êç¢
Êù•Ëá™ÁΩëÁªúËØ∑Ê±ÇÁöÑËæìÂÖ•Êï∞ÊçÆ‰∏∫ Python Êï∞ÊçÆÁ±ªÂûã„ÄÇÂåÖÊã¨‰ª•‰∏ãÊï∞ÊçÆÔºö
JSON
Ë∑ØÂæÑÂèÇÊï∞
Êü•ËØ¢ÂèÇÊï∞
Cookies
ËØ∑Ê±ÇÂ§¥
Ë°®Âçï
Êñá‰ª∂
ËΩ¨Êç¢
ËæìÂá∫ÁöÑÊï∞ÊçÆÔºöËΩ¨Êç¢ Python Êï∞ÊçÆÁ±ªÂûã‰∏∫‰æõÁΩëÁªú‰º†ËæìÁöÑ JSON Êï∞ÊçÆÔºö
ËΩ¨Êç¢ Python Âü∫Á°ÄÁ±ªÂûã Ôºà
str
„ÄÅ
int
„ÄÅ
float
„ÄÅ
bool
„ÄÅ
list
Á≠âÔºâ
datetime
ÂØπË±°
UUID
ÂØπË±°
Êï∞ÊçÆÂ∫ìÊ®°Âûã
......‰ª•ÂèäÊõ¥Â§öÂÖ∂‰ªñÁ±ªÂûã
Ëá™Âä®ÁîüÊàêÁöÑ‰∫§‰∫íÂºè API ÊñáÊ°£ÔºåÂåÖÊã¨‰∏§ÁßçÂèØÈÄâÁöÑÁî®Êà∑ÁïåÈù¢Ôºö
Swagger UI
ReDoc
ÂõûÂà∞ÂâçÈù¢ÁöÑ‰ª£Á†ÅÁ§∫‰æãÔºå
FastAPI
Â∞Ü‰ºöÔºö
Ê†°È™å
GET
Âíå
PUT
ËØ∑Ê±ÇÁöÑË∑ØÂæÑ‰∏≠ÊòØÂê¶Âê´Êúâ
item_id
„ÄÇ
Ê†°È™å
GET
Âíå
PUT
ËØ∑Ê±Ç‰∏≠ÁöÑ
item_id
ÊòØÂê¶‰∏∫
int
Á±ªÂûã„ÄÇ
Â¶ÇÊûú‰∏çÊòØÔºåÂÆ¢Êà∑Á´ØÂ∞Ü‰ºöÊî∂Âà∞Ê∏ÖÊô∞ÊúâÁî®ÁöÑÈîôËØØ‰ø°ÊÅØ„ÄÇ
Ê£ÄÊü•
GET
ËØ∑Ê±Ç‰∏≠ÊòØÂê¶ÊúâÂëΩÂêç‰∏∫
q
ÁöÑÂèØÈÄâÊü•ËØ¢ÂèÇÊï∞ÔºàÊØîÂ¶Ç
http://127.0.0.1:8000/items/foo?q=somequery
Ôºâ„ÄÇ
Âõ†‰∏∫
q
Ë¢´Â£∞Êòé‰∏∫
= None
ÔºåÊâÄ‰ª•ÂÆÉÊòØÂèØÈÄâÁöÑ„ÄÇ
Â¶ÇÊûúÊ≤°Êúâ
None
ÂÆÉÂ∞Ü‰ºöÊòØÂøÖÈúÄÁöÑ (Â¶Ç
PUT
‰æãÂ≠ê‰∏≠ÁöÑËØ∑Ê±Ç‰Ωì)„ÄÇ
ÂØπ‰∫éËÆøÈóÆ
/items/{item_id}
ÁöÑ
PUT
ËØ∑Ê±ÇÔºåÂ∞ÜËØ∑Ê±Ç‰ΩìËØªÂèñ‰∏∫ JSON Âπ∂Ôºö
Ê£ÄÊü•ÊòØÂê¶ÊúâÂøÖÈúÄÂ±ûÊÄß
name
Âπ∂‰∏îÂÄº‰∏∫
str
Á±ªÂûã „ÄÇ
Ê£ÄÊü•ÊòØÂê¶ÊúâÂøÖÈúÄÂ±ûÊÄß
price
Âπ∂‰∏îÂÄº‰∏∫
float
Á±ªÂûã„ÄÇ
Ê£ÄÊü•ÊòØÂê¶ÊúâÂèØÈÄâÂ±ûÊÄß
is_offer
Ôºå Â¶ÇÊûúÊúâÁöÑËØùÂÄºÂ∫îËØ•‰∏∫
bool
Á±ªÂûã„ÄÇ
‰ª•‰∏äËøáÁ®ãÂØπ‰∫éÂ§öÂ±ÇÂµåÂ•óÁöÑ JSON ÂØπË±°ÂêåÊ†∑‰πü‰ºöÊâßË°å
Ëá™Âä®ÂØπ JSON ËøõË°åËΩ¨Êç¢ÊàñËΩ¨Êç¢Êàê JSON„ÄÇ
ÈÄöËøá OpenAPI ÊñáÊ°£Êù•ËÆ∞ÂΩïÊâÄÊúâÂÜÖÂÆπÔºåÂèØË¢´Áî®‰∫éÔºö
‰∫§‰∫íÂºèÊñáÊ°£Á≥ªÁªü
ËÆ∏Â§öÁºñÁ®ãËØ≠Ë®ÄÁöÑÂÆ¢Êà∑Á´Ø‰ª£Á†ÅËá™Âä®ÁîüÊàêÁ≥ªÁªü
Áõ¥Êé•Êèê‰æõ 2 Áßç‰∫§‰∫íÂºèÊñáÊ°£ web ÁïåÈù¢„ÄÇ
ËôΩÁÑ∂Êàë‰ª¨ÊâçÂàöÂàöÂºÄÂßãÔºå‰ΩÜÂÖ∂ÂÆû‰Ω†Â∑≤Áªè‰∫ÜËß£‰∫ÜËøô‰∏ÄÂàáÊòØÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑ„ÄÇ
Â∞ùËØïÊõ¥Êîπ‰∏ãÈù¢ËøôË°å‰ª£Á†ÅÔºö
return
{
"item_name"
:
item
.
name
,
"item_id"
:
item_id
}
......‰ªéÔºö
...
"item_name"
:
item
.
name
...
......Êîπ‰∏∫Ôºö
...
"item_price"
:
item
.
price
...
......Ê≥®ÊÑèËßÇÂØüÁºñËæëÂô®ÊòØÂ¶Ç‰ΩïËá™Âä®Ë°•ÂÖ®Â±ûÊÄßÂπ∂‰∏îËøòÁü•ÈÅìÂÆÉ‰ª¨ÁöÑÁ±ªÂûãÔºö
ÊïôÁ®ã - Áî®Êà∑ÊåáÂçó
‰∏≠ÊúâÂåÖÂê´Êõ¥Â§öÁâπÊÄßÁöÑÊõ¥ÂÆåÊï¥Á§∫‰æã„ÄÇ
ÂâßÈÄèË≠¶Âëä
Ôºö ÊïôÁ®ã - Áî®Êà∑ÊåáÂçó‰∏≠ÁöÑÂÜÖÂÆπÊúâÔºö
ÂØπÊù•Ëá™‰∏çÂêåÂú∞ÊñπÁöÑÂèÇÊï∞ËøõË°åÂ£∞ÊòéÔºåÂ¶ÇÔºö
ËØ∑Ê±ÇÂ§¥
„ÄÅ
cookies
„ÄÅ
form Ë°®Âçï
‰ª•Âèä
‰∏ä‰º†ÁöÑÊñá‰ª∂
„ÄÇ
Â¶Ç‰ΩïËÆæÁΩÆ
Ê†°È™åÁ∫¶Êùü
Â¶Ç
maximum_length
ÊàñËÄÖ
regex
„ÄÇ
‰∏Ä‰∏™Âº∫Â§ßÂπ∂Êòì‰∫é‰ΩøÁî®ÁöÑ
‰æùËµñÊ≥®ÂÖ•
Á≥ªÁªü„ÄÇ
ÂÆâÂÖ®ÊÄßÂíåË∫´‰ªΩÈ™åËØÅÔºåÂåÖÊã¨ÈÄöËøá
JWT ‰ª§Áâå
Âíå
HTTP Âü∫Êú¨Ë∫´‰ªΩËÆ§ËØÅ
Êù•ÊîØÊåÅ
OAuth2
„ÄÇ
Êõ¥ËøõÈò∂Ôºà‰ΩÜÂêåÊ†∑ÁÆÄÂçïÔºâÁöÑÊäÄÂ∑ßÊù•Â£∞Êòé
Â§öÂ±ÇÂµåÂ•ó JSON Ê®°Âûã
ÔºàÂÄüÂä© PydanticÔºâ„ÄÇ
ËÆ∏Â§öÈ¢ùÂ§ñÂäüËÉΩÔºàÂΩíÂäü‰∫é StarletteÔºâÊØîÂ¶ÇÔºö
WebSockets
GraphQL
Âü∫‰∫é HTTPX Âíå
pytest
ÁöÑÊûÅÂÖ∂ÁÆÄÂçïÁöÑÊµãËØï
CORS
Cookie Sessions
......‰ª•ÂèäÊõ¥Â§ö
ÊÄßËÉΩ
Áã¨Á´ãÊú∫ÊûÑ TechEmpower ÊâÄ‰ΩúÁöÑÂü∫ÂáÜÊµãËØïÁªìÊûúÊòæÁ§∫ÔºåÂü∫‰∫é Uvicorn ËøêË°åÁöÑ
FastAPI
Á®ãÂ∫èÊòØ
ÊúÄÂø´ÁöÑ Python web Ê°ÜÊû∂‰πã‰∏Ä
Ôºå‰ªÖÊ¨°‰∫é Starlette Âíå Uvicorn Êú¨Ë∫´ÔºàFastAPI ÂÜÖÈÉ®‰ΩøÁî®‰∫ÜÂÆÉ‰ª¨Ôºâ„ÄÇ(*)
ÊÉ≥‰∫ÜËß£Êõ¥Â§öÔºåËØ∑Êü•ÈòÖ
Âü∫ÂáÜÊµãËØï
Á´†ËäÇ„ÄÇ
ÂèØÈÄâ‰æùËµñ
Áî®‰∫é PydanticÔºö
email-validator
- Áî®‰∫é email Ê†°È™å„ÄÇ
Áî®‰∫é StarletteÔºö
httpx
- ‰ΩøÁî®
TestClient
Êó∂ÂÆâË£Ö„ÄÇ
jinja2
- ‰ΩøÁî®ÈªòËÆ§Ê®°ÊùøÈÖçÁΩÆÊó∂ÂÆâË£Ö„ÄÇ
python-multipart
- ÈúÄË¶ÅÈÄöËøá
request.form()
ÂØπË°®ÂçïËøõË°å
„ÄåËß£Êûê„Äç
Êó∂ÂÆâË£Ö„ÄÇ
itsdangerous
- ÈúÄË¶Å
SessionMiddleware
ÊîØÊåÅÊó∂ÂÆâË£Ö„ÄÇ
pyyaml
- ‰ΩøÁî® Starlette Êèê‰æõÁöÑ
SchemaGenerator
Êó∂ÂÆâË£ÖÔºàÊúâ FastAPI ‰Ω†ÂèØËÉΩÂπ∂‰∏çÈúÄË¶ÅÂÆÉÔºâ„ÄÇ
graphene
- ÈúÄË¶Å
GraphQLApp
ÊîØÊåÅÊó∂ÂÆâË£Ö„ÄÇ
Áî®‰∫é FastAPI / StarletteÔºö
uvicorn
- Áî®‰∫éÂä†ËΩΩÂíåËøêË°å‰Ω†ÁöÑÂ∫îÁî®Á®ãÂ∫èÁöÑÊúçÂä°Âô®„ÄÇ
orjson
- ‰ΩøÁî®
ORJSONResponse
Êó∂ÂÆâË£Ö„ÄÇ
ujson
- ‰ΩøÁî®
UJSONResponse
Êó∂ÂÆâË£Ö„ÄÇ
‰Ω†ÂèØ‰ª•ÈÄöËøá
pip install "fastapi[all]"
ÂëΩ‰ª§Êù•ÂÆâË£Ö‰ª•‰∏äÊâÄÊúâ‰æùËµñ„ÄÇ
ËÆ∏ÂèØÂçèËÆÆ
ËØ•È°πÁõÆÈÅµÂæ™ MIT ËÆ∏ÂèØÂçèËÆÆ„ÄÇ