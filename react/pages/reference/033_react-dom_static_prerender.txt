URL: https://react.dev/reference/react-dom/static/prerender
Section: Reference
============================================================

# prerender
# prerender
prerender renders a React tree to a static HTML string using a Web Stream.
``````
- Reference prerender(reactNode, options?)
- Usage Rendering a React tree to a stream of static HTML Rendering a React tree to a string of static HTML Waiting for all data to load Aborting prerendering
- Troubleshooting My stream doesn’t start until the entire app is rendered
- prerender(reactNode, options?)
- Rendering a React tree to a stream of static HTML
- Rendering a React tree to a string of static HTML
- Waiting for all data to load
- Aborting prerendering
- My stream doesn’t start until the entire app is rendered
### Note
This API depends on Web Streams. For Node.js, use prerenderToNodeStream instead.
## Reference
### prerender(reactNode, options?)
Call prerender to render your app to static HTML.
``````
On the client, call hydrateRoot to make the server-generated HTML interactive.
See more examples below.
#### Parameters
- reactNode: A React node you want to render to HTML. For example, a JSX node like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.
- optional options: An object with static generation options.
optional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.
optional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don’t want to run React on the client at all.
optional bootstrapModules: Like bootstrapScripts, but emits <script type="module"> instead.
optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.
optional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.
optional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.
optional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.
optional signal: An abort signal that lets you abort prerendering and render the rest on the client.
reactNode: A React node you want to render to HTML. For example, a JSX node like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.
optional options: An object with static generation options.
- optional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.
- optional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don’t want to run React on the client at all.
- optional bootstrapModules: Like bootstrapScripts, but emits <script type="module"> instead.
- optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.
- optional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.
- optional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.
- optional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.
- optional signal: An abort signal that lets you abort prerendering and render the rest on the client.
#### Returns
prerender returns a Promise:
- If rendering the is successful, the Promise will resolve to an object containing:
prelude: a Web Stream of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
- If rendering fails, the Promise will be rejected. Use this to output a fallback shell.
- prelude: a Web Stream of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
#### Caveats
nonce is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with CSP it would be inappropriate and insecure to include the nonce value in the prerender itself.
### Note
### When should I use prerender?
The static prerender API is used for static server-side generation (SSG). Unlike renderToString, prerender waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like renderToReadableStream.
## Usage
### Rendering a React tree to a stream of static HTML
Call prerender to render your React tree to static HTML into a Readable Web Stream::
``````
Along with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.
For example, it might look like this:
``````
React will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:
``````
On the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:
``````
This will attach event listeners to the static server-generated HTML and make it interactive.
##### Deep Dive
#### Reading CSS and JS asset paths from the build output
The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of styles.css you might end up with styles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.
However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding "/styles.css" into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:
``````
On the server, render <App assetMap={assetMap} /> and pass your assetMap with the asset URLs:
``````
Since your server is now rendering <App assetMap={assetMap} />, you need to render it with assetMap on the client too to avoid hydration errors. You can serialize and pass assetMap to the client like this:
``````
In the example above, the bootstrapScriptContent option adds an extra inline <script> tag that sets the global window.assetMap variable on the client. This lets the client code read the same assetMap:
``````
Both client and server render App with the same assetMap prop, so there are no hydration errors.
### Rendering a React tree to a string of static HTML
Call prerender to render your app to a static HTML string:
``````
This will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.
### Waiting for all data to load
prerender waits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:
``````
Imagine that <Posts /> needs to load some data, which takes some time. Ideally, you’d want wait for the posts to finish so it’s included in the HTML. To do this, you can use Suspense to suspend on the data, and prerender will wait for the suspended content to finish before resolving to the static HTML.
### Note
Only Suspense-enabled data sources will activate the Suspense component. They include:
- Data fetching with Suspense-enabled frameworks like Relay and Next.js
- Lazy-loading component code with lazy
- Reading the value of a Promise with use
Suspense does not detect when data is fetched inside an Effect or event handler.
The exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.
Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.
### Aborting prerendering
You can force the prerender to “give up” after a timeout:
``````
Any Suspense boundaries with incomplete children will be included in the prelude in the fallback state.
## Troubleshooting
### My stream doesn’t start until the entire app is rendered
The prerender response waits for the entire app to finish rendering, including waiting for all Suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.
To stream content as it loads, use a streaming server render API like renderToReadableStream.